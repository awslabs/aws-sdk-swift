// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AthenaClientTypes.AclConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3AclOption = "S3AclOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3AclOption = self.s3AclOption {
            try encodeContainer.encode(s3AclOption.rawValue, forKey: .s3AclOption)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3AclOptionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.S3AclOption.self, forKey: .s3AclOption)
        s3AclOption = s3AclOptionDecoded
    }
}

extension AthenaClientTypes {
    /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the x-amz-acl request header. For more information about S3 Object Ownership, see [Object Ownership settings](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview) in the Amazon S3 User Guide.
    public struct AclConfiguration: Swift.Equatable {
        /// The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) in the Amazon S3 User Guide.
        /// This member is required.
        public var s3AclOption: AthenaClientTypes.S3AclOption?

        public init(
            s3AclOption: AthenaClientTypes.S3AclOption? = nil
        )
        {
            self.s3AclOption = s3AclOption
        }
    }

}

extension AthenaClientTypes.ApplicationDPUSizes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationRuntimeId = "ApplicationRuntimeId"
        case supportedDPUSizes = "SupportedDPUSizes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationRuntimeId = self.applicationRuntimeId {
            try encodeContainer.encode(applicationRuntimeId, forKey: .applicationRuntimeId)
        }
        if let supportedDPUSizes = supportedDPUSizes {
            var supportedDPUSizesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDPUSizes)
            for integer0 in supportedDPUSizes {
                try supportedDPUSizesContainer.encode(integer0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationRuntimeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationRuntimeId)
        applicationRuntimeId = applicationRuntimeIdDecoded
        let supportedDPUSizesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .supportedDPUSizes)
        var supportedDPUSizesDecoded0:[Swift.Int]? = nil
        if let supportedDPUSizesContainer = supportedDPUSizesContainer {
            supportedDPUSizesDecoded0 = [Swift.Int]()
            for integer0 in supportedDPUSizesContainer {
                if let integer0 = integer0 {
                    supportedDPUSizesDecoded0?.append(integer0)
                }
            }
        }
        supportedDPUSizes = supportedDPUSizesDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains the application runtime IDs and their supported DPU sizes.
    public struct ApplicationDPUSizes: Swift.Equatable {
        /// The name of the supported application runtime (for example, Athena notebook version 1).
        public var applicationRuntimeId: Swift.String?
        /// A list of the supported DPU sizes that the application runtime supports.
        public var supportedDPUSizes: [Swift.Int]?

        public init(
            applicationRuntimeId: Swift.String? = nil,
            supportedDPUSizes: [Swift.Int]? = nil
        )
        {
            self.applicationRuntimeId = applicationRuntimeId
            self.supportedDPUSizes = supportedDPUSizes
        }
    }

}

extension AthenaClientTypes.AthenaError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory = "ErrorCategory"
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
        case retryable = "Retryable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
        if retryable != false {
            try encodeContainer.encode(retryable, forKey: .retryable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCategoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .retryable) ?? false
        retryable = retryableDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Provides information about an Athena query error. The AthenaError feature provides standardized error information to help you understand failed queries and take steps after a query failure occurs. AthenaError includes an ErrorCategory field that specifies whether the cause of the failed query is due to system error, user error, or other error.
    public struct AthenaError: Swift.Equatable {
        /// An integer value that specifies the category of a query failure error. The following list shows the category for each integer value. 1 - System 2 - User 3 - Other
        public var errorCategory: Swift.Int?
        /// Contains a short description of the error that occurred.
        public var errorMessage: Swift.String?
        /// An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the [Error Type Reference](https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference) in the Amazon Athena User Guide.
        public var errorType: Swift.Int?
        /// True if the query might succeed if resubmitted.
        public var retryable: Swift.Bool

        public init(
            errorCategory: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.Int? = nil,
            retryable: Swift.Bool = false
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.retryable = retryable
        }
    }

}

extension BatchGetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryIds = namedQueryIds {
            var namedQueryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namedQueryIds)
            for namedqueryid0 in namedQueryIds {
                try namedQueryIdsContainer.encode(namedqueryid0)
            }
        }
    }
}

extension BatchGetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains an array of named query IDs.
public struct BatchGetNamedQueryInput: Swift.Equatable {
    /// An array of query IDs.
    /// This member is required.
    public var namedQueryIds: [Swift.String]?

    public init(
        namedQueryIds: [Swift.String]? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
    }
}

struct BatchGetNamedQueryInputBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
}

extension BatchGetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
    }
}

extension BatchGetNamedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetNamedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.namedQueries = output.namedQueries
            self.unprocessedNamedQueryIds = output.unprocessedNamedQueryIds
        } else {
            self.namedQueries = nil
            self.unprocessedNamedQueryIds = nil
        }
    }
}

public struct BatchGetNamedQueryOutput: Swift.Equatable {
    /// Information about the named query IDs submitted.
    public var namedQueries: [AthenaClientTypes.NamedQuery]?
    /// Information about provided query IDs.
    public var unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?

    public init(
        namedQueries: [AthenaClientTypes.NamedQuery]? = nil,
        unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]? = nil
    )
    {
        self.namedQueries = namedQueries
        self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
    }
}

struct BatchGetNamedQueryOutputBody: Swift.Equatable {
    let namedQueries: [AthenaClientTypes.NamedQuery]?
    let unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?
}

extension BatchGetNamedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueries = "NamedQueries"
        case unprocessedNamedQueryIds = "UnprocessedNamedQueryIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueriesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NamedQuery?].self, forKey: .namedQueries)
        var namedQueriesDecoded0:[AthenaClientTypes.NamedQuery]? = nil
        if let namedQueriesContainer = namedQueriesContainer {
            namedQueriesDecoded0 = [AthenaClientTypes.NamedQuery]()
            for structure0 in namedQueriesContainer {
                if let structure0 = structure0 {
                    namedQueriesDecoded0?.append(structure0)
                }
            }
        }
        namedQueries = namedQueriesDecoded0
        let unprocessedNamedQueryIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedNamedQueryId?].self, forKey: .unprocessedNamedQueryIds)
        var unprocessedNamedQueryIdsDecoded0:[AthenaClientTypes.UnprocessedNamedQueryId]? = nil
        if let unprocessedNamedQueryIdsContainer = unprocessedNamedQueryIdsContainer {
            unprocessedNamedQueryIdsDecoded0 = [AthenaClientTypes.UnprocessedNamedQueryId]()
            for structure0 in unprocessedNamedQueryIdsContainer {
                if let structure0 = structure0 {
                    unprocessedNamedQueryIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedNamedQueryIds = unprocessedNamedQueryIdsDecoded0
    }
}

enum BatchGetNamedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetPreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatementNames = "PreparedStatementNames"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preparedStatementNames = preparedStatementNames {
            var preparedStatementNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .preparedStatementNames)
            for statementname0 in preparedStatementNames {
                try preparedStatementNamesContainer.encode(statementname0)
            }
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension BatchGetPreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetPreparedStatementInput: Swift.Equatable {
    /// A list of prepared statement names to return.
    /// This member is required.
    public var preparedStatementNames: [Swift.String]?
    /// The name of the workgroup to which the prepared statements belong.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        preparedStatementNames: [Swift.String]? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.preparedStatementNames = preparedStatementNames
        self.workGroup = workGroup
    }
}

struct BatchGetPreparedStatementInputBody: Swift.Equatable {
    let preparedStatementNames: [Swift.String]?
    let workGroup: Swift.String?
}

extension BatchGetPreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatementNames = "PreparedStatementNames"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .preparedStatementNames)
        var preparedStatementNamesDecoded0:[Swift.String]? = nil
        if let preparedStatementNamesContainer = preparedStatementNamesContainer {
            preparedStatementNamesDecoded0 = [Swift.String]()
            for string0 in preparedStatementNamesContainer {
                if let string0 = string0 {
                    preparedStatementNamesDecoded0?.append(string0)
                }
            }
        }
        preparedStatementNames = preparedStatementNamesDecoded0
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension BatchGetPreparedStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetPreparedStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatements = output.preparedStatements
            self.unprocessedPreparedStatementNames = output.unprocessedPreparedStatementNames
        } else {
            self.preparedStatements = nil
            self.unprocessedPreparedStatementNames = nil
        }
    }
}

public struct BatchGetPreparedStatementOutput: Swift.Equatable {
    /// The list of prepared statements returned.
    public var preparedStatements: [AthenaClientTypes.PreparedStatement]?
    /// A list of one or more prepared statements that were requested but could not be returned.
    public var unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]?

    public init(
        preparedStatements: [AthenaClientTypes.PreparedStatement]? = nil,
        unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]? = nil
    )
    {
        self.preparedStatements = preparedStatements
        self.unprocessedPreparedStatementNames = unprocessedPreparedStatementNames
    }
}

struct BatchGetPreparedStatementOutputBody: Swift.Equatable {
    let preparedStatements: [AthenaClientTypes.PreparedStatement]?
    let unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]?
}

extension BatchGetPreparedStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatements = "PreparedStatements"
        case unprocessedPreparedStatementNames = "UnprocessedPreparedStatementNames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.PreparedStatement?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[AthenaClientTypes.PreparedStatement]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [AthenaClientTypes.PreparedStatement]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let unprocessedPreparedStatementNamesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedPreparedStatementName?].self, forKey: .unprocessedPreparedStatementNames)
        var unprocessedPreparedStatementNamesDecoded0:[AthenaClientTypes.UnprocessedPreparedStatementName]? = nil
        if let unprocessedPreparedStatementNamesContainer = unprocessedPreparedStatementNamesContainer {
            unprocessedPreparedStatementNamesDecoded0 = [AthenaClientTypes.UnprocessedPreparedStatementName]()
            for structure0 in unprocessedPreparedStatementNamesContainer {
                if let structure0 = structure0 {
                    unprocessedPreparedStatementNamesDecoded0?.append(structure0)
                }
            }
        }
        unprocessedPreparedStatementNames = unprocessedPreparedStatementNamesDecoded0
    }
}

enum BatchGetPreparedStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionIds = queryExecutionIds {
            var queryExecutionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryExecutionIds)
            for queryexecutionid0 in queryExecutionIds {
                try queryExecutionIdsContainer.encode(queryexecutionid0)
            }
        }
    }
}

extension BatchGetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains an array of query execution IDs.
public struct BatchGetQueryExecutionInput: Swift.Equatable {
    /// An array of query execution IDs.
    /// This member is required.
    public var queryExecutionIds: [Swift.String]?

    public init(
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.queryExecutionIds = queryExecutionIds
    }
}

struct BatchGetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
}

extension BatchGetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
    }
}

extension BatchGetQueryExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetQueryExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutions = output.queryExecutions
            self.unprocessedQueryExecutionIds = output.unprocessedQueryExecutionIds
        } else {
            self.queryExecutions = nil
            self.unprocessedQueryExecutionIds = nil
        }
    }
}

public struct BatchGetQueryExecutionOutput: Swift.Equatable {
    /// Information about a query execution.
    public var queryExecutions: [AthenaClientTypes.QueryExecution]?
    /// Information about the query executions that failed to run.
    public var unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?

    public init(
        queryExecutions: [AthenaClientTypes.QueryExecution]? = nil,
        unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
    )
    {
        self.queryExecutions = queryExecutions
        self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
    }
}

struct BatchGetQueryExecutionOutputBody: Swift.Equatable {
    let queryExecutions: [AthenaClientTypes.QueryExecution]?
    let unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?
}

extension BatchGetQueryExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutions = "QueryExecutions"
        case unprocessedQueryExecutionIds = "UnprocessedQueryExecutionIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryExecution?].self, forKey: .queryExecutions)
        var queryExecutionsDecoded0:[AthenaClientTypes.QueryExecution]? = nil
        if let queryExecutionsContainer = queryExecutionsContainer {
            queryExecutionsDecoded0 = [AthenaClientTypes.QueryExecution]()
            for structure0 in queryExecutionsContainer {
                if let structure0 = structure0 {
                    queryExecutionsDecoded0?.append(structure0)
                }
            }
        }
        queryExecutions = queryExecutionsDecoded0
        let unprocessedQueryExecutionIdsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.UnprocessedQueryExecutionId?].self, forKey: .unprocessedQueryExecutionIds)
        var unprocessedQueryExecutionIdsDecoded0:[AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
        if let unprocessedQueryExecutionIdsContainer = unprocessedQueryExecutionIdsContainer {
            unprocessedQueryExecutionIdsDecoded0 = [AthenaClientTypes.UnprocessedQueryExecutionId]()
            for structure0 in unprocessedQueryExecutionIdsContainer {
                if let structure0 = structure0 {
                    unprocessedQueryExecutionIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedQueryExecutionIds = unprocessedQueryExecutionIdsDecoded0
    }
}

enum BatchGetQueryExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.CalculationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeBlock = "CodeBlock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeBlock = self.codeBlock {
            try encodeContainer.encode(codeBlock, forKey: .codeBlock)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
    }
}

extension AthenaClientTypes {
    /// Contains configuration information for the calculation.
    public struct CalculationConfiguration: Swift.Equatable {
        /// A string that contains the code for the calculation.
        public var codeBlock: Swift.String?

        public init(
            codeBlock: Swift.String? = nil
        )
        {
            self.codeBlock = codeBlock
        }
    }

}

extension AthenaClientTypes {
    public enum CalculationExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case creating
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CalculationExecutionState] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .creating,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CalculationExecutionState(rawValue: rawValue) ?? CalculationExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.CalculationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultS3Uri = "ResultS3Uri"
        case resultType = "ResultType"
        case stdErrorS3Uri = "StdErrorS3Uri"
        case stdOutS3Uri = "StdOutS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultS3Uri = self.resultS3Uri {
            try encodeContainer.encode(resultS3Uri, forKey: .resultS3Uri)
        }
        if let resultType = self.resultType {
            try encodeContainer.encode(resultType, forKey: .resultType)
        }
        if let stdErrorS3Uri = self.stdErrorS3Uri {
            try encodeContainer.encode(stdErrorS3Uri, forKey: .stdErrorS3Uri)
        }
        if let stdOutS3Uri = self.stdOutS3Uri {
            try encodeContainer.encode(stdOutS3Uri, forKey: .stdOutS3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stdOutS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stdOutS3Uri)
        stdOutS3Uri = stdOutS3UriDecoded
        let stdErrorS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stdErrorS3Uri)
        stdErrorS3Uri = stdErrorS3UriDecoded
        let resultS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultS3Uri)
        resultS3Uri = resultS3UriDecoded
        let resultTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultType)
        resultType = resultTypeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about an application-specific calculation result.
    public struct CalculationResult: Swift.Equatable {
        /// The Amazon S3 location of the folder for the calculation results.
        public var resultS3Uri: Swift.String?
        /// The data format of the calculation result.
        public var resultType: Swift.String?
        /// The Amazon S3 location of the stderr error messages file for the calculation.
        public var stdErrorS3Uri: Swift.String?
        /// The Amazon S3 location of the stdout file for the calculation.
        public var stdOutS3Uri: Swift.String?

        public init(
            resultS3Uri: Swift.String? = nil,
            resultType: Swift.String? = nil,
            stdErrorS3Uri: Swift.String? = nil,
            stdOutS3Uri: Swift.String? = nil
        )
        {
            self.resultS3Uri = resultS3Uri
            self.resultType = resultType
            self.stdErrorS3Uri = stdErrorS3Uri
            self.stdOutS3Uri = stdOutS3Uri
        }
    }

}

extension AthenaClientTypes.CalculationStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpuExecutionInMillis = "DpuExecutionInMillis"
        case progress = "Progress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dpuExecutionInMillis = self.dpuExecutionInMillis {
            try encodeContainer.encode(dpuExecutionInMillis, forKey: .dpuExecutionInMillis)
        }
        if let progress = self.progress {
            try encodeContainer.encode(progress, forKey: .progress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpuExecutionInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpuExecutionInMillis)
        dpuExecutionInMillis = dpuExecutionInMillisDecoded
        let progressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progress)
        progress = progressDecoded
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a notebook calculation.
    public struct CalculationStatistics: Swift.Equatable {
        /// The data processing unit execution time in milliseconds for the calculation.
        public var dpuExecutionInMillis: Swift.Int?
        /// The progress of the calculation.
        public var progress: Swift.String?

        public init(
            dpuExecutionInMillis: Swift.Int? = nil,
            progress: Swift.String? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
            self.progress = progress
        }
    }

}

extension AthenaClientTypes.CalculationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionDateTime = self.completionDateTime {
            try encodeContainer.encodeTimestamp(completionDateTime, format: .epochSeconds, forKey: .completionDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = self.submissionDateTime {
            try encodeContainer.encodeTimestamp(submissionDateTime, format: .epochSeconds, forKey: .submissionDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submissionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a notebook calculation.
    public struct CalculationStatus: Swift.Equatable {
        /// The date and time the calculation completed processing.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of the calculation execution. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
        public var state: AthenaClientTypes.CalculationExecutionState?
        /// The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).
        public var stateChangeReason: Swift.String?
        /// The date and time the calculation was submitted for processing.
        public var submissionDateTime: ClientRuntime.Date?

        public init(
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.CalculationExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.CalculationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case description = "Description"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AthenaClientTypes {
    /// Summary information for a notebook calculation.
    public struct CalculationSummary: Swift.Equatable {
        /// The calculation execution UUID.
        public var calculationExecutionId: Swift.String?
        /// A description of the calculation.
        public var description: Swift.String?
        /// Contains information about the status of the calculation.
        public var status: AthenaClientTypes.CalculationStatus?

        public init(
            calculationExecutionId: Swift.String? = nil,
            description: Swift.String? = nil,
            status: AthenaClientTypes.CalculationStatus? = nil
        )
        {
            self.calculationExecutionId = calculationExecutionId
            self.description = description
            self.status = status
        }
    }

}

extension CancelCapacityReservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CancelCapacityReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelCapacityReservationInput: Swift.Equatable {
    /// The name of the capacity reservation to cancel.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CancelCapacityReservationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CancelCapacityReservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CancelCapacityReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelCapacityReservationOutput: Swift.Equatable {

    public init() { }
}

enum CancelCapacityReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.CapacityAllocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestCompletionTime = "RequestCompletionTime"
        case requestTime = "RequestTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestCompletionTime = self.requestCompletionTime {
            try encodeContainer.encodeTimestamp(requestCompletionTime, format: .epochSeconds, forKey: .requestCompletionTime)
        }
        if let requestTime = self.requestTime {
            try encodeContainer.encodeTimestamp(requestTime, format: .epochSeconds, forKey: .requestTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CapacityAllocationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let requestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestTime)
        requestTime = requestTimeDecoded
        let requestCompletionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestCompletionTime)
        requestCompletionTime = requestCompletionTimeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains the submission time of a single allocation request for a capacity reservation and the most recent status of the attempted allocation.
    public struct CapacityAllocation: Swift.Equatable {
        /// The time when the capacity allocation request was completed.
        public var requestCompletionTime: ClientRuntime.Date?
        /// The time when the capacity allocation was requested.
        /// This member is required.
        public var requestTime: ClientRuntime.Date?
        /// The status of the capacity allocation.
        /// This member is required.
        public var status: AthenaClientTypes.CapacityAllocationStatus?
        /// The status message of the capacity allocation.
        public var statusMessage: Swift.String?

        public init(
            requestCompletionTime: ClientRuntime.Date? = nil,
            requestTime: ClientRuntime.Date? = nil,
            status: AthenaClientTypes.CapacityAllocationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.requestCompletionTime = requestCompletionTime
            self.requestTime = requestTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension AthenaClientTypes {
    public enum CapacityAllocationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityAllocationStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapacityAllocationStatus(rawValue: rawValue) ?? CapacityAllocationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.CapacityAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroupNames = "WorkGroupNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroupNames = workGroupNames {
            var workGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workGroupNames)
            for workgroupname0 in workGroupNames {
                try workGroupNamesContainer.encode(workgroupname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workGroupNames)
        var workGroupNamesDecoded0:[Swift.String]? = nil
        if let workGroupNamesContainer = workGroupNamesContainer {
            workGroupNamesDecoded0 = [Swift.String]()
            for string0 in workGroupNamesContainer {
                if let string0 = string0 {
                    workGroupNamesDecoded0?.append(string0)
                }
            }
        }
        workGroupNames = workGroupNamesDecoded0
    }
}

extension AthenaClientTypes {
    /// A mapping between one or more workgroups and a capacity reservation.
    public struct CapacityAssignment: Swift.Equatable {
        /// The list of workgroup names for the capacity assignment.
        public var workGroupNames: [Swift.String]?

        public init(
            workGroupNames: [Swift.String]? = nil
        )
        {
            self.workGroupNames = workGroupNames
        }
    }

}

extension AthenaClientTypes.CapacityAssignmentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityAssignments = "CapacityAssignments"
        case capacityReservationName = "CapacityReservationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityAssignments = capacityAssignments {
            var capacityAssignmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityAssignments)
            for capacityassignment0 in capacityAssignments {
                try capacityAssignmentsContainer.encode(capacityassignment0)
            }
        }
        if let capacityReservationName = self.capacityReservationName {
            try encodeContainer.encode(capacityReservationName, forKey: .capacityReservationName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationName)
        capacityReservationName = capacityReservationNameDecoded
        let capacityAssignmentsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.CapacityAssignment?].self, forKey: .capacityAssignments)
        var capacityAssignmentsDecoded0:[AthenaClientTypes.CapacityAssignment]? = nil
        if let capacityAssignmentsContainer = capacityAssignmentsContainer {
            capacityAssignmentsDecoded0 = [AthenaClientTypes.CapacityAssignment]()
            for structure0 in capacityAssignmentsContainer {
                if let structure0 = structure0 {
                    capacityAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        capacityAssignments = capacityAssignmentsDecoded0
    }
}

extension AthenaClientTypes {
    /// Assigns Athena workgroups (and hence their queries) to capacity reservations. A capacity reservation can have only one capacity assignment configuration, but the capacity assignment configuration can be made up of multiple individual assignments. Each assignment specifies how Athena queries can consume capacity from the capacity reservation that their workgroup is mapped to.
    public struct CapacityAssignmentConfiguration: Swift.Equatable {
        /// The list of assignments that make up the capacity assignment configuration.
        public var capacityAssignments: [AthenaClientTypes.CapacityAssignment]?
        /// The name of the reservation that the capacity assignment configuration is for.
        public var capacityReservationName: Swift.String?

        public init(
            capacityAssignments: [AthenaClientTypes.CapacityAssignment]? = nil,
            capacityReservationName: Swift.String? = nil
        )
        {
            self.capacityAssignments = capacityAssignments
            self.capacityReservationName = capacityReservationName
        }
    }

}

extension AthenaClientTypes.CapacityReservation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedDpus = "AllocatedDpus"
        case creationTime = "CreationTime"
        case lastAllocation = "LastAllocation"
        case lastSuccessfulAllocationTime = "LastSuccessfulAllocationTime"
        case name = "Name"
        case status = "Status"
        case targetDpus = "TargetDpus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedDpus = self.allocatedDpus {
            try encodeContainer.encode(allocatedDpus, forKey: .allocatedDpus)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastAllocation = self.lastAllocation {
            try encodeContainer.encode(lastAllocation, forKey: .lastAllocation)
        }
        if let lastSuccessfulAllocationTime = self.lastSuccessfulAllocationTime {
            try encodeContainer.encodeTimestamp(lastSuccessfulAllocationTime, format: .epochSeconds, forKey: .lastSuccessfulAllocationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetDpus = self.targetDpus {
            try encodeContainer.encode(targetDpus, forKey: .targetDpus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CapacityReservationStatus.self, forKey: .status)
        status = statusDecoded
        let targetDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetDpus)
        targetDpus = targetDpusDecoded
        let allocatedDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedDpus)
        allocatedDpus = allocatedDpusDecoded
        let lastAllocationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CapacityAllocation.self, forKey: .lastAllocation)
        lastAllocation = lastAllocationDecoded
        let lastSuccessfulAllocationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSuccessfulAllocationTime)
        lastSuccessfulAllocationTime = lastSuccessfulAllocationTimeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A reservation for a specified number of data processing units (DPUs). When a reservation is initially created, it has no DPUs. Athena allocates DPUs until the allocated amount equals the requested amount.
    public struct CapacityReservation: Swift.Equatable {
        /// The number of data processing units currently allocated.
        /// This member is required.
        public var allocatedDpus: Swift.Int?
        /// The time in UTC epoch millis when the capacity reservation was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Contains the submission time of a single allocation request for a capacity reservation and the most recent status of the attempted allocation.
        public var lastAllocation: AthenaClientTypes.CapacityAllocation?
        /// The time of the most recent capacity allocation that succeeded.
        public var lastSuccessfulAllocationTime: ClientRuntime.Date?
        /// The name of the capacity reservation.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the capacity reservation.
        /// This member is required.
        public var status: AthenaClientTypes.CapacityReservationStatus?
        /// The number of data processing units requested.
        /// This member is required.
        public var targetDpus: Swift.Int?

        public init(
            allocatedDpus: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastAllocation: AthenaClientTypes.CapacityAllocation? = nil,
            lastSuccessfulAllocationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AthenaClientTypes.CapacityReservationStatus? = nil,
            targetDpus: Swift.Int? = nil
        )
        {
            self.allocatedDpus = allocatedDpus
            self.creationTime = creationTime
            self.lastAllocation = lastAllocation
            self.lastSuccessfulAllocationTime = lastSuccessfulAllocationTime
            self.name = name
            self.status = status
            self.targetDpus = targetDpus
        }
    }

}

extension AthenaClientTypes {
    public enum CapacityReservationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case cancelled
        case cancelling
        case failed
        case pending
        case updatePending
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityReservationStatus] {
            return [
                .active,
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .updatePending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .updatePending: return "UPDATE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapacityReservationStatus(rawValue: rawValue) ?? CapacityReservationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.Column: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a column in a table.
    public struct Column: Swift.Equatable {
        /// Optional information about the column.
        public var comment: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        public var type: Swift.String?

        public init(
            comment: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.comment = comment
            self.name = name
            self.type = type
        }
    }

}

extension AthenaClientTypes.ColumnInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive = "CaseSensitive"
        case catalogName = "CatalogName"
        case label = "Label"
        case name = "Name"
        case nullable = "Nullable"
        case precision = "Precision"
        case scale = "Scale"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if caseSensitive != false {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nullable = self.nullable {
            try encodeContainer.encode(nullable.rawValue, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = self.schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .precision) ?? 0
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scale) ?? 0
        scale = scaleDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ColumnNullable.self, forKey: .nullable)
        nullable = nullableDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive) ?? false
        caseSensitive = caseSensitiveDecoded
    }
}

extension AthenaClientTypes {
    /// Information about the columns in a query execution result.
    public struct ColumnInfo: Swift.Equatable {
        /// Indicates whether values in the column are case-sensitive.
        public var caseSensitive: Swift.Bool
        /// The catalog to which the query results belong.
        public var catalogName: Swift.String?
        /// A column label.
        public var label: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates the column's nullable status.
        public var nullable: AthenaClientTypes.ColumnNullable?
        /// For DECIMAL data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.
        public var precision: Swift.Int
        /// For DECIMAL data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.
        public var scale: Swift.Int
        /// The schema name (database name) to which the query results belong.
        public var schemaName: Swift.String?
        /// The table name for the query results.
        public var tableName: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init(
            caseSensitive: Swift.Bool = false,
            catalogName: Swift.String? = nil,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: AthenaClientTypes.ColumnNullable? = nil,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.catalogName = catalogName
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum ColumnNullable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notNull
        case nullable
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnNullable] {
            return [
                .notNull,
                .nullable,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notNull: return "NOT_NULL"
            case .nullable: return "NULLABLE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnNullable(rawValue: rawValue) ?? ColumnNullable.sdkUnknown(rawValue)
        }
    }
}

extension CreateCapacityReservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case tags = "Tags"
        case targetDpus = "TargetDpus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetDpus = self.targetDpus {
            try encodeContainer.encode(targetDpus, forKey: .targetDpus)
        }
    }
}

extension CreateCapacityReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCapacityReservationInput: Swift.Equatable {
    /// The name of the capacity reservation to create.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the capacity reservation.
    public var tags: [AthenaClientTypes.Tag]?
    /// The number of requested data processing units.
    /// This member is required.
    public var targetDpus: Swift.Int?

    public init(
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        targetDpus: Swift.Int? = nil
    )
    {
        self.name = name
        self.tags = tags
        self.targetDpus = targetDpus
    }
}

struct CreateCapacityReservationInputBody: Swift.Equatable {
    let targetDpus: Swift.Int?
    let name: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateCapacityReservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case tags = "Tags"
        case targetDpus = "TargetDpus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetDpus)
        targetDpus = targetDpusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCapacityReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateCapacityReservationOutput: Swift.Equatable {

    public init() { }
}

enum CreateCapacityReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDataCatalogInput: Swift.Equatable {
    /// A description of the data catalog to be created.
    public var description: Swift.String?
    /// The name of the data catalog to create. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for creating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    ///
    ///
    ///
    ///
    /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue Data Catalog belongs. catalog-id=catalog_id
    ///
    /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
    ///
    /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
    ///
    /// * In Regions where Athena engine version 2 is not available, creating new Glue data catalogs results in an INVALID_INPUT error.
    public var parameters: [Swift.String:Swift.String]?
    /// A list of comma separated tags to add to the data catalog that is created.
    public var tags: [AthenaClientTypes.Tag]?
    /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
        self.type = type
    }
}

struct CreateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateDataCatalogOutput: Swift.Equatable {

    public init() { }
}

enum CreateDataCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreateNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNamedQueryInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another CreateNamedQuery request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The database to which the query belongs.
    /// This member is required.
    public var database: Swift.String?
    /// The query description.
    public var description: Swift.String?
    /// The query name.
    /// This member is required.
    public var name: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?
    /// The name of the workgroup in which the named query is being created.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        database: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryString: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.database = database
        self.description = description
        self.name = name
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

struct CreateNamedQueryInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let database: Swift.String?
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let workGroup: Swift.String?
}

extension CreateNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension CreateNamedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNamedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryId = output.namedQueryId
        } else {
            self.namedQueryId = nil
        }
    }
}

public struct CreateNamedQueryOutput: Swift.Equatable {
    /// The unique ID of the query.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct CreateNamedQueryOutputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension CreateNamedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

enum CreateNamedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreateNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the ipynb file to be created in the Spark workgroup, without the .ipynb extension.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the Spark enabled workgroup in which the notebook will be created.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.workGroup = workGroup
    }
}

struct CreateNotebookInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let name: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateNotebookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNotebookOutputBody = try responseDecoder.decode(responseBody: data)
            self.notebookId = output.notebookId
        } else {
            self.notebookId = nil
        }
    }
}

public struct CreateNotebookOutput: Swift.Equatable {
    /// A unique identifier for the notebook.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct CreateNotebookOutputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension CreateNotebookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

enum CreateNotebookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension CreatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The name of the workgroup to which the prepared statement belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct CreatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension CreatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreatePreparedStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreatePreparedStatementOutput: Swift.Equatable {

    public init() { }
}

enum CreatePreparedStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePresignedNotebookUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension CreatePresignedNotebookUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePresignedNotebookUrlInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct CreatePresignedNotebookUrlInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension CreatePresignedNotebookUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension CreatePresignedNotebookUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePresignedNotebookUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.authToken = output.authToken
            self.authTokenExpirationTime = output.authTokenExpirationTime
            self.notebookUrl = output.notebookUrl
        } else {
            self.authToken = nil
            self.authTokenExpirationTime = nil
            self.notebookUrl = nil
        }
    }
}

public struct CreatePresignedNotebookUrlOutput: Swift.Equatable {
    /// The authentication token for the notebook.
    /// This member is required.
    public var authToken: Swift.String?
    /// The UTC epoch time when the authentication token expires.
    /// This member is required.
    public var authTokenExpirationTime: Swift.Int?
    /// The URL of the notebook. The URL includes the authentication token and notebook file name and points directly to the opened notebook.
    /// This member is required.
    public var notebookUrl: Swift.String?

    public init(
        authToken: Swift.String? = nil,
        authTokenExpirationTime: Swift.Int? = nil,
        notebookUrl: Swift.String? = nil
    )
    {
        self.authToken = authToken
        self.authTokenExpirationTime = authTokenExpirationTime
        self.notebookUrl = notebookUrl
    }
}

struct CreatePresignedNotebookUrlOutputBody: Swift.Equatable {
    let notebookUrl: Swift.String?
    let authToken: Swift.String?
    let authTokenExpirationTime: Swift.Int?
}

extension CreatePresignedNotebookUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authToken = "AuthToken"
        case authTokenExpirationTime = "AuthTokenExpirationTime"
        case notebookUrl = "NotebookUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookUrl)
        notebookUrl = notebookUrlDecoded
        let authTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authToken)
        authToken = authTokenDecoded
        let authTokenExpirationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authTokenExpirationTime)
        authTokenExpirationTime = authTokenExpirationTimeDecoded
    }
}

enum CreatePresignedNotebookUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWorkGroupInput: Swift.Equatable {
    /// Contains configuration information for creating an Athena SQL workgroup or Spark enabled Athena workgroup. Athena SQL workgroup configuration includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var configuration: AthenaClientTypes.WorkGroupConfiguration?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup name.
    /// This member is required.
    public var name: Swift.String?
    /// A list of comma separated tags to add to the workgroup that is created.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWorkGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let configuration: AthenaClientTypes.WorkGroupConfiguration?
    let description: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension CreateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateWorkGroupOutput: Swift.Equatable {

    public init() { }
}

enum CreateWorkGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.CustomerContentEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
    public struct CustomerContentEncryptionConfiguration: Swift.Equatable {
        /// The KMS key that is used to encrypt the user's data stores in Athena.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init(
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes.DataCatalog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains information about a data catalog in an Amazon Web Services account. In the Athena console, data catalogs are listed as "data sources" on the Data sources page under the Data source name column.
    public struct DataCatalog: Swift.Equatable {
        /// An optional description of the data catalog.
        public var description: Swift.String?
        /// The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type.
        ///
        /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
        ///
        /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
        ///
        /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
        ///
        /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
        ///
        ///
        ///
        ///
        /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue catalog belongs. catalog-id=catalog_id
        ///
        /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
        ///
        /// * Queries that specify a Glue Data Catalog other than the default AwsDataCatalog must be run on Athena engine version 2.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
        /// This member is required.
        public var type: AthenaClientTypes.DataCatalogType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.type = type
        }
    }

}

extension AthenaClientTypes.DataCatalogSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the data catalog, which includes its name and type.
    public struct DataCatalogSummary: Swift.Equatable {
        /// The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        public var catalogName: Swift.String?
        /// The data catalog type.
        public var type: AthenaClientTypes.DataCatalogType?

        public init(
            catalogName: Swift.String? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.catalogName = catalogName
            self.type = type
        }
    }

}

extension AthenaClientTypes {
    public enum DataCatalogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case glue
        case hive
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCatalogType] {
            return [
                .glue,
                .hive,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case .hive: return "HIVE"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCatalogType(rawValue: rawValue) ?? DataCatalogType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.Database: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata information for a database in a data catalog.
    public struct Database: Swift.Equatable {
        /// An optional description of the database.
        public var description: Swift.String?
        /// The name of the database.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension AthenaClientTypes.Datum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case varCharValue = "VarCharValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let varCharValue = self.varCharValue {
            try encodeContainer.encode(varCharValue, forKey: .varCharValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let varCharValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .varCharValue)
        varCharValue = varCharValueDecoded
    }
}

extension AthenaClientTypes {
    /// A piece of data (a field in the table).
    public struct Datum: Swift.Equatable {
        /// The value of the datum.
        public var varCharValue: Swift.String?

        public init(
            varCharValue: Swift.String? = nil
        )
        {
            self.varCharValue = varCharValue
        }
    }

}

extension DeleteCapacityReservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteCapacityReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCapacityReservationInput: Swift.Equatable {
    /// The name of the capacity reservation to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCapacityReservationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteCapacityReservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteCapacityReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCapacityReservationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCapacityReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDataCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataCatalogOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension DeleteNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query to delete.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct DeleteNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension DeleteNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension DeleteNamedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNamedQueryOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNamedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension DeleteNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNotebookInput: Swift.Equatable {
    /// The ID of the notebook to delete.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct DeleteNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension DeleteNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension DeleteNotebookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteNotebookOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNotebookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeletePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to delete.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be deleted belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct DeletePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension DeletePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension DeletePreparedStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePreparedStatementOutput: Swift.Equatable {

    public init() { }
}

enum DeletePreparedStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recursiveDeleteOption = self.recursiveDeleteOption {
            try encodeContainer.encode(recursiveDeleteOption, forKey: .recursiveDeleteOption)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension DeleteWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWorkGroupInput: Swift.Equatable {
    /// The option to delete the workgroup and its contents even if the workgroup contains any named queries, query executions, or notebooks.
    public var recursiveDeleteOption: Swift.Bool?
    /// The unique name of the workgroup to delete.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        recursiveDeleteOption: Swift.Bool? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.recursiveDeleteOption = recursiveDeleteOption
        self.workGroup = workGroup
    }
}

struct DeleteWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let recursiveDeleteOption: Swift.Bool?
}

extension DeleteWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let recursiveDeleteOptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .recursiveDeleteOption)
        recursiveDeleteOption = recursiveDeleteOptionDecoded
    }
}

extension DeleteWorkGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionOption = "EncryptionOption"
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = self.encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AthenaClientTypes {
    /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        /// This member is required.
        public var encryptionOption: AthenaClientTypes.EncryptionOption?
        /// For SSE_KMS and CSE_KMS, this is the KMS key ARN or ID.
        public var kmsKey: Swift.String?

        public init(
            encryptionOption: AthenaClientTypes.EncryptionOption? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes {
    public enum EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cseKms
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionOption] {
            return [
                .cseKms,
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cseKms: return "CSE_KMS"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.EngineConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfigs = "AdditionalConfigs"
        case coordinatorDpuSize = "CoordinatorDpuSize"
        case defaultExecutorDpuSize = "DefaultExecutorDpuSize"
        case maxConcurrentDpus = "MaxConcurrentDpus"
        case sparkProperties = "SparkProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfigs = additionalConfigs {
            var additionalConfigsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalConfigs)
            for (dictKey0, parametersMap0) in additionalConfigs {
                try additionalConfigsContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let coordinatorDpuSize = self.coordinatorDpuSize {
            try encodeContainer.encode(coordinatorDpuSize, forKey: .coordinatorDpuSize)
        }
        if let defaultExecutorDpuSize = self.defaultExecutorDpuSize {
            try encodeContainer.encode(defaultExecutorDpuSize, forKey: .defaultExecutorDpuSize)
        }
        if maxConcurrentDpus != 0 {
            try encodeContainer.encode(maxConcurrentDpus, forKey: .maxConcurrentDpus)
        }
        if let sparkProperties = sparkProperties {
            var sparkPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sparkProperties)
            for (dictKey0, parametersMap0) in sparkProperties {
                try sparkPropertiesContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatorDpuSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coordinatorDpuSize)
        coordinatorDpuSize = coordinatorDpuSizeDecoded
        let maxConcurrentDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentDpus) ?? 0
        maxConcurrentDpus = maxConcurrentDpusDecoded
        let defaultExecutorDpuSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultExecutorDpuSize)
        defaultExecutorDpuSize = defaultExecutorDpuSizeDecoded
        let additionalConfigsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalConfigs)
        var additionalConfigsDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalConfigsContainer = additionalConfigsContainer {
            additionalConfigsDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in additionalConfigsContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    additionalConfigsDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        additionalConfigs = additionalConfigsDecoded0
        let sparkPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sparkProperties)
        var sparkPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let sparkPropertiesContainer = sparkPropertiesContainer {
            sparkPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in sparkPropertiesContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    sparkPropertiesDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        sparkProperties = sparkPropertiesDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains data processing unit (DPU) configuration settings and parameter mappings for a notebook engine.
    public struct EngineConfiguration: Swift.Equatable {
        /// Contains additional notebook engine MAP parameter mappings in the form of key-value pairs. To specify an Athena notebook that the Jupyter server will download and serve, specify a value for the [StartSessionRequest$NotebookVersion] field, and then add a key named NotebookId to AdditionalConfigs that has the value of the Athena notebook ID.
        public var additionalConfigs: [Swift.String:Swift.String]?
        /// The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session. The default is 1.
        public var coordinatorDpuSize: Swift.Int?
        /// The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena. The default is 1.
        public var defaultExecutorDpuSize: Swift.Int?
        /// The maximum number of DPUs that can run concurrently.
        /// This member is required.
        public var maxConcurrentDpus: Swift.Int
        /// Specifies custom jar files and Spark properties for use cases like cluster encryption, table formats, and general Spark tuning.
        public var sparkProperties: [Swift.String:Swift.String]?

        public init(
            additionalConfigs: [Swift.String:Swift.String]? = nil,
            coordinatorDpuSize: Swift.Int? = nil,
            defaultExecutorDpuSize: Swift.Int? = nil,
            maxConcurrentDpus: Swift.Int = 0,
            sparkProperties: [Swift.String:Swift.String]? = nil
        )
        {
            self.additionalConfigs = additionalConfigs
            self.coordinatorDpuSize = coordinatorDpuSize
            self.defaultExecutorDpuSize = defaultExecutorDpuSize
            self.maxConcurrentDpus = maxConcurrentDpus
            self.sparkProperties = sparkProperties
        }
    }

}

extension AthenaClientTypes.EngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveEngineVersion = "EffectiveEngineVersion"
        case selectedEngineVersion = "SelectedEngineVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveEngineVersion = self.effectiveEngineVersion {
            try encodeContainer.encode(effectiveEngineVersion, forKey: .effectiveEngineVersion)
        }
        if let selectedEngineVersion = self.selectedEngineVersion {
            try encodeContainer.encode(selectedEngineVersion, forKey: .selectedEngineVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectedEngineVersion)
        selectedEngineVersion = selectedEngineVersionDecoded
        let effectiveEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEngineVersion)
        effectiveEngineVersion = effectiveEngineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The Athena engine version for running queries, or the PySpark engine version for running sessions.
    public struct EngineVersion: Swift.Equatable {
        /// Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a CreateWorkGroup or UpdateWorkGroup operation, the EffectiveEngineVersion field is ignored.
        public var effectiveEngineVersion: Swift.String?
        /// The engine version requested by the user. Possible values are determined by the output of ListEngineVersions, including AUTO. The default is AUTO.
        public var selectedEngineVersion: Swift.String?

        public init(
            effectiveEngineVersion: Swift.String? = nil,
            selectedEngineVersion: Swift.String? = nil
        )
        {
            self.effectiveEngineVersion = effectiveEngineVersion
            self.selectedEngineVersion = selectedEngineVersion
        }
    }

}

extension AthenaClientTypes {
    public enum ExecutorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case failed
        case registered
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorState] {
            return [
                .created,
                .creating,
                .failed,
                .registered,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .registered: return "REGISTERED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutorState(rawValue: rawValue) ?? ExecutorState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes {
    public enum ExecutorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coordinator
        case gateway
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorType] {
            return [
                .coordinator,
                .gateway,
                .worker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coordinator: return "COORDINATOR"
            case .gateway: return "GATEWAY"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutorType(rawValue: rawValue) ?? ExecutorType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.ExecutorsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorId = "ExecutorId"
        case executorSize = "ExecutorSize"
        case executorState = "ExecutorState"
        case executorType = "ExecutorType"
        case startDateTime = "StartDateTime"
        case terminationDateTime = "TerminationDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executorId = self.executorId {
            try encodeContainer.encode(executorId, forKey: .executorId)
        }
        if let executorSize = self.executorSize {
            try encodeContainer.encode(executorSize, forKey: .executorSize)
        }
        if let executorState = self.executorState {
            try encodeContainer.encode(executorState.rawValue, forKey: .executorState)
        }
        if let executorType = self.executorType {
            try encodeContainer.encode(executorType.rawValue, forKey: .executorType)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let terminationDateTime = self.terminationDateTime {
            try encodeContainer.encode(terminationDateTime, forKey: .terminationDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executorId)
        executorId = executorIdDecoded
        let executorTypeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorType.self, forKey: .executorType)
        executorType = executorTypeDecoded
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let terminationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminationDateTime)
        terminationDateTime = terminationDateTimeDecoded
        let executorStateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorState.self, forKey: .executorState)
        executorState = executorStateDecoded
        let executorSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executorSize)
        executorSize = executorSizeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains summary information about an executor.
    public struct ExecutorsSummary: Swift.Equatable {
        /// The UUID of the executor.
        /// This member is required.
        public var executorId: Swift.String?
        /// The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.
        public var executorSize: Swift.Int?
        /// The processing state of the executor. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
        public var executorState: AthenaClientTypes.ExecutorState?
        /// The type of executor used for the application (COORDINATOR, GATEWAY, or WORKER).
        public var executorType: AthenaClientTypes.ExecutorType?
        /// The date and time that the executor started.
        public var startDateTime: Swift.Int?
        /// The date and time that the executor was terminated.
        public var terminationDateTime: Swift.Int?

        public init(
            executorId: Swift.String? = nil,
            executorSize: Swift.Int? = nil,
            executorState: AthenaClientTypes.ExecutorState? = nil,
            executorType: AthenaClientTypes.ExecutorType? = nil,
            startDateTime: Swift.Int? = nil,
            terminationDateTime: Swift.Int? = nil
        )
        {
            self.executorId = executorId
            self.executorSize = executorSize
            self.executorState = executorState
            self.executorType = executorType
            self.startDateTime = startDateTime
            self.terminationDateTime = terminationDateTime
        }
    }

}

extension ExportNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension ExportNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportNotebookInput: Swift.Equatable {
    /// The ID of the notebook to export.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct ExportNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension ExportNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension ExportNotebookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportNotebookOutputBody = try responseDecoder.decode(responseBody: data)
            self.notebookMetadata = output.notebookMetadata
            self.payload = output.payload
        } else {
            self.notebookMetadata = nil
            self.payload = nil
        }
    }
}

public struct ExportNotebookOutput: Swift.Equatable {
    /// The notebook metadata, including notebook ID, notebook name, and workgroup name.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?
    /// The content of the exported notebook.
    public var payload: Swift.String?

    public init(
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil,
        payload: Swift.String? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
        self.payload = payload
    }
}

struct ExportNotebookOutputBody: Swift.Equatable {
    let notebookMetadata: AthenaClientTypes.NotebookMetadata?
    let payload: Swift.String?
}

extension ExportNotebookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookMetadata = "NotebookMetadata"
        case payload = "Payload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookMetadata.self, forKey: .notebookMetadata)
        notebookMetadata = notebookMetadataDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
    }
}

enum ExportNotebookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.FilterDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AthenaClientTypes {
    /// A string for searching notebook names.
    public struct FilterDefinition: Swift.Equatable {
        /// The name of the notebook to search for.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension GetCalculationExecutionCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionCodeInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionCodeInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCalculationExecutionCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeBlock = output.codeBlock
        } else {
            self.codeBlock = nil
        }
    }
}

public struct GetCalculationExecutionCodeOutput: Swift.Equatable {
    /// The unencrypted code that was executed for the calculation.
    public var codeBlock: Swift.String?

    public init(
        codeBlock: Swift.String? = nil
    )
    {
        self.codeBlock = codeBlock
    }
}

struct GetCalculationExecutionCodeOutputBody: Swift.Equatable {
    let codeBlock: Swift.String?
}

extension GetCalculationExecutionCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeBlock = "CodeBlock"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
    }
}

enum GetCalculationExecutionCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCalculationExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculationExecutionId = output.calculationExecutionId
            self.description = output.description
            self.result = output.result
            self.sessionId = output.sessionId
            self.statistics = output.statistics
            self.status = output.status
            self.workingDirectory = output.workingDirectory
        } else {
            self.calculationExecutionId = nil
            self.description = nil
            self.result = nil
            self.sessionId = nil
            self.statistics = nil
            self.status = nil
            self.workingDirectory = nil
        }
    }
}

public struct GetCalculationExecutionOutput: Swift.Equatable {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// The description of the calculation execution.
    public var description: Swift.String?
    /// Contains result information. This field is populated only if the calculation is completed.
    public var result: AthenaClientTypes.CalculationResult?
    /// The session ID that the calculation ran in.
    public var sessionId: Swift.String?
    /// Contains information about the data processing unit (DPU) execution time and progress. This field is populated only when statistics are available.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the status of the calculation.
    public var status: AthenaClientTypes.CalculationStatus?
    /// The Amazon S3 location in which calculation results are stored.
    public var workingDirectory: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil,
        description: Swift.String? = nil,
        result: AthenaClientTypes.CalculationResult? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.description = description
        self.result = result
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workingDirectory = workingDirectory
    }
}

struct GetCalculationExecutionOutputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
    let sessionId: Swift.String?
    let description: Swift.String?
    let workingDirectory: Swift.String?
    let status: AthenaClientTypes.CalculationStatus?
    let statistics: AthenaClientTypes.CalculationStatistics?
    let result: AthenaClientTypes.CalculationResult?
}

extension GetCalculationExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case description = "Description"
        case result = "Result"
        case sessionId = "SessionId"
        case statistics = "Statistics"
        case status = "Status"
        case workingDirectory = "WorkingDirectory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let resultDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationResult.self, forKey: .result)
        result = resultDecoded
    }
}

enum GetCalculationExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCalculationExecutionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension GetCalculationExecutionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCalculationExecutionStatusInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct GetCalculationExecutionStatusInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension GetCalculationExecutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension GetCalculationExecutionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCalculationExecutionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.statistics = output.statistics
            self.status = output.status
        } else {
            self.statistics = nil
            self.status = nil
        }
    }
}

public struct GetCalculationExecutionStatusOutput: Swift.Equatable {
    /// Contains information about the DPU execution time and progress.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the calculation execution status.
    public var status: AthenaClientTypes.CalculationStatus?

    public init(
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil
    )
    {
        self.statistics = statistics
        self.status = status
    }
}

struct GetCalculationExecutionStatusOutputBody: Swift.Equatable {
    let status: AthenaClientTypes.CalculationStatus?
    let statistics: AthenaClientTypes.CalculationStatistics?
}

extension GetCalculationExecutionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statistics = "Statistics"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

enum GetCalculationExecutionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCapacityAssignmentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservationName = "CapacityReservationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityReservationName = self.capacityReservationName {
            try encodeContainer.encode(capacityReservationName, forKey: .capacityReservationName)
        }
    }
}

extension GetCapacityAssignmentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCapacityAssignmentConfigurationInput: Swift.Equatable {
    /// The name of the capacity reservation to retrieve the capacity assignment configuration for.
    /// This member is required.
    public var capacityReservationName: Swift.String?

    public init(
        capacityReservationName: Swift.String? = nil
    )
    {
        self.capacityReservationName = capacityReservationName
    }
}

struct GetCapacityAssignmentConfigurationInputBody: Swift.Equatable {
    let capacityReservationName: Swift.String?
}

extension GetCapacityAssignmentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservationName = "CapacityReservationName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationName)
        capacityReservationName = capacityReservationNameDecoded
    }
}

extension GetCapacityAssignmentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCapacityAssignmentConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.capacityAssignmentConfiguration = output.capacityAssignmentConfiguration
        } else {
            self.capacityAssignmentConfiguration = nil
        }
    }
}

public struct GetCapacityAssignmentConfigurationOutput: Swift.Equatable {
    /// The requested capacity assignment configuration for the specified capacity reservation.
    /// This member is required.
    public var capacityAssignmentConfiguration: AthenaClientTypes.CapacityAssignmentConfiguration?

    public init(
        capacityAssignmentConfiguration: AthenaClientTypes.CapacityAssignmentConfiguration? = nil
    )
    {
        self.capacityAssignmentConfiguration = capacityAssignmentConfiguration
    }
}

struct GetCapacityAssignmentConfigurationOutputBody: Swift.Equatable {
    let capacityAssignmentConfiguration: AthenaClientTypes.CapacityAssignmentConfiguration?
}

extension GetCapacityAssignmentConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityAssignmentConfiguration = "CapacityAssignmentConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityAssignmentConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CapacityAssignmentConfiguration.self, forKey: .capacityAssignmentConfiguration)
        capacityAssignmentConfiguration = capacityAssignmentConfigurationDecoded
    }
}

enum GetCapacityAssignmentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCapacityReservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetCapacityReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCapacityReservationInput: Swift.Equatable {
    /// The name of the capacity reservation.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetCapacityReservationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetCapacityReservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetCapacityReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCapacityReservationOutputBody = try responseDecoder.decode(responseBody: data)
            self.capacityReservation = output.capacityReservation
        } else {
            self.capacityReservation = nil
        }
    }
}

public struct GetCapacityReservationOutput: Swift.Equatable {
    /// The requested capacity reservation structure.
    /// This member is required.
    public var capacityReservation: AthenaClientTypes.CapacityReservation?

    public init(
        capacityReservation: AthenaClientTypes.CapacityReservation? = nil
    )
    {
        self.capacityReservation = capacityReservation
    }
}

struct GetCapacityReservationOutputBody: Swift.Equatable {
    let capacityReservation: AthenaClientTypes.CapacityReservation?
}

extension GetCapacityReservationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservation = "CapacityReservation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CapacityReservation.self, forKey: .capacityReservation)
        capacityReservation = capacityReservationDecoded
    }
}

enum GetCapacityReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDataCatalogInput: Swift.Equatable {
    /// The name of the data catalog to return.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDataCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalog = output.dataCatalog
        } else {
            self.dataCatalog = nil
        }
    }
}

public struct GetDataCatalogOutput: Swift.Equatable {
    /// The data catalog returned.
    public var dataCatalog: AthenaClientTypes.DataCatalog?

    public init(
        dataCatalog: AthenaClientTypes.DataCatalog? = nil
    )
    {
        self.dataCatalog = dataCatalog
    }
}

struct GetDataCatalogOutputBody: Swift.Equatable {
    let dataCatalog: AthenaClientTypes.DataCatalog?
}

extension GetDataCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalog = "DataCatalog"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalog.self, forKey: .dataCatalog)
        dataCatalog = dataCatalogDecoded
    }
}

enum GetDataCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDatabaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

extension GetDatabaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDatabaseInput: Swift.Equatable {
    /// The name of the data catalog that contains the database to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database to return.
    /// This member is required.
    public var databaseName: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
    }
}

struct GetDatabaseInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
}

extension GetDatabaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension GetDatabaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDatabaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct GetDatabaseOutput: Swift.Equatable {
    /// The database returned.
    public var database: AthenaClientTypes.Database?

    public init(
        database: AthenaClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

struct GetDatabaseOutputBody: Swift.Equatable {
    let database: AthenaClientTypes.Database?
}

extension GetDatabaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.Database.self, forKey: .database)
        database = databaseDecoded
    }
}

enum GetDatabaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MetadataException": return try await MetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

extension GetNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNamedQueryInput: Swift.Equatable {
    /// The unique ID of the query. Use [ListNamedQueries] to get query IDs.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct GetNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
}

extension GetNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension GetNamedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNamedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.namedQuery = output.namedQuery
        } else {
            self.namedQuery = nil
        }
    }
}

public struct GetNamedQueryOutput: Swift.Equatable {
    /// Information about the query.
    public var namedQuery: AthenaClientTypes.NamedQuery?

    public init(
        namedQuery: AthenaClientTypes.NamedQuery? = nil
    )
    {
        self.namedQuery = namedQuery
    }
}

struct GetNamedQueryOutputBody: Swift.Equatable {
    let namedQuery: AthenaClientTypes.NamedQuery?
}

extension GetNamedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQuery = "NamedQuery"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NamedQuery.self, forKey: .namedQuery)
        namedQuery = namedQueryDecoded
    }
}

enum GetNamedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension GetNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNotebookMetadataInput: Swift.Equatable {
    /// The ID of the notebook whose metadata is to be retrieved.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct GetNotebookMetadataInputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension GetNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

extension GetNotebookMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNotebookMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.notebookMetadata = output.notebookMetadata
        } else {
            self.notebookMetadata = nil
        }
    }
}

public struct GetNotebookMetadataOutput: Swift.Equatable {
    /// The metadata that is returned for the specified notebook ID.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?

    public init(
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
    }
}

struct GetNotebookMetadataOutputBody: Swift.Equatable {
    let notebookMetadata: AthenaClientTypes.NotebookMetadata?
}

extension GetNotebookMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookMetadata = "NotebookMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookMetadata.self, forKey: .notebookMetadata)
        notebookMetadata = notebookMetadataDecoded
    }
}

enum GetNotebookMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetPreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPreparedStatementInput: Swift.Equatable {
    /// The name of the prepared statement to retrieve.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be retrieved belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct GetPreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
}

extension GetPreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetPreparedStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPreparedStatementOutputBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatement = output.preparedStatement
        } else {
            self.preparedStatement = nil
        }
    }
}

public struct GetPreparedStatementOutput: Swift.Equatable {
    /// The name of the prepared statement that was retrieved.
    public var preparedStatement: AthenaClientTypes.PreparedStatement?

    public init(
        preparedStatement: AthenaClientTypes.PreparedStatement? = nil
    )
    {
        self.preparedStatement = preparedStatement
    }
}

struct GetPreparedStatementOutputBody: Swift.Equatable {
    let preparedStatement: AthenaClientTypes.PreparedStatement?
}

extension GetPreparedStatementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preparedStatement = "PreparedStatement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.PreparedStatement.self, forKey: .preparedStatement)
        preparedStatement = preparedStatementDecoded
    }
}

enum GetPreparedStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension GetQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryExecution = output.queryExecution
        } else {
            self.queryExecution = nil
        }
    }
}

public struct GetQueryExecutionOutput: Swift.Equatable {
    /// Information about the query execution.
    public var queryExecution: AthenaClientTypes.QueryExecution?

    public init(
        queryExecution: AthenaClientTypes.QueryExecution? = nil
    )
    {
        self.queryExecution = queryExecution
    }
}

struct GetQueryExecutionOutputBody: Swift.Equatable {
    let queryExecution: AthenaClientTypes.QueryExecution?
}

extension GetQueryExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecution = "QueryExecution"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecution.self, forKey: .queryExecution)
        queryExecution = queryExecutionDecoded
    }
}

enum GetQueryExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryResultsInput: Swift.Equatable {
    /// The maximum number of results (rows) to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryResultsInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetQueryResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetQueryResultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryResultsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resultSet = output.resultSet
            self.updateCount = output.updateCount
        } else {
            self.nextToken = nil
            self.resultSet = nil
            self.updateCount = nil
        }
    }
}

public struct GetQueryResultsOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The results of the query execution.
    public var resultSet: AthenaClientTypes.ResultSet?
    /// The number of rows inserted with a CREATE TABLE AS SELECT statement.
    public var updateCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        resultSet: AthenaClientTypes.ResultSet? = nil,
        updateCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.resultSet = resultSet
        self.updateCount = updateCount
    }
}

struct GetQueryResultsOutputBody: Swift.Equatable {
    let updateCount: Swift.Int?
    let resultSet: AthenaClientTypes.ResultSet?
    let nextToken: Swift.String?
}

extension GetQueryResultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resultSet = "ResultSet"
        case updateCount = "UpdateCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateCount)
        updateCount = updateCountDecoded
        let resultSetDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSet.self, forKey: .resultSet)
        resultSet = resultSetDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetQueryResultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryRuntimeStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension GetQueryRuntimeStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryRuntimeStatisticsInput: Swift.Equatable {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryRuntimeStatisticsInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension GetQueryRuntimeStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryRuntimeStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryRuntimeStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryRuntimeStatistics = output.queryRuntimeStatistics
        } else {
            self.queryRuntimeStatistics = nil
        }
    }
}

public struct GetQueryRuntimeStatisticsOutput: Swift.Equatable {
    /// Runtime statistics about the query execution.
    public var queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics?

    public init(
        queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics? = nil
    )
    {
        self.queryRuntimeStatistics = queryRuntimeStatistics
    }
}

struct GetQueryRuntimeStatisticsOutputBody: Swift.Equatable {
    let queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics?
}

extension GetQueryRuntimeStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryRuntimeStatistics = "QueryRuntimeStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryRuntimeStatisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatistics.self, forKey: .queryRuntimeStatistics)
        queryRuntimeStatistics = queryRuntimeStatisticsDecoded
    }
}

enum GetQueryRuntimeStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension GetSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.engineConfiguration = output.engineConfiguration
            self.engineVersion = output.engineVersion
            self.notebookVersion = output.notebookVersion
            self.sessionConfiguration = output.sessionConfiguration
            self.sessionId = output.sessionId
            self.statistics = output.statistics
            self.status = output.status
            self.workGroup = output.workGroup
        } else {
            self.description = nil
            self.engineConfiguration = nil
            self.engineVersion = nil
            self.notebookVersion = nil
            self.sessionConfiguration = nil
            self.sessionId = nil
            self.statistics = nil
            self.status = nil
            self.workGroup = nil
        }
    }
}

public struct GetSessionOutput: Swift.Equatable {
    /// The session description.
    public var description: Swift.String?
    /// Contains engine configuration information like DPU usage.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The engine version used by the session (for example, PySpark engine version 3). You can get a list of engine versions by calling [ListEngineVersions].
    public var engineVersion: Swift.String?
    /// The notebook version.
    public var notebookVersion: Swift.String?
    /// Contains the workgroup configuration information used by the session.
    public var sessionConfiguration: AthenaClientTypes.SessionConfiguration?
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains the DPU execution time.
    public var statistics: AthenaClientTypes.SessionStatistics?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?
    /// The workgroup to which the session belongs.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        engineVersion: Swift.String? = nil,
        notebookVersion: Swift.String? = nil,
        sessionConfiguration: AthenaClientTypes.SessionConfiguration? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.SessionStatistics? = nil,
        status: AthenaClientTypes.SessionStatus? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.engineVersion = engineVersion
        self.notebookVersion = notebookVersion
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workGroup = workGroup
    }
}

struct GetSessionOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let description: Swift.String?
    let workGroup: Swift.String?
    let engineVersion: Swift.String?
    let engineConfiguration: AthenaClientTypes.EngineConfiguration?
    let notebookVersion: Swift.String?
    let sessionConfiguration: AthenaClientTypes.SessionConfiguration?
    let status: AthenaClientTypes.SessionStatus?
    let statistics: AthenaClientTypes.SessionStatistics?
}

extension GetSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case engineVersion = "EngineVersion"
        case notebookVersion = "NotebookVersion"
        case sessionConfiguration = "SessionConfiguration"
        case sessionId = "SessionId"
        case statistics = "Statistics"
        case status = "Status"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineConfiguration.self, forKey: .engineConfiguration)
        engineConfiguration = engineConfigurationDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

enum GetSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSessionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension GetSessionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSessionStatusInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct GetSessionStatusInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension GetSessionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension GetSessionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSessionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.status = output.status
        } else {
            self.sessionId = nil
            self.status = nil
        }
    }
}

public struct GetSessionStatusOutput: Swift.Equatable {
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?

    public init(
        sessionId: Swift.String? = nil,
        status: AthenaClientTypes.SessionStatus? = nil
    )
    {
        self.sessionId = sessionId
        self.status = status
    }
}

struct GetSessionStatusOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let status: AthenaClientTypes.SessionStatus?
}

extension GetSessionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetSessionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog that contains the database and table metadata to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database that contains the table metadata to return.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which metadata is returned.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct GetTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.tableMetadata = output.tableMetadata
        } else {
            self.tableMetadata = nil
        }
    }
}

public struct GetTableMetadataOutput: Swift.Equatable {
    /// An object that contains table metadata.
    public var tableMetadata: AthenaClientTypes.TableMetadata?

    public init(
        tableMetadata: AthenaClientTypes.TableMetadata? = nil
    )
    {
        self.tableMetadata = tableMetadata
    }
}

struct GetTableMetadataOutputBody: Swift.Equatable {
    let tableMetadata: AthenaClientTypes.TableMetadata?
}

extension GetTableMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableMetadata = "TableMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.TableMetadata.self, forKey: .tableMetadata)
        tableMetadata = tableMetadataDecoded
    }
}

enum GetTableMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MetadataException": return try await MetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension GetWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetWorkGroupInput: Swift.Equatable {
    /// The name of the workgroup.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        workGroup: Swift.String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
}

extension GetWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetWorkGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.workGroup = output.workGroup
        } else {
            self.workGroup = nil
        }
    }
}

public struct GetWorkGroupOutput: Swift.Equatable {
    /// Information about the workgroup.
    public var workGroup: AthenaClientTypes.WorkGroup?

    public init(
        workGroup: AthenaClientTypes.WorkGroup? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupOutputBody: Swift.Equatable {
    let workGroup: AthenaClientTypes.WorkGroup?
}

extension GetWorkGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroup.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

enum GetWorkGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case payload = "Payload"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ImportNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to import the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the notebook to import.
    /// This member is required.
    public var name: Swift.String?
    /// The notebook content to be imported.
    /// This member is required.
    public var payload: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?
    /// The name of the Spark enabled workgroup to import the notebook to.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        payload: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.payload = payload
        self.type = type
        self.workGroup = workGroup
    }
}

struct ImportNotebookInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let name: Swift.String?
    let payload: Swift.String?
    let type: AthenaClientTypes.NotebookType?
    let clientRequestToken: Swift.String?
}

extension ImportNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case payload = "Payload"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension ImportNotebookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportNotebookOutputBody = try responseDecoder.decode(responseBody: data)
            self.notebookId = output.notebookId
        } else {
            self.notebookId = nil
        }
    }
}

public struct ImportNotebookOutput: Swift.Equatable {
    /// The ID assigned to the imported notebook.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

struct ImportNotebookOutputBody: Swift.Equatable {
    let notebookId: Swift.String?
}

extension ImportNotebookOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
    }
}

enum ImportNotebookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates a platform issue, which may be due to a transient condition or outage.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.athenaErrorCode = output.athenaErrorCode
            self.properties.message = output.message
        } else {
            self.properties.athenaErrorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter may be missing or out of range.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code returned when the query execution failed to process, or when the processing request for the named query failed.
        public internal(set) var athenaErrorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        athenaErrorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.athenaErrorCode = athenaErrorCode
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let athenaErrorCode: Swift.String?
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case athenaErrorCode = "AthenaErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let athenaErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .athenaErrorCode)
        athenaErrorCode = athenaErrorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationDPUSizesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationDPUSizesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationDPUSizesInput: Swift.Equatable {
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationDPUSizesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationDPUSizesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationDPUSizesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationDPUSizesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationDPUSizes = output.applicationDPUSizes
            self.nextToken = output.nextToken
        } else {
            self.applicationDPUSizes = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationDPUSizesOutput: Swift.Equatable {
    /// A list of the supported DPU sizes that the application runtime supports.
    public var applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationDPUSizes = applicationDPUSizes
        self.nextToken = nextToken
    }
}

struct ListApplicationDPUSizesOutputBody: Swift.Equatable {
    let applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]?
    let nextToken: Swift.String?
}

extension ListApplicationDPUSizesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDPUSizes = "ApplicationDPUSizes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDPUSizesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ApplicationDPUSizes?].self, forKey: .applicationDPUSizes)
        var applicationDPUSizesDecoded0:[AthenaClientTypes.ApplicationDPUSizes]? = nil
        if let applicationDPUSizesContainer = applicationDPUSizesContainer {
            applicationDPUSizesDecoded0 = [AthenaClientTypes.ApplicationDPUSizes]()
            for structure0 in applicationDPUSizesContainer {
                if let structure0 = structure0 {
                    applicationDPUSizesDecoded0?.append(structure0)
                }
            }
        }
        applicationDPUSizes = applicationDPUSizesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationDPUSizesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCalculationExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
        case stateFilter = "StateFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let stateFilter = self.stateFilter {
            try encodeContainer.encode(stateFilter.rawValue, forKey: .stateFilter)
        }
    }
}

extension ListCalculationExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCalculationExecutionsInput: Swift.Equatable {
    /// The maximum number of calculation executions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// A filter for a specific calculation execution state. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var stateFilter: AthenaClientTypes.CalculationExecutionState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stateFilter: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stateFilter = stateFilter
    }
}

struct ListCalculationExecutionsInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let stateFilter: AthenaClientTypes.CalculationExecutionState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCalculationExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
        case stateFilter = "StateFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .stateFilter)
        stateFilter = stateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCalculationExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCalculationExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculations = output.calculations
            self.nextToken = output.nextToken
        } else {
            self.calculations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCalculationExecutionsOutput: Swift.Equatable {
    /// A list of [CalculationSummary] objects.
    public var calculations: [AthenaClientTypes.CalculationSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        calculations: [AthenaClientTypes.CalculationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.calculations = calculations
        self.nextToken = nextToken
    }
}

struct ListCalculationExecutionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let calculations: [AthenaClientTypes.CalculationSummary]?
}

extension ListCalculationExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculations = "Calculations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let calculationsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.CalculationSummary?].self, forKey: .calculations)
        var calculationsDecoded0:[AthenaClientTypes.CalculationSummary]? = nil
        if let calculationsContainer = calculationsContainer {
            calculationsDecoded0 = [AthenaClientTypes.CalculationSummary]()
            for structure0 in calculationsContainer {
                if let structure0 = structure0 {
                    calculationsDecoded0?.append(structure0)
                }
            }
        }
        calculations = calculationsDecoded0
    }
}

enum ListCalculationExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCapacityReservationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCapacityReservationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCapacityReservationsInput: Swift.Equatable {
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCapacityReservationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCapacityReservationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCapacityReservationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCapacityReservationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.capacityReservations = output.capacityReservations
            self.nextToken = output.nextToken
        } else {
            self.capacityReservations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCapacityReservationsOutput: Swift.Equatable {
    /// The capacity reservations for the current account.
    /// This member is required.
    public var capacityReservations: [AthenaClientTypes.CapacityReservation]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        capacityReservations: [AthenaClientTypes.CapacityReservation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capacityReservations = capacityReservations
        self.nextToken = nextToken
    }
}

struct ListCapacityReservationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let capacityReservations: [AthenaClientTypes.CapacityReservation]?
}

extension ListCapacityReservationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservations = "CapacityReservations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let capacityReservationsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.CapacityReservation?].self, forKey: .capacityReservations)
        var capacityReservationsDecoded0:[AthenaClientTypes.CapacityReservation]? = nil
        if let capacityReservationsContainer = capacityReservationsContainer {
            capacityReservationsDecoded0 = [AthenaClientTypes.CapacityReservation]()
            for structure0 in capacityReservationsContainer {
                if let structure0 = structure0 {
                    capacityReservationsDecoded0?.append(structure0)
                }
            }
        }
        capacityReservations = capacityReservationsDecoded0
    }
}

enum ListCapacityReservationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataCatalogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDataCatalogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDataCatalogsInput: Swift.Equatable {
    /// Specifies the maximum number of data catalogs to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDataCatalogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataCatalogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataCatalogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalogsSummary = output.dataCatalogsSummary
            self.nextToken = output.nextToken
        } else {
            self.dataCatalogsSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataCatalogsOutput: Swift.Equatable {
    /// A summary list of data catalogs.
    public var dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCatalogsSummary = dataCatalogsSummary
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsOutputBody: Swift.Equatable {
    let dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    let nextToken: Swift.String?
}

extension ListDataCatalogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCatalogsSummary = "DataCatalogsSummary"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogsSummaryContainer = try containerValues.decodeIfPresent([AthenaClientTypes.DataCatalogSummary?].self, forKey: .dataCatalogsSummary)
        var dataCatalogsSummaryDecoded0:[AthenaClientTypes.DataCatalogSummary]? = nil
        if let dataCatalogsSummaryContainer = dataCatalogsSummaryContainer {
            dataCatalogsSummaryDecoded0 = [AthenaClientTypes.DataCatalogSummary]()
            for structure0 in dataCatalogsSummaryContainer {
                if let structure0 = structure0 {
                    dataCatalogsSummaryDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogsSummary = dataCatalogsSummaryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataCatalogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatabasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDatabasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDatabasesInput: Swift.Equatable {
    /// The name of the data catalog that contains the databases to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDatabasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatabasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutput: Swift.Equatable {
    /// A list of databases from a data catalog.
    public var databaseList: [AthenaClientTypes.Database]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        databaseList: [AthenaClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputBody: Swift.Equatable {
    let databaseList: [AthenaClientTypes.Database]?
    let nextToken: Swift.String?
}

extension ListDatabasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Database?].self, forKey: .databaseList)
        var databaseListDecoded0:[AthenaClientTypes.Database]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [AthenaClientTypes.Database]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatabasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MetadataException": return try await MetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEngineVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEngineVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEngineVersionsInput: Swift.Equatable {
    /// The maximum number of engine versions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEngineVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEngineVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEngineVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngineVersionsOutput: Swift.Equatable {
    /// A list of engine versions that are available to choose from.
    public var engineVersions: [AthenaClientTypes.EngineVersion]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [AthenaClientTypes.EngineVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsOutputBody: Swift.Equatable {
    let engineVersions: [AthenaClientTypes.EngineVersion]?
    let nextToken: Swift.String?
}

extension ListEngineVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersions = "EngineVersions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[AthenaClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [AthenaClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEngineVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListExecutorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorStateFilter = "ExecutorStateFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executorStateFilter = self.executorStateFilter {
            try encodeContainer.encode(executorStateFilter.rawValue, forKey: .executorStateFilter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension ListExecutorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListExecutorsInput: Swift.Equatable {
    /// A filter for a specific executor state. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
    public var executorStateFilter: AthenaClientTypes.ExecutorState?
    /// The maximum number of executors to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        executorStateFilter: AthenaClientTypes.ExecutorState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorStateFilter = executorStateFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

struct ListExecutorsInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let executorStateFilter: AthenaClientTypes.ExecutorState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListExecutorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorStateFilter = "ExecutorStateFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let executorStateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ExecutorState.self, forKey: .executorStateFilter)
        executorStateFilter = executorStateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExecutorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.executorsSummary = output.executorsSummary
            self.nextToken = output.nextToken
            self.sessionId = output.sessionId
        } else {
            self.executorsSummary = nil
            self.nextToken = nil
            self.sessionId = nil
        }
    }
}

public struct ListExecutorsOutput: Swift.Equatable {
    /// Contains summary information about the executor.
    public var executorsSummary: [AthenaClientTypes.ExecutorsSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        executorsSummary: [AthenaClientTypes.ExecutorsSummary]? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorsSummary = executorsSummary
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

struct ListExecutorsOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let nextToken: Swift.String?
    let executorsSummary: [AthenaClientTypes.ExecutorsSummary]?
}

extension ListExecutorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executorsSummary = "ExecutorsSummary"
        case nextToken = "NextToken"
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let executorsSummaryContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ExecutorsSummary?].self, forKey: .executorsSummary)
        var executorsSummaryDecoded0:[AthenaClientTypes.ExecutorsSummary]? = nil
        if let executorsSummaryContainer = executorsSummaryContainer {
            executorsSummaryDecoded0 = [AthenaClientTypes.ExecutorsSummary]()
            for structure0 in executorsSummaryContainer {
                if let structure0 = structure0 {
                    executorsSummaryDecoded0?.append(structure0)
                }
            }
        }
        executorsSummary = executorsSummaryDecoded0
    }
}

enum ListExecutorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNamedQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListNamedQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNamedQueriesInput: Swift.Equatable {
    /// The maximum number of queries to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which the named queries are being returned. If a workgroup is not specified, the saved queries for the primary workgroup are returned.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNamedQueriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListNamedQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNamedQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNamedQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryIds = output.namedQueryIds
            self.nextToken = output.nextToken
        } else {
            self.namedQueryIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamedQueriesOutput: Swift.Equatable {
    /// The list of unique query IDs.
    public var namedQueryIds: [Swift.String]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        namedQueryIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
        self.nextToken = nextToken
    }
}

struct ListNamedQueriesOutputBody: Swift.Equatable {
    let namedQueryIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListNamedQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namedQueryIds = "NamedQueryIds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[Swift.String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [Swift.String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNamedQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNotebookMetadataInput: Swift.Equatable {
    /// Search filter string.
    public var filters: AthenaClientTypes.FilterDefinition?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?
    /// The name of the Spark enabled workgroup to retrieve notebook metadata for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        filters: AthenaClientTypes.FilterDefinition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNotebookMetadataInputBody: Swift.Equatable {
    let filters: AthenaClientTypes.FilterDefinition?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.FilterDefinition.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNotebookMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotebookMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notebookMetadataList = output.notebookMetadataList
        } else {
            self.nextToken = nil
            self.notebookMetadataList = nil
        }
    }
}

public struct ListNotebookMetadataOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of notebook metadata for the specified workgroup.
    public var notebookMetadataList: [AthenaClientTypes.NotebookMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        notebookMetadataList: [AthenaClientTypes.NotebookMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookMetadataList = notebookMetadataList
    }
}

struct ListNotebookMetadataOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let notebookMetadataList: [AthenaClientTypes.NotebookMetadata]?
}

extension ListNotebookMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notebookMetadataList = "NotebookMetadataList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let notebookMetadataListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NotebookMetadata?].self, forKey: .notebookMetadataList)
        var notebookMetadataListDecoded0:[AthenaClientTypes.NotebookMetadata]? = nil
        if let notebookMetadataListContainer = notebookMetadataListContainer {
            notebookMetadataListDecoded0 = [AthenaClientTypes.NotebookMetadata]()
            for structure0 in notebookMetadataListContainer {
                if let structure0 = structure0 {
                    notebookMetadataListDecoded0?.append(structure0)
                }
            }
        }
        notebookMetadataList = notebookMetadataListDecoded0
    }
}

enum ListNotebookMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotebookSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension ListNotebookSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListNotebookSessionsInput: Swift.Equatable {
    /// The maximum number of notebook sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The ID of the notebook to list sessions for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notebookId = notebookId
    }
}

struct ListNotebookSessionsInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListNotebookSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotebookSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotebookSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notebookSessionsList = output.notebookSessionsList
        } else {
            self.nextToken = nil
            self.notebookSessionsList = nil
        }
    }
}

public struct ListNotebookSessionsOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of the sessions belonging to the notebook.
    /// This member is required.
    public var notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookSessionsList = notebookSessionsList
    }
}

struct ListNotebookSessionsOutputBody: Swift.Equatable {
    let notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]?
    let nextToken: Swift.String?
}

extension ListNotebookSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notebookSessionsList = "NotebookSessionsList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookSessionsListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.NotebookSessionSummary?].self, forKey: .notebookSessionsList)
        var notebookSessionsListDecoded0:[AthenaClientTypes.NotebookSessionSummary]? = nil
        if let notebookSessionsListContainer = notebookSessionsListContainer {
            notebookSessionsListDecoded0 = [AthenaClientTypes.NotebookSessionSummary]()
            for structure0 in notebookSessionsListContainer {
                if let structure0 = structure0 {
                    notebookSessionsListDecoded0?.append(structure0)
                }
            }
        }
        notebookSessionsList = notebookSessionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNotebookSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPreparedStatementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListPreparedStatementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPreparedStatementsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The workgroup to list the prepared statements for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListPreparedStatementsInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPreparedStatementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPreparedStatementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPreparedStatementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.preparedStatements = output.preparedStatements
        } else {
            self.nextToken = nil
            self.preparedStatements = nil
        }
    }
}

public struct ListPreparedStatementsOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of prepared statements for the workgroup.
    public var preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?

    public init(
        nextToken: Swift.String? = nil,
        preparedStatements: [AthenaClientTypes.PreparedStatementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.preparedStatements = preparedStatements
    }
}

struct ListPreparedStatementsOutputBody: Swift.Equatable {
    let preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?
    let nextToken: Swift.String?
}

extension ListPreparedStatementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case preparedStatements = "PreparedStatements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.PreparedStatementSummary?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[AthenaClientTypes.PreparedStatementSummary]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [AthenaClientTypes.PreparedStatementSummary]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPreparedStatementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueryExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListQueryExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListQueryExecutionsInput: Swift.Equatable {
    /// The maximum number of query executions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which queries are being returned. If a workgroup is not specified, a list of available query execution IDs for the queries in the primary workgroup is returned.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListQueryExecutionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let workGroup: Swift.String?
}

extension ListQueryExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListQueryExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueryExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryExecutionIds = output.queryExecutionIds
        } else {
            self.nextToken = nil
            self.queryExecutionIds = nil
        }
    }
}

public struct ListQueryExecutionsOutput: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The unique IDs of each query execution as an array of strings.
    public var queryExecutionIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryExecutionIds = queryExecutionIds
    }
}

struct ListQueryExecutionsOutputBody: Swift.Equatable {
    let queryExecutionIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListQueryExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[Swift.String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [Swift.String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueryExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stateFilter = "StateFilter"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stateFilter = self.stateFilter {
            try encodeContainer.encode(stateFilter.rawValue, forKey: .stateFilter)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension ListSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSessionsInput: Swift.Equatable {
    /// The maximum number of sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A filter for a specific session state. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var stateFilter: AthenaClientTypes.SessionState?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateFilter: AthenaClientTypes.SessionState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateFilter = stateFilter
        self.workGroup = workGroup
    }
}

struct ListSessionsInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let stateFilter: AthenaClientTypes.SessionState?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stateFilter = "StateFilter"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let stateFilterDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .stateFilter)
        stateFilter = stateFilterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListSessionsOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of sessions.
    public var sessions: [AthenaClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [AthenaClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListSessionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sessions: [AthenaClientTypes.SessionSummary]?
}

extension ListSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.SessionSummary?].self, forKey: .sessions)
        var sessionsDecoded0:[AthenaClientTypes.SessionSummary]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [AthenaClientTypes.SessionSummary]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

enum ListSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = self.catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTableMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTableMetadataInput: Swift.Equatable {
    /// The name of the data catalog for which table metadata should be returned.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database for which table metadata should be returned.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A regex filter that pattern-matches table names. If no expression is supplied, metadata for all tables are listed.
    public var expression: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTableMetadataInputBody: Swift.Equatable {
    let catalogName: Swift.String?
    let databaseName: Swift.String?
    let expression: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTableMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTableMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableMetadataList = output.tableMetadataList
        } else {
            self.nextToken = nil
            self.tableMetadataList = nil
        }
    }
}

public struct ListTableMetadataOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of table metadata.
    public var tableMetadataList: [AthenaClientTypes.TableMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tableMetadataList: [AthenaClientTypes.TableMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableMetadataList = tableMetadataList
    }
}

struct ListTableMetadataOutputBody: Swift.Equatable {
    let tableMetadataList: [AthenaClientTypes.TableMetadata]?
    let nextToken: Swift.String?
}

extension ListTableMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tableMetadataList = "TableMetadataList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataListContainer = try containerValues.decodeIfPresent([AthenaClientTypes.TableMetadata?].self, forKey: .tableMetadataList)
        var tableMetadataListDecoded0:[AthenaClientTypes.TableMetadata]? = nil
        if let tableMetadataListContainer = tableMetadataListContainer {
            tableMetadataListDecoded0 = [AthenaClientTypes.TableMetadata]()
            for structure0 in tableMetadataListContainer {
                if let structure0 = structure0 {
                    tableMetadataListDecoded0?.append(structure0)
                }
            }
        }
        tableMetadataList = tableMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTableMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MetadataException": return try await MetadataException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of results to be returned per request that lists the tags for the resource.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no additional results for this request, where the request lists the tags for the resource with the specified ARN.
    public var nextToken: Swift.String?
    /// Lists the tags for the resource with the specified ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The list of tags associated with the specified resource.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [AthenaClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWorkGroupsInput: Swift.Equatable {
    /// The maximum number of workgroups to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorkGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workGroups = output.workGroups
        } else {
            self.nextToken = nil
            self.workGroups = nil
        }
    }
}

public struct ListWorkGroupsOutput: Swift.Equatable {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of [WorkGroupSummary] objects that include the names, descriptions, creation times, and states for each workgroup.
    public var workGroups: [AthenaClientTypes.WorkGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workGroups: [AthenaClientTypes.WorkGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workGroups = workGroups
    }
}

struct ListWorkGroupsOutputBody: Swift.Equatable {
    let workGroups: [AthenaClientTypes.WorkGroupSummary]?
    let nextToken: Swift.String?
}

extension ListWorkGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workGroups = "WorkGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.WorkGroupSummary?].self, forKey: .workGroups)
        var workGroupsDecoded0:[AthenaClientTypes.WorkGroupSummary]? = nil
        if let workGroupsContainer = workGroupsContainer {
            workGroupsDecoded0 = [AthenaClientTypes.WorkGroupSummary]()
            for structure0 in workGroupsContainer {
                if let structure0 = structure0 {
                    workGroupsDecoded0?.append(structure0)
                }
            }
        }
        workGroups = workGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MetadataException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception that Athena received when it called a custom metastore. Occurs if the error is not caused by user input (InvalidRequestException) or from the Athena platform (InternalServerException). For example, if a user-created Lambda function is missing permissions, the Lambda 4XX exception is returned in a MetadataException.
public struct MetadataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MetadataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MetadataExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MetadataExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AthenaClientTypes.NamedQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension AthenaClientTypes {
    /// A query, where QueryString contains the SQL statements that make up the query.
    public struct NamedQuery: Swift.Equatable {
        /// The database to which the query belongs.
        /// This member is required.
        public var database: Swift.String?
        /// The query description.
        public var description: Swift.String?
        /// The query name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier of the query.
        public var namedQueryId: Swift.String?
        /// The SQL statements that make up the query.
        /// This member is required.
        public var queryString: Swift.String?
        /// The name of the workgroup that contains the named query.
        public var workGroup: Swift.String?

        public init(
            database: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namedQueryId: Swift.String? = nil,
            queryString: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.database = database
            self.description = description
            self.name = name
            self.namedQueryId = namedQueryId
            self.queryString = queryString
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case notebookId = "NotebookId"
        case type = "Type"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains metadata for notebook, including the notebook name, ID, workgroup, and time created.
    public struct NotebookMetadata: Swift.Equatable {
        /// The time when the notebook was created.
        public var creationTime: ClientRuntime.Date?
        /// The time when the notebook was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the notebook.
        public var name: Swift.String?
        /// The notebook ID.
        public var notebookId: Swift.String?
        /// The type of notebook. Currently, the only valid type is IPYNB.
        public var type: AthenaClientTypes.NotebookType?
        /// The name of the Spark enabled workgroup to which the notebook belongs.
        public var workGroup: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notebookId: Swift.String? = nil,
            type: AthenaClientTypes.NotebookType? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.notebookId = notebookId
            self.type = type
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// Contains the notebook session ID and notebook session creation time.
    public struct NotebookSessionSummary: Swift.Equatable {
        /// The time when the notebook session was created.
        public var creationTime: ClientRuntime.Date?
        /// The notebook session ID.
        public var sessionId: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.sessionId = sessionId
        }
    }

}

extension AthenaClientTypes {
    public enum NotebookType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ipynb
        case sdkUnknown(Swift.String)

        public static var allCases: [NotebookType] {
            return [
                .ipynb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipynb: return "IPYNB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotebookType(rawValue: rawValue) ?? NotebookType.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.PreparedStatement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroupName = "WorkGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroupName = self.workGroupName {
            try encodeContainer.encode(workGroupName, forKey: .workGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let workGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroupName)
        workGroupName = workGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A prepared SQL statement for use with Athena.
    public struct PreparedStatement: Swift.Equatable {
        /// The description of the prepared statement.
        public var description: Swift.String?
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The query string for the prepared statement.
        public var queryStatement: Swift.String?
        /// The name of the prepared statement.
        public var statementName: Swift.String?
        /// The name of the workgroup to which the prepared statement belongs.
        public var workGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryStatement: Swift.String? = nil,
            statementName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.queryStatement = queryStatement
            self.statementName = statementName
            self.workGroupName = workGroupName
        }
    }

}

extension AthenaClientTypes.PreparedStatementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedTime = "LastModifiedTime"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension AthenaClientTypes {
    /// The name and last modified time of the prepared statement.
    public struct PreparedStatementSummary: Swift.Equatable {
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prepared statement.
        public var statementName: Swift.String?

        public init(
            lastModifiedTime: ClientRuntime.Date? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.statementName = statementName
        }
    }

}

extension PutCapacityAssignmentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityAssignments = "CapacityAssignments"
        case capacityReservationName = "CapacityReservationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityAssignments = capacityAssignments {
            var capacityAssignmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityAssignments)
            for capacityassignment0 in capacityAssignments {
                try capacityAssignmentsContainer.encode(capacityassignment0)
            }
        }
        if let capacityReservationName = self.capacityReservationName {
            try encodeContainer.encode(capacityReservationName, forKey: .capacityReservationName)
        }
    }
}

extension PutCapacityAssignmentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutCapacityAssignmentConfigurationInput: Swift.Equatable {
    /// The list of assignments for the capacity assignment configuration.
    /// This member is required.
    public var capacityAssignments: [AthenaClientTypes.CapacityAssignment]?
    /// The name of the capacity reservation to put a capacity assignment configuration for.
    /// This member is required.
    public var capacityReservationName: Swift.String?

    public init(
        capacityAssignments: [AthenaClientTypes.CapacityAssignment]? = nil,
        capacityReservationName: Swift.String? = nil
    )
    {
        self.capacityAssignments = capacityAssignments
        self.capacityReservationName = capacityReservationName
    }
}

struct PutCapacityAssignmentConfigurationInputBody: Swift.Equatable {
    let capacityReservationName: Swift.String?
    let capacityAssignments: [AthenaClientTypes.CapacityAssignment]?
}

extension PutCapacityAssignmentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityAssignments = "CapacityAssignments"
        case capacityReservationName = "CapacityReservationName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationName)
        capacityReservationName = capacityReservationNameDecoded
        let capacityAssignmentsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.CapacityAssignment?].self, forKey: .capacityAssignments)
        var capacityAssignmentsDecoded0:[AthenaClientTypes.CapacityAssignment]? = nil
        if let capacityAssignmentsContainer = capacityAssignmentsContainer {
            capacityAssignmentsDecoded0 = [AthenaClientTypes.CapacityAssignment]()
            for structure0 in capacityAssignmentsContainer {
                if let structure0 = structure0 {
                    capacityAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        capacityAssignments = capacityAssignmentsDecoded0
    }
}

extension PutCapacityAssignmentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutCapacityAssignmentConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutCapacityAssignmentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.QueryExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineVersion = "EngineVersion"
        case executionParameters = "ExecutionParameters"
        case query = "Query"
        case queryExecutionContext = "QueryExecutionContext"
        case queryExecutionId = "QueryExecutionId"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case statementType = "StatementType"
        case statistics = "Statistics"
        case status = "Status"
        case substatementType = "SubstatementType"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionParameters = executionParameters {
            var executionParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .executionParameters)
            for executionparameter0 in executionParameters {
                try executionParametersContainer.encode(executionparameter0)
            }
        }
        if let query = self.query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let queryExecutionContext = self.queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let resultReuseConfiguration = self.resultReuseConfiguration {
            try encodeContainer.encode(resultReuseConfiguration, forKey: .resultReuseConfiguration)
        }
        if let statementType = self.statementType {
            try encodeContainer.encode(statementType.rawValue, forKey: .statementType)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let substatementType = self.substatementType {
            try encodeContainer.encode(substatementType, forKey: .substatementType)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let statementTypeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.StatementType.self, forKey: .statementType)
        statementType = statementTypeDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let resultReuseConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseConfiguration.self, forKey: .resultReuseConfiguration)
        resultReuseConfiguration = resultReuseConfigurationDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let executionParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .executionParameters)
        var executionParametersDecoded0:[Swift.String]? = nil
        if let executionParametersContainer = executionParametersContainer {
            executionParametersDecoded0 = [Swift.String]()
            for string0 in executionParametersContainer {
                if let string0 = string0 {
                    executionParametersDecoded0?.append(string0)
                }
            }
        }
        executionParameters = executionParametersDecoded0
        let substatementTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .substatementType)
        substatementType = substatementTypeDecoded
    }
}

extension AthenaClientTypes {
    /// Information about a single instance of a query execution.
    public struct QueryExecution: Swift.Equatable {
        /// The engine version that executed the query.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur. The list of parameters is not returned in the response.
        public var executionParameters: [Swift.String]?
        /// The SQL query statements which the query execution ran.
        public var query: Swift.String?
        /// The database in which the query execution occurred.
        public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
        /// The unique identifier for each query execution.
        public var queryExecutionId: Swift.String?
        /// The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
        /// Specifies the query result reuse behavior that was used for the query.
        public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
        /// The type of query statement that was run. DDL indicates DDL query statements. DML indicates DML (Data Manipulation Language) query statements, such as CREATE TABLE AS SELECT. UTILITY indicates query statements other than DDL and DML, such as SHOW CREATE TABLE, or DESCRIBE TABLE.
        public var statementType: AthenaClientTypes.StatementType?
        /// Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.
        public var statistics: AthenaClientTypes.QueryExecutionStatistics?
        /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
        public var status: AthenaClientTypes.QueryExecutionStatus?
        /// The kind of query statement that was run.
        public var substatementType: Swift.String?
        /// The name of the workgroup in which the query ran.
        public var workGroup: Swift.String?

        public init(
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionParameters: [Swift.String]? = nil,
            query: Swift.String? = nil,
            queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
            queryExecutionId: Swift.String? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
            resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
            statementType: AthenaClientTypes.StatementType? = nil,
            statistics: AthenaClientTypes.QueryExecutionStatistics? = nil,
            status: AthenaClientTypes.QueryExecutionStatus? = nil,
            substatementType: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.engineVersion = engineVersion
            self.executionParameters = executionParameters
            self.query = query
            self.queryExecutionContext = queryExecutionContext
            self.queryExecutionId = queryExecutionId
            self.resultConfiguration = resultConfiguration
            self.resultReuseConfiguration = resultReuseConfiguration
            self.statementType = statementType
            self.statistics = statistics
            self.status = status
            self.substatementType = substatementType
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.QueryExecutionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case database = "Database"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension AthenaClientTypes {
    /// The database and data catalog context in which the query execution occurs.
    public struct QueryExecutionContext: Swift.Equatable {
        /// The name of the data catalog used in the query execution.
        public var catalog: Swift.String?
        /// The name of the database used in the query execution. The database must exist in the catalog.
        public var database: Swift.String?

        public init(
            catalog: Swift.String? = nil,
            database: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.database = database
        }
    }

}

extension AthenaClientTypes {
    public enum QueryExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryExecutionState] {
            return [
                .cancelled,
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryExecutionState(rawValue: rawValue) ?? QueryExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.QueryExecutionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataManifestLocation = "DataManifestLocation"
        case dataScannedInBytes = "DataScannedInBytes"
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case resultReuseInformation = "ResultReuseInformation"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataManifestLocation = self.dataManifestLocation {
            try encodeContainer.encode(dataManifestLocation, forKey: .dataManifestLocation)
        }
        if let dataScannedInBytes = self.dataScannedInBytes {
            try encodeContainer.encode(dataScannedInBytes, forKey: .dataScannedInBytes)
        }
        if let engineExecutionTimeInMillis = self.engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = self.queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = self.queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let resultReuseInformation = self.resultReuseInformation {
            try encodeContainer.encode(resultReuseInformation, forKey: .resultReuseInformation)
        }
        if let serviceProcessingTimeInMillis = self.serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = self.totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let dataScannedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataScannedInBytes)
        dataScannedInBytes = dataScannedInBytesDecoded
        let dataManifestLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataManifestLocation)
        dataManifestLocation = dataManifestLocationDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
        let resultReuseInformationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseInformation.self, forKey: .resultReuseInformation)
        resultReuseInformation = resultReuseInformationDecoded
    }
}

extension AthenaClientTypes {
    /// The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.
    public struct QueryExecutionStatistics: Swift.Equatable {
        /// The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see [Working with Query Results, Output Files, and Query History](https://docs.aws.amazon.com/athena/latest/ug/querying.html) in the Amazon Athena User Guide.
        public var dataManifestLocation: Swift.String?
        /// The number of bytes in the data that was queried.
        public var dataScannedInBytes: Swift.Int?
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// Contains information about whether previous query results were reused for the query.
        public var resultReuseInformation: AthenaClientTypes.ResultReuseInformation?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init(
            dataManifestLocation: Swift.String? = nil,
            dataScannedInBytes: Swift.Int? = nil,
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            resultReuseInformation: AthenaClientTypes.ResultReuseInformation? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.dataManifestLocation = dataManifestLocation
            self.dataScannedInBytes = dataScannedInBytes
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.resultReuseInformation = resultReuseInformation
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryExecutionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case athenaError = "AthenaError"
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let athenaError = self.athenaError {
            try encodeContainer.encode(athenaError, forKey: .athenaError)
        }
        if let completionDateTime = self.completionDateTime {
            try encodeContainer.encodeTimestamp(completionDateTime, format: .epochSeconds, forKey: .completionDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = self.submissionDateTime {
            try encodeContainer.encodeTimestamp(submissionDateTime, format: .epochSeconds, forKey: .submissionDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let submissionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
        let athenaErrorDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AthenaError.self, forKey: .athenaError)
        athenaError = athenaErrorDecoded
    }
}

extension AthenaClientTypes {
    /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
    public struct QueryExecutionStatus: Swift.Equatable {
        /// Provides information about an Athena query error.
        public var athenaError: AthenaClientTypes.AthenaError?
        /// The date and time that the query completed.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of query execution. QUEUED indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. RUNNING indicates that the query is in execution phase. SUCCEEDED indicates that the query completed without errors. FAILED indicates that the query experienced an error and did not complete processing. CANCELLED indicates that a user input interrupted query execution. Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from RUNNING or FAILED to QUEUED.
        public var state: AthenaClientTypes.QueryExecutionState?
        /// Further detail about the status of the query.
        public var stateChangeReason: Swift.String?
        /// The date and time that the query was submitted.
        public var submissionDateTime: ClientRuntime.Date?

        public init(
            athenaError: AthenaClientTypes.AthenaError? = nil,
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.QueryExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.athenaError = athenaError
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputStage = "OutputStage"
        case rows = "Rows"
        case timeline = "Timeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputStage = self.outputStage {
            try encodeContainer.encode(outputStage, forKey: .outputStage)
        }
        if let rows = self.rows {
            try encodeContainer.encode(rows, forKey: .rows)
        }
        if let timeline = self.timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timelineDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatisticsTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let rowsDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryRuntimeStatisticsRows.self, forKey: .rows)
        rows = rowsDecoded
        let outputStageDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryStage.self, forKey: .outputStage)
        outputStage = outputStageDecoded
    }
}

extension AthenaClientTypes {
    /// The query execution timeline, statistics on input and output rows and bytes, and the different query stages that form the query execution plan.
    public struct QueryRuntimeStatistics: Swift.Equatable {
        /// Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.
        public var outputStage: AthenaClientTypes.QueryStage?
        /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
        public var rows: AthenaClientTypes.QueryRuntimeStatisticsRows?
        /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
        public var timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline?

        public init(
            outputStage: AthenaClientTypes.QueryStage? = nil,
            rows: AthenaClientTypes.QueryRuntimeStatisticsRows? = nil,
            timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline? = nil
        )
        {
            self.outputStage = outputStage
            self.rows = rows
            self.timeline = timeline
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsRows: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputBytes = "InputBytes"
        case inputRows = "InputRows"
        case outputBytes = "OutputBytes"
        case outputRows = "OutputRows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputBytes = self.inputBytes {
            try encodeContainer.encode(inputBytes, forKey: .inputBytes)
        }
        if let inputRows = self.inputRows {
            try encodeContainer.encode(inputRows, forKey: .inputRows)
        }
        if let outputBytes = self.outputBytes {
            try encodeContainer.encode(outputBytes, forKey: .outputBytes)
        }
        if let outputRows = self.outputRows {
            try encodeContainer.encode(outputRows, forKey: .outputRows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRows)
        inputRows = inputRowsDecoded
        let inputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputBytes)
        inputBytes = inputBytesDecoded
        let outputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputBytes)
        outputBytes = outputBytesDecoded
        let outputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputRows)
        outputRows = outputRowsDecoded
    }
}

extension AthenaClientTypes {
    /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
    public struct QueryRuntimeStatisticsRows: Swift.Equatable {
        /// The number of bytes read to execute the query.
        public var inputBytes: Swift.Int?
        /// The number of rows read to execute the query.
        public var inputRows: Swift.Int?
        /// The number of bytes returned by the query.
        public var outputBytes: Swift.Int?
        /// The number of rows returned by the query.
        public var outputRows: Swift.Int?

        public init(
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil
        )
        {
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsTimeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineExecutionTimeInMillis = self.engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = self.queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = self.queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let serviceProcessingTimeInMillis = self.serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = self.totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
    }
}

extension AthenaClientTypes {
    /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
    public struct QueryRuntimeStatisticsTimeline: Swift.Equatable {
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init(
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionTime = "ExecutionTime"
        case inputBytes = "InputBytes"
        case inputRows = "InputRows"
        case outputBytes = "OutputBytes"
        case outputRows = "OutputRows"
        case queryStagePlan = "QueryStagePlan"
        case stageId = "StageId"
        case state = "State"
        case subStages = "SubStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionTime = self.executionTime {
            try encodeContainer.encode(executionTime, forKey: .executionTime)
        }
        if let inputBytes = self.inputBytes {
            try encodeContainer.encode(inputBytes, forKey: .inputBytes)
        }
        if let inputRows = self.inputRows {
            try encodeContainer.encode(inputRows, forKey: .inputRows)
        }
        if let outputBytes = self.outputBytes {
            try encodeContainer.encode(outputBytes, forKey: .outputBytes)
        }
        if let outputRows = self.outputRows {
            try encodeContainer.encode(outputRows, forKey: .outputRows)
        }
        if let queryStagePlan = self.queryStagePlan {
            try encodeContainer.encode(queryStagePlan, forKey: .queryStagePlan)
        }
        if let stageId = self.stageId {
            try encodeContainer.encode(stageId, forKey: .stageId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let subStages = subStages {
            var subStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subStages)
            for querystage0 in subStages {
                try subStagesContainer.encode(querystage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stageId)
        stageId = stageIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let outputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputBytes)
        outputBytes = outputBytesDecoded
        let outputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .outputRows)
        outputRows = outputRowsDecoded
        let inputBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputBytes)
        inputBytes = inputBytesDecoded
        let inputRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputRows)
        inputRows = inputRowsDecoded
        let executionTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTime)
        executionTime = executionTimeDecoded
        let queryStagePlanDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryStagePlanNode.self, forKey: .queryStagePlan)
        queryStagePlan = queryStagePlanDecoded
        let subStagesContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryStage?].self, forKey: .subStages)
        var subStagesDecoded0:[AthenaClientTypes.QueryStage]? = nil
        if let subStagesContainer = subStagesContainer {
            subStagesDecoded0 = [AthenaClientTypes.QueryStage]()
            for structure0 in subStagesContainer {
                if let structure0 = structure0 {
                    subStagesDecoded0?.append(structure0)
                }
            }
        }
        subStages = subStagesDecoded0
    }
}

extension AthenaClientTypes {
    /// Stage statistics such as input and output rows and bytes, execution time and stage state. This information also includes substages and the query stage plan.
    public struct QueryStage: Swift.Equatable {
        /// Time taken to execute this stage.
        public var executionTime: Swift.Int?
        /// The number of bytes input into the stage for execution.
        public var inputBytes: Swift.Int?
        /// The number of rows input into the stage for execution.
        public var inputRows: Swift.Int?
        /// The number of bytes output from the stage after execution.
        public var outputBytes: Swift.Int?
        /// The number of rows output from the stage after execution.
        public var outputRows: Swift.Int?
        /// Stage plan information such as name, identifier, sub plans, and source stages.
        public var queryStagePlan: AthenaClientTypes.QueryStagePlanNode?
        /// The identifier for a stage.
        public var stageId: Swift.Int?
        /// State of the stage after query execution.
        public var state: Swift.String?
        /// List of sub query stages that form this stage execution plan.
        public var subStages: [AthenaClientTypes.QueryStage]?

        public init(
            executionTime: Swift.Int? = nil,
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil,
            queryStagePlan: AthenaClientTypes.QueryStagePlanNode? = nil,
            stageId: Swift.Int? = nil,
            state: Swift.String? = nil,
            subStages: [AthenaClientTypes.QueryStage]? = nil
        )
        {
            self.executionTime = executionTime
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
            self.queryStagePlan = queryStagePlan
            self.stageId = stageId
            self.state = state
            self.subStages = subStages
        }
    }

}

extension AthenaClientTypes.QueryStagePlanNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case identifier = "Identifier"
        case name = "Name"
        case remoteSources = "RemoteSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for querystageplannode0 in children {
                try childrenContainer.encode(querystageplannode0)
            }
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remoteSources = remoteSources {
            var remoteSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .remoteSources)
            for string0 in remoteSources {
                try remoteSourcesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let childrenContainer = try containerValues.decodeIfPresent([AthenaClientTypes.QueryStagePlanNode?].self, forKey: .children)
        var childrenDecoded0:[AthenaClientTypes.QueryStagePlanNode]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AthenaClientTypes.QueryStagePlanNode]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let remoteSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .remoteSources)
        var remoteSourcesDecoded0:[Swift.String]? = nil
        if let remoteSourcesContainer = remoteSourcesContainer {
            remoteSourcesDecoded0 = [Swift.String]()
            for string0 in remoteSourcesContainer {
                if let string0 = string0 {
                    remoteSourcesDecoded0?.append(string0)
                }
            }
        }
        remoteSources = remoteSourcesDecoded0
    }
}

extension AthenaClientTypes {
    /// Stage plan information such as name, identifier, sub plans, and remote sources.
    public struct QueryStagePlanNode: Swift.Equatable {
        /// Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/
        public var children: [AthenaClientTypes.QueryStagePlanNode]?
        /// Information about the operation this query stage plan node is performing.
        public var identifier: Swift.String?
        /// Name of the query stage plan that describes the operation this stage is performing as part of query execution.
        public var name: Swift.String?
        /// Source plan node IDs.
        public var remoteSources: [Swift.String]?

        public init(
            children: [AthenaClientTypes.QueryStagePlanNode]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteSources: [Swift.String]? = nil
        )
        {
            self.children = children
            self.identifier = identifier
            self.name = name
            self.remoteSources = remoteSources
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A resource, such as a workgroup, was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the Amazon resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AthenaClientTypes.ResultConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclConfiguration = "AclConfiguration"
        case encryptionConfiguration = "EncryptionConfiguration"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case outputLocation = "OutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = self.aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
    public struct ResultConfiguration: Swift.Equatable {
        /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query and calculation results are stored, such as s3://path/to/query/bucket/. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using [WorkGroupConfiguration]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?

        public init(
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
        }
    }

}

extension AthenaClientTypes.ResultConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclConfiguration = "AclConfiguration"
        case encryptionConfiguration = "EncryptionConfiguration"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case outputLocation = "OutputLocation"
        case removeAclConfiguration = "RemoveAclConfiguration"
        case removeEncryptionConfiguration = "RemoveEncryptionConfiguration"
        case removeExpectedBucketOwner = "RemoveExpectedBucketOwner"
        case removeOutputLocation = "RemoveOutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aclConfiguration = self.aclConfiguration {
            try encodeContainer.encode(aclConfiguration, forKey: .aclConfiguration)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let removeAclConfiguration = self.removeAclConfiguration {
            try encodeContainer.encode(removeAclConfiguration, forKey: .removeAclConfiguration)
        }
        if let removeEncryptionConfiguration = self.removeEncryptionConfiguration {
            try encodeContainer.encode(removeEncryptionConfiguration, forKey: .removeEncryptionConfiguration)
        }
        if let removeExpectedBucketOwner = self.removeExpectedBucketOwner {
            try encodeContainer.encode(removeExpectedBucketOwner, forKey: .removeExpectedBucketOwner)
        }
        if let removeOutputLocation = self.removeOutputLocation {
            try encodeContainer.encode(removeOutputLocation, forKey: .removeOutputLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let removeOutputLocationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOutputLocation)
        removeOutputLocation = removeOutputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let removeEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeEncryptionConfiguration)
        removeEncryptionConfiguration = removeEncryptionConfigurationDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
        let removeExpectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeExpectedBucketOwner)
        removeExpectedBucketOwner = removeExpectedBucketOwnerDecoded
        let aclConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.AclConfiguration.self, forKey: .aclConfiguration)
        aclConfiguration = aclConfigurationDecoded
        let removeAclConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeAclConfiguration)
        removeAclConfiguration = removeAclConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The information about the updates in the query results, such as output location and encryption configuration for the query results.
    public struct ResultConfigurationUpdates: Swift.Equatable {
        /// The ACL configuration for the query results.
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// The encryption configuration for query and calculation results.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query and calculation results are stored, such as s3://path/to/query/bucket/. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?
        /// If set to true, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to false or not set, and a value is present in the AclConfiguration of ResultConfigurationUpdates, the AclConfiguration in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeAclConfiguration: Swift.Bool?
        /// If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the EncryptionConfiguration in ResultConfigurationUpdates (the client-side setting), the EncryptionConfiguration in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeEncryptionConfiguration: Swift.Bool?
        /// If set to "true", removes the Amazon Web Services account ID previously specified for [ResultConfiguration$ExpectedBucketOwner]. If set to "false" or not set, and a value is present in the ExpectedBucketOwner in ResultConfigurationUpdates (the client-side setting), the ExpectedBucketOwner in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeExpectedBucketOwner: Swift.Bool?
        /// If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the OutputLocation in ResultConfigurationUpdates (the client-side setting), the OutputLocation in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeOutputLocation: Swift.Bool?

        public init(
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            removeAclConfiguration: Swift.Bool? = nil,
            removeEncryptionConfiguration: Swift.Bool? = nil,
            removeExpectedBucketOwner: Swift.Bool? = nil,
            removeOutputLocation: Swift.Bool? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
            self.removeAclConfiguration = removeAclConfiguration
            self.removeEncryptionConfiguration = removeEncryptionConfiguration
            self.removeExpectedBucketOwner = removeExpectedBucketOwner
            self.removeOutputLocation = removeOutputLocation
        }
    }

}

extension AthenaClientTypes.ResultReuseByAgeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case maxAgeInMinutes = "MaxAgeInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let maxAgeInMinutes = self.maxAgeInMinutes {
            try encodeContainer.encode(maxAgeInMinutes, forKey: .maxAgeInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let maxAgeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAgeInMinutes)
        maxAgeInMinutes = maxAgeInMinutesDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies whether previous query results are reused, and if so, their maximum age.
    public struct ResultReuseByAgeConfiguration: Swift.Equatable {
        /// True if previous query results can be reused when the query is run; otherwise, false. The default is false.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.
        public var maxAgeInMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool = false,
            maxAgeInMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.maxAgeInMinutes = maxAgeInMinutes
        }
    }

}

extension AthenaClientTypes.ResultReuseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultReuseByAgeConfiguration = "ResultReuseByAgeConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultReuseByAgeConfiguration = self.resultReuseByAgeConfiguration {
            try encodeContainer.encode(resultReuseByAgeConfiguration, forKey: .resultReuseByAgeConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultReuseByAgeConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseByAgeConfiguration.self, forKey: .resultReuseByAgeConfiguration)
        resultReuseByAgeConfiguration = resultReuseByAgeConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// Specifies the query result reuse behavior for the query.
    public struct ResultReuseConfiguration: Swift.Equatable {
        /// Specifies whether previous query results are reused, and if so, their maximum age.
        public var resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration?

        public init(
            resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration? = nil
        )
        {
            self.resultReuseByAgeConfiguration = resultReuseByAgeConfiguration
        }
    }

}

extension AthenaClientTypes.ResultReuseInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reusedPreviousResult = "ReusedPreviousResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if reusedPreviousResult != false {
            try encodeContainer.encode(reusedPreviousResult, forKey: .reusedPreviousResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reusedPreviousResultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .reusedPreviousResult) ?? false
        reusedPreviousResult = reusedPreviousResultDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about whether the result of a previous query was reused.
    public struct ResultReuseInformation: Swift.Equatable {
        /// True if a previous query result was reused; false if the result was generated from a new run of the query.
        /// This member is required.
        public var reusedPreviousResult: Swift.Bool

        public init(
            reusedPreviousResult: Swift.Bool = false
        )
        {
            self.reusedPreviousResult = reusedPreviousResult
        }
    }

}

extension AthenaClientTypes.ResultSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultSetMetadata = "ResultSetMetadata"
        case rows = "Rows"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultSetMetadata = self.resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for row0 in rows {
                try rowsContainer.encode(row0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Row?].self, forKey: .rows)
        var rowsDecoded0:[AthenaClientTypes.Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [AthenaClientTypes.Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
    }
}

extension AthenaClientTypes {
    /// The metadata and rows that make up a query result set. The metadata describes the column structure and data types. To return a ResultSet object, use [GetQueryResults].
    public struct ResultSet: Swift.Equatable {
        /// The metadata that describes the column structure and data types of a table of query results.
        public var resultSetMetadata: AthenaClientTypes.ResultSetMetadata?
        /// The rows in the table.
        public var rows: [AthenaClientTypes.Row]?

        public init(
            resultSetMetadata: AthenaClientTypes.ResultSetMetadata? = nil,
            rows: [AthenaClientTypes.Row]? = nil
        )
        {
            self.resultSetMetadata = resultSetMetadata
            self.rows = rows
        }
    }

}

extension AthenaClientTypes.ResultSetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnInfo = "ColumnInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnInfo = columnInfo {
            var columnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnInfo)
            for columninfo0 in columnInfo {
                try columnInfoContainer.encode(columninfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnInfoContainer = try containerValues.decodeIfPresent([AthenaClientTypes.ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[AthenaClientTypes.ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [AthenaClientTypes.ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
    }
}

extension AthenaClientTypes {
    /// The metadata that describes the column structure and data types of a table of query results. To return a ResultSetMetadata object, use [GetQueryResults].
    public struct ResultSetMetadata: Swift.Equatable {
        /// Information about the columns returned in a query result metadata.
        public var columnInfo: [AthenaClientTypes.ColumnInfo]?

        public init(
            columnInfo: [AthenaClientTypes.ColumnInfo]? = nil
        )
        {
            self.columnInfo = columnInfo
        }
    }

}

extension AthenaClientTypes.Row: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datum0 in data {
                try dataContainer.encode(datum0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Datum?].self, forKey: .data)
        var dataDecoded0:[AthenaClientTypes.Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [AthenaClientTypes.Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension AthenaClientTypes {
    /// The rows that make up a query result table.
    public struct Row: Swift.Equatable {
        /// The data that populates a row in a query result table.
        public var data: [AthenaClientTypes.Datum]?

        public init(
            data: [AthenaClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension AthenaClientTypes {
    public enum S3AclOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketOwnerFullControl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3AclOption] {
            return [
                .bucketOwnerFullControl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketOwnerFullControl: return "BUCKET_OWNER_FULL_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3AclOption(rawValue: rawValue) ?? S3AclOption.sdkUnknown(rawValue)
        }
    }
}

extension SessionAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SessionAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified session already exists.
public struct SessionAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SessionAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SessionAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SessionAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AthenaClientTypes.SessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case executionRole = "ExecutionRole"
        case idleTimeoutSeconds = "IdleTimeoutSeconds"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let idleTimeoutSeconds = self.idleTimeoutSeconds {
            try encodeContainer.encode(idleTimeoutSeconds, forKey: .idleTimeoutSeconds)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let idleTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeoutSeconds)
        idleTimeoutSeconds = idleTimeoutSecondsDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// Contains session configuration information.
    public struct SessionConfiguration: Swift.Equatable {
        /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The ARN of the execution role used for the session.
        public var executionRole: Swift.String?
        /// The idle timeout in seconds for the session.
        public var idleTimeoutSeconds: Swift.Int?
        /// The Amazon S3 location that stores information for the notebook.
        public var workingDirectory: Swift.String?

        public init(
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            executionRole: Swift.String? = nil,
            idleTimeoutSeconds: Swift.Int? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.executionRole = executionRole
            self.idleTimeoutSeconds = idleTimeoutSeconds
            self.workingDirectory = workingDirectory
        }
    }

}

extension AthenaClientTypes {
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case busy
        case created
        case creating
        case degraded
        case failed
        case idle
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .busy,
                .created,
                .creating,
                .degraded,
                .failed,
                .idle,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .busy: return "BUSY"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .degraded: return "DEGRADED"
            case .failed: return "FAILED"
            case .idle: return "IDLE"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.SessionStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpuExecutionInMillis = "DpuExecutionInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dpuExecutionInMillis = self.dpuExecutionInMillis {
            try encodeContainer.encode(dpuExecutionInMillis, forKey: .dpuExecutionInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpuExecutionInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpuExecutionInMillis)
        dpuExecutionInMillis = dpuExecutionInMillisDecoded
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a session.
    public struct SessionStatistics: Swift.Equatable {
        /// The data processing unit execution time for a session in milliseconds.
        public var dpuExecutionInMillis: Swift.Int?

        public init(
            dpuExecutionInMillis: Swift.Int? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
        }
    }

}

extension AthenaClientTypes.SessionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDateTime = "EndDateTime"
        case idleSinceDateTime = "IdleSinceDateTime"
        case lastModifiedDateTime = "LastModifiedDateTime"
        case startDateTime = "StartDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDateTime = self.endDateTime {
            try encodeContainer.encodeTimestamp(endDateTime, format: .epochSeconds, forKey: .endDateTime)
        }
        if let idleSinceDateTime = self.idleSinceDateTime {
            try encodeContainer.encodeTimestamp(idleSinceDateTime, format: .epochSeconds, forKey: .idleSinceDateTime)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encodeTimestamp(lastModifiedDateTime, format: .epochSeconds, forKey: .lastModifiedDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encodeTimestamp(startDateTime, format: .epochSeconds, forKey: .startDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = self.stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let idleSinceDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .idleSinceDateTime)
        idleSinceDateTime = idleSinceDateTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a session.
    public struct SessionStatus: Swift.Equatable {
        /// The date and time that the session ended.
        public var endDateTime: ClientRuntime.Date?
        /// The date and time starting at which the session became idle. Can be empty if the session is not currently idle.
        public var idleSinceDateTime: ClientRuntime.Date?
        /// The most recent date and time that the session was modified.
        public var lastModifiedDateTime: ClientRuntime.Date?
        /// The date and time that the session started.
        public var startDateTime: ClientRuntime.Date?
        /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
        public var state: AthenaClientTypes.SessionState?
        /// The reason for the session state change (for example, canceled because the session was terminated).
        public var stateChangeReason: Swift.String?

        public init(
            endDateTime: ClientRuntime.Date? = nil,
            idleSinceDateTime: ClientRuntime.Date? = nil,
            lastModifiedDateTime: ClientRuntime.Date? = nil,
            startDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.SessionState? = nil,
            stateChangeReason: Swift.String? = nil
        )
        {
            self.endDateTime = endDateTime
            self.idleSinceDateTime = idleSinceDateTime
            self.lastModifiedDateTime = lastModifiedDateTime
            self.startDateTime = startDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
        }
    }

}

extension AthenaClientTypes.SessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case engineVersion = "EngineVersion"
        case notebookVersion = "NotebookVersion"
        case sessionId = "SessionId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let notebookVersion = self.notebookVersion {
            try encodeContainer.encode(notebookVersion, forKey: .notebookVersion)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AthenaClientTypes {
    /// Contains summary information about a session.
    public struct SessionSummary: Swift.Equatable {
        /// The session description.
        public var description: Swift.String?
        /// The engine version used by the session (for example, PySpark engine version 3).
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The notebook version.
        public var notebookVersion: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// Contains information about the session status.
        public var status: AthenaClientTypes.SessionStatus?

        public init(
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            notebookVersion: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: AthenaClientTypes.SessionStatus? = nil
        )
        {
            self.description = description
            self.engineVersion = engineVersion
            self.notebookVersion = notebookVersion
            self.sessionId = sessionId
            self.status = status
        }
    }

}

extension StartCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationConfiguration = "CalculationConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case codeBlock = "CodeBlock"
        case description = "Description"
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationConfiguration = self.calculationConfiguration {
            try encodeContainer.encode(calculationConfiguration, forKey: .calculationConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let codeBlock = self.codeBlock {
            try encodeContainer.encode(codeBlock, forKey: .codeBlock)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension StartCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartCalculationExecutionInput: Swift.Equatable {
    /// Contains configuration information for the calculation.
    @available(*, deprecated, message: "Kepler Post GA Tasks : https://sim.amazon.com/issues/ATHENA-39828")
    public var calculationConfiguration: AthenaClientTypes.CalculationConfiguration?
    /// A unique case-sensitive string used to ensure the request to create the calculation is idempotent (executes only once). If another StartCalculationExecutionRequest is received, the same response is returned and another calculation is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A string that contains the code of the calculation.
    public var codeBlock: Swift.String?
    /// A description of the calculation.
    public var description: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        calculationConfiguration: AthenaClientTypes.CalculationConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        codeBlock: Swift.String? = nil,
        description: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.calculationConfiguration = calculationConfiguration
        self.clientRequestToken = clientRequestToken
        self.codeBlock = codeBlock
        self.description = description
        self.sessionId = sessionId
    }
}

struct StartCalculationExecutionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let description: Swift.String?
    let calculationConfiguration: AthenaClientTypes.CalculationConfiguration?
    let codeBlock: Swift.String?
    let clientRequestToken: Swift.String?
}

extension StartCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationConfiguration = "CalculationConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case codeBlock = "CodeBlock"
        case description = "Description"
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let calculationConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationConfiguration.self, forKey: .calculationConfiguration)
        calculationConfiguration = calculationConfigurationDecoded
        let codeBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeBlock)
        codeBlock = codeBlockDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartCalculationExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartCalculationExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.calculationExecutionId = output.calculationExecutionId
            self.state = output.state
        } else {
            self.calculationExecutionId = nil
            self.state = nil
        }
    }
}

public struct StartCalculationExecutionOutput: Swift.Equatable {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init(
        calculationExecutionId: Swift.String? = nil,
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.state = state
    }
}

struct StartCalculationExecutionOutputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
    let state: AthenaClientTypes.CalculationExecutionState?
}

extension StartCalculationExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
    }
}

enum StartCalculationExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case executionParameters = "ExecutionParameters"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let executionParameters = executionParameters {
            var executionParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .executionParameters)
            for executionparameter0 in executionParameters {
                try executionParametersContainer.encode(executionparameter0)
            }
        }
        if let queryExecutionContext = self.queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let resultReuseConfiguration = self.resultReuseConfiguration {
            try encodeContainer.encode(resultReuseConfiguration, forKey: .resultReuseConfiguration)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension StartQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartQueryExecutionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another StartQueryExecution request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.
    public var executionParameters: [Swift.String]?
    /// The database within which the query executes.
    public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    /// The SQL query statements to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies information about where and how to save the results of the query execution. If the query runs in a workgroup, then workgroup's settings may override query settings. This affects the query results location. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
    /// Specifies the query result reuse behavior for the query.
    public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
    /// The name of the workgroup in which the query is being started.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        executionParameters: [Swift.String]? = nil,
        queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
        queryString: Swift.String? = nil,
        resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
        resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.executionParameters = executionParameters
        self.queryExecutionContext = queryExecutionContext
        self.queryString = queryString
        self.resultConfiguration = resultConfiguration
        self.resultReuseConfiguration = resultReuseConfiguration
        self.workGroup = workGroup
    }
}

struct StartQueryExecutionInputBody: Swift.Equatable {
    let queryString: Swift.String?
    let clientRequestToken: Swift.String?
    let queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    let resultConfiguration: AthenaClientTypes.ResultConfiguration?
    let workGroup: Swift.String?
    let executionParameters: [Swift.String]?
    let resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
}

extension StartQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case executionParameters = "ExecutionParameters"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case resultReuseConfiguration = "ResultReuseConfiguration"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let executionParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .executionParameters)
        var executionParametersDecoded0:[Swift.String]? = nil
        if let executionParametersContainer = executionParametersContainer {
            executionParametersDecoded0 = [Swift.String]()
            for string0 in executionParametersContainer {
                if let string0 = string0 {
                    executionParametersDecoded0?.append(string0)
                }
            }
        }
        executionParameters = executionParametersDecoded0
        let resultReuseConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultReuseConfiguration.self, forKey: .resultReuseConfiguration)
        resultReuseConfiguration = resultReuseConfigurationDecoded
    }
}

extension StartQueryExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartQueryExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutionId = output.queryExecutionId
        } else {
            self.queryExecutionId = nil
        }
    }
}

public struct StartQueryExecutionOutput: Swift.Equatable {
    /// The unique ID of the query that ran as a result of this request.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StartQueryExecutionOutputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StartQueryExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

enum StartQueryExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case notebookVersion = "NotebookVersion"
        case sessionIdleTimeoutInMinutes = "SessionIdleTimeoutInMinutes"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineConfiguration = self.engineConfiguration {
            try encodeContainer.encode(engineConfiguration, forKey: .engineConfiguration)
        }
        if let notebookVersion = self.notebookVersion {
            try encodeContainer.encode(notebookVersion, forKey: .notebookVersion)
        }
        if let sessionIdleTimeoutInMinutes = self.sessionIdleTimeoutInMinutes {
            try encodeContainer.encode(sessionIdleTimeoutInMinutes, forKey: .sessionIdleTimeoutInMinutes)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension StartSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSessionInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another StartSessionRequest is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The session description.
    public var description: Swift.String?
    /// Contains engine data processing unit (DPU) configuration settings and parameter mappings.
    /// This member is required.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is Athena notebook version 1. If you specify a value for NotebookVersion, you must also specify a value for NotebookId. See [EngineConfiguration$AdditionalConfigs].
    public var notebookVersion: Swift.String?
    /// The idle timeout in minutes for the session.
    public var sessionIdleTimeoutInMinutes: Swift.Int?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        notebookVersion: Swift.String? = nil,
        sessionIdleTimeoutInMinutes: Swift.Int? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.notebookVersion = notebookVersion
        self.sessionIdleTimeoutInMinutes = sessionIdleTimeoutInMinutes
        self.workGroup = workGroup
    }
}

struct StartSessionInputBody: Swift.Equatable {
    let description: Swift.String?
    let workGroup: Swift.String?
    let engineConfiguration: AthenaClientTypes.EngineConfiguration?
    let notebookVersion: Swift.String?
    let sessionIdleTimeoutInMinutes: Swift.Int?
    let clientRequestToken: Swift.String?
}

extension StartSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case engineConfiguration = "EngineConfiguration"
        case notebookVersion = "NotebookVersion"
        case sessionIdleTimeoutInMinutes = "SessionIdleTimeoutInMinutes"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineConfiguration.self, forKey: .engineConfiguration)
        engineConfiguration = engineConfigurationDecoded
        let notebookVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookVersion)
        notebookVersion = notebookVersionDecoded
        let sessionIdleTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionIdleTimeoutInMinutes)
        sessionIdleTimeoutInMinutes = sessionIdleTimeoutInMinutesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.sessionId = output.sessionId
            self.state = output.state
        } else {
            self.sessionId = nil
            self.state = nil
        }
    }
}

public struct StartSessionOutput: Swift.Equatable {
    /// The session ID.
    public var sessionId: Swift.String?
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init(
        sessionId: Swift.String? = nil,
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.sessionId = sessionId
        self.state = state
    }
}

struct StartSessionOutputBody: Swift.Equatable {
    let sessionId: Swift.String?
    let state: AthenaClientTypes.SessionState?
}

extension StartSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
    }
}

enum StartSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SessionAlreadyExistsException": return try await SessionAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes {
    public enum StatementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ddl
        case dml
        case utility
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementType] {
            return [
                .ddl,
                .dml,
                .utility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ddl: return "DDL"
            case .dml: return "DML"
            case .utility: return "UTILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatementType(rawValue: rawValue) ?? StatementType.sdkUnknown(rawValue)
        }
    }
}

extension StopCalculationExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let calculationExecutionId = self.calculationExecutionId {
            try encodeContainer.encode(calculationExecutionId, forKey: .calculationExecutionId)
        }
    }
}

extension StopCalculationExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopCalculationExecutionInput: Swift.Equatable {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

struct StopCalculationExecutionInputBody: Swift.Equatable {
    let calculationExecutionId: Swift.String?
}

extension StopCalculationExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case calculationExecutionId = "CalculationExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let calculationExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .calculationExecutionId)
        calculationExecutionId = calculationExecutionIdDecoded
    }
}

extension StopCalculationExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopCalculationExecutionOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct StopCalculationExecutionOutput: Swift.Equatable {
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init(
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.state = state
    }
}

struct StopCalculationExecutionOutputBody: Swift.Equatable {
    let state: AthenaClientTypes.CalculationExecutionState?
}

extension StopCalculationExecutionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CalculationExecutionState.self, forKey: .state)
        state = stateDecoded
    }
}

enum StopCalculationExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopQueryExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

extension StopQueryExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopQueryExecutionInput: Swift.Equatable {
    /// The unique ID of the query execution to stop.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StopQueryExecutionInputBody: Swift.Equatable {
    let queryExecutionId: Swift.String?
}

extension StopQueryExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension StopQueryExecutionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopQueryExecutionOutput: Swift.Equatable {

    public init() { }
}

enum StopQueryExecutionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.TableMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns = "Columns"
        case createTime = "CreateTime"
        case lastAccessTime = "LastAccessTime"
        case name = "Name"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case tableType = "TableType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for column0 in columns {
                try columnsContainer.encode(column0)
            }
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let lastAccessTime = self.lastAccessTime {
            try encodeContainer.encodeTimestamp(lastAccessTime, format: .epochSeconds, forKey: .lastAccessTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for column0 in partitionKeys {
                try partitionKeysContainer.encode(column0)
            }
        }
        if let tableType = self.tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .columns)
        var columnsDecoded0:[AthenaClientTypes.Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[AthenaClientTypes.Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [AthenaClientTypes.Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a table.
    public struct TableMetadata: Swift.Equatable {
        /// A list of the columns in the table.
        public var columns: [AthenaClientTypes.Column]?
        /// The time that the table was created.
        public var createTime: ClientRuntime.Date?
        /// The last time the table was accessed.
        public var lastAccessTime: ClientRuntime.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs for table properties.
        public var parameters: [Swift.String:Swift.String]?
        /// A list of the partition keys in the table.
        public var partitionKeys: [AthenaClientTypes.Column]?
        /// The type of table. In Athena, only EXTERNAL_TABLE is supported.
        public var tableType: Swift.String?

        public init(
            columns: [AthenaClientTypes.Column]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastAccessTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            partitionKeys: [AthenaClientTypes.Column]? = nil,
            tableType: Swift.String? = nil
        )
        {
            self.columns = columns
            self.createTime = createTime
            self.lastAccessTime = lastAccessTime
            self.name = name
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.tableType = tableType
        }
    }

}

extension AthenaClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AthenaClientTypes {
    /// A label that you assign to a resource. Athena resources include workgroups, data catalogs, and capacity reservations. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena resources by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter the resources in your account. For best practices, see [Tagging Best Practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html). Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas.
    public struct Tag: Swift.Equatable {
        /// A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource.
        public var key: Swift.String?
        /// A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the Athena resource to which tags are to be added.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A collection of one or more tags, separated by commas, to be added to an Athena resource.
    /// This member is required.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [AthenaClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AthenaClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AthenaClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AthenaClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TerminateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension TerminateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateSessionInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct TerminateSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension TerminateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension TerminateSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct TerminateSessionOutput: Swift.Equatable {
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init(
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.state = state
    }
}

struct TerminateSessionOutputBody: Swift.Equatable {
    let state: AthenaClientTypes.SessionState?
}

extension TerminateSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
    }
}

enum TerminateSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes {
    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentQueryLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .concurrentQueryLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentQueryLimitExceeded: return "CONCURRENT_QUERY_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the request was throttled.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
        public internal(set) var reason: AthenaClientTypes.ThrottleReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: AthenaClientTypes.ThrottleReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AthenaClientTypes.ThrottleReason?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension AthenaClientTypes.UnprocessedNamedQueryId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Information about a named query ID that could not be processed.
    public struct UnprocessedNamedQueryId: Swift.Equatable {
        /// The error code returned when the processing request for the named query failed, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the processing request for the named query failed, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the named query.
        public var namedQueryId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            namedQueryId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.namedQueryId = namedQueryId
        }
    }

}

extension AthenaClientTypes.UnprocessedPreparedStatementName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// The name of a prepared statement that could not be returned.
    public struct UnprocessedPreparedStatementName: Swift.Equatable {
        /// The error code returned when the request for the prepared statement failed.
        public var errorCode: Swift.String?
        /// The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:
        ///
        /// * INVALID_INPUT - The name of the prepared statement that was provided is not valid (for example, the name is too long).
        ///
        /// * STATEMENT_NOT_FOUND - A prepared statement with the name provided could not be found.
        ///
        /// * UNAUTHORIZED - The requester does not have permission to access the workgroup that contains the prepared statement.
        public var errorMessage: Swift.String?
        /// The name of a prepared statement that could not be returned due to an error.
        public var statementName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.statementName = statementName
        }
    }

}

extension AthenaClientTypes.UnprocessedQueryExecutionId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let queryExecutionId = self.queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AthenaClientTypes {
    /// Describes a query execution that failed to process.
    public struct UnprocessedQueryExecutionId: Swift.Equatable {
        /// The error code returned when the query execution failed to process, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the query execution failed to process, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the query execution.
        public var queryExecutionId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            queryExecutionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.queryExecutionId = queryExecutionId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the ARN of the resource from which tags are to be removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A comma-separated list of one or more tag keys whose tags are to be removed from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCapacityReservationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case targetDpus = "TargetDpus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetDpus = self.targetDpus {
            try encodeContainer.encode(targetDpus, forKey: .targetDpus)
        }
    }
}

extension UpdateCapacityReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCapacityReservationInput: Swift.Equatable {
    /// The name of the capacity reservation.
    /// This member is required.
    public var name: Swift.String?
    /// The new number of requested data processing units.
    /// This member is required.
    public var targetDpus: Swift.Int?

    public init(
        name: Swift.String? = nil,
        targetDpus: Swift.Int? = nil
    )
    {
        self.name = name
        self.targetDpus = targetDpus
    }
}

struct UpdateCapacityReservationInputBody: Swift.Equatable {
    let targetDpus: Swift.Int?
    let name: Swift.String?
}

extension UpdateCapacityReservationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case targetDpus = "TargetDpus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetDpus)
        targetDpus = targetDpusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateCapacityReservationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCapacityReservationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCapacityReservationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parametersMap0) in parameters {
                try parametersContainer.encode(parametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateDataCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDataCatalogInput: Swift.Equatable {
    /// New or modified text that describes the data catalog.
    public var description: Swift.String?
    /// The name of the data catalog to update. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for updating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    public var parameters: [Swift.String:Swift.String]?
    /// Specifies the type of data catalog to update. Specify LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

struct UpdateDataCatalogInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: AthenaClientTypes.DataCatalogType?
    let description: Swift.String?
    let parameters: [Swift.String:Swift.String]?
}

extension UpdateDataCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension UpdateDataCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataCatalogOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNamedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = self.namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }
}

extension UpdateNamedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNamedQueryInput: Swift.Equatable {
    /// The query description.
    public var description: Swift.String?
    /// The name of the query.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier (UUID) of the query.
    /// This member is required.
    public var namedQueryId: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        namedQueryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.namedQueryId = namedQueryId
        self.queryString = queryString
    }
}

struct UpdateNamedQueryInputBody: Swift.Equatable {
    let namedQueryId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let queryString: Swift.String?
}

extension UpdateNamedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
    }
}

extension UpdateNamedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNamedQueryOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNamedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNotebookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case notebookId = "NotebookId"
        case payload = "Payload"
        case sessionId = "SessionId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
        if let payload = self.payload {
            try encodeContainer.encode(payload, forKey: .payload)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateNotebookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNotebookInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The ID of the notebook to update.
    /// This member is required.
    public var notebookId: Swift.String?
    /// The updated content for the notebook.
    /// This member is required.
    public var payload: Swift.String?
    /// The active notebook session ID. Required if the notebook has an active session.
    public var sessionId: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?

    public init(
        clientRequestToken: Swift.String? = nil,
        notebookId: Swift.String? = nil,
        payload: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.notebookId = notebookId
        self.payload = payload
        self.sessionId = sessionId
        self.type = type
    }
}

struct UpdateNotebookInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let payload: Swift.String?
    let type: AthenaClientTypes.NotebookType?
    let sessionId: Swift.String?
    let clientRequestToken: Swift.String?
}

extension UpdateNotebookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case notebookId = "NotebookId"
        case payload = "Payload"
        case sessionId = "SessionId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .payload)
        payload = payloadDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.NotebookType.self, forKey: .type)
        type = typeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpdateNotebookMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case notebookId = "NotebookId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notebookId = self.notebookId {
            try encodeContainer.encode(notebookId, forKey: .notebookId)
        }
    }
}

extension UpdateNotebookMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNotebookMetadataInput: Swift.Equatable {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name to update the notebook to.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the notebook to update the metadata for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.notebookId = notebookId
    }
}

struct UpdateNotebookMetadataInputBody: Swift.Equatable {
    let notebookId: Swift.String?
    let clientRequestToken: Swift.String?
    let name: Swift.String?
}

extension UpdateNotebookMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case notebookId = "NotebookId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notebookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookId)
        notebookId = notebookIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateNotebookMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNotebookMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNotebookMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNotebookOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNotebookOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNotebookOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePreparedStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = self.statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdatePreparedStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePreparedStatementInput: Swift.Equatable {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup for the prepared statement.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct UpdatePreparedStatementInputBody: Swift.Equatable {
    let statementName: Swift.String?
    let workGroup: Swift.String?
    let queryStatement: Swift.String?
    let description: Swift.String?
}

extension UpdatePreparedStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePreparedStatementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePreparedStatementOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePreparedStatementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUpdates = self.configurationUpdates {
            try encodeContainer.encode(configurationUpdates, forKey: .configurationUpdates)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let workGroup = self.workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

extension UpdateWorkGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWorkGroupInput: Swift.Equatable {
    /// Contains configuration updates for an Athena SQL workgroup.
    public var configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup state that will be updated for the given workgroup.
    public var state: AthenaClientTypes.WorkGroupState?
    /// The specified workgroup that will be updated.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates? = nil,
        description: Swift.String? = nil,
        state: AthenaClientTypes.WorkGroupState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.configurationUpdates = configurationUpdates
        self.description = description
        self.state = state
        self.workGroup = workGroup
    }
}

struct UpdateWorkGroupInputBody: Swift.Equatable {
    let workGroup: Swift.String?
    let description: Swift.String?
    let configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    let state: AthenaClientTypes.WorkGroupState?
}

extension UpdateWorkGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfigurationUpdates.self, forKey: .configurationUpdates)
        configurationUpdates = configurationUpdatesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateWorkGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateWorkGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateWorkGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AthenaClientTypes.WorkGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case creationTime = "CreationTime"
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AthenaClientTypes {
    /// A workgroup, which contains a name, description, creation time, state, and other configuration, listed under [WorkGroup$Configuration]. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroup: Swift.Equatable {
        /// The configuration of the workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for query and calculation results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var configuration: AthenaClientTypes.WorkGroupConfiguration?
        /// The date and time the workgroup was created.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The workgroup name.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the workgroup: ENABLED or DISABLED.
        public var state: AthenaClientTypes.WorkGroupState?

        public init(
            configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.configuration = configuration
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.state = state
        }
    }

}

extension AthenaClientTypes.WorkGroupConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "AdditionalConfiguration"
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case customerContentEncryptionConfiguration = "CustomerContentEncryptionConfiguration"
        case enableMinimumEncryptionConfiguration = "EnableMinimumEncryptionConfiguration"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case executionRole = "ExecutionRole"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfiguration = "ResultConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = self.additionalConfiguration {
            try encodeContainer.encode(additionalConfiguration, forKey: .additionalConfiguration)
        }
        if let bytesScannedCutoffPerQuery = self.bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let customerContentEncryptionConfiguration = self.customerContentEncryptionConfiguration {
            try encodeContainer.encode(customerContentEncryptionConfiguration, forKey: .customerContentEncryptionConfiguration)
        }
        if let enableMinimumEncryptionConfiguration = self.enableMinimumEncryptionConfiguration {
            try encodeContainer.encode(enableMinimumEncryptionConfiguration, forKey: .enableMinimumEncryptionConfiguration)
        }
        if let enforceWorkGroupConfiguration = self.enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let publishCloudWatchMetricsEnabled = self.publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let requesterPaysEnabled = self.requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let additionalConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalConfiguration)
        additionalConfiguration = additionalConfigurationDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let customerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CustomerContentEncryptionConfiguration.self, forKey: .customerContentEncryptionConfiguration)
        customerContentEncryptionConfiguration = customerContentEncryptionConfigurationDecoded
        let enableMinimumEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMinimumEncryptionConfiguration)
        enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration of the workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption option, if any, used for query and calculation results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroupConfiguration: Swift.Equatable {
        /// Specifies a user defined JSON string that is passed to the notebook engine.
        public var additionalConfiguration: Swift.String?
        /// The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// Enforces a minimal level of encryption for the workgroup for query and calculation results that are written to Amazon S3. When enabled, workgroup users can set encryption only to the minimum level set by the administrator or higher when they submit queries. The EnforceWorkGroupConfiguration setting takes precedence over the EnableMinimumEncryptionConfiguration flag. This means that if EnforceWorkGroupConfiguration is true, the EnableMinimumEncryptionConfiguration flag is ignored, and the workgroup configuration for encryption is used.
        public var enableMinimumEncryptionConfiguration: Swift.Bool?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version that all queries running on the workgroup use. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Role used in a session for accessing the user's resources.
        public var executionRole: Swift.String?
        /// Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The configuration for the workgroup, which includes the location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using [ResultConfiguration$OutputLocation]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?

        public init(
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enableMinimumEncryptionConfiguration: Swift.Bool? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfiguration = resultConfiguration
        }
    }

}

extension AthenaClientTypes.WorkGroupConfigurationUpdates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "AdditionalConfiguration"
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case customerContentEncryptionConfiguration = "CustomerContentEncryptionConfiguration"
        case enableMinimumEncryptionConfiguration = "EnableMinimumEncryptionConfiguration"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case executionRole = "ExecutionRole"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case removeBytesScannedCutoffPerQuery = "RemoveBytesScannedCutoffPerQuery"
        case removeCustomerContentEncryptionConfiguration = "RemoveCustomerContentEncryptionConfiguration"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfigurationUpdates = "ResultConfigurationUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = self.additionalConfiguration {
            try encodeContainer.encode(additionalConfiguration, forKey: .additionalConfiguration)
        }
        if let bytesScannedCutoffPerQuery = self.bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let customerContentEncryptionConfiguration = self.customerContentEncryptionConfiguration {
            try encodeContainer.encode(customerContentEncryptionConfiguration, forKey: .customerContentEncryptionConfiguration)
        }
        if let enableMinimumEncryptionConfiguration = self.enableMinimumEncryptionConfiguration {
            try encodeContainer.encode(enableMinimumEncryptionConfiguration, forKey: .enableMinimumEncryptionConfiguration)
        }
        if let enforceWorkGroupConfiguration = self.enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let executionRole = self.executionRole {
            try encodeContainer.encode(executionRole, forKey: .executionRole)
        }
        if let publishCloudWatchMetricsEnabled = self.publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let removeBytesScannedCutoffPerQuery = self.removeBytesScannedCutoffPerQuery {
            try encodeContainer.encode(removeBytesScannedCutoffPerQuery, forKey: .removeBytesScannedCutoffPerQuery)
        }
        if let removeCustomerContentEncryptionConfiguration = self.removeCustomerContentEncryptionConfiguration {
            try encodeContainer.encode(removeCustomerContentEncryptionConfiguration, forKey: .removeCustomerContentEncryptionConfiguration)
        }
        if let requesterPaysEnabled = self.requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfigurationUpdates = self.resultConfigurationUpdates {
            try encodeContainer.encode(resultConfigurationUpdates, forKey: .resultConfigurationUpdates)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let resultConfigurationUpdatesDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.ResultConfigurationUpdates.self, forKey: .resultConfigurationUpdates)
        resultConfigurationUpdates = resultConfigurationUpdatesDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let removeBytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeBytesScannedCutoffPerQuery)
        removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let removeCustomerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeCustomerContentEncryptionConfiguration)
        removeCustomerContentEncryptionConfiguration = removeCustomerContentEncryptionConfigurationDecoded
        let additionalConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalConfiguration)
        additionalConfiguration = additionalConfigurationDecoded
        let executionRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRole)
        executionRole = executionRoleDecoded
        let customerContentEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.CustomerContentEncryptionConfiguration.self, forKey: .customerContentEncryptionConfiguration)
        customerContentEncryptionConfiguration = customerContentEncryptionConfigurationDecoded
        let enableMinimumEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMinimumEncryptionConfiguration)
        enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfigurationDecoded
    }
}

extension AthenaClientTypes {
    /// The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.
    public struct WorkGroupConfigurationUpdates: Swift.Equatable {
        /// Contains a user defined string in JSON format for a Spark-enabled workgroup.
        public var additionalConfiguration: Swift.String?
        /// The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// Enforces a minimal level of encryption for the workgroup for query and calculation results that are written to Amazon S3. When enabled, workgroup users can set encryption only to the minimum level set by the administrator or higher when they submit queries. This setting does not apply to Spark-enabled workgroups. The EnforceWorkGroupConfiguration setting takes precedence over the EnableMinimumEncryptionConfiguration flag. This means that if EnforceWorkGroupConfiguration is true, the EnableMinimumEncryptionConfiguration flag is ignored, and the workgroup configuration for encryption is used.
        public var enableMinimumEncryptionConfiguration: Swift.Bool?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// Contains the ARN of the execution role for the workgroup
        public var executionRole: Swift.String?
        /// Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// Indicates that the data usage control limit per query is removed. [WorkGroupConfiguration$BytesScannedCutoffPerQuery]
        public var removeBytesScannedCutoffPerQuery: Swift.Bool?
        /// Removes content encryption configuration from an Apache Spark-enabled Athena workgroup.
        public var removeCustomerContentEncryptionConfiguration: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.
        public var resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates?

        public init(
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enableMinimumEncryptionConfiguration: Swift.Bool? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            removeBytesScannedCutoffPerQuery: Swift.Bool? = nil,
            removeCustomerContentEncryptionConfiguration: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery
            self.removeCustomerContentEncryptionConfiguration = removeCustomerContentEncryptionConfiguration
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfigurationUpdates = resultConfigurationUpdates
        }
    }

}

extension AthenaClientTypes {
    public enum WorkGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkGroupState(rawValue: rawValue) ?? WorkGroupState.sdkUnknown(rawValue)
        }
    }
}

extension AthenaClientTypes.WorkGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(AthenaClientTypes.EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension AthenaClientTypes {
    /// The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.
    public struct WorkGroupSummary: Swift.Equatable {
        /// The workgroup creation date and time.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The engine version setting for all queries on the workgroup. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The name of the workgroup.
        public var name: Swift.String?
        /// The state of the workgroup.
        public var state: AthenaClientTypes.WorkGroupState?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.engineVersion = engineVersion
            self.name = name
            self.state = state
        }
    }

}
