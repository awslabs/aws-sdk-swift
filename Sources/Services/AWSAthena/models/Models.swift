// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AthenaClientTypes.AclConfiguration {

    static func write(value: AthenaClientTypes.AclConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3AclOption"].write(value.s3AclOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.AclConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.AclConfiguration()
        value.s3AclOption = try reader["S3AclOption"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. When Athena stores query results in Amazon S3, the canned ACL is set with the x-amz-acl request header. For more information about S3 Object Ownership, see [Object Ownership settings](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html#object-ownership-overview) in the Amazon S3 User Guide.
    public struct AclConfiguration {
        /// The Amazon S3 canned ACL that Athena should specify when storing query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. If a query runs in a workgroup and the workgroup overrides client-side settings, then the Amazon S3 canned ACL specified in the workgroup's settings is used for all queries that run in the workgroup. For more information about Amazon S3 canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) in the Amazon S3 User Guide.
        /// This member is required.
        public var s3AclOption: AthenaClientTypes.S3AclOption?

        public init(
            s3AclOption: AthenaClientTypes.S3AclOption? = nil
        )
        {
            self.s3AclOption = s3AclOption
        }
    }

}

extension AthenaClientTypes.ApplicationDPUSizes {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ApplicationDPUSizes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ApplicationDPUSizes()
        value.applicationRuntimeId = try reader["ApplicationRuntimeId"].readIfPresent()
        value.supportedDPUSizes = try reader["SupportedDPUSizes"].readListIfPresent(memberReadingClosure: Swift.Int.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains the application runtime IDs and their supported DPU sizes.
    public struct ApplicationDPUSizes {
        /// The name of the supported application runtime (for example, Athena notebook version 1).
        public var applicationRuntimeId: Swift.String?
        /// A list of the supported DPU sizes that the application runtime supports.
        public var supportedDPUSizes: [Swift.Int]?

        public init(
            applicationRuntimeId: Swift.String? = nil,
            supportedDPUSizes: [Swift.Int]? = nil
        )
        {
            self.applicationRuntimeId = applicationRuntimeId
            self.supportedDPUSizes = supportedDPUSizes
        }
    }

}

public enum AthenaClientTypes {}

extension AthenaClientTypes.AthenaError {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.AthenaError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.AthenaError()
        value.errorCategory = try reader["ErrorCategory"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        value.retryable = try reader["Retryable"].readIfPresent() ?? false
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Provides information about an Athena query error. The AthenaError feature provides standardized error information to help you understand failed queries and take steps after a query failure occurs. AthenaError includes an ErrorCategory field that specifies whether the cause of the failed query is due to system error, user error, or other error.
    public struct AthenaError {
        /// An integer value that specifies the category of a query failure error. The following list shows the category for each integer value. 1 - System 2 - User 3 - Other
        public var errorCategory: Swift.Int?
        /// Contains a short description of the error that occurred.
        public var errorMessage: Swift.String?
        /// An integer value that provides specific information about an Athena query error. For the meaning of specific values, see the [Error Type Reference](https://docs.aws.amazon.com/athena/latest/ug/error-reference.html#error-reference-error-type-reference) in the Amazon Athena User Guide.
        public var errorType: Swift.Int?
        /// True if the query might succeed if resubmitted.
        public var retryable: Swift.Bool

        public init(
            errorCategory: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            errorType: Swift.Int? = nil,
            retryable: Swift.Bool = false
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.retryable = retryable
        }
    }

}

extension AthenaClientTypes {

    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directoryIdentity
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .directoryIdentity,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directoryIdentity: return "DIRECTORY_IDENTITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BatchGetNamedQueryInput {

    static func urlPathProvider(_ value: BatchGetNamedQueryInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetNamedQueryInput {

    static func write(value: BatchGetNamedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamedQueryIds"].writeList(value.namedQueryIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Contains an array of named query IDs.
public struct BatchGetNamedQueryInput {
    /// An array of query IDs.
    /// This member is required.
    public var namedQueryIds: [Swift.String]?

    public init(
        namedQueryIds: [Swift.String]? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
    }
}

extension BatchGetNamedQueryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchGetNamedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetNamedQueryOutput()
        value.namedQueries = try reader["NamedQueries"].readListIfPresent(memberReadingClosure: AthenaClientTypes.NamedQuery.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedNamedQueryIds = try reader["UnprocessedNamedQueryIds"].readListIfPresent(memberReadingClosure: AthenaClientTypes.UnprocessedNamedQueryId.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchGetNamedQueryOutput {
    /// Information about the named query IDs submitted.
    public var namedQueries: [AthenaClientTypes.NamedQuery]?
    /// Information about provided query IDs.
    public var unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]?

    public init(
        namedQueries: [AthenaClientTypes.NamedQuery]? = nil,
        unprocessedNamedQueryIds: [AthenaClientTypes.UnprocessedNamedQueryId]? = nil
    )
    {
        self.namedQueries = namedQueries
        self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
    }
}

enum BatchGetNamedQueryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BatchGetPreparedStatementInput {

    static func urlPathProvider(_ value: BatchGetPreparedStatementInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetPreparedStatementInput {

    static func write(value: BatchGetPreparedStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PreparedStatementNames"].writeList(value.preparedStatementNames, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct BatchGetPreparedStatementInput {
    /// A list of prepared statement names to return.
    /// This member is required.
    public var preparedStatementNames: [Swift.String]?
    /// The name of the workgroup to which the prepared statements belong.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        preparedStatementNames: [Swift.String]? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.preparedStatementNames = preparedStatementNames
        self.workGroup = workGroup
    }
}

extension BatchGetPreparedStatementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchGetPreparedStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetPreparedStatementOutput()
        value.preparedStatements = try reader["PreparedStatements"].readListIfPresent(memberReadingClosure: AthenaClientTypes.PreparedStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedPreparedStatementNames = try reader["UnprocessedPreparedStatementNames"].readListIfPresent(memberReadingClosure: AthenaClientTypes.UnprocessedPreparedStatementName.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchGetPreparedStatementOutput {
    /// The list of prepared statements returned.
    public var preparedStatements: [AthenaClientTypes.PreparedStatement]?
    /// A list of one or more prepared statements that were requested but could not be returned.
    public var unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]?

    public init(
        preparedStatements: [AthenaClientTypes.PreparedStatement]? = nil,
        unprocessedPreparedStatementNames: [AthenaClientTypes.UnprocessedPreparedStatementName]? = nil
    )
    {
        self.preparedStatements = preparedStatements
        self.unprocessedPreparedStatementNames = unprocessedPreparedStatementNames
    }
}

enum BatchGetPreparedStatementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BatchGetQueryExecutionInput {

    static func urlPathProvider(_ value: BatchGetQueryExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetQueryExecutionInput {

    static func write(value: BatchGetQueryExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryExecutionIds"].writeList(value.queryExecutionIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Contains an array of query execution IDs.
public struct BatchGetQueryExecutionInput {
    /// An array of query execution IDs.
    /// This member is required.
    public var queryExecutionIds: [Swift.String]?

    public init(
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.queryExecutionIds = queryExecutionIds
    }
}

extension BatchGetQueryExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchGetQueryExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetQueryExecutionOutput()
        value.queryExecutions = try reader["QueryExecutions"].readListIfPresent(memberReadingClosure: AthenaClientTypes.QueryExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedQueryExecutionIds = try reader["UnprocessedQueryExecutionIds"].readListIfPresent(memberReadingClosure: AthenaClientTypes.UnprocessedQueryExecutionId.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchGetQueryExecutionOutput {
    /// Information about a query execution.
    public var queryExecutions: [AthenaClientTypes.QueryExecution]?
    /// Information about the query executions that failed to run.
    public var unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]?

    public init(
        queryExecutions: [AthenaClientTypes.QueryExecution]? = nil,
        unprocessedQueryExecutionIds: [AthenaClientTypes.UnprocessedQueryExecutionId]? = nil
    )
    {
        self.queryExecutions = queryExecutions
        self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
    }
}

enum BatchGetQueryExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.CalculationConfiguration {

    static func write(value: AthenaClientTypes.CalculationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeBlock"].write(value.codeBlock)
    }
}

extension AthenaClientTypes {
    /// Contains configuration information for the calculation.
    public struct CalculationConfiguration {
        /// A string that contains the code for the calculation.
        public var codeBlock: Swift.String?

        public init(
            codeBlock: Swift.String? = nil
        )
        {
            self.codeBlock = codeBlock
        }
    }

}

extension AthenaClientTypes {

    public enum CalculationExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case creating
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CalculationExecutionState] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .creating,
                .failed,
                .queued,
                .running,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.CalculationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CalculationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CalculationResult()
        value.stdOutS3Uri = try reader["StdOutS3Uri"].readIfPresent()
        value.stdErrorS3Uri = try reader["StdErrorS3Uri"].readIfPresent()
        value.resultS3Uri = try reader["ResultS3Uri"].readIfPresent()
        value.resultType = try reader["ResultType"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains information about an application-specific calculation result.
    public struct CalculationResult {
        /// The Amazon S3 location of the folder for the calculation results.
        public var resultS3Uri: Swift.String?
        /// The data format of the calculation result.
        public var resultType: Swift.String?
        /// The Amazon S3 location of the stderr error messages file for the calculation.
        public var stdErrorS3Uri: Swift.String?
        /// The Amazon S3 location of the stdout file for the calculation.
        public var stdOutS3Uri: Swift.String?

        public init(
            resultS3Uri: Swift.String? = nil,
            resultType: Swift.String? = nil,
            stdErrorS3Uri: Swift.String? = nil,
            stdOutS3Uri: Swift.String? = nil
        )
        {
            self.resultS3Uri = resultS3Uri
            self.resultType = resultType
            self.stdErrorS3Uri = stdErrorS3Uri
            self.stdOutS3Uri = stdOutS3Uri
        }
    }

}

extension AthenaClientTypes.CalculationStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CalculationStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CalculationStatistics()
        value.dpuExecutionInMillis = try reader["DpuExecutionInMillis"].readIfPresent()
        value.progress = try reader["Progress"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a notebook calculation.
    public struct CalculationStatistics {
        /// The data processing unit execution time in milliseconds for the calculation.
        public var dpuExecutionInMillis: Swift.Int?
        /// The progress of the calculation.
        public var progress: Swift.String?

        public init(
            dpuExecutionInMillis: Swift.Int? = nil,
            progress: Swift.String? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
            self.progress = progress
        }
    }

}

extension AthenaClientTypes.CalculationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CalculationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CalculationStatus()
        value.submissionDateTime = try reader["SubmissionDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.completionDateTime = try reader["CompletionDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a notebook calculation.
    public struct CalculationStatus {
        /// The date and time the calculation completed processing.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of the calculation execution. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
        public var state: AthenaClientTypes.CalculationExecutionState?
        /// The reason for the calculation state change (for example, the calculation was canceled because the session was terminated).
        public var stateChangeReason: Swift.String?
        /// The date and time the calculation was submitted for processing.
        public var submissionDateTime: ClientRuntime.Date?

        public init(
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.CalculationExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.CalculationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CalculationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CalculationSummary()
        value.calculationExecutionId = try reader["CalculationExecutionId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.CalculationStatus.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// Summary information for a notebook calculation.
    public struct CalculationSummary {
        /// The calculation execution UUID.
        public var calculationExecutionId: Swift.String?
        /// A description of the calculation.
        public var description: Swift.String?
        /// Contains information about the status of the calculation.
        public var status: AthenaClientTypes.CalculationStatus?

        public init(
            calculationExecutionId: Swift.String? = nil,
            description: Swift.String? = nil,
            status: AthenaClientTypes.CalculationStatus? = nil
        )
        {
            self.calculationExecutionId = calculationExecutionId
            self.description = description
            self.status = status
        }
    }

}

extension CancelCapacityReservationInput {

    static func urlPathProvider(_ value: CancelCapacityReservationInput) -> Swift.String? {
        return "/"
    }
}

extension CancelCapacityReservationInput {

    static func write(value: CancelCapacityReservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct CancelCapacityReservationInput {
    /// The name of the capacity reservation to cancel.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension CancelCapacityReservationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CancelCapacityReservationOutput {
        return CancelCapacityReservationOutput()
    }
}

public struct CancelCapacityReservationOutput {

    public init() { }
}

enum CancelCapacityReservationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.CapacityAllocation {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CapacityAllocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CapacityAllocation()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.requestTime = try reader["RequestTime"].readTimestampIfPresent(format: .epochSeconds)
        value.requestCompletionTime = try reader["RequestCompletionTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains the submission time of a single allocation request for a capacity reservation and the most recent status of the attempted allocation.
    public struct CapacityAllocation {
        /// The time when the capacity allocation request was completed.
        public var requestCompletionTime: ClientRuntime.Date?
        /// The time when the capacity allocation was requested.
        /// This member is required.
        public var requestTime: ClientRuntime.Date?
        /// The status of the capacity allocation.
        /// This member is required.
        public var status: AthenaClientTypes.CapacityAllocationStatus?
        /// The status message of the capacity allocation.
        public var statusMessage: Swift.String?

        public init(
            requestCompletionTime: ClientRuntime.Date? = nil,
            requestTime: ClientRuntime.Date? = nil,
            status: AthenaClientTypes.CapacityAllocationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.requestCompletionTime = requestCompletionTime
            self.requestTime = requestTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension AthenaClientTypes {

    public enum CapacityAllocationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityAllocationStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.CapacityAssignment {

    static func write(value: AthenaClientTypes.CapacityAssignment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkGroupNames"].writeList(value.workGroupNames, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CapacityAssignment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CapacityAssignment()
        value.workGroupNames = try reader["WorkGroupNames"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// A mapping between one or more workgroups and a capacity reservation.
    public struct CapacityAssignment {
        /// The list of workgroup names for the capacity assignment.
        public var workGroupNames: [Swift.String]?

        public init(
            workGroupNames: [Swift.String]? = nil
        )
        {
            self.workGroupNames = workGroupNames
        }
    }

}

extension AthenaClientTypes.CapacityAssignmentConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CapacityAssignmentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CapacityAssignmentConfiguration()
        value.capacityReservationName = try reader["CapacityReservationName"].readIfPresent()
        value.capacityAssignments = try reader["CapacityAssignments"].readListIfPresent(memberReadingClosure: AthenaClientTypes.CapacityAssignment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Assigns Athena workgroups (and hence their queries) to capacity reservations. A capacity reservation can have only one capacity assignment configuration, but the capacity assignment configuration can be made up of multiple individual assignments. Each assignment specifies how Athena queries can consume capacity from the capacity reservation that their workgroup is mapped to.
    public struct CapacityAssignmentConfiguration {
        /// The list of assignments that make up the capacity assignment configuration.
        public var capacityAssignments: [AthenaClientTypes.CapacityAssignment]?
        /// The name of the reservation that the capacity assignment configuration is for.
        public var capacityReservationName: Swift.String?

        public init(
            capacityAssignments: [AthenaClientTypes.CapacityAssignment]? = nil,
            capacityReservationName: Swift.String? = nil
        )
        {
            self.capacityAssignments = capacityAssignments
            self.capacityReservationName = capacityReservationName
        }
    }

}

extension AthenaClientTypes.CapacityReservation {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CapacityReservation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CapacityReservation()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetDpus = try reader["TargetDpus"].readIfPresent()
        value.allocatedDpus = try reader["AllocatedDpus"].readIfPresent()
        value.lastAllocation = try reader["LastAllocation"].readIfPresent(with: AthenaClientTypes.CapacityAllocation.read(from:))
        value.lastSuccessfulAllocationTime = try reader["LastSuccessfulAllocationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// A reservation for a specified number of data processing units (DPUs). When a reservation is initially created, it has no DPUs. Athena allocates DPUs until the allocated amount equals the requested amount.
    public struct CapacityReservation {
        /// The number of data processing units currently allocated.
        /// This member is required.
        public var allocatedDpus: Swift.Int?
        /// The time in UTC epoch millis when the capacity reservation was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Contains the submission time of a single allocation request for a capacity reservation and the most recent status of the attempted allocation.
        public var lastAllocation: AthenaClientTypes.CapacityAllocation?
        /// The time of the most recent capacity allocation that succeeded.
        public var lastSuccessfulAllocationTime: ClientRuntime.Date?
        /// The name of the capacity reservation.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the capacity reservation.
        /// This member is required.
        public var status: AthenaClientTypes.CapacityReservationStatus?
        /// The number of data processing units requested.
        /// This member is required.
        public var targetDpus: Swift.Int?

        public init(
            allocatedDpus: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastAllocation: AthenaClientTypes.CapacityAllocation? = nil,
            lastSuccessfulAllocationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AthenaClientTypes.CapacityReservationStatus? = nil,
            targetDpus: Swift.Int? = nil
        )
        {
            self.allocatedDpus = allocatedDpus
            self.creationTime = creationTime
            self.lastAllocation = lastAllocation
            self.lastSuccessfulAllocationTime = lastSuccessfulAllocationTime
            self.name = name
            self.status = status
            self.targetDpus = targetDpus
        }
    }

}

extension AthenaClientTypes {

    public enum CapacityReservationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case cancelled
        case cancelling
        case failed
        case pending
        case updatePending
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityReservationStatus] {
            return [
                .active,
                .cancelled,
                .cancelling,
                .failed,
                .pending,
                .updatePending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .updatePending: return "UPDATE_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.Column {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.Column {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.Column()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a column in a table.
    public struct Column {
        /// Optional information about the column.
        public var comment: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column.
        public var type: Swift.String?

        public init(
            comment: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.comment = comment
            self.name = name
            self.type = type
        }
    }

}

extension AthenaClientTypes.ColumnInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ColumnInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ColumnInfo()
        value.catalogName = try reader["CatalogName"].readIfPresent()
        value.schemaName = try reader["SchemaName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.precision = try reader["Precision"].readIfPresent() ?? 0
        value.scale = try reader["Scale"].readIfPresent() ?? 0
        value.nullable = try reader["Nullable"].readIfPresent()
        value.caseSensitive = try reader["CaseSensitive"].readIfPresent() ?? false
        return value
    }
}

extension AthenaClientTypes {
    /// Information about the columns in a query execution result.
    public struct ColumnInfo {
        /// Indicates whether values in the column are case-sensitive.
        public var caseSensitive: Swift.Bool
        /// The catalog to which the query results belong.
        public var catalogName: Swift.String?
        /// A column label.
        public var label: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// Unsupported constraint. This value always shows as UNKNOWN.
        public var nullable: AthenaClientTypes.ColumnNullable?
        /// For DECIMAL data types, specifies the total number of digits, up to 38. For performance reasons, we recommend up to 18 digits.
        public var precision: Swift.Int
        /// For DECIMAL data types, specifies the total number of digits in the fractional part of the value. Defaults to 0.
        public var scale: Swift.Int
        /// The schema name (database name) to which the query results belong.
        public var schemaName: Swift.String?
        /// The table name for the query results.
        public var tableName: Swift.String?
        /// The data type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init(
            caseSensitive: Swift.Bool = false,
            catalogName: Swift.String? = nil,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: AthenaClientTypes.ColumnNullable? = nil,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.catalogName = catalogName
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
        }
    }

}

extension AthenaClientTypes {

    public enum ColumnNullable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notNull
        case nullable
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnNullable] {
            return [
                .notNull,
                .nullable,
                .unknown,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notNull: return "NOT_NULL"
            case .nullable: return "NULLABLE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CreateCapacityReservationInput {

    static func urlPathProvider(_ value: CreateCapacityReservationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCapacityReservationInput {

    static func write(value: CreateCapacityReservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AthenaClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetDpus"].write(value.targetDpus)
    }
}

public struct CreateCapacityReservationInput {
    /// The name of the capacity reservation to create.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the capacity reservation.
    public var tags: [AthenaClientTypes.Tag]?
    /// The number of requested data processing units.
    /// This member is required.
    public var targetDpus: Swift.Int?

    public init(
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        targetDpus: Swift.Int? = nil
    )
    {
        self.name = name
        self.tags = tags
        self.targetDpus = targetDpus
    }
}

extension CreateCapacityReservationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateCapacityReservationOutput {
        return CreateCapacityReservationOutput()
    }
}

public struct CreateCapacityReservationOutput {

    public init() { }
}

enum CreateCapacityReservationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDataCatalogInput {

    static func urlPathProvider(_ value: CreateDataCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDataCatalogInput {

    static func write(value: CreateDataCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AthenaClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

public struct CreateDataCatalogInput {
    /// A description of the data catalog to be created.
    public var description: Swift.String?
    /// The name of the data catalog to create. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for creating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    ///
    ///
    ///
    ///
    /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue Data Catalog belongs. catalog-id=catalog_id
    ///
    /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
    public var parameters: [Swift.String:Swift.String]?
    /// A list of comma separated tags to add to the data catalog that is created.
    public var tags: [AthenaClientTypes.Tag]?
    /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        tags: [AthenaClientTypes.Tag]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
        self.type = type
    }
}

extension CreateDataCatalogOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDataCatalogOutput {
        return CreateDataCatalogOutput()
    }
}

public struct CreateDataCatalogOutput {

    public init() { }
}

enum CreateDataCatalogOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateNamedQueryInput {

    static func urlPathProvider(_ value: CreateNamedQueryInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNamedQueryInput {

    static func write(value: CreateNamedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Database"].write(value.database)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["QueryString"].write(value.queryString)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct CreateNamedQueryInput {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another CreateNamedQuery request is received, the same response is returned and another query is not created. If a parameter has changed, for example, the QueryString, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The database to which the query belongs.
    /// This member is required.
    public var database: Swift.String?
    /// The query description.
    public var description: Swift.String?
    /// The query name.
    /// This member is required.
    public var name: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?
    /// The name of the workgroup in which the named query is being created.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        database: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        queryString: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.database = database
        self.description = description
        self.name = name
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

extension CreateNamedQueryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateNamedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNamedQueryOutput()
        value.namedQueryId = try reader["NamedQueryId"].readIfPresent()
        return value
    }
}

public struct CreateNamedQueryOutput {
    /// The unique ID of the query.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

enum CreateNamedQueryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateNotebookInput {

    static func urlPathProvider(_ value: CreateNotebookInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNotebookInput {

    static func write(value: CreateNotebookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct CreateNotebookInput {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the ipynb file to be created in the Spark workgroup, without the .ipynb extension.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the Spark enabled workgroup in which the notebook will be created.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.workGroup = workGroup
    }
}

extension CreateNotebookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateNotebookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotebookOutput()
        value.notebookId = try reader["NotebookId"].readIfPresent()
        return value
    }
}

public struct CreateNotebookOutput {
    /// A unique identifier for the notebook.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

enum CreateNotebookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreatePreparedStatementInput {

    static func urlPathProvider(_ value: CreatePreparedStatementInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePreparedStatementInput {

    static func write(value: CreatePreparedStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["QueryStatement"].write(value.queryStatement)
        try writer["StatementName"].write(value.statementName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct CreatePreparedStatementInput {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The name of the workgroup to which the prepared statement belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

extension CreatePreparedStatementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreatePreparedStatementOutput {
        return CreatePreparedStatementOutput()
    }
}

public struct CreatePreparedStatementOutput {

    public init() { }
}

enum CreatePreparedStatementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreatePresignedNotebookUrlInput {

    static func urlPathProvider(_ value: CreatePresignedNotebookUrlInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePresignedNotebookUrlInput {

    static func write(value: CreatePresignedNotebookUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct CreatePresignedNotebookUrlInput {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

extension CreatePresignedNotebookUrlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreatePresignedNotebookUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePresignedNotebookUrlOutput()
        value.authToken = try reader["AuthToken"].readIfPresent()
        value.authTokenExpirationTime = try reader["AuthTokenExpirationTime"].readIfPresent()
        value.notebookUrl = try reader["NotebookUrl"].readIfPresent()
        return value
    }
}

public struct CreatePresignedNotebookUrlOutput {
    /// The authentication token for the notebook.
    /// This member is required.
    public var authToken: Swift.String?
    /// The UTC epoch time when the authentication token expires.
    /// This member is required.
    public var authTokenExpirationTime: Swift.Int?
    /// The URL of the notebook. The URL includes the authentication token and notebook file name and points directly to the opened notebook.
    /// This member is required.
    public var notebookUrl: Swift.String?

    public init(
        authToken: Swift.String? = nil,
        authTokenExpirationTime: Swift.Int? = nil,
        notebookUrl: Swift.String? = nil
    )
    {
        self.authToken = authToken
        self.authTokenExpirationTime = authTokenExpirationTime
        self.notebookUrl = notebookUrl
    }
}

enum CreatePresignedNotebookUrlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateWorkGroupInput {

    static func urlPathProvider(_ value: CreateWorkGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkGroupInput {

    static func write(value: CreateWorkGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: AthenaClientTypes.WorkGroupConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AthenaClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateWorkGroupInput {
    /// Contains configuration information for creating an Athena SQL workgroup or Spark enabled Athena workgroup. Athena SQL workgroup configuration includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for encrypting query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the limit for the amount of bytes scanned (cutoff) per query, if it is specified, and whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the WorkGroupConfiguration override client-side settings. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var configuration: AthenaClientTypes.WorkGroupConfiguration?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup name.
    /// This member is required.
    public var name: Swift.String?
    /// A list of comma separated tags to add to the workgroup that is created.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateWorkGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateWorkGroupOutput {
        return CreateWorkGroupOutput()
    }
}

public struct CreateWorkGroupOutput {

    public init() { }
}

enum CreateWorkGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.CustomerContentEncryptionConfiguration {

    static func write(value: AthenaClientTypes.CustomerContentEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKey"].write(value.kmsKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.CustomerContentEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.CustomerContentEncryptionConfiguration()
        value.kmsKey = try reader["KmsKey"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Specifies the customer managed KMS key that is used to encrypt the user's data stores in Athena. When an Amazon Web Services managed key is used, this value is null. This setting does not apply to Athena SQL workgroups.
    public struct CustomerContentEncryptionConfiguration {
        /// The customer managed KMS key that is used to encrypt the user's data stores in Athena.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init(
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes.DataCatalog {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.DataCatalog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.DataCatalog()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains information about a data catalog in an Amazon Web Services account. In the Athena console, data catalogs are listed as "data sources" on the Data sources page under the Data source name column.
    public struct DataCatalog {
        /// An optional description of the data catalog.
        public var description: Swift.String?
        /// The name of the data catalog. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the Lambda function or functions to use for the data catalog. This is a mapping whose values depend on the catalog type.
        ///
        /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
        ///
        /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
        ///
        /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
        ///
        /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
        ///
        ///
        ///
        ///
        /// * The GLUE type takes a catalog ID parameter and is required. The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue catalog belongs. catalog-id=catalog_id
        ///
        /// * The GLUE data catalog type also applies to the default AwsDataCatalog that already exists in your account, of which you can have only one and cannot modify.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
        /// This member is required.
        public var type: AthenaClientTypes.DataCatalogType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.type = type
        }
    }

}

extension AthenaClientTypes.DataCatalogSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.DataCatalogSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.DataCatalogSummary()
        value.catalogName = try reader["CatalogName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// The summary information for the data catalog, which includes its name and type.
    public struct DataCatalogSummary {
        /// The name of the data catalog. The catalog name is unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
        public var catalogName: Swift.String?
        /// The data catalog type.
        public var type: AthenaClientTypes.DataCatalogType?

        public init(
            catalogName: Swift.String? = nil,
            type: AthenaClientTypes.DataCatalogType? = nil
        )
        {
            self.catalogName = catalogName
            self.type = type
        }
    }

}

extension AthenaClientTypes {

    public enum DataCatalogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case glue
        case hive
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCatalogType] {
            return [
                .glue,
                .hive,
                .lambda,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case .hive: return "HIVE"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.Database {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.Database {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.Database()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains metadata information for a database in a data catalog.
    public struct Database {
        /// An optional description of the database.
        public var description: Swift.String?
        /// The name of the database.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension AthenaClientTypes.Datum {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.Datum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.Datum()
        value.varCharValue = try reader["VarCharValue"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// A piece of data (a field in the table).
    public struct Datum {
        /// The value of the datum.
        public var varCharValue: Swift.String?

        public init(
            varCharValue: Swift.String? = nil
        )
        {
            self.varCharValue = varCharValue
        }
    }

}

extension DeleteCapacityReservationInput {

    static func urlPathProvider(_ value: DeleteCapacityReservationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCapacityReservationInput {

    static func write(value: DeleteCapacityReservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct DeleteCapacityReservationInput {
    /// The name of the capacity reservation to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension DeleteCapacityReservationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteCapacityReservationOutput {
        return DeleteCapacityReservationOutput()
    }
}

public struct DeleteCapacityReservationOutput {

    public init() { }
}

enum DeleteCapacityReservationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDataCatalogInput {

    static func urlPathProvider(_ value: DeleteDataCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDataCatalogInput {

    static func write(value: DeleteDataCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct DeleteDataCatalogInput {
    /// The name of the data catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension DeleteDataCatalogOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDataCatalogOutput {
        return DeleteDataCatalogOutput()
    }
}

public struct DeleteDataCatalogOutput {

    public init() { }
}

enum DeleteDataCatalogOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteNamedQueryInput {

    static func urlPathProvider(_ value: DeleteNamedQueryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNamedQueryInput {

    static func write(value: DeleteNamedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamedQueryId"].write(value.namedQueryId)
    }
}

public struct DeleteNamedQueryInput {
    /// The unique ID of the query to delete.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

extension DeleteNamedQueryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteNamedQueryOutput {
        return DeleteNamedQueryOutput()
    }
}

public struct DeleteNamedQueryOutput {

    public init() { }
}

enum DeleteNamedQueryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteNotebookInput {

    static func urlPathProvider(_ value: DeleteNotebookInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNotebookInput {

    static func write(value: DeleteNotebookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotebookId"].write(value.notebookId)
    }
}

public struct DeleteNotebookInput {
    /// The ID of the notebook to delete.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

extension DeleteNotebookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteNotebookOutput {
        return DeleteNotebookOutput()
    }
}

public struct DeleteNotebookOutput {

    public init() { }
}

enum DeleteNotebookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeletePreparedStatementInput {

    static func urlPathProvider(_ value: DeletePreparedStatementInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePreparedStatementInput {

    static func write(value: DeletePreparedStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StatementName"].write(value.statementName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct DeletePreparedStatementInput {
    /// The name of the prepared statement to delete.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be deleted belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

extension DeletePreparedStatementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeletePreparedStatementOutput {
        return DeletePreparedStatementOutput()
    }
}

public struct DeletePreparedStatementOutput {

    public init() { }
}

enum DeletePreparedStatementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteWorkGroupInput {

    static func urlPathProvider(_ value: DeleteWorkGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkGroupInput {

    static func write(value: DeleteWorkGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecursiveDeleteOption"].write(value.recursiveDeleteOption)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct DeleteWorkGroupInput {
    /// The option to delete the workgroup and its contents even if the workgroup contains any named queries, query executions, or notebooks.
    public var recursiveDeleteOption: Swift.Bool?
    /// The unique name of the workgroup to delete.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        recursiveDeleteOption: Swift.Bool? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.recursiveDeleteOption = recursiveDeleteOption
        self.workGroup = workGroup
    }
}

extension DeleteWorkGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteWorkGroupOutput {
        return DeleteWorkGroupOutput()
    }
}

public struct DeleteWorkGroupOutput {

    public init() { }
}

enum DeleteWorkGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.EncryptionConfiguration {

    static func write(value: AthenaClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionOption"].write(value.encryptionOption)
        try writer["KmsKey"].write(value.kmsKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.EncryptionConfiguration()
        value.encryptionOption = try reader["EncryptionOption"].readIfPresent()
        value.kmsKey = try reader["KmsKey"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
    public struct EncryptionConfiguration {
        /// Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys (SSE_S3), server-side encryption with KMS-managed keys (SSE_KMS), or client-side encryption with KMS-managed keys (CSE_KMS) is used. If a query runs in a workgroup and the workgroup overrides client-side settings, then the workgroup's setting for encryption is used. It specifies whether query results must be encrypted, for all queries that run in this workgroup.
        /// This member is required.
        public var encryptionOption: AthenaClientTypes.EncryptionOption?
        /// For SSE_KMS and CSE_KMS, this is the KMS key ARN or ID.
        public var kmsKey: Swift.String?

        public init(
            encryptionOption: AthenaClientTypes.EncryptionOption? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }
    }

}

extension AthenaClientTypes {

    public enum EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cseKms
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionOption] {
            return [
                .cseKms,
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cseKms: return "CSE_KMS"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.EngineConfiguration {

    static func write(value: AthenaClientTypes.EngineConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalConfigs"].writeMap(value.additionalConfigs, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CoordinatorDpuSize"].write(value.coordinatorDpuSize)
        try writer["DefaultExecutorDpuSize"].write(value.defaultExecutorDpuSize)
        try writer["MaxConcurrentDpus"].write(value.maxConcurrentDpus)
        try writer["SparkProperties"].writeMap(value.sparkProperties, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.EngineConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.EngineConfiguration()
        value.coordinatorDpuSize = try reader["CoordinatorDpuSize"].readIfPresent()
        value.maxConcurrentDpus = try reader["MaxConcurrentDpus"].readIfPresent()
        value.defaultExecutorDpuSize = try reader["DefaultExecutorDpuSize"].readIfPresent()
        value.additionalConfigs = try reader["AdditionalConfigs"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sparkProperties = try reader["SparkProperties"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains data processing unit (DPU) configuration settings and parameter mappings for a notebook engine.
    public struct EngineConfiguration {
        /// Contains additional notebook engine MAP parameter mappings in the form of key-value pairs. To specify an Athena notebook that the Jupyter server will download and serve, specify a value for the [StartSessionRequest$NotebookVersion] field, and then add a key named NotebookId to AdditionalConfigs that has the value of the Athena notebook ID.
        public var additionalConfigs: [Swift.String:Swift.String]?
        /// The number of DPUs to use for the coordinator. A coordinator is a special executor that orchestrates processing work and manages other executors in a notebook session. The default is 1.
        public var coordinatorDpuSize: Swift.Int?
        /// The default number of DPUs to use for executors. An executor is the smallest unit of compute that a notebook session can request from Athena. The default is 1.
        public var defaultExecutorDpuSize: Swift.Int?
        /// The maximum number of DPUs that can run concurrently.
        /// This member is required.
        public var maxConcurrentDpus: Swift.Int?
        /// Specifies custom jar files and Spark properties for use cases like cluster encryption, table formats, and general Spark tuning.
        public var sparkProperties: [Swift.String:Swift.String]?

        public init(
            additionalConfigs: [Swift.String:Swift.String]? = nil,
            coordinatorDpuSize: Swift.Int? = nil,
            defaultExecutorDpuSize: Swift.Int? = nil,
            maxConcurrentDpus: Swift.Int? = nil,
            sparkProperties: [Swift.String:Swift.String]? = nil
        )
        {
            self.additionalConfigs = additionalConfigs
            self.coordinatorDpuSize = coordinatorDpuSize
            self.defaultExecutorDpuSize = defaultExecutorDpuSize
            self.maxConcurrentDpus = maxConcurrentDpus
            self.sparkProperties = sparkProperties
        }
    }

}

extension AthenaClientTypes.EngineVersion {

    static func write(value: AthenaClientTypes.EngineVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EffectiveEngineVersion"].write(value.effectiveEngineVersion)
        try writer["SelectedEngineVersion"].write(value.selectedEngineVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.EngineVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.EngineVersion()
        value.selectedEngineVersion = try reader["SelectedEngineVersion"].readIfPresent()
        value.effectiveEngineVersion = try reader["EffectiveEngineVersion"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// The Athena engine version for running queries, or the PySpark engine version for running sessions.
    public struct EngineVersion {
        /// Read only. The engine version on which the query runs. If the user requests a valid engine version other than Auto, the effective engine version is the same as the engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a CreateWorkGroup or UpdateWorkGroup operation, the EffectiveEngineVersion field is ignored.
        public var effectiveEngineVersion: Swift.String?
        /// The engine version requested by the user. Possible values are determined by the output of ListEngineVersions, including AUTO. The default is AUTO.
        public var selectedEngineVersion: Swift.String?

        public init(
            effectiveEngineVersion: Swift.String? = nil,
            selectedEngineVersion: Swift.String? = nil
        )
        {
            self.effectiveEngineVersion = effectiveEngineVersion
            self.selectedEngineVersion = selectedEngineVersion
        }
    }

}

extension AthenaClientTypes {

    public enum ExecutorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case creating
        case failed
        case registered
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorState] {
            return [
                .created,
                .creating,
                .failed,
                .registered,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .registered: return "REGISTERED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes {

    public enum ExecutorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coordinator
        case gateway
        case worker
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorType] {
            return [
                .coordinator,
                .gateway,
                .worker,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coordinator: return "COORDINATOR"
            case .gateway: return "GATEWAY"
            case .worker: return "WORKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.ExecutorsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ExecutorsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ExecutorsSummary()
        value.executorId = try reader["ExecutorId"].readIfPresent()
        value.executorType = try reader["ExecutorType"].readIfPresent()
        value.startDateTime = try reader["StartDateTime"].readIfPresent()
        value.terminationDateTime = try reader["TerminationDateTime"].readIfPresent()
        value.executorState = try reader["ExecutorState"].readIfPresent()
        value.executorSize = try reader["ExecutorSize"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains summary information about an executor.
    public struct ExecutorsSummary {
        /// The UUID of the executor.
        /// This member is required.
        public var executorId: Swift.String?
        /// The smallest unit of compute that a session can request from Athena. Size is measured in data processing unit (DPU) values, a relative measure of processing power.
        public var executorSize: Swift.Int?
        /// The processing state of the executor. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
        public var executorState: AthenaClientTypes.ExecutorState?
        /// The type of executor used for the application (COORDINATOR, GATEWAY, or WORKER).
        public var executorType: AthenaClientTypes.ExecutorType?
        /// The date and time that the executor started.
        public var startDateTime: Swift.Int?
        /// The date and time that the executor was terminated.
        public var terminationDateTime: Swift.Int?

        public init(
            executorId: Swift.String? = nil,
            executorSize: Swift.Int? = nil,
            executorState: AthenaClientTypes.ExecutorState? = nil,
            executorType: AthenaClientTypes.ExecutorType? = nil,
            startDateTime: Swift.Int? = nil,
            terminationDateTime: Swift.Int? = nil
        )
        {
            self.executorId = executorId
            self.executorSize = executorSize
            self.executorState = executorState
            self.executorType = executorType
            self.startDateTime = startDateTime
            self.terminationDateTime = terminationDateTime
        }
    }

}

extension ExportNotebookInput {

    static func urlPathProvider(_ value: ExportNotebookInput) -> Swift.String? {
        return "/"
    }
}

extension ExportNotebookInput {

    static func write(value: ExportNotebookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotebookId"].write(value.notebookId)
    }
}

public struct ExportNotebookInput {
    /// The ID of the notebook to export.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

extension ExportNotebookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ExportNotebookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportNotebookOutput()
        value.notebookMetadata = try reader["NotebookMetadata"].readIfPresent(with: AthenaClientTypes.NotebookMetadata.read(from:))
        value.payload = try reader["Payload"].readIfPresent()
        return value
    }
}

public struct ExportNotebookOutput {
    /// The notebook metadata, including notebook ID, notebook name, and workgroup name.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?
    /// The content of the exported notebook.
    public var payload: Swift.String?

    public init(
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil,
        payload: Swift.String? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
        self.payload = payload
    }
}

enum ExportNotebookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.FilterDefinition {

    static func write(value: AthenaClientTypes.FilterDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension AthenaClientTypes {
    /// A string for searching notebook names.
    public struct FilterDefinition {
        /// The name of the notebook to search for.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension GetCalculationExecutionCodeInput {

    static func urlPathProvider(_ value: GetCalculationExecutionCodeInput) -> Swift.String? {
        return "/"
    }
}

extension GetCalculationExecutionCodeInput {

    static func write(value: GetCalculationExecutionCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculationExecutionId"].write(value.calculationExecutionId)
    }
}

public struct GetCalculationExecutionCodeInput {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

extension GetCalculationExecutionCodeOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCalculationExecutionCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculationExecutionCodeOutput()
        value.codeBlock = try reader["CodeBlock"].readIfPresent()
        return value
    }
}

public struct GetCalculationExecutionCodeOutput {
    /// The unencrypted code that was executed for the calculation.
    public var codeBlock: Swift.String?

    public init(
        codeBlock: Swift.String? = nil
    )
    {
        self.codeBlock = codeBlock
    }
}

enum GetCalculationExecutionCodeOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCalculationExecutionInput {

    static func urlPathProvider(_ value: GetCalculationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetCalculationExecutionInput {

    static func write(value: GetCalculationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculationExecutionId"].write(value.calculationExecutionId)
    }
}

public struct GetCalculationExecutionInput {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

extension GetCalculationExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCalculationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculationExecutionOutput()
        value.calculationExecutionId = try reader["CalculationExecutionId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.result = try reader["Result"].readIfPresent(with: AthenaClientTypes.CalculationResult.read(from:))
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.statistics = try reader["Statistics"].readIfPresent(with: AthenaClientTypes.CalculationStatistics.read(from:))
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.CalculationStatus.read(from:))
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        return value
    }
}

public struct GetCalculationExecutionOutput {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// The description of the calculation execution.
    public var description: Swift.String?
    /// Contains result information. This field is populated only if the calculation is completed.
    public var result: AthenaClientTypes.CalculationResult?
    /// The session ID that the calculation ran in.
    public var sessionId: Swift.String?
    /// Contains information about the data processing unit (DPU) execution time and progress. This field is populated only when statistics are available.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the status of the calculation.
    public var status: AthenaClientTypes.CalculationStatus?
    /// The Amazon S3 location in which calculation results are stored.
    public var workingDirectory: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil,
        description: Swift.String? = nil,
        result: AthenaClientTypes.CalculationResult? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.description = description
        self.result = result
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workingDirectory = workingDirectory
    }
}

enum GetCalculationExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCalculationExecutionStatusInput {

    static func urlPathProvider(_ value: GetCalculationExecutionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetCalculationExecutionStatusInput {

    static func write(value: GetCalculationExecutionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculationExecutionId"].write(value.calculationExecutionId)
    }
}

public struct GetCalculationExecutionStatusInput {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

extension GetCalculationExecutionStatusOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCalculationExecutionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalculationExecutionStatusOutput()
        value.statistics = try reader["Statistics"].readIfPresent(with: AthenaClientTypes.CalculationStatistics.read(from:))
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.CalculationStatus.read(from:))
        return value
    }
}

public struct GetCalculationExecutionStatusOutput {
    /// Contains information about the DPU execution time and progress.
    public var statistics: AthenaClientTypes.CalculationStatistics?
    /// Contains information about the calculation execution status.
    public var status: AthenaClientTypes.CalculationStatus?

    public init(
        statistics: AthenaClientTypes.CalculationStatistics? = nil,
        status: AthenaClientTypes.CalculationStatus? = nil
    )
    {
        self.statistics = statistics
        self.status = status
    }
}

enum GetCalculationExecutionStatusOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCapacityAssignmentConfigurationInput {

    static func urlPathProvider(_ value: GetCapacityAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetCapacityAssignmentConfigurationInput {

    static func write(value: GetCapacityAssignmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationName"].write(value.capacityReservationName)
    }
}

public struct GetCapacityAssignmentConfigurationInput {
    /// The name of the capacity reservation to retrieve the capacity assignment configuration for.
    /// This member is required.
    public var capacityReservationName: Swift.String?

    public init(
        capacityReservationName: Swift.String? = nil
    )
    {
        self.capacityReservationName = capacityReservationName
    }
}

extension GetCapacityAssignmentConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCapacityAssignmentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapacityAssignmentConfigurationOutput()
        value.capacityAssignmentConfiguration = try reader["CapacityAssignmentConfiguration"].readIfPresent(with: AthenaClientTypes.CapacityAssignmentConfiguration.read(from:))
        return value
    }
}

public struct GetCapacityAssignmentConfigurationOutput {
    /// The requested capacity assignment configuration for the specified capacity reservation.
    /// This member is required.
    public var capacityAssignmentConfiguration: AthenaClientTypes.CapacityAssignmentConfiguration?

    public init(
        capacityAssignmentConfiguration: AthenaClientTypes.CapacityAssignmentConfiguration? = nil
    )
    {
        self.capacityAssignmentConfiguration = capacityAssignmentConfiguration
    }
}

enum GetCapacityAssignmentConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCapacityReservationInput {

    static func urlPathProvider(_ value: GetCapacityReservationInput) -> Swift.String? {
        return "/"
    }
}

extension GetCapacityReservationInput {

    static func write(value: GetCapacityReservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct GetCapacityReservationInput {
    /// The name of the capacity reservation.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension GetCapacityReservationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCapacityReservationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapacityReservationOutput()
        value.capacityReservation = try reader["CapacityReservation"].readIfPresent(with: AthenaClientTypes.CapacityReservation.read(from:))
        return value
    }
}

public struct GetCapacityReservationOutput {
    /// The requested capacity reservation structure.
    /// This member is required.
    public var capacityReservation: AthenaClientTypes.CapacityReservation?

    public init(
        capacityReservation: AthenaClientTypes.CapacityReservation? = nil
    )
    {
        self.capacityReservation = capacityReservation
    }
}

enum GetCapacityReservationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDataCatalogInput {

    static func urlPathProvider(_ value: GetDataCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataCatalogInput {

    static func write(value: GetDataCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct GetDataCatalogInput {
    /// The name of the data catalog to return.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the workgroup. Required if making an IAM Identity Center request.
    public var workGroup: Swift.String?

    public init(
        name: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.name = name
        self.workGroup = workGroup
    }
}

extension GetDataCatalogOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDataCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataCatalogOutput()
        value.dataCatalog = try reader["DataCatalog"].readIfPresent(with: AthenaClientTypes.DataCatalog.read(from:))
        return value
    }
}

public struct GetDataCatalogOutput {
    /// The data catalog returned.
    public var dataCatalog: AthenaClientTypes.DataCatalog?

    public init(
        dataCatalog: AthenaClientTypes.DataCatalog? = nil
    )
    {
        self.dataCatalog = dataCatalog
    }
}

enum GetDataCatalogOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDatabaseInput {

    static func urlPathProvider(_ value: GetDatabaseInput) -> Swift.String? {
        return "/"
    }
}

extension GetDatabaseInput {

    static func write(value: GetDatabaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogName"].write(value.catalogName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct GetDatabaseInput {
    /// The name of the data catalog that contains the database to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database to return.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the workgroup for which the metadata is being fetched. Required if requesting an IAM Identity Center enabled Glue Data Catalog.
    public var workGroup: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.workGroup = workGroup
    }
}

extension GetDatabaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDatabaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDatabaseOutput()
        value.database = try reader["Database"].readIfPresent(with: AthenaClientTypes.Database.read(from:))
        return value
    }
}

public struct GetDatabaseOutput {
    /// The database returned.
    public var database: AthenaClientTypes.Database?

    public init(
        database: AthenaClientTypes.Database? = nil
    )
    {
        self.database = database
    }
}

enum GetDatabaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MetadataException": return try MetadataException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetNamedQueryInput {

    static func urlPathProvider(_ value: GetNamedQueryInput) -> Swift.String? {
        return "/"
    }
}

extension GetNamedQueryInput {

    static func write(value: GetNamedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamedQueryId"].write(value.namedQueryId)
    }
}

public struct GetNamedQueryInput {
    /// The unique ID of the query. Use [ListNamedQueries] to get query IDs.
    /// This member is required.
    public var namedQueryId: Swift.String?

    public init(
        namedQueryId: Swift.String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

extension GetNamedQueryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetNamedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamedQueryOutput()
        value.namedQuery = try reader["NamedQuery"].readIfPresent(with: AthenaClientTypes.NamedQuery.read(from:))
        return value
    }
}

public struct GetNamedQueryOutput {
    /// Information about the query.
    public var namedQuery: AthenaClientTypes.NamedQuery?

    public init(
        namedQuery: AthenaClientTypes.NamedQuery? = nil
    )
    {
        self.namedQuery = namedQuery
    }
}

enum GetNamedQueryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetNotebookMetadataInput {

    static func urlPathProvider(_ value: GetNotebookMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetNotebookMetadataInput {

    static func write(value: GetNotebookMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotebookId"].write(value.notebookId)
    }
}

public struct GetNotebookMetadataInput {
    /// The ID of the notebook whose metadata is to be retrieved.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

extension GetNotebookMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetNotebookMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotebookMetadataOutput()
        value.notebookMetadata = try reader["NotebookMetadata"].readIfPresent(with: AthenaClientTypes.NotebookMetadata.read(from:))
        return value
    }
}

public struct GetNotebookMetadataOutput {
    /// The metadata that is returned for the specified notebook ID.
    public var notebookMetadata: AthenaClientTypes.NotebookMetadata?

    public init(
        notebookMetadata: AthenaClientTypes.NotebookMetadata? = nil
    )
    {
        self.notebookMetadata = notebookMetadata
    }
}

enum GetNotebookMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetPreparedStatementInput {

    static func urlPathProvider(_ value: GetPreparedStatementInput) -> Swift.String? {
        return "/"
    }
}

extension GetPreparedStatementInput {

    static func write(value: GetPreparedStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StatementName"].write(value.statementName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct GetPreparedStatementInput {
    /// The name of the prepared statement to retrieve.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup to which the statement to be retrieved belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

extension GetPreparedStatementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetPreparedStatementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPreparedStatementOutput()
        value.preparedStatement = try reader["PreparedStatement"].readIfPresent(with: AthenaClientTypes.PreparedStatement.read(from:))
        return value
    }
}

public struct GetPreparedStatementOutput {
    /// The name of the prepared statement that was retrieved.
    public var preparedStatement: AthenaClientTypes.PreparedStatement?

    public init(
        preparedStatement: AthenaClientTypes.PreparedStatement? = nil
    )
    {
        self.preparedStatement = preparedStatement
    }
}

enum GetPreparedStatementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetQueryExecutionInput {

    static func urlPathProvider(_ value: GetQueryExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetQueryExecutionInput {

    static func write(value: GetQueryExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryExecutionId"].write(value.queryExecutionId)
    }
}

public struct GetQueryExecutionInput {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

extension GetQueryExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetQueryExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryExecutionOutput()
        value.queryExecution = try reader["QueryExecution"].readIfPresent(with: AthenaClientTypes.QueryExecution.read(from:))
        return value
    }
}

public struct GetQueryExecutionOutput {
    /// Information about the query execution.
    public var queryExecution: AthenaClientTypes.QueryExecution?

    public init(
        queryExecution: AthenaClientTypes.QueryExecution? = nil
    )
    {
        self.queryExecution = queryExecution
    }
}

enum GetQueryExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetQueryResultsInput {

    static func urlPathProvider(_ value: GetQueryResultsInput) -> Swift.String? {
        return "/"
    }
}

extension GetQueryResultsInput {

    static func write(value: GetQueryResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryExecutionId"].write(value.queryExecutionId)
    }
}

public struct GetQueryResultsInput {
    /// The maximum number of results (rows) to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryExecutionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryExecutionId = queryExecutionId
    }
}

extension GetQueryResultsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetQueryResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resultSet = try reader["ResultSet"].readIfPresent(with: AthenaClientTypes.ResultSet.read(from:))
        value.updateCount = try reader["UpdateCount"].readIfPresent()
        return value
    }
}

public struct GetQueryResultsOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The results of the query execution.
    public var resultSet: AthenaClientTypes.ResultSet?
    /// The number of rows inserted with a CREATE TABLE AS SELECT statement.
    public var updateCount: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        resultSet: AthenaClientTypes.ResultSet? = nil,
        updateCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.resultSet = resultSet
        self.updateCount = updateCount
    }
}

enum GetQueryResultsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetQueryRuntimeStatisticsInput {

    static func urlPathProvider(_ value: GetQueryRuntimeStatisticsInput) -> Swift.String? {
        return "/"
    }
}

extension GetQueryRuntimeStatisticsInput {

    static func write(value: GetQueryRuntimeStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryExecutionId"].write(value.queryExecutionId)
    }
}

public struct GetQueryRuntimeStatisticsInput {
    /// The unique ID of the query execution.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

extension GetQueryRuntimeStatisticsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetQueryRuntimeStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryRuntimeStatisticsOutput()
        value.queryRuntimeStatistics = try reader["QueryRuntimeStatistics"].readIfPresent(with: AthenaClientTypes.QueryRuntimeStatistics.read(from:))
        return value
    }
}

public struct GetQueryRuntimeStatisticsOutput {
    /// Runtime statistics about the query execution.
    public var queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics?

    public init(
        queryRuntimeStatistics: AthenaClientTypes.QueryRuntimeStatistics? = nil
    )
    {
        self.queryRuntimeStatistics = queryRuntimeStatistics
    }
}

enum GetQueryRuntimeStatisticsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        return "/"
    }
}

extension GetSessionInput {

    static func write(value: GetSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct GetSessionInput {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.description = try reader["Description"].readIfPresent()
        value.engineConfiguration = try reader["EngineConfiguration"].readIfPresent(with: AthenaClientTypes.EngineConfiguration.read(from:))
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.notebookVersion = try reader["NotebookVersion"].readIfPresent()
        value.sessionConfiguration = try reader["SessionConfiguration"].readIfPresent(with: AthenaClientTypes.SessionConfiguration.read(from:))
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.statistics = try reader["Statistics"].readIfPresent(with: AthenaClientTypes.SessionStatistics.read(from:))
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.SessionStatus.read(from:))
        value.workGroup = try reader["WorkGroup"].readIfPresent()
        return value
    }
}

public struct GetSessionOutput {
    /// The session description.
    public var description: Swift.String?
    /// Contains engine configuration information like DPU usage.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The engine version used by the session (for example, PySpark engine version 3). You can get a list of engine versions by calling [ListEngineVersions].
    public var engineVersion: Swift.String?
    /// The notebook version.
    public var notebookVersion: Swift.String?
    /// Contains the workgroup configuration information used by the session.
    public var sessionConfiguration: AthenaClientTypes.SessionConfiguration?
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains the DPU execution time.
    public var statistics: AthenaClientTypes.SessionStatistics?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?
    /// The workgroup to which the session belongs.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        engineVersion: Swift.String? = nil,
        notebookVersion: Swift.String? = nil,
        sessionConfiguration: AthenaClientTypes.SessionConfiguration? = nil,
        sessionId: Swift.String? = nil,
        statistics: AthenaClientTypes.SessionStatistics? = nil,
        status: AthenaClientTypes.SessionStatus? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.engineVersion = engineVersion
        self.notebookVersion = notebookVersion
        self.sessionConfiguration = sessionConfiguration
        self.sessionId = sessionId
        self.statistics = statistics
        self.status = status
        self.workGroup = workGroup
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSessionStatusInput {

    static func urlPathProvider(_ value: GetSessionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetSessionStatusInput {

    static func write(value: GetSessionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct GetSessionStatusInput {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

extension GetSessionStatusOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSessionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionStatusOutput()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.SessionStatus.read(from:))
        return value
    }
}

public struct GetSessionStatusOutput {
    /// The session ID.
    public var sessionId: Swift.String?
    /// Contains information about the status of the session.
    public var status: AthenaClientTypes.SessionStatus?

    public init(
        sessionId: Swift.String? = nil,
        status: AthenaClientTypes.SessionStatus? = nil
    )
    {
        self.sessionId = sessionId
        self.status = status
    }
}

enum GetSessionStatusOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTableMetadataInput {

    static func urlPathProvider(_ value: GetTableMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableMetadataInput {

    static func write(value: GetTableMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogName"].write(value.catalogName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct GetTableMetadataInput {
    /// The name of the data catalog that contains the database and table metadata to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database that contains the table metadata to return.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name of the table for which metadata is returned.
    /// This member is required.
    public var tableName: Swift.String?
    /// The name of the workgroup for which the metadata is being fetched. Required if requesting an IAM Identity Center enabled Glue Data Catalog.
    public var workGroup: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
        self.workGroup = workGroup
    }
}

extension GetTableMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTableMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMetadataOutput()
        value.tableMetadata = try reader["TableMetadata"].readIfPresent(with: AthenaClientTypes.TableMetadata.read(from:))
        return value
    }
}

public struct GetTableMetadataOutput {
    /// An object that contains table metadata.
    public var tableMetadata: AthenaClientTypes.TableMetadata?

    public init(
        tableMetadata: AthenaClientTypes.TableMetadata? = nil
    )
    {
        self.tableMetadata = tableMetadata
    }
}

enum GetTableMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MetadataException": return try MetadataException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetWorkGroupInput {

    static func urlPathProvider(_ value: GetWorkGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkGroupInput {

    static func write(value: GetWorkGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct GetWorkGroupInput {
    /// The name of the workgroup.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        workGroup: Swift.String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

extension GetWorkGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetWorkGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkGroupOutput()
        value.workGroup = try reader["WorkGroup"].readIfPresent(with: AthenaClientTypes.WorkGroup.read(from:))
        return value
    }
}

public struct GetWorkGroupOutput {
    /// Information about the workgroup.
    public var workGroup: AthenaClientTypes.WorkGroup?

    public init(
        workGroup: AthenaClientTypes.WorkGroup? = nil
    )
    {
        self.workGroup = workGroup
    }
}

enum GetWorkGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.IdentityCenterConfiguration {

    static func write(value: AthenaClientTypes.IdentityCenterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableIdentityCenter"].write(value.enableIdentityCenter)
        try writer["IdentityCenterInstanceArn"].write(value.identityCenterInstanceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.IdentityCenterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.IdentityCenterConfiguration()
        value.enableIdentityCenter = try reader["EnableIdentityCenter"].readIfPresent()
        value.identityCenterInstanceArn = try reader["IdentityCenterInstanceArn"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Specifies whether the workgroup is IAM Identity Center supported.
    public struct IdentityCenterConfiguration {
        /// Specifies whether the workgroup is IAM Identity Center supported.
        public var enableIdentityCenter: Swift.Bool?
        /// The IAM Identity Center instance ARN that the workgroup associates to.
        public var identityCenterInstanceArn: Swift.String?

        public init(
            enableIdentityCenter: Swift.Bool? = nil,
            identityCenterInstanceArn: Swift.String? = nil
        )
        {
            self.enableIdentityCenter = enableIdentityCenter
            self.identityCenterInstanceArn = identityCenterInstanceArn
        }
    }

}

extension ImportNotebookInput {

    static func urlPathProvider(_ value: ImportNotebookInput) -> Swift.String? {
        return "/"
    }
}

extension ImportNotebookInput {

    static func write(value: ImportNotebookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
        try writer["NotebookS3LocationUri"].write(value.notebookS3LocationUri)
        try writer["Payload"].write(value.payload)
        try writer["Type"].write(value.type)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ImportNotebookInput {
    /// A unique case-sensitive string used to ensure the request to import the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the notebook to import.
    /// This member is required.
    public var name: Swift.String?
    /// A URI that specifies the Amazon S3 location of a notebook file in ipynb format.
    public var notebookS3LocationUri: Swift.String?
    /// The notebook content to be imported. The payload must be in ipynb format.
    public var payload: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?
    /// The name of the Spark enabled workgroup to import the notebook to.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        notebookS3LocationUri: Swift.String? = nil,
        payload: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.notebookS3LocationUri = notebookS3LocationUri
        self.payload = payload
        self.type = type
        self.workGroup = workGroup
    }
}

extension ImportNotebookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ImportNotebookOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportNotebookOutput()
        value.notebookId = try reader["NotebookId"].readIfPresent()
        return value
    }
}

public struct ImportNotebookOutput {
    /// The ID assigned to the imported notebook.
    public var notebookId: Swift.String?

    public init(
        notebookId: Swift.String? = nil
    )
    {
        self.notebookId = notebookId
    }
}

enum ImportNotebookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Indicates a platform issue, which may be due to a transient condition or outage.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.athenaErrorCode = try reader["AthenaErrorCode"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Indicates that something is wrong with the input to the request. For example, a required parameter may be missing or out of range.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code returned when the query execution failed to process, or when the processing request for the named query failed.
        public internal(set) var athenaErrorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        athenaErrorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.athenaErrorCode = athenaErrorCode
        self.properties.message = message
    }
}

extension ListApplicationDPUSizesInput {

    static func urlPathProvider(_ value: ListApplicationDPUSizesInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationDPUSizesInput {

    static func write(value: ListApplicationDPUSizesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListApplicationDPUSizesInput {
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListApplicationDPUSizesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListApplicationDPUSizesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationDPUSizesOutput()
        value.applicationDPUSizes = try reader["ApplicationDPUSizes"].readListIfPresent(memberReadingClosure: AthenaClientTypes.ApplicationDPUSizes.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListApplicationDPUSizesOutput {
    /// A list of the supported DPU sizes that the application runtime supports.
    public var applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        applicationDPUSizes: [AthenaClientTypes.ApplicationDPUSizes]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationDPUSizes = applicationDPUSizes
        self.nextToken = nextToken
    }
}

enum ListApplicationDPUSizesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListCalculationExecutionsInput {

    static func urlPathProvider(_ value: ListCalculationExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCalculationExecutionsInput {

    static func write(value: ListCalculationExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SessionId"].write(value.sessionId)
        try writer["StateFilter"].write(value.stateFilter)
    }
}

public struct ListCalculationExecutionsInput {
    /// The maximum number of calculation executions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// A filter for a specific calculation execution state. A description of each state follows. CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var stateFilter: AthenaClientTypes.CalculationExecutionState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stateFilter: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stateFilter = stateFilter
    }
}

extension ListCalculationExecutionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCalculationExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCalculationExecutionsOutput()
        value.calculations = try reader["Calculations"].readListIfPresent(memberReadingClosure: AthenaClientTypes.CalculationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListCalculationExecutionsOutput {
    /// A list of [CalculationSummary] objects.
    public var calculations: [AthenaClientTypes.CalculationSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        calculations: [AthenaClientTypes.CalculationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.calculations = calculations
        self.nextToken = nextToken
    }
}

enum ListCalculationExecutionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListCapacityReservationsInput {

    static func urlPathProvider(_ value: ListCapacityReservationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCapacityReservationsInput {

    static func write(value: ListCapacityReservationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListCapacityReservationsInput {
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListCapacityReservationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCapacityReservationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCapacityReservationsOutput()
        value.capacityReservations = try reader["CapacityReservations"].readListIfPresent(memberReadingClosure: AthenaClientTypes.CapacityReservation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListCapacityReservationsOutput {
    /// The capacity reservations for the current account.
    /// This member is required.
    public var capacityReservations: [AthenaClientTypes.CapacityReservation]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        capacityReservations: [AthenaClientTypes.CapacityReservation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capacityReservations = capacityReservations
        self.nextToken = nextToken
    }
}

enum ListCapacityReservationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataCatalogsInput {

    static func urlPathProvider(_ value: ListDataCatalogsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDataCatalogsInput {

    static func write(value: ListDataCatalogsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListDataCatalogsInput {
    /// Specifies the maximum number of data catalogs to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup. Required if making an IAM Identity Center request.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListDataCatalogsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataCatalogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataCatalogsOutput()
        value.dataCatalogsSummary = try reader["DataCatalogsSummary"].readListIfPresent(memberReadingClosure: AthenaClientTypes.DataCatalogSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDataCatalogsOutput {
    /// A summary list of data catalogs.
    public var dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        dataCatalogsSummary: [AthenaClientTypes.DataCatalogSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCatalogsSummary = dataCatalogsSummary
        self.nextToken = nextToken
    }
}

enum ListDataCatalogsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDatabasesInput {

    static func urlPathProvider(_ value: ListDatabasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDatabasesInput {

    static func write(value: ListDatabasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogName"].write(value.catalogName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListDatabasesInput {
    /// The name of the data catalog that contains the databases to return.
    /// This member is required.
    public var catalogName: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup for which the metadata is being fetched. Required if requesting an IAM Identity Center enabled Glue Data Catalog.
    public var workGroup: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListDatabasesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDatabasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDatabasesOutput()
        value.databaseList = try reader["DatabaseList"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Database.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDatabasesOutput {
    /// A list of databases from a data catalog.
    public var databaseList: [AthenaClientTypes.Database]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        databaseList: [AthenaClientTypes.Database]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

enum ListDatabasesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MetadataException": return try MetadataException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListEngineVersionsInput {

    static func urlPathProvider(_ value: ListEngineVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngineVersionsInput {

    static func write(value: ListEngineVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListEngineVersionsInput {
    /// The maximum number of engine versions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEngineVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListEngineVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngineVersionsOutput()
        value.engineVersions = try reader["EngineVersions"].readListIfPresent(memberReadingClosure: AthenaClientTypes.EngineVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListEngineVersionsOutput {
    /// A list of engine versions that are available to choose from.
    public var engineVersions: [AthenaClientTypes.EngineVersion]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [AthenaClientTypes.EngineVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

enum ListEngineVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListExecutorsInput {

    static func urlPathProvider(_ value: ListExecutorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListExecutorsInput {

    static func write(value: ListExecutorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutorStateFilter"].write(value.executorStateFilter)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct ListExecutorsInput {
    /// A filter for a specific executor state. A description of each state follows. CREATING - The executor is being started, including acquiring resources. CREATED - The executor has been started. REGISTERED - The executor has been registered. TERMINATING - The executor is in the process of shutting down. TERMINATED - The executor is no longer running. FAILED - Due to a failure, the executor is no longer running.
    public var executorStateFilter: AthenaClientTypes.ExecutorState?
    /// The maximum number of executors to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        executorStateFilter: AthenaClientTypes.ExecutorState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorStateFilter = executorStateFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

extension ListExecutorsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListExecutorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExecutorsOutput()
        value.executorsSummary = try reader["ExecutorsSummary"].readListIfPresent(memberReadingClosure: AthenaClientTypes.ExecutorsSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessionId = try reader["SessionId"].readIfPresent()
        return value
    }
}

public struct ListExecutorsOutput {
    /// Contains summary information about the executor.
    public var executorsSummary: [AthenaClientTypes.ExecutorsSummary]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        executorsSummary: [AthenaClientTypes.ExecutorsSummary]? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.executorsSummary = executorsSummary
        self.nextToken = nextToken
        self.sessionId = sessionId
    }
}

enum ListExecutorsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListNamedQueriesInput {

    static func urlPathProvider(_ value: ListNamedQueriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListNamedQueriesInput {

    static func write(value: ListNamedQueriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListNamedQueriesInput {
    /// The maximum number of queries to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which the named queries are being returned. If a workgroup is not specified, the saved queries for the primary workgroup are returned.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListNamedQueriesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNamedQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamedQueriesOutput()
        value.namedQueryIds = try reader["NamedQueryIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListNamedQueriesOutput {
    /// The list of unique query IDs.
    public var namedQueryIds: [Swift.String]?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        namedQueryIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
        self.nextToken = nextToken
    }
}

enum ListNamedQueriesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListNotebookMetadataInput {

    static func urlPathProvider(_ value: ListNotebookMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension ListNotebookMetadataInput {

    static func write(value: ListNotebookMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: AthenaClientTypes.FilterDefinition.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListNotebookMetadataInput {
    /// Search filter string.
    public var filters: AthenaClientTypes.FilterDefinition?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated.
    public var nextToken: Swift.String?
    /// The name of the Spark enabled workgroup to retrieve notebook metadata for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        filters: AthenaClientTypes.FilterDefinition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListNotebookMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNotebookMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotebookMetadataOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notebookMetadataList = try reader["NotebookMetadataList"].readListIfPresent(memberReadingClosure: AthenaClientTypes.NotebookMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListNotebookMetadataOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of notebook metadata for the specified workgroup.
    public var notebookMetadataList: [AthenaClientTypes.NotebookMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        notebookMetadataList: [AthenaClientTypes.NotebookMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookMetadataList = notebookMetadataList
    }
}

enum ListNotebookMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListNotebookSessionsInput {

    static func urlPathProvider(_ value: ListNotebookSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListNotebookSessionsInput {

    static func write(value: ListNotebookSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["NotebookId"].write(value.notebookId)
    }
}

public struct ListNotebookSessionsInput {
    /// The maximum number of notebook sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The ID of the notebook to list sessions for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notebookId = notebookId
    }
}

extension ListNotebookSessionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListNotebookSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotebookSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notebookSessionsList = try reader["NotebookSessionsList"].readListIfPresent(memberReadingClosure: AthenaClientTypes.NotebookSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListNotebookSessionsOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of the sessions belonging to the notebook.
    /// This member is required.
    public var notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notebookSessionsList: [AthenaClientTypes.NotebookSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notebookSessionsList = notebookSessionsList
    }
}

enum ListNotebookSessionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListPreparedStatementsInput {

    static func urlPathProvider(_ value: ListPreparedStatementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPreparedStatementsInput {

    static func write(value: ListPreparedStatementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListPreparedStatementsInput {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The workgroup to list the prepared statements for.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListPreparedStatementsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListPreparedStatementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPreparedStatementsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.preparedStatements = try reader["PreparedStatements"].readListIfPresent(memberReadingClosure: AthenaClientTypes.PreparedStatementSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListPreparedStatementsOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The list of prepared statements for the workgroup.
    public var preparedStatements: [AthenaClientTypes.PreparedStatementSummary]?

    public init(
        nextToken: Swift.String? = nil,
        preparedStatements: [AthenaClientTypes.PreparedStatementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.preparedStatements = preparedStatements
    }
}

enum ListPreparedStatementsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListQueryExecutionsInput {

    static func urlPathProvider(_ value: ListQueryExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListQueryExecutionsInput {

    static func write(value: ListQueryExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListQueryExecutionsInput {
    /// The maximum number of query executions to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup from which queries are being returned. If a workgroup is not specified, a list of available query execution IDs for the queries in the primary workgroup is returned.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListQueryExecutionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListQueryExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueryExecutionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queryExecutionIds = try reader["QueryExecutionIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListQueryExecutionsOutput {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The unique IDs of each query execution as an array of strings.
    public var queryExecutionIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        queryExecutionIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryExecutionIds = queryExecutionIds
    }
}

enum ListQueryExecutionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StateFilter"].write(value.stateFilter)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListSessionsInput {
    /// The maximum number of sessions to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A filter for a specific session state. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var stateFilter: AthenaClientTypes.SessionState?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateFilter: AthenaClientTypes.SessionState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateFilter = stateFilter
        self.workGroup = workGroup
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: AthenaClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSessionsOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of sessions.
    public var sessions: [AthenaClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [AthenaClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTableMetadataInput {

    static func urlPathProvider(_ value: ListTableMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension ListTableMetadataInput {

    static func write(value: ListTableMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogName"].write(value.catalogName)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Expression"].write(value.expression)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct ListTableMetadataInput {
    /// The name of the data catalog for which table metadata should be returned.
    /// This member is required.
    public var catalogName: Swift.String?
    /// The name of the database for which table metadata should be returned.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A regex filter that pattern-matches table names. If no expression is supplied, metadata for all tables are listed.
    public var expression: Swift.String?
    /// Specifies the maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// The name of the workgroup for which the metadata is being fetched. Required if requesting an IAM Identity Center enabled Glue Data Catalog.
    public var workGroup: Swift.String?

    public init(
        catalogName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        expression: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

extension ListTableMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTableMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableMetadataOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableMetadataList = try reader["TableMetadataList"].readListIfPresent(memberReadingClosure: AthenaClientTypes.TableMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTableMetadataOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of table metadata.
    public var tableMetadataList: [AthenaClientTypes.TableMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        tableMetadataList: [AthenaClientTypes.TableMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableMetadataList = tableMetadataList
    }
}

enum ListTableMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "MetadataException": return try MetadataException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

public struct ListTagsForResourceInput {
    /// The maximum number of results to be returned per request that lists the tags for the resource.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no additional results for this request, where the request lists the tags for the resource with the specified ARN.
    public var nextToken: Swift.String?
    /// Lists the tags for the resource with the specified ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// A token to be used by the next request if this request is truncated.
    public var nextToken: Swift.String?
    /// The list of tags associated with the specified resource.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWorkGroupsInput {

    static func urlPathProvider(_ value: ListWorkGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkGroupsInput {

    static func write(value: ListWorkGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListWorkGroupsInput {
    /// The maximum number of workgroups to return in this request.
    public var maxResults: Swift.Int?
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListWorkGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListWorkGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workGroups = try reader["WorkGroups"].readListIfPresent(memberReadingClosure: AthenaClientTypes.WorkGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListWorkGroupsOutput {
    /// A token generated by the Athena service that specifies where to continue pagination if a previous request was truncated. To obtain the next set of pages, pass in the NextToken from the response object of the previous page call.
    public var nextToken: Swift.String?
    /// A list of [WorkGroupSummary] objects that include the names, descriptions, creation times, and states for each workgroup.
    public var workGroups: [AthenaClientTypes.WorkGroupSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workGroups: [AthenaClientTypes.WorkGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workGroups = workGroups
    }
}

enum ListWorkGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension MetadataException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MetadataException {
        let reader = baseError.errorBodyReader
        var value = MetadataException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An exception that Athena received when it called a custom metastore. Occurs if the error is not caused by user input (InvalidRequestException) or from the Athena platform (InternalServerException). For example, if a user-created Lambda function is missing permissions, the Lambda 4XX exception is returned in a MetadataException.
public struct MetadataException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MetadataException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AthenaClientTypes.NamedQuery {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.NamedQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.NamedQuery()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.database = try reader["Database"].readIfPresent()
        value.queryString = try reader["QueryString"].readIfPresent()
        value.namedQueryId = try reader["NamedQueryId"].readIfPresent()
        value.workGroup = try reader["WorkGroup"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// A query, where QueryString contains the SQL statements that make up the query.
    public struct NamedQuery {
        /// The database to which the query belongs.
        /// This member is required.
        public var database: Swift.String?
        /// The query description.
        public var description: Swift.String?
        /// The query name.
        /// This member is required.
        public var name: Swift.String?
        /// The unique identifier of the query.
        public var namedQueryId: Swift.String?
        /// The SQL statements that make up the query.
        /// This member is required.
        public var queryString: Swift.String?
        /// The name of the workgroup that contains the named query.
        public var workGroup: Swift.String?

        public init(
            database: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            namedQueryId: Swift.String? = nil,
            queryString: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.database = database
            self.description = description
            self.name = name
            self.namedQueryId = namedQueryId
            self.queryString = queryString
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.NotebookMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.NotebookMetadata()
        value.notebookId = try reader["NotebookId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.workGroup = try reader["WorkGroup"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.type = try reader["Type"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains metadata for notebook, including the notebook name, ID, workgroup, and time created.
    public struct NotebookMetadata {
        /// The time when the notebook was created.
        public var creationTime: ClientRuntime.Date?
        /// The time when the notebook was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the notebook.
        public var name: Swift.String?
        /// The notebook ID.
        public var notebookId: Swift.String?
        /// The type of notebook. Currently, the only valid type is IPYNB.
        public var type: AthenaClientTypes.NotebookType?
        /// The name of the Spark enabled workgroup to which the notebook belongs.
        public var workGroup: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            notebookId: Swift.String? = nil,
            type: AthenaClientTypes.NotebookType? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.notebookId = notebookId
            self.type = type
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.NotebookSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.NotebookSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.NotebookSessionSummary()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains the notebook session ID and notebook session creation time.
    public struct NotebookSessionSummary {
        /// The time when the notebook session was created.
        public var creationTime: ClientRuntime.Date?
        /// The notebook session ID.
        public var sessionId: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.sessionId = sessionId
        }
    }

}

extension AthenaClientTypes {

    public enum NotebookType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipynb
        case sdkUnknown(Swift.String)

        public static var allCases: [NotebookType] {
            return [
                .ipynb,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipynb: return "IPYNB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.PreparedStatement {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.PreparedStatement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.PreparedStatement()
        value.statementName = try reader["StatementName"].readIfPresent()
        value.queryStatement = try reader["QueryStatement"].readIfPresent()
        value.workGroupName = try reader["WorkGroupName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// A prepared SQL statement for use with Athena.
    public struct PreparedStatement {
        /// The description of the prepared statement.
        public var description: Swift.String?
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The query string for the prepared statement.
        public var queryStatement: Swift.String?
        /// The name of the prepared statement.
        public var statementName: Swift.String?
        /// The name of the workgroup to which the prepared statement belongs.
        public var workGroupName: Swift.String?

        public init(
            description: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryStatement: Swift.String? = nil,
            statementName: Swift.String? = nil,
            workGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.queryStatement = queryStatement
            self.statementName = statementName
            self.workGroupName = workGroupName
        }
    }

}

extension AthenaClientTypes.PreparedStatementSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.PreparedStatementSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.PreparedStatementSummary()
        value.statementName = try reader["StatementName"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension AthenaClientTypes {
    /// The name and last modified time of the prepared statement.
    public struct PreparedStatementSummary {
        /// The last modified time of the prepared statement.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the prepared statement.
        public var statementName: Swift.String?

        public init(
            lastModifiedTime: ClientRuntime.Date? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.lastModifiedTime = lastModifiedTime
            self.statementName = statementName
        }
    }

}

extension PutCapacityAssignmentConfigurationInput {

    static func urlPathProvider(_ value: PutCapacityAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutCapacityAssignmentConfigurationInput {

    static func write(value: PutCapacityAssignmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityAssignments"].writeList(value.capacityAssignments, memberWritingClosure: AthenaClientTypes.CapacityAssignment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityReservationName"].write(value.capacityReservationName)
    }
}

public struct PutCapacityAssignmentConfigurationInput {
    /// The list of assignments for the capacity assignment configuration.
    /// This member is required.
    public var capacityAssignments: [AthenaClientTypes.CapacityAssignment]?
    /// The name of the capacity reservation to put a capacity assignment configuration for.
    /// This member is required.
    public var capacityReservationName: Swift.String?

    public init(
        capacityAssignments: [AthenaClientTypes.CapacityAssignment]? = nil,
        capacityReservationName: Swift.String? = nil
    )
    {
        self.capacityAssignments = capacityAssignments
        self.capacityReservationName = capacityReservationName
    }
}

extension PutCapacityAssignmentConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutCapacityAssignmentConfigurationOutput {
        return PutCapacityAssignmentConfigurationOutput()
    }
}

public struct PutCapacityAssignmentConfigurationOutput {

    public init() { }
}

enum PutCapacityAssignmentConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.QueryExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryExecution()
        value.queryExecutionId = try reader["QueryExecutionId"].readIfPresent()
        value.query = try reader["Query"].readIfPresent()
        value.statementType = try reader["StatementType"].readIfPresent()
        value.resultConfiguration = try reader["ResultConfiguration"].readIfPresent(with: AthenaClientTypes.ResultConfiguration.read(from:))
        value.resultReuseConfiguration = try reader["ResultReuseConfiguration"].readIfPresent(with: AthenaClientTypes.ResultReuseConfiguration.read(from:))
        value.queryExecutionContext = try reader["QueryExecutionContext"].readIfPresent(with: AthenaClientTypes.QueryExecutionContext.read(from:))
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.QueryExecutionStatus.read(from:))
        value.statistics = try reader["Statistics"].readIfPresent(with: AthenaClientTypes.QueryExecutionStatistics.read(from:))
        value.workGroup = try reader["WorkGroup"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent(with: AthenaClientTypes.EngineVersion.read(from:))
        value.executionParameters = try reader["ExecutionParameters"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.substatementType = try reader["SubstatementType"].readIfPresent()
        value.queryResultsS3AccessGrantsConfiguration = try reader["QueryResultsS3AccessGrantsConfiguration"].readIfPresent(with: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// Information about a single instance of a query execution.
    public struct QueryExecution {
        /// The engine version that executed the query.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur. The list of parameters is not returned in the response.
        public var executionParameters: [Swift.String]?
        /// The SQL query statements which the query execution ran.
        public var query: Swift.String?
        /// The database in which the query execution occurred.
        public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
        /// The unique identifier for each query execution.
        public var queryExecutionId: Swift.String?
        /// Specifies whether Amazon S3 access grants are enabled for query results.
        public var queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration?
        /// The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup.
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
        /// Specifies the query result reuse behavior that was used for the query.
        public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
        /// The type of query statement that was run. DDL indicates DDL query statements. DML indicates DML (Data Manipulation Language) query statements, such as CREATE TABLE AS SELECT. UTILITY indicates query statements other than DDL and DML, such as SHOW CREATE TABLE, or DESCRIBE TABLE.
        public var statementType: AthenaClientTypes.StatementType?
        /// Query execution statistics, such as the amount of data scanned, the amount of time that the query took to process, and the type of statement that was run.
        public var statistics: AthenaClientTypes.QueryExecutionStatistics?
        /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
        public var status: AthenaClientTypes.QueryExecutionStatus?
        /// The kind of query statement that was run.
        public var substatementType: Swift.String?
        /// The name of the workgroup in which the query ran.
        public var workGroup: Swift.String?

        public init(
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionParameters: [Swift.String]? = nil,
            query: Swift.String? = nil,
            queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
            queryExecutionId: Swift.String? = nil,
            queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
            resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
            statementType: AthenaClientTypes.StatementType? = nil,
            statistics: AthenaClientTypes.QueryExecutionStatistics? = nil,
            status: AthenaClientTypes.QueryExecutionStatus? = nil,
            substatementType: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.engineVersion = engineVersion
            self.executionParameters = executionParameters
            self.query = query
            self.queryExecutionContext = queryExecutionContext
            self.queryExecutionId = queryExecutionId
            self.queryResultsS3AccessGrantsConfiguration = queryResultsS3AccessGrantsConfiguration
            self.resultConfiguration = resultConfiguration
            self.resultReuseConfiguration = resultReuseConfiguration
            self.statementType = statementType
            self.statistics = statistics
            self.status = status
            self.substatementType = substatementType
            self.workGroup = workGroup
        }
    }

}

extension AthenaClientTypes.QueryExecutionContext {

    static func write(value: AthenaClientTypes.QueryExecutionContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Database"].write(value.database)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryExecutionContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryExecutionContext()
        value.database = try reader["Database"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// The database and data catalog context in which the query execution occurs.
    public struct QueryExecutionContext {
        /// The name of the data catalog used in the query execution.
        public var catalog: Swift.String?
        /// The name of the database used in the query execution. The database must exist in the catalog.
        public var database: Swift.String?

        public init(
            catalog: Swift.String? = nil,
            database: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.database = database
        }
    }

}

extension AthenaClientTypes {

    public enum QueryExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryExecutionState] {
            return [
                .cancelled,
                .failed,
                .queued,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.QueryExecutionStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryExecutionStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryExecutionStatistics()
        value.engineExecutionTimeInMillis = try reader["EngineExecutionTimeInMillis"].readIfPresent()
        value.dataScannedInBytes = try reader["DataScannedInBytes"].readIfPresent()
        value.dataManifestLocation = try reader["DataManifestLocation"].readIfPresent()
        value.totalExecutionTimeInMillis = try reader["TotalExecutionTimeInMillis"].readIfPresent()
        value.queryQueueTimeInMillis = try reader["QueryQueueTimeInMillis"].readIfPresent()
        value.servicePreProcessingTimeInMillis = try reader["ServicePreProcessingTimeInMillis"].readIfPresent()
        value.queryPlanningTimeInMillis = try reader["QueryPlanningTimeInMillis"].readIfPresent()
        value.serviceProcessingTimeInMillis = try reader["ServiceProcessingTimeInMillis"].readIfPresent()
        value.resultReuseInformation = try reader["ResultReuseInformation"].readIfPresent(with: AthenaClientTypes.ResultReuseInformation.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The amount of data scanned during the query execution and the amount of time that it took to execute, and the type of statement that was run.
    public struct QueryExecutionStatistics {
        /// The location and file name of a data manifest file. The manifest file is saved to the Athena query results location in Amazon S3. The manifest file tracks files that the query wrote to Amazon S3. If the query fails, the manifest file also tracks files that the query intended to write. The manifest is useful for identifying orphaned files resulting from a failed query. For more information, see [Working with Query Results, Output Files, and Query History](https://docs.aws.amazon.com/athena/latest/ug/querying.html) in the Amazon Athena User Guide.
        public var dataManifestLocation: Swift.String?
        /// The number of bytes in the data that was queried.
        public var dataScannedInBytes: Swift.Int?
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// Contains information about whether previous query results were reused for the query.
        public var resultReuseInformation: AthenaClientTypes.ResultReuseInformation?
        /// The number of milliseconds that Athena took to preprocess the query before submitting the query to the query engine.
        public var servicePreProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init(
            dataManifestLocation: Swift.String? = nil,
            dataScannedInBytes: Swift.Int? = nil,
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            resultReuseInformation: AthenaClientTypes.ResultReuseInformation? = nil,
            servicePreProcessingTimeInMillis: Swift.Int? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.dataManifestLocation = dataManifestLocation
            self.dataScannedInBytes = dataScannedInBytes
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.resultReuseInformation = resultReuseInformation
            self.servicePreProcessingTimeInMillis = servicePreProcessingTimeInMillis
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryExecutionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryExecutionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryExecutionStatus()
        value.state = try reader["State"].readIfPresent()
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent()
        value.submissionDateTime = try reader["SubmissionDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.completionDateTime = try reader["CompletionDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.athenaError = try reader["AthenaError"].readIfPresent(with: AthenaClientTypes.AthenaError.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The completion date, current state, submission time, and state change reason (if applicable) for the query execution.
    public struct QueryExecutionStatus {
        /// Provides information about an Athena query error.
        public var athenaError: AthenaClientTypes.AthenaError?
        /// The date and time that the query completed.
        public var completionDateTime: ClientRuntime.Date?
        /// The state of query execution. QUEUED indicates that the query has been submitted to the service, and Athena will execute the query as soon as resources are available. RUNNING indicates that the query is in execution phase. SUCCEEDED indicates that the query completed without errors. FAILED indicates that the query experienced an error and did not complete processing. CANCELLED indicates that a user input interrupted query execution. Athena automatically retries your queries in cases of certain transient errors. As a result, you may see the query state transition from RUNNING or FAILED to QUEUED.
        public var state: AthenaClientTypes.QueryExecutionState?
        /// Further detail about the status of the query.
        public var stateChangeReason: Swift.String?
        /// The date and time that the query was submitted.
        public var submissionDateTime: ClientRuntime.Date?

        public init(
            athenaError: AthenaClientTypes.AthenaError? = nil,
            completionDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.QueryExecutionState? = nil,
            stateChangeReason: Swift.String? = nil,
            submissionDateTime: ClientRuntime.Date? = nil
        )
        {
            self.athenaError = athenaError
            self.completionDateTime = completionDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.submissionDateTime = submissionDateTime
        }
    }

}

extension AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration {

    static func write(value: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["CreateUserLevelPrefix"].write(value.createUserLevelPrefix)
        try writer["EnableS3AccessGrants"].write(value.enableS3AccessGrants)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration()
        value.enableS3AccessGrants = try reader["EnableS3AccessGrants"].readIfPresent()
        value.createUserLevelPrefix = try reader["CreateUserLevelPrefix"].readIfPresent()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Specifies whether Amazon S3 access grants are enabled for query results.
    public struct QueryResultsS3AccessGrantsConfiguration {
        /// The authentication type used for Amazon S3 access grants. Currently, only DIRECTORY_IDENTITY is supported.
        /// This member is required.
        public var authenticationType: AthenaClientTypes.AuthenticationType?
        /// When enabled, appends the user ID as an Amazon S3 path prefix to the query result output location.
        public var createUserLevelPrefix: Swift.Bool?
        /// Specifies whether Amazon S3 access grants are enabled for query results.
        /// This member is required.
        public var enableS3AccessGrants: Swift.Bool?

        public init(
            authenticationType: AthenaClientTypes.AuthenticationType? = nil,
            createUserLevelPrefix: Swift.Bool? = nil,
            enableS3AccessGrants: Swift.Bool? = nil
        )
        {
            self.authenticationType = authenticationType
            self.createUserLevelPrefix = createUserLevelPrefix
            self.enableS3AccessGrants = enableS3AccessGrants
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryRuntimeStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryRuntimeStatistics()
        value.timeline = try reader["Timeline"].readIfPresent(with: AthenaClientTypes.QueryRuntimeStatisticsTimeline.read(from:))
        value.rows = try reader["Rows"].readIfPresent(with: AthenaClientTypes.QueryRuntimeStatisticsRows.read(from:))
        value.outputStage = try reader["OutputStage"].readIfPresent(with: AthenaClientTypes.QueryStage.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The query execution timeline, statistics on input and output rows and bytes, and the different query stages that form the query execution plan.
    public struct QueryRuntimeStatistics {
        /// Stage statistics such as input and output rows and bytes, execution time, and stage state. This information also includes substages and the query stage plan.
        public var outputStage: AthenaClientTypes.QueryStage?
        /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
        public var rows: AthenaClientTypes.QueryRuntimeStatisticsRows?
        /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
        public var timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline?

        public init(
            outputStage: AthenaClientTypes.QueryStage? = nil,
            rows: AthenaClientTypes.QueryRuntimeStatisticsRows? = nil,
            timeline: AthenaClientTypes.QueryRuntimeStatisticsTimeline? = nil
        )
        {
            self.outputStage = outputStage
            self.rows = rows
            self.timeline = timeline
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsRows {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryRuntimeStatisticsRows {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryRuntimeStatisticsRows()
        value.inputRows = try reader["InputRows"].readIfPresent()
        value.inputBytes = try reader["InputBytes"].readIfPresent()
        value.outputBytes = try reader["OutputBytes"].readIfPresent()
        value.outputRows = try reader["OutputRows"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Statistics such as input rows and bytes read by the query, rows and bytes output by the query, and the number of rows written by the query.
    public struct QueryRuntimeStatisticsRows {
        /// The number of bytes read to execute the query.
        public var inputBytes: Swift.Int?
        /// The number of rows read to execute the query.
        public var inputRows: Swift.Int?
        /// The number of bytes returned by the query.
        public var outputBytes: Swift.Int?
        /// The number of rows returned by the query.
        public var outputRows: Swift.Int?

        public init(
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil
        )
        {
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
        }
    }

}

extension AthenaClientTypes.QueryRuntimeStatisticsTimeline {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryRuntimeStatisticsTimeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryRuntimeStatisticsTimeline()
        value.queryQueueTimeInMillis = try reader["QueryQueueTimeInMillis"].readIfPresent()
        value.servicePreProcessingTimeInMillis = try reader["ServicePreProcessingTimeInMillis"].readIfPresent()
        value.queryPlanningTimeInMillis = try reader["QueryPlanningTimeInMillis"].readIfPresent()
        value.engineExecutionTimeInMillis = try reader["EngineExecutionTimeInMillis"].readIfPresent()
        value.serviceProcessingTimeInMillis = try reader["ServiceProcessingTimeInMillis"].readIfPresent()
        value.totalExecutionTimeInMillis = try reader["TotalExecutionTimeInMillis"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Timeline statistics such as query queue time, planning time, execution time, service processing time, and total execution time.
    public struct QueryRuntimeStatisticsTimeline {
        /// The number of milliseconds that the query took to execute.
        public var engineExecutionTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to plan the query processing flow. This includes the time spent retrieving table partitions from the data source. Note that because the query engine performs the query planning, query planning time is a subset of engine processing time.
        public var queryPlanningTimeInMillis: Swift.Int?
        /// The number of milliseconds that the query was in your query queue waiting for resources. Note that if transient errors occur, Athena might automatically add the query back to the queue.
        public var queryQueueTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena spends on preprocessing before it submits the query to the engine.
        public var servicePreProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to finalize and publish the query results after the query engine finished running the query.
        public var serviceProcessingTimeInMillis: Swift.Int?
        /// The number of milliseconds that Athena took to run the query.
        public var totalExecutionTimeInMillis: Swift.Int?

        public init(
            engineExecutionTimeInMillis: Swift.Int? = nil,
            queryPlanningTimeInMillis: Swift.Int? = nil,
            queryQueueTimeInMillis: Swift.Int? = nil,
            servicePreProcessingTimeInMillis: Swift.Int? = nil,
            serviceProcessingTimeInMillis: Swift.Int? = nil,
            totalExecutionTimeInMillis: Swift.Int? = nil
        )
        {
            self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
            self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
            self.queryQueueTimeInMillis = queryQueueTimeInMillis
            self.servicePreProcessingTimeInMillis = servicePreProcessingTimeInMillis
            self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
            self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
        }
    }

}

extension AthenaClientTypes.QueryStage {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryStage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryStage()
        value.stageId = try reader["StageId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.outputBytes = try reader["OutputBytes"].readIfPresent()
        value.outputRows = try reader["OutputRows"].readIfPresent()
        value.inputBytes = try reader["InputBytes"].readIfPresent()
        value.inputRows = try reader["InputRows"].readIfPresent()
        value.executionTime = try reader["ExecutionTime"].readIfPresent()
        value.queryStagePlan = try reader["QueryStagePlan"].readIfPresent(with: AthenaClientTypes.QueryStagePlanNode.read(from:))
        value.subStages = try reader["SubStages"].readListIfPresent(memberReadingClosure: AthenaClientTypes.QueryStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Stage statistics such as input and output rows and bytes, execution time and stage state. This information also includes substages and the query stage plan.
    public struct QueryStage {
        /// Time taken to execute this stage.
        public var executionTime: Swift.Int?
        /// The number of bytes input into the stage for execution.
        public var inputBytes: Swift.Int?
        /// The number of rows input into the stage for execution.
        public var inputRows: Swift.Int?
        /// The number of bytes output from the stage after execution.
        public var outputBytes: Swift.Int?
        /// The number of rows output from the stage after execution.
        public var outputRows: Swift.Int?
        /// Stage plan information such as name, identifier, sub plans, and source stages.
        public var queryStagePlan: AthenaClientTypes.QueryStagePlanNode?
        /// The identifier for a stage.
        public var stageId: Swift.Int?
        /// State of the stage after query execution.
        public var state: Swift.String?
        /// List of sub query stages that form this stage execution plan.
        public var subStages: [AthenaClientTypes.QueryStage]?

        public init(
            executionTime: Swift.Int? = nil,
            inputBytes: Swift.Int? = nil,
            inputRows: Swift.Int? = nil,
            outputBytes: Swift.Int? = nil,
            outputRows: Swift.Int? = nil,
            queryStagePlan: AthenaClientTypes.QueryStagePlanNode? = nil,
            stageId: Swift.Int? = nil,
            state: Swift.String? = nil,
            subStages: [AthenaClientTypes.QueryStage]? = nil
        )
        {
            self.executionTime = executionTime
            self.inputBytes = inputBytes
            self.inputRows = inputRows
            self.outputBytes = outputBytes
            self.outputRows = outputRows
            self.queryStagePlan = queryStagePlan
            self.stageId = stageId
            self.state = state
            self.subStages = subStages
        }
    }

}

extension AthenaClientTypes.QueryStagePlanNode {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.QueryStagePlanNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.QueryStagePlanNode()
        value.name = try reader["Name"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.children = try reader["Children"].readListIfPresent(memberReadingClosure: AthenaClientTypes.QueryStagePlanNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.remoteSources = try reader["RemoteSources"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Stage plan information such as name, identifier, sub plans, and remote sources.
    public struct QueryStagePlanNode {
        /// Stage plan information such as name, identifier, sub plans, and remote sources of child plan nodes/
        public var children: [AthenaClientTypes.QueryStagePlanNode]?
        /// Information about the operation this query stage plan node is performing.
        public var identifier: Swift.String?
        /// Name of the query stage plan that describes the operation this stage is performing as part of query execution.
        public var name: Swift.String?
        /// Source plan node IDs.
        public var remoteSources: [Swift.String]?

        public init(
            children: [AthenaClientTypes.QueryStagePlanNode]? = nil,
            identifier: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteSources: [Swift.String]? = nil
        )
        {
            self.children = children
            self.identifier = identifier
            self.name = name
            self.remoteSources = remoteSources
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A resource, such as a workgroup, was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the Amazon resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension AthenaClientTypes.ResultConfiguration {

    static func write(value: AthenaClientTypes.ResultConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AclConfiguration"].write(value.aclConfiguration, with: AthenaClientTypes.AclConfiguration.write(value:to:))
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: AthenaClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["ExpectedBucketOwner"].write(value.expectedBucketOwner)
        try writer["OutputLocation"].write(value.outputLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultConfiguration()
        value.outputLocation = try reader["OutputLocation"].readIfPresent()
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: AthenaClientTypes.EncryptionConfiguration.read(from:))
        value.expectedBucketOwner = try reader["ExpectedBucketOwner"].readIfPresent()
        value.aclConfiguration = try reader["AclConfiguration"].readIfPresent(with: AthenaClientTypes.AclConfiguration.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
    public struct ResultConfiguration {
        /// Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results. Currently the only supported canned ACL is BUCKET_OWNER_FULL_CONTROL. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ACL configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. For more information, see [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the encryption configuration that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. This is a client-side setting. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query and calculation results are stored, such as s3://path/to/query/bucket/. To run the query, you must specify the query results location using one of the ways: either for individual queries using either this setting (client-side), or in the workgroup, using [WorkGroupConfiguration]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the settings specified for the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?

        public init(
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
        }
    }

}

extension AthenaClientTypes.ResultConfigurationUpdates {

    static func write(value: AthenaClientTypes.ResultConfigurationUpdates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AclConfiguration"].write(value.aclConfiguration, with: AthenaClientTypes.AclConfiguration.write(value:to:))
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: AthenaClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["ExpectedBucketOwner"].write(value.expectedBucketOwner)
        try writer["OutputLocation"].write(value.outputLocation)
        try writer["RemoveAclConfiguration"].write(value.removeAclConfiguration)
        try writer["RemoveEncryptionConfiguration"].write(value.removeEncryptionConfiguration)
        try writer["RemoveExpectedBucketOwner"].write(value.removeExpectedBucketOwner)
        try writer["RemoveOutputLocation"].write(value.removeOutputLocation)
    }
}

extension AthenaClientTypes {
    /// The information about the updates in the query results, such as output location and encryption configuration for the query results.
    public struct ResultConfigurationUpdates {
        /// The ACL configuration for the query results.
        public var aclConfiguration: AthenaClientTypes.AclConfiguration?
        /// The encryption configuration for query and calculation results.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The Amazon Web Services account ID that you expect to be the owner of the Amazon S3 bucket specified by [ResultConfiguration$OutputLocation]. If set, Athena uses the value for ExpectedBucketOwner when it makes Amazon S3 calls to your specified output location. If the ExpectedBucketOwner Amazon Web Services account ID does not match the actual owner of the Amazon S3 bucket, the call fails with a permissions error. If workgroup settings override client-side settings, then the query uses the ExpectedBucketOwner setting that is specified for the workgroup, and also uses the location for storing query results specified in the workgroup. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration] and [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var expectedBucketOwner: Swift.String?
        /// The location in Amazon S3 where your query and calculation results are stored, such as s3://path/to/query/bucket/. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html). If workgroup settings override client-side settings, then the query uses the location for the query results and the encryption configuration that are specified for the workgroup. The "workgroup settings override" is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var outputLocation: Swift.String?
        /// If set to true, indicates that the previously-specified ACL configuration for queries in this workgroup should be ignored and set to null. If set to false or not set, and a value is present in the AclConfiguration of ResultConfigurationUpdates, the AclConfiguration in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeAclConfiguration: Swift.Bool?
        /// If set to "true", indicates that the previously-specified encryption configuration (also known as the client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the EncryptionConfiguration in ResultConfigurationUpdates (the client-side setting), the EncryptionConfiguration in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeEncryptionConfiguration: Swift.Bool?
        /// If set to "true", removes the Amazon Web Services account ID previously specified for [ResultConfiguration$ExpectedBucketOwner]. If set to "false" or not set, and a value is present in the ExpectedBucketOwner in ResultConfigurationUpdates (the client-side setting), the ExpectedBucketOwner in the workgroup's ResultConfiguration is updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeExpectedBucketOwner: Swift.Bool?
        /// If set to "true", indicates that the previously-specified query results location (also known as a client-side setting) for queries in this workgroup should be ignored and set to null. If set to "false" or not set, and a value is present in the OutputLocation in ResultConfigurationUpdates (the client-side setting), the OutputLocation in the workgroup's ResultConfiguration will be updated with the new value. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var removeOutputLocation: Swift.Bool?

        public init(
            aclConfiguration: AthenaClientTypes.AclConfiguration? = nil,
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            expectedBucketOwner: Swift.String? = nil,
            outputLocation: Swift.String? = nil,
            removeAclConfiguration: Swift.Bool? = nil,
            removeEncryptionConfiguration: Swift.Bool? = nil,
            removeExpectedBucketOwner: Swift.Bool? = nil,
            removeOutputLocation: Swift.Bool? = nil
        )
        {
            self.aclConfiguration = aclConfiguration
            self.encryptionConfiguration = encryptionConfiguration
            self.expectedBucketOwner = expectedBucketOwner
            self.outputLocation = outputLocation
            self.removeAclConfiguration = removeAclConfiguration
            self.removeEncryptionConfiguration = removeEncryptionConfiguration
            self.removeExpectedBucketOwner = removeExpectedBucketOwner
            self.removeOutputLocation = removeOutputLocation
        }
    }

}

extension AthenaClientTypes.ResultReuseByAgeConfiguration {

    static func write(value: AthenaClientTypes.ResultReuseByAgeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["MaxAgeInMinutes"].write(value.maxAgeInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultReuseByAgeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultReuseByAgeConfiguration()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.maxAgeInMinutes = try reader["MaxAgeInMinutes"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Specifies whether previous query results are reused, and if so, their maximum age.
    public struct ResultReuseByAgeConfiguration {
        /// True if previous query results can be reused when the query is run; otherwise, false. The default is false.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Specifies, in minutes, the maximum age of a previous query result that Athena should consider for reuse. The default is 60.
        public var maxAgeInMinutes: Swift.Int?

        public init(
            enabled: Swift.Bool = false,
            maxAgeInMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.maxAgeInMinutes = maxAgeInMinutes
        }
    }

}

extension AthenaClientTypes.ResultReuseConfiguration {

    static func write(value: AthenaClientTypes.ResultReuseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResultReuseByAgeConfiguration"].write(value.resultReuseByAgeConfiguration, with: AthenaClientTypes.ResultReuseByAgeConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultReuseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultReuseConfiguration()
        value.resultReuseByAgeConfiguration = try reader["ResultReuseByAgeConfiguration"].readIfPresent(with: AthenaClientTypes.ResultReuseByAgeConfiguration.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// Specifies the query result reuse behavior for the query.
    public struct ResultReuseConfiguration {
        /// Specifies whether previous query results are reused, and if so, their maximum age.
        public var resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration?

        public init(
            resultReuseByAgeConfiguration: AthenaClientTypes.ResultReuseByAgeConfiguration? = nil
        )
        {
            self.resultReuseByAgeConfiguration = resultReuseByAgeConfiguration
        }
    }

}

extension AthenaClientTypes.ResultReuseInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultReuseInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultReuseInformation()
        value.reusedPreviousResult = try reader["ReusedPreviousResult"].readIfPresent() ?? false
        return value
    }
}

extension AthenaClientTypes {
    /// Contains information about whether the result of a previous query was reused.
    public struct ResultReuseInformation {
        /// True if a previous query result was reused; false if the result was generated from a new run of the query.
        /// This member is required.
        public var reusedPreviousResult: Swift.Bool

        public init(
            reusedPreviousResult: Swift.Bool = false
        )
        {
            self.reusedPreviousResult = reusedPreviousResult
        }
    }

}

extension AthenaClientTypes.ResultSet {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultSet()
        value.rows = try reader["Rows"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Row.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resultSetMetadata = try reader["ResultSetMetadata"].readIfPresent(with: AthenaClientTypes.ResultSetMetadata.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The metadata and rows that make up a query result set. The metadata describes the column structure and data types. To return a ResultSet object, use [GetQueryResults].
    public struct ResultSet {
        /// The metadata that describes the column structure and data types of a table of query results.
        public var resultSetMetadata: AthenaClientTypes.ResultSetMetadata?
        /// The rows in the table.
        public var rows: [AthenaClientTypes.Row]?

        public init(
            resultSetMetadata: AthenaClientTypes.ResultSetMetadata? = nil,
            rows: [AthenaClientTypes.Row]? = nil
        )
        {
            self.resultSetMetadata = resultSetMetadata
            self.rows = rows
        }
    }

}

extension AthenaClientTypes.ResultSetMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.ResultSetMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.ResultSetMetadata()
        value.columnInfo = try reader["ColumnInfo"].readListIfPresent(memberReadingClosure: AthenaClientTypes.ColumnInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// The metadata that describes the column structure and data types of a table of query results. To return a ResultSetMetadata object, use [GetQueryResults].
    public struct ResultSetMetadata {
        /// Information about the columns returned in a query result metadata.
        public var columnInfo: [AthenaClientTypes.ColumnInfo]?

        public init(
            columnInfo: [AthenaClientTypes.ColumnInfo]? = nil
        )
        {
            self.columnInfo = columnInfo
        }
    }

}

extension AthenaClientTypes.Row {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.Row {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.Row()
        value.data = try reader["Data"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Datum.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// The rows that make up a query result table.
    public struct Row {
        /// The data that populates a row in a query result table.
        public var data: [AthenaClientTypes.Datum]?

        public init(
            data: [AthenaClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }

}

extension AthenaClientTypes {

    public enum S3AclOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bucketOwnerFullControl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3AclOption] {
            return [
                .bucketOwnerFullControl,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bucketOwnerFullControl: return "BUCKET_OWNER_FULL_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SessionAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SessionAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = SessionAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified session already exists.
public struct SessionAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SessionAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AthenaClientTypes.SessionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.SessionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.SessionConfiguration()
        value.executionRole = try reader["ExecutionRole"].readIfPresent()
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        value.idleTimeoutSeconds = try reader["IdleTimeoutSeconds"].readIfPresent()
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: AthenaClientTypes.EncryptionConfiguration.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// Contains session configuration information.
    public struct SessionConfiguration {
        /// If query and calculation results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE_KMS or CSE_KMS) and key information.
        public var encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration?
        /// The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.
        public var executionRole: Swift.String?
        /// The idle timeout in seconds for the session.
        public var idleTimeoutSeconds: Swift.Int?
        /// The Amazon S3 location that stores information for the notebook.
        public var workingDirectory: Swift.String?

        public init(
            encryptionConfiguration: AthenaClientTypes.EncryptionConfiguration? = nil,
            executionRole: Swift.String? = nil,
            idleTimeoutSeconds: Swift.Int? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.executionRole = executionRole
            self.idleTimeoutSeconds = idleTimeoutSeconds
            self.workingDirectory = workingDirectory
        }
    }

}

extension AthenaClientTypes {

    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case busy
        case created
        case creating
        case degraded
        case failed
        case idle
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .busy,
                .created,
                .creating,
                .degraded,
                .failed,
                .idle,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .busy: return "BUSY"
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .degraded: return "DEGRADED"
            case .failed: return "FAILED"
            case .idle: return "IDLE"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.SessionStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.SessionStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.SessionStatistics()
        value.dpuExecutionInMillis = try reader["DpuExecutionInMillis"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains statistics for a session.
    public struct SessionStatistics {
        /// The data processing unit execution time for a session in milliseconds.
        public var dpuExecutionInMillis: Swift.Int?

        public init(
            dpuExecutionInMillis: Swift.Int? = nil
        )
        {
            self.dpuExecutionInMillis = dpuExecutionInMillis
        }
    }

}

extension AthenaClientTypes.SessionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.SessionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.SessionStatus()
        value.startDateTime = try reader["StartDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastModifiedDateTime = try reader["LastModifiedDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.endDateTime = try reader["EndDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.idleSinceDateTime = try reader["IdleSinceDateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.stateChangeReason = try reader["StateChangeReason"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Contains information about the status of a session.
    public struct SessionStatus {
        /// The date and time that the session ended.
        public var endDateTime: ClientRuntime.Date?
        /// The date and time starting at which the session became idle. Can be empty if the session is not currently idle.
        public var idleSinceDateTime: ClientRuntime.Date?
        /// The most recent date and time that the session was modified.
        public var lastModifiedDateTime: ClientRuntime.Date?
        /// The date and time that the session started.
        public var startDateTime: ClientRuntime.Date?
        /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
        public var state: AthenaClientTypes.SessionState?
        /// The reason for the session state change (for example, canceled because the session was terminated).
        public var stateChangeReason: Swift.String?

        public init(
            endDateTime: ClientRuntime.Date? = nil,
            idleSinceDateTime: ClientRuntime.Date? = nil,
            lastModifiedDateTime: ClientRuntime.Date? = nil,
            startDateTime: ClientRuntime.Date? = nil,
            state: AthenaClientTypes.SessionState? = nil,
            stateChangeReason: Swift.String? = nil
        )
        {
            self.endDateTime = endDateTime
            self.idleSinceDateTime = idleSinceDateTime
            self.lastModifiedDateTime = lastModifiedDateTime
            self.startDateTime = startDateTime
            self.state = state
            self.stateChangeReason = stateChangeReason
        }
    }

}

extension AthenaClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.SessionSummary()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent(with: AthenaClientTypes.EngineVersion.read(from:))
        value.notebookVersion = try reader["NotebookVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: AthenaClientTypes.SessionStatus.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// Contains summary information about a session.
    public struct SessionSummary {
        /// The session description.
        public var description: Swift.String?
        /// The engine version used by the session (for example, PySpark engine version 3).
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The notebook version.
        public var notebookVersion: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// Contains information about the session status.
        public var status: AthenaClientTypes.SessionStatus?

        public init(
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            notebookVersion: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            status: AthenaClientTypes.SessionStatus? = nil
        )
        {
            self.description = description
            self.engineVersion = engineVersion
            self.notebookVersion = notebookVersion
            self.sessionId = sessionId
            self.status = status
        }
    }

}

extension StartCalculationExecutionInput {

    static func urlPathProvider(_ value: StartCalculationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartCalculationExecutionInput {

    static func write(value: StartCalculationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculationConfiguration"].write(value.calculationConfiguration, with: AthenaClientTypes.CalculationConfiguration.write(value:to:))
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["CodeBlock"].write(value.codeBlock)
        try writer["Description"].write(value.description)
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct StartCalculationExecutionInput {
    /// Contains configuration information for the calculation.
    @available(*, deprecated, message: "Kepler Post GA Tasks : https://sim.amazon.com/issues/ATHENA-39828")
    public var calculationConfiguration: AthenaClientTypes.CalculationConfiguration?
    /// A unique case-sensitive string used to ensure the request to create the calculation is idempotent (executes only once). If another StartCalculationExecutionRequest is received, the same response is returned and another calculation is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A string that contains the code of the calculation. Use this parameter instead of [CalculationConfiguration$CodeBlock], which is deprecated.
    public var codeBlock: Swift.String?
    /// A description of the calculation.
    public var description: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        calculationConfiguration: AthenaClientTypes.CalculationConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        codeBlock: Swift.String? = nil,
        description: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.calculationConfiguration = calculationConfiguration
        self.clientRequestToken = clientRequestToken
        self.codeBlock = codeBlock
        self.description = description
        self.sessionId = sessionId
    }
}

extension StartCalculationExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartCalculationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCalculationExecutionOutput()
        value.calculationExecutionId = try reader["CalculationExecutionId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct StartCalculationExecutionOutput {
    /// The calculation execution UUID.
    public var calculationExecutionId: Swift.String?
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init(
        calculationExecutionId: Swift.String? = nil,
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
        self.state = state
    }
}

enum StartCalculationExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartQueryExecutionInput {

    static func urlPathProvider(_ value: StartQueryExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartQueryExecutionInput {

    static func write(value: StartQueryExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ExecutionParameters"].writeList(value.executionParameters, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryExecutionContext"].write(value.queryExecutionContext, with: AthenaClientTypes.QueryExecutionContext.write(value:to:))
        try writer["QueryString"].write(value.queryString)
        try writer["ResultConfiguration"].write(value.resultConfiguration, with: AthenaClientTypes.ResultConfiguration.write(value:to:))
        try writer["ResultReuseConfiguration"].write(value.resultReuseConfiguration, with: AthenaClientTypes.ResultReuseConfiguration.write(value:to:))
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct StartQueryExecutionInput {
    /// A unique case-sensitive string used to ensure the request to create the query is idempotent (executes only once). If another StartQueryExecution request is received, the same response is returned and another query is not created. An error is returned if a parameter, such as QueryString, has changed. A call to StartQueryExecution that uses a previous client request token returns the same QueryExecutionId even if the requester doesn't have permission on the tables specified in QueryString. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// A list of values for the parameters in a query. The values are applied sequentially to the parameters in the query in the order in which the parameters occur.
    public var executionParameters: [Swift.String]?
    /// The database within which the query executes.
    public var queryExecutionContext: AthenaClientTypes.QueryExecutionContext?
    /// The SQL query statements to be executed.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies information about where and how to save the results of the query execution. If the query runs in a workgroup, then workgroup's settings may override query settings. This affects the query results location. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public var resultConfiguration: AthenaClientTypes.ResultConfiguration?
    /// Specifies the query result reuse behavior for the query.
    public var resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration?
    /// The name of the workgroup in which the query is being started.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        executionParameters: [Swift.String]? = nil,
        queryExecutionContext: AthenaClientTypes.QueryExecutionContext? = nil,
        queryString: Swift.String? = nil,
        resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil,
        resultReuseConfiguration: AthenaClientTypes.ResultReuseConfiguration? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.executionParameters = executionParameters
        self.queryExecutionContext = queryExecutionContext
        self.queryString = queryString
        self.resultConfiguration = resultConfiguration
        self.resultReuseConfiguration = resultReuseConfiguration
        self.workGroup = workGroup
    }
}

extension StartQueryExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartQueryExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryExecutionOutput()
        value.queryExecutionId = try reader["QueryExecutionId"].readIfPresent()
        return value
    }
}

public struct StartQueryExecutionOutput {
    /// The unique ID of the query that ran as a result of this request.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

enum StartQueryExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartSessionInput {

    static func urlPathProvider(_ value: StartSessionInput) -> Swift.String? {
        return "/"
    }
}

extension StartSessionInput {

    static func write(value: StartSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["EngineConfiguration"].write(value.engineConfiguration, with: AthenaClientTypes.EngineConfiguration.write(value:to:))
        try writer["NotebookVersion"].write(value.notebookVersion)
        try writer["SessionIdleTimeoutInMinutes"].write(value.sessionIdleTimeoutInMinutes)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct StartSessionInput {
    /// A unique case-sensitive string used to ensure the request to create the session is idempotent (executes only once). If another StartSessionRequest is received, the same response is returned and another session is not created. If a parameter has changed, an error is returned. This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for users. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The session description.
    public var description: Swift.String?
    /// Contains engine data processing unit (DPU) configuration settings and parameter mappings.
    /// This member is required.
    public var engineConfiguration: AthenaClientTypes.EngineConfiguration?
    /// The notebook version. This value is supplied automatically for notebook sessions in the Athena console and is not required for programmatic session access. The only valid notebook version is Athena notebook version 1. If you specify a value for NotebookVersion, you must also specify a value for NotebookId. See [EngineConfiguration$AdditionalConfigs].
    public var notebookVersion: Swift.String?
    /// The idle timeout in minutes for the session.
    public var sessionIdleTimeoutInMinutes: Swift.Int?
    /// The workgroup to which the session belongs.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engineConfiguration: AthenaClientTypes.EngineConfiguration? = nil,
        notebookVersion: Swift.String? = nil,
        sessionIdleTimeoutInMinutes: Swift.Int? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.engineConfiguration = engineConfiguration
        self.notebookVersion = notebookVersion
        self.sessionIdleTimeoutInMinutes = sessionIdleTimeoutInMinutes
        self.workGroup = workGroup
    }
}

extension StartSessionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSessionOutput()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct StartSessionOutput {
    /// The session ID.
    public var sessionId: Swift.String?
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init(
        sessionId: Swift.String? = nil,
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.sessionId = sessionId
        self.state = state
    }
}

enum StartSessionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SessionAlreadyExistsException": return try SessionAlreadyExistsException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes {

    public enum StatementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ddl
        case dml
        case utility
        case sdkUnknown(Swift.String)

        public static var allCases: [StatementType] {
            return [
                .ddl,
                .dml,
                .utility,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ddl: return "DDL"
            case .dml: return "DML"
            case .utility: return "UTILITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StopCalculationExecutionInput {

    static func urlPathProvider(_ value: StopCalculationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StopCalculationExecutionInput {

    static func write(value: StopCalculationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculationExecutionId"].write(value.calculationExecutionId)
    }
}

public struct StopCalculationExecutionInput {
    /// The calculation execution UUID.
    /// This member is required.
    public var calculationExecutionId: Swift.String?

    public init(
        calculationExecutionId: Swift.String? = nil
    )
    {
        self.calculationExecutionId = calculationExecutionId
    }
}

extension StopCalculationExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopCalculationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopCalculationExecutionOutput()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct StopCalculationExecutionOutput {
    /// CREATING - The calculation is in the process of being created. CREATED - The calculation has been created and is ready to run. QUEUED - The calculation has been queued for processing. RUNNING - The calculation is running. CANCELING - A request to cancel the calculation has been received and the system is working to stop it. CANCELED - The calculation is no longer running as the result of a cancel request. COMPLETED - The calculation has completed without error. FAILED - The calculation failed and is no longer running.
    public var state: AthenaClientTypes.CalculationExecutionState?

    public init(
        state: AthenaClientTypes.CalculationExecutionState? = nil
    )
    {
        self.state = state
    }
}

enum StopCalculationExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopQueryExecutionInput {

    static func urlPathProvider(_ value: StopQueryExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StopQueryExecutionInput {

    static func write(value: StopQueryExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryExecutionId"].write(value.queryExecutionId)
    }
}

public struct StopQueryExecutionInput {
    /// The unique ID of the query execution to stop.
    /// This member is required.
    public var queryExecutionId: Swift.String?

    public init(
        queryExecutionId: Swift.String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

extension StopQueryExecutionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopQueryExecutionOutput {
        return StopQueryExecutionOutput()
    }
}

public struct StopQueryExecutionOutput {

    public init() { }
}

enum StopQueryExecutionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.TableMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.TableMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.TableMetadata()
        value.name = try reader["Name"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: .epochSeconds)
        value.lastAccessTime = try reader["LastAccessTime"].readTimestampIfPresent(format: .epochSeconds)
        value.tableType = try reader["TableType"].readIfPresent()
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: AthenaClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AthenaClientTypes {
    /// Contains metadata for a table.
    public struct TableMetadata {
        /// A list of the columns in the table.
        public var columns: [AthenaClientTypes.Column]?
        /// The time that the table was created.
        public var createTime: ClientRuntime.Date?
        /// The last time the table was accessed.
        public var lastAccessTime: ClientRuntime.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// A set of custom key/value pairs for table properties.
        public var parameters: [Swift.String:Swift.String]?
        /// A list of the partition keys in the table.
        public var partitionKeys: [AthenaClientTypes.Column]?
        /// The type of table. In Athena, only EXTERNAL_TABLE is supported.
        public var tableType: Swift.String?

        public init(
            columns: [AthenaClientTypes.Column]? = nil,
            createTime: ClientRuntime.Date? = nil,
            lastAccessTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            partitionKeys: [AthenaClientTypes.Column]? = nil,
            tableType: Swift.String? = nil
        )
        {
            self.columns = columns
            self.createTime = createTime
            self.lastAccessTime = lastAccessTime
            self.name = name
            self.parameters = parameters
            self.partitionKeys = partitionKeys
            self.tableType = tableType
        }
    }

}

extension AthenaClientTypes.Tag {

    static func write(value: AthenaClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// A label that you assign to a resource. Athena resources include workgroups, data catalogs, and capacity reservations. Each tag consists of a key and an optional value, both of which you define. For example, you can use tags to categorize Athena resources by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to search and filter the resources in your account. For best practices, see [Tagging Best Practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html). Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you specify more than one tag, separate them by commas.
    public struct Tag {
        /// A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag keys are case-sensitive and must be unique per resource.
        public var key: Swift.String?
        /// A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You can use letters and numbers representable in UTF-8, and the following characters: + - = . _ : / @. Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AthenaClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// Specifies the ARN of the Athena resource to which tags are to be added.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A collection of one or more tags, separated by commas, to be added to an Athena resource.
    /// This member is required.
    public var tags: [AthenaClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [AthenaClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TerminateSessionInput {

    static func urlPathProvider(_ value: TerminateSessionInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateSessionInput {

    static func write(value: TerminateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

public struct TerminateSessionInput {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

extension TerminateSessionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TerminateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateSessionOutput()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

public struct TerminateSessionOutput {
    /// The state of the session. A description of each state follows. CREATING - The session is being started, including acquiring resources. CREATED - The session has been started. IDLE - The session is able to accept a calculation. BUSY - The session is processing another task and is unable to accept a calculation. TERMINATING - The session is in the process of shutting down. TERMINATED - The session and its resources are no longer running. DEGRADED - The session has no healthy coordinators. FAILED - Due to a failure, the session and its resources are no longer running.
    public var state: AthenaClientTypes.SessionState?

    public init(
        state: AthenaClientTypes.SessionState? = nil
    )
    {
        self.state = state
    }
}

enum TerminateSessionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes {

    /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
    public enum ThrottleReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concurrentQueryLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ThrottleReason] {
            return [
                .concurrentQueryLimitExceeded,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concurrentQueryLimitExceeded: return "CONCURRENT_QUERY_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Indicates that the request was throttled.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the query throttling, for example, when it exceeds the concurrent query limit.
        public internal(set) var reason: AthenaClientTypes.ThrottleReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: AthenaClientTypes.ThrottleReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension AthenaClientTypes.UnprocessedNamedQueryId {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.UnprocessedNamedQueryId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.UnprocessedNamedQueryId()
        value.namedQueryId = try reader["NamedQueryId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Information about a named query ID that could not be processed.
    public struct UnprocessedNamedQueryId {
        /// The error code returned when the processing request for the named query failed, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the processing request for the named query failed, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the named query.
        public var namedQueryId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            namedQueryId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.namedQueryId = namedQueryId
        }
    }

}

extension AthenaClientTypes.UnprocessedPreparedStatementName {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.UnprocessedPreparedStatementName {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.UnprocessedPreparedStatementName()
        value.statementName = try reader["StatementName"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// The name of a prepared statement that could not be returned.
    public struct UnprocessedPreparedStatementName {
        /// The error code returned when the request for the prepared statement failed.
        public var errorCode: Swift.String?
        /// The error message containing the reason why the prepared statement could not be returned. The following error messages are possible:
        ///
        /// * INVALID_INPUT - The name of the prepared statement that was provided is not valid (for example, the name is too long).
        ///
        /// * STATEMENT_NOT_FOUND - A prepared statement with the name provided could not be found.
        ///
        /// * UNAUTHORIZED - The requester does not have permission to access the workgroup that contains the prepared statement.
        public var errorMessage: Swift.String?
        /// The name of a prepared statement that could not be returned due to an error.
        public var statementName: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            statementName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.statementName = statementName
        }
    }

}

extension AthenaClientTypes.UnprocessedQueryExecutionId {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.UnprocessedQueryExecutionId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.UnprocessedQueryExecutionId()
        value.queryExecutionId = try reader["QueryExecutionId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// Describes a query execution that failed to process.
    public struct UnprocessedQueryExecutionId {
        /// The error code returned when the query execution failed to process, if applicable.
        public var errorCode: Swift.String?
        /// The error message returned when the query execution failed to process, if applicable.
        public var errorMessage: Swift.String?
        /// The unique identifier of the query execution.
        public var queryExecutionId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            queryExecutionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.queryExecutionId = queryExecutionId
        }
    }

}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UntagResourceInput {
    /// Specifies the ARN of the resource from which tags are to be removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A comma-separated list of one or more tag keys whose tags are to be removed from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateCapacityReservationInput {

    static func urlPathProvider(_ value: UpdateCapacityReservationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCapacityReservationInput {

    static func write(value: UpdateCapacityReservationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["TargetDpus"].write(value.targetDpus)
    }
}

public struct UpdateCapacityReservationInput {
    /// The name of the capacity reservation.
    /// This member is required.
    public var name: Swift.String?
    /// The new number of requested data processing units.
    /// This member is required.
    public var targetDpus: Swift.Int?

    public init(
        name: Swift.String? = nil,
        targetDpus: Swift.Int? = nil
    )
    {
        self.name = name
        self.targetDpus = targetDpus
    }
}

extension UpdateCapacityReservationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateCapacityReservationOutput {
        return UpdateCapacityReservationOutput()
    }
}

public struct UpdateCapacityReservationOutput {

    public init() { }
}

enum UpdateCapacityReservationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDataCatalogInput {

    static func urlPathProvider(_ value: UpdateDataCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDataCatalogInput {

    static func write(value: UpdateDataCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

public struct UpdateDataCatalogInput {
    /// New or modified text that describes the data catalog.
    public var description: Swift.String?
    /// The name of the data catalog to update. The catalog name must be unique for the Amazon Web Services account and can use a maximum of 127 alphanumeric, underscore, at sign, or hyphen characters. The remainder of the length constraint of 256 is reserved for use by Athena.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the Lambda function or functions to use for updating the data catalog. This is a mapping whose values depend on the catalog type.
    ///
    /// * For the HIVE data catalog type, use the following syntax. The metadata-function parameter is required. The sdk-version parameter is optional and defaults to the currently supported version. metadata-function=lambda_arn, sdk-version=version_number
    ///
    /// * For the LAMBDA data catalog type, use one of the following sets of required parameters, but not both.
    ///
    /// * If you have one Lambda function that processes metadata and another for reading the actual data, use the following syntax. Both parameters are required. metadata-function=lambda_arn, record-function=lambda_arn
    ///
    /// * If you have a composite Lambda function that processes both metadata and data, use the following syntax to specify your Lambda function. function=lambda_arn
    public var parameters: [Swift.String:Swift.String]?
    /// Specifies the type of data catalog to update. Specify LAMBDA for a federated catalog, HIVE for an external hive metastore, or GLUE for an Glue Data Catalog.
    /// This member is required.
    public var type: AthenaClientTypes.DataCatalogType?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        type: AthenaClientTypes.DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

extension UpdateDataCatalogOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDataCatalogOutput {
        return UpdateDataCatalogOutput()
    }
}

public struct UpdateDataCatalogOutput {

    public init() { }
}

enum UpdateDataCatalogOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateNamedQueryInput {

    static func urlPathProvider(_ value: UpdateNamedQueryInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNamedQueryInput {

    static func write(value: UpdateNamedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["NamedQueryId"].write(value.namedQueryId)
        try writer["QueryString"].write(value.queryString)
    }
}

public struct UpdateNamedQueryInput {
    /// The query description.
    public var description: Swift.String?
    /// The name of the query.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier (UUID) of the query.
    /// This member is required.
    public var namedQueryId: Swift.String?
    /// The contents of the query with all query statements.
    /// This member is required.
    public var queryString: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        namedQueryId: Swift.String? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.namedQueryId = namedQueryId
        self.queryString = queryString
    }
}

extension UpdateNamedQueryOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateNamedQueryOutput {
        return UpdateNamedQueryOutput()
    }
}

public struct UpdateNamedQueryOutput {

    public init() { }
}

enum UpdateNamedQueryOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateNotebookInput {

    static func urlPathProvider(_ value: UpdateNotebookInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNotebookInput {

    static func write(value: UpdateNotebookInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["NotebookId"].write(value.notebookId)
        try writer["Payload"].write(value.payload)
        try writer["SessionId"].write(value.sessionId)
        try writer["Type"].write(value.type)
    }
}

public struct UpdateNotebookInput {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The ID of the notebook to update.
    /// This member is required.
    public var notebookId: Swift.String?
    /// The updated content for the notebook.
    /// This member is required.
    public var payload: Swift.String?
    /// The active notebook session ID. Required if the notebook has an active session.
    public var sessionId: Swift.String?
    /// The notebook content type. Currently, the only valid type is IPYNB.
    /// This member is required.
    public var type: AthenaClientTypes.NotebookType?

    public init(
        clientRequestToken: Swift.String? = nil,
        notebookId: Swift.String? = nil,
        payload: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        type: AthenaClientTypes.NotebookType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.notebookId = notebookId
        self.payload = payload
        self.sessionId = sessionId
        self.type = type
    }
}

extension UpdateNotebookMetadataInput {

    static func urlPathProvider(_ value: UpdateNotebookMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNotebookMetadataInput {

    static func write(value: UpdateNotebookMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
        try writer["NotebookId"].write(value.notebookId)
    }
}

public struct UpdateNotebookMetadataInput {
    /// A unique case-sensitive string used to ensure the request to create the notebook is idempotent (executes only once). This token is listed as not required because Amazon Web Services SDKs (for example the Amazon Web Services SDK for Java) auto-generate the token for you. If you are not using the Amazon Web Services SDK or the Amazon Web Services CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The name to update the notebook to.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the notebook to update the metadata for.
    /// This member is required.
    public var notebookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        notebookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.notebookId = notebookId
    }
}

extension UpdateNotebookMetadataOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateNotebookMetadataOutput {
        return UpdateNotebookMetadataOutput()
    }
}

public struct UpdateNotebookMetadataOutput {

    public init() { }
}

enum UpdateNotebookMetadataOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateNotebookOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateNotebookOutput {
        return UpdateNotebookOutput()
    }
}

public struct UpdateNotebookOutput {

    public init() { }
}

enum UpdateNotebookOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdatePreparedStatementInput {

    static func urlPathProvider(_ value: UpdatePreparedStatementInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePreparedStatementInput {

    static func write(value: UpdatePreparedStatementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["QueryStatement"].write(value.queryStatement)
        try writer["StatementName"].write(value.statementName)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct UpdatePreparedStatementInput {
    /// The description of the prepared statement.
    public var description: Swift.String?
    /// The query string for the prepared statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The name of the prepared statement.
    /// This member is required.
    public var statementName: Swift.String?
    /// The workgroup for the prepared statement.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        description: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        statementName: Swift.String? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

extension UpdatePreparedStatementOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdatePreparedStatementOutput {
        return UpdatePreparedStatementOutput()
    }
}

public struct UpdatePreparedStatementOutput {

    public init() { }
}

enum UpdatePreparedStatementOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateWorkGroupInput {

    static func urlPathProvider(_ value: UpdateWorkGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkGroupInput {

    static func write(value: UpdateWorkGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationUpdates"].write(value.configurationUpdates, with: AthenaClientTypes.WorkGroupConfigurationUpdates.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["State"].write(value.state)
        try writer["WorkGroup"].write(value.workGroup)
    }
}

public struct UpdateWorkGroupInput {
    /// Contains configuration updates for an Athena SQL workgroup.
    public var configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates?
    /// The workgroup description.
    public var description: Swift.String?
    /// The workgroup state that will be updated for the given workgroup.
    public var state: AthenaClientTypes.WorkGroupState?
    /// The specified workgroup that will be updated.
    /// This member is required.
    public var workGroup: Swift.String?

    public init(
        configurationUpdates: AthenaClientTypes.WorkGroupConfigurationUpdates? = nil,
        description: Swift.String? = nil,
        state: AthenaClientTypes.WorkGroupState? = nil,
        workGroup: Swift.String? = nil
    )
    {
        self.configurationUpdates = configurationUpdates
        self.description = description
        self.state = state
        self.workGroup = workGroup
    }
}

extension UpdateWorkGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateWorkGroupOutput {
        return UpdateWorkGroupOutput()
    }
}

public struct UpdateWorkGroupOutput {

    public init() { }
}

enum UpdateWorkGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AthenaClientTypes.WorkGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.WorkGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.WorkGroup()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.configuration = try reader["Configuration"].readIfPresent(with: AthenaClientTypes.WorkGroupConfiguration.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.identityCenterApplicationArn = try reader["IdentityCenterApplicationArn"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// A workgroup, which contains a name, description, creation time, state, and other configuration, listed under [WorkGroup$Configuration]. Each workgroup enables you to isolate queries for you or your group of users from other queries in the same account, to configure the query results location and the encryption configuration (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and to establish per-query data usage control limits for all queries in a workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroup {
        /// The configuration of the workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption configuration, if any, used for query and calculation results; whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup settings override client-side settings; and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
        public var configuration: AthenaClientTypes.WorkGroupConfiguration?
        /// The date and time the workgroup was created.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The ARN of the IAM Identity Center enabled application associated with the workgroup.
        public var identityCenterApplicationArn: Swift.String?
        /// The workgroup name.
        /// This member is required.
        public var name: Swift.String?
        /// The state of the workgroup: ENABLED or DISABLED.
        public var state: AthenaClientTypes.WorkGroupState?

        public init(
            configuration: AthenaClientTypes.WorkGroupConfiguration? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            identityCenterApplicationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.configuration = configuration
            self.creationTime = creationTime
            self.description = description
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.name = name
            self.state = state
        }
    }

}

extension AthenaClientTypes.WorkGroupConfiguration {

    static func write(value: AthenaClientTypes.WorkGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalConfiguration"].write(value.additionalConfiguration)
        try writer["BytesScannedCutoffPerQuery"].write(value.bytesScannedCutoffPerQuery)
        try writer["CustomerContentEncryptionConfiguration"].write(value.customerContentEncryptionConfiguration, with: AthenaClientTypes.CustomerContentEncryptionConfiguration.write(value:to:))
        try writer["EnableMinimumEncryptionConfiguration"].write(value.enableMinimumEncryptionConfiguration)
        try writer["EnforceWorkGroupConfiguration"].write(value.enforceWorkGroupConfiguration)
        try writer["EngineVersion"].write(value.engineVersion, with: AthenaClientTypes.EngineVersion.write(value:to:))
        try writer["ExecutionRole"].write(value.executionRole)
        try writer["IdentityCenterConfiguration"].write(value.identityCenterConfiguration, with: AthenaClientTypes.IdentityCenterConfiguration.write(value:to:))
        try writer["PublishCloudWatchMetricsEnabled"].write(value.publishCloudWatchMetricsEnabled)
        try writer["QueryResultsS3AccessGrantsConfiguration"].write(value.queryResultsS3AccessGrantsConfiguration, with: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration.write(value:to:))
        try writer["RequesterPaysEnabled"].write(value.requesterPaysEnabled)
        try writer["ResultConfiguration"].write(value.resultConfiguration, with: AthenaClientTypes.ResultConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.WorkGroupConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.WorkGroupConfiguration()
        value.resultConfiguration = try reader["ResultConfiguration"].readIfPresent(with: AthenaClientTypes.ResultConfiguration.read(from:))
        value.enforceWorkGroupConfiguration = try reader["EnforceWorkGroupConfiguration"].readIfPresent()
        value.publishCloudWatchMetricsEnabled = try reader["PublishCloudWatchMetricsEnabled"].readIfPresent()
        value.bytesScannedCutoffPerQuery = try reader["BytesScannedCutoffPerQuery"].readIfPresent()
        value.requesterPaysEnabled = try reader["RequesterPaysEnabled"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent(with: AthenaClientTypes.EngineVersion.read(from:))
        value.additionalConfiguration = try reader["AdditionalConfiguration"].readIfPresent()
        value.executionRole = try reader["ExecutionRole"].readIfPresent()
        value.customerContentEncryptionConfiguration = try reader["CustomerContentEncryptionConfiguration"].readIfPresent(with: AthenaClientTypes.CustomerContentEncryptionConfiguration.read(from:))
        value.enableMinimumEncryptionConfiguration = try reader["EnableMinimumEncryptionConfiguration"].readIfPresent()
        value.identityCenterConfiguration = try reader["IdentityCenterConfiguration"].readIfPresent(with: AthenaClientTypes.IdentityCenterConfiguration.read(from:))
        value.queryResultsS3AccessGrantsConfiguration = try reader["QueryResultsS3AccessGrantsConfiguration"].readIfPresent(with: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration.read(from:))
        return value
    }
}

extension AthenaClientTypes {
    /// The configuration of the workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption option, if any, used for query and calculation results, whether the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup settings override query settings, and the data usage limits for the amount of data scanned per query or per workgroup. The workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See [WorkGroupConfiguration$EnforceWorkGroupConfiguration].
    public struct WorkGroupConfiguration {
        /// Specifies a user defined JSON string that is passed to the notebook engine.
        public var additionalConfiguration: Swift.String?
        /// The upper data usage limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the KMS key that is used to encrypt the user's data stores in Athena. This setting does not apply to Athena SQL workgroups.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// Enforces a minimal level of encryption for the workgroup for query and calculation results that are written to Amazon S3. When enabled, workgroup users can set encryption only to the minimum level set by the administrator or higher when they submit queries. The EnforceWorkGroupConfiguration setting takes precedence over the EnableMinimumEncryptionConfiguration flag. This means that if EnforceWorkGroupConfiguration is true, the EnableMinimumEncryptionConfiguration flag is ignored, and the workgroup configuration for encryption is used.
        public var enableMinimumEncryptionConfiguration: Swift.Bool?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false", client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version that all queries running on the workgroup use. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The ARN of the execution role used to access user resources for Spark sessions and IAM Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and IAM Identity Center enabled workgroups. The property is required for IAM Identity Center enabled workgroups.
        public var executionRole: Swift.String?
        /// Specifies whether the workgroup is IAM Identity Center supported.
        public var identityCenterConfiguration: AthenaClientTypes.IdentityCenterConfiguration?
        /// Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// Specifies whether Amazon S3 access grants are enabled for query results.
        public var queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration?
        /// If set to true, allows members assigned to a workgroup to reference Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The configuration for the workgroup, which includes the location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. To run the query, you must specify the query results location using one of the ways: either in the workgroup using this setting, or for individual queries (client-side), using [ResultConfiguration$OutputLocation]. If none of them is set, Athena issues an error that no output location is provided. For more information, see [Working with query results, recent queries, and output files](https://docs.aws.amazon.com/athena/latest/ug/querying.html).
        public var resultConfiguration: AthenaClientTypes.ResultConfiguration?

        public init(
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enableMinimumEncryptionConfiguration: Swift.Bool? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            identityCenterConfiguration: AthenaClientTypes.IdentityCenterConfiguration? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfiguration: AthenaClientTypes.ResultConfiguration? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.identityCenterConfiguration = identityCenterConfiguration
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.queryResultsS3AccessGrantsConfiguration = queryResultsS3AccessGrantsConfiguration
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfiguration = resultConfiguration
        }
    }

}

extension AthenaClientTypes.WorkGroupConfigurationUpdates {

    static func write(value: AthenaClientTypes.WorkGroupConfigurationUpdates?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalConfiguration"].write(value.additionalConfiguration)
        try writer["BytesScannedCutoffPerQuery"].write(value.bytesScannedCutoffPerQuery)
        try writer["CustomerContentEncryptionConfiguration"].write(value.customerContentEncryptionConfiguration, with: AthenaClientTypes.CustomerContentEncryptionConfiguration.write(value:to:))
        try writer["EnableMinimumEncryptionConfiguration"].write(value.enableMinimumEncryptionConfiguration)
        try writer["EnforceWorkGroupConfiguration"].write(value.enforceWorkGroupConfiguration)
        try writer["EngineVersion"].write(value.engineVersion, with: AthenaClientTypes.EngineVersion.write(value:to:))
        try writer["ExecutionRole"].write(value.executionRole)
        try writer["PublishCloudWatchMetricsEnabled"].write(value.publishCloudWatchMetricsEnabled)
        try writer["QueryResultsS3AccessGrantsConfiguration"].write(value.queryResultsS3AccessGrantsConfiguration, with: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration.write(value:to:))
        try writer["RemoveBytesScannedCutoffPerQuery"].write(value.removeBytesScannedCutoffPerQuery)
        try writer["RemoveCustomerContentEncryptionConfiguration"].write(value.removeCustomerContentEncryptionConfiguration)
        try writer["RequesterPaysEnabled"].write(value.requesterPaysEnabled)
        try writer["ResultConfigurationUpdates"].write(value.resultConfigurationUpdates, with: AthenaClientTypes.ResultConfigurationUpdates.write(value:to:))
    }
}

extension AthenaClientTypes {
    /// The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query and calculation results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified.
    public struct WorkGroupConfigurationUpdates {
        /// Contains a user defined string in JSON format for a Spark-enabled workgroup.
        public var additionalConfiguration: Swift.String?
        /// The upper limit (cutoff) for the amount of bytes a single query in a workgroup is allowed to scan.
        public var bytesScannedCutoffPerQuery: Swift.Int?
        /// Specifies the customer managed KMS key that is used to encrypt the user's data stores in Athena. When an Amazon Web Services managed key is used, this value is null. This setting does not apply to Athena SQL workgroups.
        public var customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration?
        /// Enforces a minimal level of encryption for the workgroup for query and calculation results that are written to Amazon S3. When enabled, workgroup users can set encryption only to the minimum level set by the administrator or higher when they submit queries. This setting does not apply to Spark-enabled workgroups. The EnforceWorkGroupConfiguration setting takes precedence over the EnableMinimumEncryptionConfiguration flag. This means that if EnforceWorkGroupConfiguration is true, the EnableMinimumEncryptionConfiguration flag is ignored, and the workgroup configuration for encryption is used.
        public var enableMinimumEncryptionConfiguration: Swift.Bool?
        /// If set to "true", the settings for the workgroup override client-side settings. If set to "false" client-side settings are used. For more information, see [Workgroup Settings Override Client-Side Settings](https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html).
        public var enforceWorkGroupConfiguration: Swift.Bool?
        /// The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The ARN of the execution role used to access user resources for Spark sessions and Identity Center enabled workgroups. This property applies only to Spark enabled workgroups and Identity Center enabled workgroups.
        public var executionRole: Swift.String?
        /// Indicates whether this workgroup enables publishing metrics to Amazon CloudWatch.
        public var publishCloudWatchMetricsEnabled: Swift.Bool?
        /// Specifies whether Amazon S3 access grants are enabled for query results.
        public var queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration?
        /// Indicates that the data usage control limit per query is removed. [WorkGroupConfiguration$BytesScannedCutoffPerQuery]
        public var removeBytesScannedCutoffPerQuery: Swift.Bool?
        /// Removes content encryption configuration from an Apache Spark-enabled Athena workgroup.
        public var removeCustomerContentEncryptionConfiguration: Swift.Bool?
        /// If set to true, allows members assigned to a workgroup to specify Amazon S3 Requester Pays buckets in queries. If set to false, workgroup members cannot query data from Requester Pays buckets, and queries that retrieve data from Requester Pays buckets cause an error. The default is false. For more information about Requester Pays buckets, see [Requester Pays Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html) in the Amazon Simple Storage Service Developer Guide.
        public var requesterPaysEnabled: Swift.Bool?
        /// The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results.
        public var resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates?

        public init(
            additionalConfiguration: Swift.String? = nil,
            bytesScannedCutoffPerQuery: Swift.Int? = nil,
            customerContentEncryptionConfiguration: AthenaClientTypes.CustomerContentEncryptionConfiguration? = nil,
            enableMinimumEncryptionConfiguration: Swift.Bool? = nil,
            enforceWorkGroupConfiguration: Swift.Bool? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            executionRole: Swift.String? = nil,
            publishCloudWatchMetricsEnabled: Swift.Bool? = nil,
            queryResultsS3AccessGrantsConfiguration: AthenaClientTypes.QueryResultsS3AccessGrantsConfiguration? = nil,
            removeBytesScannedCutoffPerQuery: Swift.Bool? = nil,
            removeCustomerContentEncryptionConfiguration: Swift.Bool? = nil,
            requesterPaysEnabled: Swift.Bool? = nil,
            resultConfigurationUpdates: AthenaClientTypes.ResultConfigurationUpdates? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
            self.customerContentEncryptionConfiguration = customerContentEncryptionConfiguration
            self.enableMinimumEncryptionConfiguration = enableMinimumEncryptionConfiguration
            self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
            self.engineVersion = engineVersion
            self.executionRole = executionRole
            self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
            self.queryResultsS3AccessGrantsConfiguration = queryResultsS3AccessGrantsConfiguration
            self.removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery
            self.removeCustomerContentEncryptionConfiguration = removeCustomerContentEncryptionConfiguration
            self.requesterPaysEnabled = requesterPaysEnabled
            self.resultConfigurationUpdates = resultConfigurationUpdates
        }
    }

}

extension AthenaClientTypes {

    public enum WorkGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AthenaClientTypes.WorkGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AthenaClientTypes.WorkGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AthenaClientTypes.WorkGroupSummary()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: .epochSeconds)
        value.engineVersion = try reader["EngineVersion"].readIfPresent(with: AthenaClientTypes.EngineVersion.read(from:))
        value.identityCenterApplicationArn = try reader["IdentityCenterApplicationArn"].readIfPresent()
        return value
    }
}

extension AthenaClientTypes {
    /// The summary information for the workgroup, which includes its name, state, description, and the date and time it was created.
    public struct WorkGroupSummary {
        /// The workgroup creation date and time.
        public var creationTime: ClientRuntime.Date?
        /// The workgroup description.
        public var description: Swift.String?
        /// The engine version setting for all queries on the workgroup. Queries on the AmazonAthenaPreviewFunctionality workgroup run on the preview engine regardless of this setting.
        public var engineVersion: AthenaClientTypes.EngineVersion?
        /// The ARN of the IAM Identity Center enabled application associated with the workgroup.
        public var identityCenterApplicationArn: Swift.String?
        /// The name of the workgroup.
        public var name: Swift.String?
        /// The state of the workgroup.
        public var state: AthenaClientTypes.WorkGroupState?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineVersion: AthenaClientTypes.EngineVersion? = nil,
            identityCenterApplicationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: AthenaClientTypes.WorkGroupState? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.engineVersion = engineVersion
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.name = name
            self.state = state
        }
    }

}
