// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddApplicationCloudWatchLoggingOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOption = self.cloudWatchLoggingOption {
            try encodeContainer.encode(cloudWatchLoggingOption, forKey: .cloudWatchLoggingOption)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension AddApplicationCloudWatchLoggingOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationCloudWatchLoggingOptionInput: Swift.Equatable {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Provides the CloudWatch log stream Amazon Resource Name (ARN) and the IAM role ARN. Note: To write application messages to CloudWatch, the IAM role that is used must have the PutLogEvents policy action enabled.
    /// This member is required.
    public var cloudWatchLoggingOption: KinesisAnalyticsClientTypes.CloudWatchLoggingOption?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOption: KinesisAnalyticsClientTypes.CloudWatchLoggingOption? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct AddApplicationCloudWatchLoggingOptionInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let cloudWatchLoggingOption: KinesisAnalyticsClientTypes.CloudWatchLoggingOption?
}

extension AddApplicationCloudWatchLoggingOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOption = "CloudWatchLoggingOption"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.CloudWatchLoggingOption.self, forKey: .cloudWatchLoggingOption)
        cloudWatchLoggingOption = cloudWatchLoggingOptionDecoded
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationCloudWatchLoggingOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddApplicationCloudWatchLoggingOptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddApplicationInputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let input = self.input {
            try encodeContainer.encode(input, forKey: .input)
        }
    }
}

extension AddApplicationInputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AddApplicationInputInput: Swift.Equatable {
    /// Name of your existing Amazon Kinesis Analytics application to which you want to add the streaming source.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Current version of your Amazon Kinesis Analytics application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to find the current application version.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The [Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_Input.html) to add.
    /// This member is required.
    public var input: KinesisAnalyticsClientTypes.Input?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        input: KinesisAnalyticsClientTypes.Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

struct AddApplicationInputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let input: KinesisAnalyticsClientTypes.Input?
}

extension AddApplicationInputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case input = "Input"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.Input.self, forKey: .input)
        input = inputDecoded
    }
}

extension AddApplicationInputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationInputOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct AddApplicationInputOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddApplicationInputProcessingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
    }
}

extension AddApplicationInputProcessingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AddApplicationInputProcessingConfigurationInput: Swift.Equatable {
    /// Name of the application to which you want to add the input processing configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application to which you want to add the input processing configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var inputId: Swift.String?
    /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) to add to the application.
    /// This member is required.
    public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

struct AddApplicationInputProcessingConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let inputId: Swift.String?
    let inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
}

extension AddApplicationInputProcessingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension AddApplicationInputProcessingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationInputProcessingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationInputProcessingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationInputProcessingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddApplicationInputProcessingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddApplicationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let output = self.output {
            try encodeContainer.encode(output, forKey: .output)
        }
    }
}

extension AddApplicationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AddApplicationOutputInput: Swift.Equatable {
    /// Name of the application to which you want to add the output configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application to which you want to add the output configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, an Amazon Kinesis stream, an Amazon Kinesis Firehose delivery stream, or an AWS Lambda function), and record the formation to use when writing to the destination.
    /// This member is required.
    public var output: KinesisAnalyticsClientTypes.Output?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        output: KinesisAnalyticsClientTypes.Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

struct AddApplicationOutputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let output: KinesisAnalyticsClientTypes.Output?
}

extension AddApplicationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case output = "Output"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension AddApplicationOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationOutputOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct AddApplicationOutputOutputResponse: Swift.Equatable {

    public init () { }
}

extension AddApplicationReferenceDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceDataSource = self.referenceDataSource {
            try encodeContainer.encode(referenceDataSource, forKey: .referenceDataSource)
        }
    }
}

extension AddApplicationReferenceDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct AddApplicationReferenceDataSourceInput: Swift.Equatable {
    /// Name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application for which you are adding the reference data source. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The reference data source can be an object in your Amazon S3 bucket. Amazon Kinesis Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting in-application table that is created. You must also provide an IAM role with the necessary permissions that Amazon Kinesis Analytics can assume to read the object from your S3 bucket on your behalf.
    /// This member is required.
    public var referenceDataSource: KinesisAnalyticsClientTypes.ReferenceDataSource?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceDataSource: KinesisAnalyticsClientTypes.ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

struct AddApplicationReferenceDataSourceInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let referenceDataSource: KinesisAnalyticsClientTypes.ReferenceDataSource?
}

extension AddApplicationReferenceDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceDataSource = "ReferenceDataSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceDataSourceDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ReferenceDataSource.self, forKey: .referenceDataSource)
        referenceDataSource = referenceDataSourceDecoded
    }
}

extension AddApplicationReferenceDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddApplicationReferenceDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddApplicationReferenceDataSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddApplicationReferenceDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct AddApplicationReferenceDataSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisAnalyticsClientTypes.ApplicationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
        case applicationVersionId = "ApplicationVersionId"
        case cloudWatchLoggingOptionDescriptions = "CloudWatchLoggingOptionDescriptions"
        case createTimestamp = "CreateTimestamp"
        case inputDescriptions = "InputDescriptions"
        case lastUpdateTimestamp = "LastUpdateTimestamp"
        case outputDescriptions = "OutputDescriptions"
        case referenceDataSourceDescriptions = "ReferenceDataSourceDescriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = self.applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationCode = self.applicationCode {
            try encodeContainer.encode(applicationCode, forKey: .applicationCode)
        }
        if let applicationDescription = self.applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let applicationVersionId = self.applicationVersionId {
            try encodeContainer.encode(applicationVersionId, forKey: .applicationVersionId)
        }
        if let cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions {
            var cloudWatchLoggingOptionDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionDescriptions)
            for cloudwatchloggingoptiondescription0 in cloudWatchLoggingOptionDescriptions {
                try cloudWatchLoggingOptionDescriptionsContainer.encode(cloudwatchloggingoptiondescription0)
            }
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
        if let inputDescriptions = inputDescriptions {
            var inputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputDescriptions)
            for inputdescription0 in inputDescriptions {
                try inputDescriptionsContainer.encode(inputdescription0)
            }
        }
        if let lastUpdateTimestamp = self.lastUpdateTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdateTimestamp, format: .epochSeconds, forKey: .lastUpdateTimestamp)
        }
        if let outputDescriptions = outputDescriptions {
            var outputDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputDescriptions)
            for outputdescription0 in outputDescriptions {
                try outputDescriptionsContainer.encode(outputdescription0)
            }
        }
        if let referenceDataSourceDescriptions = referenceDataSourceDescriptions {
            var referenceDataSourceDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceDescriptions)
            for referencedatasourcedescription0 in referenceDataSourceDescriptions {
                try referenceDataSourceDescriptionsContainer.encode(referencedatasourcedescription0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let lastUpdateTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTimestamp)
        lastUpdateTimestamp = lastUpdateTimestampDecoded
        let inputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.InputDescription?].self, forKey: .inputDescriptions)
        var inputDescriptionsDecoded0:[KinesisAnalyticsClientTypes.InputDescription]? = nil
        if let inputDescriptionsContainer = inputDescriptionsContainer {
            inputDescriptionsDecoded0 = [KinesisAnalyticsClientTypes.InputDescription]()
            for structure0 in inputDescriptionsContainer {
                if let structure0 = structure0 {
                    inputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        inputDescriptions = inputDescriptionsDecoded0
        let outputDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.OutputDescription?].self, forKey: .outputDescriptions)
        var outputDescriptionsDecoded0:[KinesisAnalyticsClientTypes.OutputDescription]? = nil
        if let outputDescriptionsContainer = outputDescriptionsContainer {
            outputDescriptionsDecoded0 = [KinesisAnalyticsClientTypes.OutputDescription]()
            for structure0 in outputDescriptionsContainer {
                if let structure0 = structure0 {
                    outputDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        outputDescriptions = outputDescriptionsDecoded0
        let referenceDataSourceDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.ReferenceDataSourceDescription?].self, forKey: .referenceDataSourceDescriptions)
        var referenceDataSourceDescriptionsDecoded0:[KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]? = nil
        if let referenceDataSourceDescriptionsContainer = referenceDataSourceDescriptionsContainer {
            referenceDataSourceDescriptionsDecoded0 = [KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]()
            for structure0 in referenceDataSourceDescriptionsContainer {
                if let structure0 = structure0 {
                    referenceDataSourceDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceDescriptions = referenceDataSourceDescriptionsDecoded0
        let cloudWatchLoggingOptionDescriptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription?].self, forKey: .cloudWatchLoggingOptionDescriptions)
        var cloudWatchLoggingOptionDescriptionsDecoded0:[KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]? = nil
        if let cloudWatchLoggingOptionDescriptionsContainer = cloudWatchLoggingOptionDescriptionsContainer {
            cloudWatchLoggingOptionDescriptionsDecoded0 = [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]()
            for structure0 in cloudWatchLoggingOptionDescriptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptionsDecoded0
        let applicationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationCode)
        applicationCode = applicationCodeDecoded
        let applicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationVersionId)
        applicationVersionId = applicationVersionIdDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see [Amazon Kinesis Data Analytics API V2 Documentation]. Provides a description of the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configuration.
    public struct ApplicationDetail: Swift.Equatable {
        /// ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Returns the application code that you provided to perform data analysis on any of the in-application streams in your application.
        public var applicationCode: Swift.String?
        /// Description of the application.
        public var applicationDescription: Swift.String?
        /// Name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// Status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus?
        /// Provides the current application version.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// Describes the CloudWatch log streams that are configured to receive application messages. For more information about using CloudWatch log streams with Amazon Kinesis Analytics applications, see [Working with Amazon CloudWatch Logs](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html).
        public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]?
        /// Time stamp when the application version was created.
        public var createTimestamp: ClientRuntime.Date?
        /// Describes the application input configuration. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var inputDescriptions: [KinesisAnalyticsClientTypes.InputDescription]?
        /// Time stamp when the application was last updated.
        public var lastUpdateTimestamp: ClientRuntime.Date?
        /// Describes the application output configuration. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        public var outputDescriptions: [KinesisAnalyticsClientTypes.OutputDescription]?
        /// Describes reference data sources configured for the application. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var referenceDataSourceDescriptions: [KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]?

        public init (
            applicationARN: Swift.String? = nil,
            applicationCode: Swift.String? = nil,
            applicationDescription: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil,
            cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]? = nil,
            createTimestamp: ClientRuntime.Date? = nil,
            inputDescriptions: [KinesisAnalyticsClientTypes.InputDescription]? = nil,
            lastUpdateTimestamp: ClientRuntime.Date? = nil,
            outputDescriptions: [KinesisAnalyticsClientTypes.OutputDescription]? = nil,
            referenceDataSourceDescriptions: [KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationCode = applicationCode
            self.applicationDescription = applicationDescription
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.createTimestamp = createTimestamp
            self.inputDescriptions = inputDescriptions
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }
    }

}

extension KinesisAnalyticsClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case ready
        case running
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .deleting,
                .ready,
                .running,
                .starting,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationARN = "ApplicationARN"
        case applicationName = "ApplicationName"
        case applicationStatus = "ApplicationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationARN = self.applicationARN {
            try encodeContainer.encode(applicationARN, forKey: .applicationARN)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationARN)
        applicationARN = applicationARNDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see [Amazon Kinesis Data Analytics API V2 Documentation]. Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.
    public struct ApplicationSummary: Swift.Equatable {
        /// ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// Status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus?

        public init (
            applicationARN: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
        }
    }

}

extension KinesisAnalyticsClientTypes.ApplicationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCodeUpdate = "ApplicationCodeUpdate"
        case cloudWatchLoggingOptionUpdates = "CloudWatchLoggingOptionUpdates"
        case inputUpdates = "InputUpdates"
        case outputUpdates = "OutputUpdates"
        case referenceDataSourceUpdates = "ReferenceDataSourceUpdates"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCodeUpdate = self.applicationCodeUpdate {
            try encodeContainer.encode(applicationCodeUpdate, forKey: .applicationCodeUpdate)
        }
        if let cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates {
            var cloudWatchLoggingOptionUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptionUpdates)
            for cloudwatchloggingoptionupdate0 in cloudWatchLoggingOptionUpdates {
                try cloudWatchLoggingOptionUpdatesContainer.encode(cloudwatchloggingoptionupdate0)
            }
        }
        if let inputUpdates = inputUpdates {
            var inputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputUpdates)
            for inputupdate0 in inputUpdates {
                try inputUpdatesContainer.encode(inputupdate0)
            }
        }
        if let outputUpdates = outputUpdates {
            var outputUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputUpdates)
            for outputupdate0 in outputUpdates {
                try outputUpdatesContainer.encode(outputupdate0)
            }
        }
        if let referenceDataSourceUpdates = referenceDataSourceUpdates {
            var referenceDataSourceUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceDataSourceUpdates)
            for referencedatasourceupdate0 in referenceDataSourceUpdates {
                try referenceDataSourceUpdatesContainer.encode(referencedatasourceupdate0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.InputUpdate?].self, forKey: .inputUpdates)
        var inputUpdatesDecoded0:[KinesisAnalyticsClientTypes.InputUpdate]? = nil
        if let inputUpdatesContainer = inputUpdatesContainer {
            inputUpdatesDecoded0 = [KinesisAnalyticsClientTypes.InputUpdate]()
            for structure0 in inputUpdatesContainer {
                if let structure0 = structure0 {
                    inputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        inputUpdates = inputUpdatesDecoded0
        let applicationCodeUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationCodeUpdate)
        applicationCodeUpdate = applicationCodeUpdateDecoded
        let outputUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.OutputUpdate?].self, forKey: .outputUpdates)
        var outputUpdatesDecoded0:[KinesisAnalyticsClientTypes.OutputUpdate]? = nil
        if let outputUpdatesContainer = outputUpdatesContainer {
            outputUpdatesDecoded0 = [KinesisAnalyticsClientTypes.OutputUpdate]()
            for structure0 in outputUpdatesContainer {
                if let structure0 = structure0 {
                    outputUpdatesDecoded0?.append(structure0)
                }
            }
        }
        outputUpdates = outputUpdatesDecoded0
        let referenceDataSourceUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate?].self, forKey: .referenceDataSourceUpdates)
        var referenceDataSourceUpdatesDecoded0:[KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]? = nil
        if let referenceDataSourceUpdatesContainer = referenceDataSourceUpdatesContainer {
            referenceDataSourceUpdatesDecoded0 = [KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]()
            for structure0 in referenceDataSourceUpdatesContainer {
                if let structure0 = structure0 {
                    referenceDataSourceUpdatesDecoded0?.append(structure0)
                }
            }
        }
        referenceDataSourceUpdates = referenceDataSourceUpdatesDecoded0
        let cloudWatchLoggingOptionUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate?].self, forKey: .cloudWatchLoggingOptionUpdates)
        var cloudWatchLoggingOptionUpdatesDecoded0:[KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]? = nil
        if let cloudWatchLoggingOptionUpdatesContainer = cloudWatchLoggingOptionUpdatesContainer {
            cloudWatchLoggingOptionUpdatesDecoded0 = [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]()
            for structure0 in cloudWatchLoggingOptionUpdatesContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionUpdatesDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdatesDecoded0
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to apply to an existing Amazon Kinesis Analytics application.
    public struct ApplicationUpdate: Swift.Equatable {
        /// Describes application code updates.
        public var applicationCodeUpdate: Swift.String?
        /// Describes application CloudWatch logging option updates.
        public var cloudWatchLoggingOptionUpdates: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]?
        /// Describes application input configuration updates.
        public var inputUpdates: [KinesisAnalyticsClientTypes.InputUpdate]?
        /// Describes application output configuration updates.
        public var outputUpdates: [KinesisAnalyticsClientTypes.OutputUpdate]?
        /// Describes application reference data source updates.
        public var referenceDataSourceUpdates: [KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]?

        public init (
            applicationCodeUpdate: Swift.String? = nil,
            cloudWatchLoggingOptionUpdates: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]? = nil,
            inputUpdates: [KinesisAnalyticsClientTypes.InputUpdate]? = nil,
            outputUpdates: [KinesisAnalyticsClientTypes.OutputUpdate]? = nil,
            referenceDataSourceUpdates: [KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]? = nil
        )
        {
            self.applicationCodeUpdate = applicationCodeUpdate
            self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }
    }

}

extension KinesisAnalyticsClientTypes.CSVMappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumnDelimiter = "RecordColumnDelimiter"
        case recordRowDelimiter = "RecordRowDelimiter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnDelimiter = self.recordColumnDelimiter {
            try encodeContainer.encode(recordColumnDelimiter, forKey: .recordColumnDelimiter)
        }
        if let recordRowDelimiter = self.recordRowDelimiter {
            try encodeContainer.encode(recordRowDelimiter, forKey: .recordRowDelimiter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordRowDelimiter)
        recordRowDelimiter = recordRowDelimiterDecoded
        let recordColumnDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordColumnDelimiter)
        recordColumnDelimiter = recordColumnDelimiterDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter: "name1", "address1"
    ///     "name2", "address2"
    public struct CSVMappingParameters: Swift.Equatable {
        /// Column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        /// This member is required.
        public var recordColumnDelimiter: Swift.String?
        /// Row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        /// This member is required.
        public var recordRowDelimiter: Swift.String?

        public init (
            recordColumnDelimiter: Swift.String? = nil,
            recordRowDelimiter: Swift.String? = nil
        )
        {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }
    }

}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logStreamARN = self.logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logStreamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of CloudWatch logging options, including the log stream Amazon Resource Name (ARN) and the role ARN.
    public struct CloudWatchLoggingOption: Swift.Equatable {
        /// ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role that is used must have the PutLogEvents policy action enabled.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARN = "LogStreamARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARN = self.logStreamARN {
            try encodeContainer.encode(logStreamARN, forKey: .logStreamARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARN)
        logStreamARN = logStreamARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Description of the CloudWatch logging option.
    public struct CloudWatchLoggingOptionDescription: Swift.Equatable {
        /// ID of the CloudWatch logging option description.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the PutLogEvents policy action enabled.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case logStreamARNUpdate = "LogStreamARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let logStreamARNUpdate = self.logStreamARNUpdate {
            try encodeContainer.encode(logStreamARNUpdate, forKey: .logStreamARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
        let logStreamARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamARNUpdate)
        logStreamARNUpdate = logStreamARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes CloudWatch logging option updates.
    public struct CloudWatchLoggingOptionUpdate: Swift.Equatable {
        /// ID of the CloudWatch logging option to update
        /// This member is required.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// ARN of the CloudWatch log to receive application messages.
        public var logStreamARNUpdate: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the PutLogEvents policy action enabled.
        public var roleARNUpdate: Swift.String?

        public init (
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension CodeValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CodeValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User-provided application code (query) is invalid. This can be a simple syntax error.
public struct CodeValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Test
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CodeValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CodeValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception thrown as a result of concurrent modification to an application. For example, two individuals attempting to edit the same application at the same time.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case inputs = "Inputs"
        case outputs = "Outputs"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCode = self.applicationCode {
            try encodeContainer.encode(applicationCode, forKey: .applicationCode)
        }
        if let applicationDescription = self.applicationDescription {
            try encodeContainer.encode(applicationDescription, forKey: .applicationDescription)
        }
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptions = cloudWatchLoggingOptions {
            var cloudWatchLoggingOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloudWatchLoggingOptions)
            for cloudwatchloggingoption0 in cloudWatchLoggingOptions {
                try cloudWatchLoggingOptionsContainer.encode(cloudwatchloggingoption0)
            }
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for input0 in inputs {
                try inputsContainer.encode(input0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for output0 in outputs {
                try outputsContainer.encode(output0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// TBD
public struct CreateApplicationInput: Swift.Equatable {
    /// One or more SQL statements that read input data, transform it, and generate output. For example, you can write a SQL statement that reads data from one in-application stream, generates a running average of the number of advertisement clicks by vendor, and insert resulting rows in another in-application stream using pumps. For more information about the typical pattern, see [Application Code](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-app-code.html). You can provide such series of SQL statements, where output of one statement can be used as the input for the next statement. You store intermediate results by creating in-application streams and pumps. Note that the application code must create the streams with names specified in the Outputs. For example, if your Outputs defines output streams named ExampleOutputStream1 and ExampleOutputStream2, then your application code must create these streams.
    public var applicationCode: Swift.String?
    /// Summary description of the application.
    public var applicationDescription: Swift.String?
    /// Name of your Amazon Kinesis Analytics application (for example, sample-app).
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use this parameter to configure a CloudWatch log stream to monitor application configuration errors. For more information, see [Working with Amazon CloudWatch Logs](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html).
    public var cloudWatchLoggingOptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]?
    /// Use this parameter to configure the application input. You can configure your application to receive input from a single streaming source. In this configuration, you map this streaming source to an in-application stream that is created. Your application code can then query the in-application stream like a table (you can think of it as a constantly updating table). For the streaming source, you provide its Amazon Resource Name (ARN) and format of data on the stream (for example, JSON, CSV, etc.). You also must provide an IAM role that Amazon Kinesis Analytics can assume to read this stream on your behalf. To create the in-application stream, you need to specify a schema to transform your data into a schematized version used in SQL. In the schema, you provide the necessary mapping of the data elements in the streaming source to record columns in the in-app stream.
    public var inputs: [KinesisAnalyticsClientTypes.Input]?
    /// You can configure application output to write data from any of the in-application streams to up to three destinations. These destinations can be Amazon Kinesis streams, Amazon Kinesis Firehose delivery streams, AWS Lambda destinations, or any combination of the three. In the configuration, you specify the in-application stream name, the destination stream or Lambda function Amazon Resource Name (ARN), and the format to use when writing data. You must also provide an IAM role that Amazon Kinesis Analytics can assume to write to the destination stream or Lambda function on your behalf. In the output configuration, you also provide the output stream or Lambda function ARN. For stream destinations, you provide the format of data in the stream (for example, JSON, CSV). You also must provide an IAM role that Amazon Kinesis Analytics can assume to write to the stream or Lambda function on your behalf.
    public var outputs: [KinesisAnalyticsClientTypes.Output]?
    /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html).
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init (
        applicationCode: Swift.String? = nil,
        applicationDescription: Swift.String? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]? = nil,
        inputs: [KinesisAnalyticsClientTypes.Input]? = nil,
        outputs: [KinesisAnalyticsClientTypes.Output]? = nil,
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.applicationCode = applicationCode
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.inputs = inputs
        self.outputs = outputs
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let applicationDescription: Swift.String?
    let inputs: [KinesisAnalyticsClientTypes.Input]?
    let outputs: [KinesisAnalyticsClientTypes.Output]?
    let cloudWatchLoggingOptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]?
    let applicationCode: Swift.String?
    let tags: [KinesisAnalyticsClientTypes.Tag]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCode = "ApplicationCode"
        case applicationDescription = "ApplicationDescription"
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptions = "CloudWatchLoggingOptions"
        case inputs = "Inputs"
        case outputs = "Outputs"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let applicationDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationDescription)
        applicationDescription = applicationDescriptionDecoded
        let inputsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.Input?].self, forKey: .inputs)
        var inputsDecoded0:[KinesisAnalyticsClientTypes.Input]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [KinesisAnalyticsClientTypes.Input]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[KinesisAnalyticsClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [KinesisAnalyticsClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let cloudWatchLoggingOptionsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.CloudWatchLoggingOption?].self, forKey: .cloudWatchLoggingOptions)
        var cloudWatchLoggingOptionsDecoded0:[KinesisAnalyticsClientTypes.CloudWatchLoggingOption]? = nil
        if let cloudWatchLoggingOptionsContainer = cloudWatchLoggingOptionsContainer {
            cloudWatchLoggingOptionsDecoded0 = [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]()
            for structure0 in cloudWatchLoggingOptionsContainer {
                if let structure0 = structure0 {
                    cloudWatchLoggingOptionsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchLoggingOptions = cloudWatchLoggingOptionsDecoded0
        let applicationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationCode)
        applicationCode = applicationCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummary = output.applicationSummary
        } else {
            self.applicationSummary = nil
        }
    }
}

/// TBD
public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// In response to your CreateApplication request, Amazon Kinesis Analytics returns a response with a summary of the application it created, including the application Amazon Resource Name (ARN), name, and status.
    /// This member is required.
    public var applicationSummary: KinesisAnalyticsClientTypes.ApplicationSummary?

    public init (
        applicationSummary: KinesisAnalyticsClientTypes.ApplicationSummary? = nil
    )
    {
        self.applicationSummary = applicationSummary
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let applicationSummary: KinesisAnalyticsClientTypes.ApplicationSummary?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSummary = "ApplicationSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummaryDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ApplicationSummary.self, forKey: .applicationSummary)
        applicationSummary = applicationSummaryDecoded
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cloudWatchLoggingOptionId = self.cloudWatchLoggingOptionId {
            try encodeContainer.encode(cloudWatchLoggingOptionId, forKey: .cloudWatchLoggingOptionId)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionInput: Swift.Equatable {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The CloudWatchLoggingOptionId of the CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var cloudWatchLoggingOptionId: Swift.String?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionId: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct DeleteApplicationCloudWatchLoggingOptionInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let cloudWatchLoggingOptionId: Swift.String?
}

extension DeleteApplicationCloudWatchLoggingOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cloudWatchLoggingOptionId = "CloudWatchLoggingOptionId"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let cloudWatchLoggingOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLoggingOptionId)
        cloudWatchLoggingOptionId = cloudWatchLoggingOptionIdDecoded
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationCloudWatchLoggingOptionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationCloudWatchLoggingOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let createTimestamp = self.createTimestamp {
            try encodeContainer.encodeTimestamp(createTimestamp, format: .epochSeconds, forKey: .createTimestamp)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteApplicationInput: Swift.Equatable {
    /// Name of the Amazon Kinesis Analytics application to delete.
    /// This member is required.
    public var applicationName: Swift.String?
    /// You can use the DescribeApplication operation to get this value.
    /// This member is required.
    public var createTimestamp: ClientRuntime.Date?

    public init (
        applicationName: Swift.String? = nil,
        createTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let createTimestamp: ClientRuntime.Date?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case createTimestamp = "CreateTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let createTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
    }
}

extension DeleteApplicationInputProcessingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInputProcessingConfigurationInput: Swift.Equatable {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var inputId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

struct DeleteApplicationInputProcessingConfigurationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let inputId: Swift.String?
}

extension DeleteApplicationInputProcessingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case inputId = "InputId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationInputProcessingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationInputProcessingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationInputProcessingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }
}

extension DeleteApplicationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DeleteApplicationOutputInput: Swift.Equatable {
    /// Amazon Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Amazon Kinesis Analytics application version. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the configuration to delete. Each output configuration that is added to the application, either when the application is created or later using the [AddApplicationOutput](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationOutput.html) operation, has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the specific OutputId.
    /// This member is required.
    public var outputId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        outputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

struct DeleteApplicationOutputInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let outputId: Swift.String?
}

extension DeleteApplicationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case outputId = "OutputId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
    }
}

extension DeleteApplicationOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct DeleteApplicationOutputOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteApplicationReferenceDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }
}

extension DeleteApplicationReferenceDataSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationReferenceDataSourceInput: Swift.Equatable {
    /// Name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// ID of the reference data source. When you add a reference data source to your application using the [AddApplicationReferenceDataSource](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html), Amazon Kinesis Analytics assigns an ID. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the reference ID.
    /// This member is required.
    public var referenceId: Swift.String?

    public init (
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

struct DeleteApplicationReferenceDataSourceInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let referenceId: Swift.String?
}

extension DeleteApplicationReferenceDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
        case referenceId = "ReferenceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension DeleteApplicationReferenceDataSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationReferenceDataSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationReferenceDataSourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationReferenceDataSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationReferenceDataSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

extension DescribeApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct DescribeApplicationInput: Swift.Equatable {
    /// Name of the application.
    /// This member is required.
    public var applicationName: Swift.String?

    public init (
        applicationName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

struct DescribeApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
}

extension DescribeApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
    }
}

extension DescribeApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationDetail = output.applicationDetail
        } else {
            self.applicationDetail = nil
        }
    }
}

///
public struct DescribeApplicationOutputResponse: Swift.Equatable {
    /// Provides a description of the application, such as the application Amazon Resource Name (ARN), status, latest version, and input and output configuration details.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsClientTypes.ApplicationDetail?

    public init (
        applicationDetail: KinesisAnalyticsClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

struct DescribeApplicationOutputResponseBody: Swift.Equatable {
    let applicationDetail: KinesisAnalyticsClientTypes.ApplicationDetail?
}

extension DescribeApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationDetail = "ApplicationDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDetailDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ApplicationDetail.self, forKey: .applicationDetail)
        applicationDetail = applicationDetailDecoded
    }
}

extension KinesisAnalyticsClientTypes.DestinationSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordFormatType = self.recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
    public struct DestinationSchema: Swift.Equatable {
        /// Specifies the format of the records on the output stream.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType?

        public init (
            recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType? = nil
        )
        {
            self.recordFormatType = recordFormatType
        }
    }

}

extension DiscoverInputSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
        case s3Configuration = "S3Configuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
    }
}

extension DiscoverInputSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DiscoverInputSchemaInput: Swift.Equatable {
    /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) to use to preprocess the records before discovering the schema of the records.
    public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
    /// Point at which you want Amazon Kinesis Analytics to start reading records from the specified streaming source discovery purposes.
    public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?
    /// Amazon Resource Name (ARN) of the streaming source.
    public var resourceARN: Swift.String?
    /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf.
    public var roleARN: Swift.String?
    /// Specify this parameter to discover a schema from data in an Amazon S3 object.
    public var s3Configuration: KinesisAnalyticsClientTypes.S3Configuration?

    public init (
        inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil,
        resourceARN: Swift.String? = nil,
        roleARN: Swift.String? = nil,
        s3Configuration: KinesisAnalyticsClientTypes.S3Configuration? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.roleARN = roleARN
        self.s3Configuration = s3Configuration
    }
}

struct DiscoverInputSchemaInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let roleARN: Swift.String?
    let inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?
    let s3Configuration: KinesisAnalyticsClientTypes.S3Configuration?
    let inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
}

extension DiscoverInputSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
        case s3Configuration = "S3Configuration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.S3Configuration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
    }
}

extension DiscoverInputSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DiscoverInputSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceProvisionedThroughputExceededException" : self = .resourceProvisionedThroughputExceededException(try ResourceProvisionedThroughputExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnableToDetectSchemaException" : self = .unableToDetectSchemaException(try UnableToDetectSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DiscoverInputSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidArgumentException(InvalidArgumentException)
    case resourceProvisionedThroughputExceededException(ResourceProvisionedThroughputExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unableToDetectSchemaException(UnableToDetectSchemaException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DiscoverInputSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DiscoverInputSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.inputSchema = output.inputSchema
            self.parsedInputRecords = output.parsedInputRecords
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.inputSchema = nil
            self.parsedInputRecords = nil
            self.processedInputRecords = nil
            self.rawInputRecords = nil
        }
    }
}

///
public struct DiscoverInputSchemaOutputResponse: Swift.Equatable {
    /// Schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
    public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
    /// An array of elements, where each element corresponds to a row in a stream record (a stream record can have more than one row).
    public var parsedInputRecords: [[Swift.String]]?
    /// Stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
    public var processedInputRecords: [Swift.String]?
    /// Raw stream data that was sampled to infer the schema.
    public var rawInputRecords: [Swift.String]?

    public init (
        inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
        parsedInputRecords: [[Swift.String]]? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct DiscoverInputSchemaOutputResponseBody: Swift.Equatable {
    let inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
    let parsedInputRecords: [[Swift.String]]?
    let processedInputRecords: [Swift.String]?
    let rawInputRecords: [Swift.String]?
}

extension DiscoverInputSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputSchema = "InputSchema"
        case parsedInputRecords = "ParsedInputRecords"
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let parsedInputRecordsContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .parsedInputRecords)
        var parsedInputRecordsDecoded0:[[Swift.String]]? = nil
        if let parsedInputRecordsContainer = parsedInputRecordsContainer {
            parsedInputRecordsDecoded0 = [[Swift.String]]()
            for list0 in parsedInputRecordsContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parsedInputRecordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parsedInputRecords = parsedInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[Swift.String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [Swift.String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[Swift.String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [Swift.String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
    }
}

extension KinesisAnalyticsClientTypes.Input: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputParallelism = "InputParallelism"
        case inputProcessingConfiguration = "InputProcessingConfiguration"
        case inputSchema = "InputSchema"
        case kinesisFirehoseInput = "KinesisFirehoseInput"
        case kinesisStreamsInput = "KinesisStreamsInput"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputParallelism = self.inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfiguration = self.inputProcessingConfiguration {
            try encodeContainer.encode(inputProcessingConfiguration, forKey: .inputProcessingConfiguration)
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let kinesisFirehoseInput = self.kinesisFirehoseInput {
            try encodeContainer.encode(kinesisFirehoseInput, forKey: .kinesisFirehoseInput)
        }
        if let kinesisStreamsInput = self.kinesisStreamsInput {
            try encodeContainer.encode(kinesisStreamsInput, forKey: .kinesisStreamsInput)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inputProcessingConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputProcessingConfiguration.self, forKey: .inputProcessingConfiguration)
        inputProcessingConfiguration = inputProcessingConfigurationDecoded
        let kinesisStreamsInputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsInput.self, forKey: .kinesisStreamsInput)
        kinesisStreamsInput = kinesisStreamsInputDecoded
        let kinesisFirehoseInputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseInput.self, forKey: .kinesisFirehoseInput)
        kinesisFirehoseInput = kinesisFirehoseInputDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When you configure the application input, you specify the streaming source, the in-application stream name that is created, and the mapping between the two. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct Input: Swift.Equatable {
        /// Describes the number of in-application streams to create. Data from your source is routed to these in-application input streams. (see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var inputParallelism: KinesisAnalyticsClientTypes.InputParallelism?
        /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html).
        public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        /// This member is required.
        public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// If the streaming source is an Amazon Kinesis Firehose delivery stream, identifies the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf. Note: Either KinesisStreamsInput or KinesisFirehoseInput is required.
        public var kinesisFirehoseInput: KinesisAnalyticsClientTypes.KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis stream, identifies the stream's Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf. Note: Either KinesisStreamsInput or KinesisFirehoseInput is required.
        public var kinesisStreamsInput: KinesisAnalyticsClientTypes.KinesisStreamsInput?
        /// Name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Amazon Kinesis Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        /// This member is required.
        public var namePrefix: Swift.String?

        public init (
            inputParallelism: KinesisAnalyticsClientTypes.InputParallelism? = nil,
            inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil,
            inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            kinesisFirehoseInput: KinesisAnalyticsClientTypes.KinesisFirehoseInput? = nil,
            kinesisStreamsInput: KinesisAnalyticsClientTypes.KinesisStreamsInput? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }
    }

}

extension KinesisAnalyticsClientTypes.InputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When you start your application, you provide this configuration, which identifies the input source and the point in the input source at which you want the application to start processing records.
    public struct InputConfiguration: Swift.Equatable {
        /// Input source ID. You can get this ID by calling the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
        /// This member is required.
        public var id: Swift.String?
        /// Point at which you want the application to start processing records from the streaming source.
        /// This member is required.
        public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?

        public init (
            id: Swift.String? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil
        )
        {
            self.id = id
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }
    }

}

extension KinesisAnalyticsClientTypes.InputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inAppStreamNames = "InAppStreamNames"
        case inputId = "InputId"
        case inputParallelism = "InputParallelism"
        case inputProcessingConfigurationDescription = "InputProcessingConfigurationDescription"
        case inputSchema = "InputSchema"
        case inputStartingPositionConfiguration = "InputStartingPositionConfiguration"
        case kinesisFirehoseInputDescription = "KinesisFirehoseInputDescription"
        case kinesisStreamsInputDescription = "KinesisStreamsInputDescription"
        case namePrefix = "NamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inAppStreamNames = inAppStreamNames {
            var inAppStreamNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inAppStreamNames)
            for inappstreamname0 in inAppStreamNames {
                try inAppStreamNamesContainer.encode(inappstreamname0)
            }
        }
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelism = self.inputParallelism {
            try encodeContainer.encode(inputParallelism, forKey: .inputParallelism)
        }
        if let inputProcessingConfigurationDescription = self.inputProcessingConfigurationDescription {
            try encodeContainer.encode(inputProcessingConfigurationDescription, forKey: .inputProcessingConfigurationDescription)
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let inputStartingPositionConfiguration = self.inputStartingPositionConfiguration {
            try encodeContainer.encode(inputStartingPositionConfiguration, forKey: .inputStartingPositionConfiguration)
        }
        if let kinesisFirehoseInputDescription = self.kinesisFirehoseInputDescription {
            try encodeContainer.encode(kinesisFirehoseInputDescription, forKey: .kinesisFirehoseInputDescription)
        }
        if let kinesisStreamsInputDescription = self.kinesisStreamsInputDescription {
            try encodeContainer.encode(kinesisStreamsInputDescription, forKey: .kinesisStreamsInputDescription)
        }
        if let namePrefix = self.namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let inAppStreamNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inAppStreamNames)
        var inAppStreamNamesDecoded0:[Swift.String]? = nil
        if let inAppStreamNamesContainer = inAppStreamNamesContainer {
            inAppStreamNamesDecoded0 = [Swift.String]()
            for string0 in inAppStreamNamesContainer {
                if let string0 = string0 {
                    inAppStreamNamesDecoded0?.append(string0)
                }
            }
        }
        inAppStreamNames = inAppStreamNamesDecoded0
        let inputProcessingConfigurationDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription.self, forKey: .inputProcessingConfigurationDescription)
        inputProcessingConfigurationDescription = inputProcessingConfigurationDescriptionDecoded
        let kinesisStreamsInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsInputDescription.self, forKey: .kinesisStreamsInputDescription)
        kinesisStreamsInputDescription = kinesisStreamsInputDescriptionDecoded
        let kinesisFirehoseInputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription.self, forKey: .kinesisFirehoseInputDescription)
        kinesisFirehoseInputDescription = kinesisFirehoseInputDescriptionDecoded
        let inputSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let inputParallelismDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputParallelism.self, forKey: .inputParallelism)
        inputParallelism = inputParallelismDecoded
        let inputStartingPositionConfigurationDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.self, forKey: .inputStartingPositionConfiguration)
        inputStartingPositionConfiguration = inputStartingPositionConfigurationDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the application input configuration. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct InputDescription: Swift.Equatable {
        /// Returns the in-application stream names that are mapped to the stream source.
        public var inAppStreamNames: [Swift.String]?
        /// Input ID associated with the application input. This is the ID that Amazon Kinesis Analytics assigns to each input configuration you add to your application.
        public var inputId: Swift.String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public var inputParallelism: KinesisAnalyticsClientTypes.InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public var inputProcessingConfigurationDescription: KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Point at which the application is configured to read from the input stream.
        public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?
        /// If an Amazon Kinesis Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf.
        public var kinesisFirehoseInputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription?
        /// If an Amazon Kinesis stream is configured as streaming source, provides Amazon Kinesis stream's Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf.
        public var kinesisStreamsInputDescription: KinesisAnalyticsClientTypes.KinesisStreamsInputDescription?
        /// In-application name prefix.
        public var namePrefix: Swift.String?

        public init (
            inAppStreamNames: [Swift.String]? = nil,
            inputId: Swift.String? = nil,
            inputParallelism: KinesisAnalyticsClientTypes.InputParallelism? = nil,
            inputProcessingConfigurationDescription: KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription? = nil,
            inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil,
            kinesisFirehoseInputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription? = nil,
            kinesisStreamsInputDescription: KinesisAnalyticsClientTypes.KinesisStreamsInputDescription? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }
    }

}

extension KinesisAnalyticsClientTypes.InputLambdaProcessor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess records in the stream, and the ARN of the IAM role that is used to access the AWS Lambda function.
    public struct InputLambdaProcessor: Swift.Equatable {
        /// The ARN of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that operates on records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the AWS Lambda function.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.InputLambdaProcessorDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess records in the stream, and the ARN of the IAM role that is used to access the AWS Lambda expression.
    public struct InputLambdaProcessorDescription: Swift.Equatable {
        /// The ARN of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess the records in the stream.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the AWS Lambda function.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Represents an update to the [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream.
    public struct InputLambdaProcessorUpdate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the new [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        public var resourceARNUpdate: Swift.String?
        /// The ARN of the new IAM role that is used to access the AWS Lambda function.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.InputParallelism: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the number of in-application streams to create for a given streaming source. For information about parallelism, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct InputParallelism: Swift.Equatable {
        /// Number of in-application streams to create. For more information, see [Limits](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html).
        public var count: Swift.Int?

        public init (
            count: Swift.Int? = nil
        )
        {
            self.count = count
        }
    }

}

extension KinesisAnalyticsClientTypes.InputParallelismUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countUpdate = "CountUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countUpdate = self.countUpdate {
            try encodeContainer.encode(countUpdate, forKey: .countUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countUpdateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .countUpdate)
        countUpdate = countUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides updates to the parallelism count.
    public struct InputParallelismUpdate: Swift.Equatable {
        /// Number of in-application streams to create for the specified streaming source.
        public var countUpdate: Swift.Int?

        public init (
            countUpdate: Swift.Int? = nil
        )
        {
            self.countUpdate = countUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.InputProcessingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessor = "InputLambdaProcessor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessor = self.inputLambdaProcessor {
            try encodeContainer.encode(inputLambdaProcessor, forKey: .inputLambdaProcessor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputLambdaProcessor.self, forKey: .inputLambdaProcessor)
        inputLambdaProcessor = inputLambdaProcessorDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is [AWS Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfiguration: Swift.Equatable {
        /// The [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream before being processed by your application code.
        /// This member is required.
        public var inputLambdaProcessor: KinesisAnalyticsClientTypes.InputLambdaProcessor?

        public init (
            inputLambdaProcessor: KinesisAnalyticsClientTypes.InputLambdaProcessor? = nil
        )
        {
            self.inputLambdaProcessor = inputLambdaProcessor
        }
    }

}

extension KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessorDescription = "InputLambdaProcessorDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorDescription = self.inputLambdaProcessorDescription {
            try encodeContainer.encode(inputLambdaProcessorDescription, forKey: .inputLambdaProcessorDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputLambdaProcessorDescription.self, forKey: .inputLambdaProcessorDescription)
        inputLambdaProcessorDescription = inputLambdaProcessorDescriptionDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides configuration information about an input processor. Currently, the only input processor available is [AWS Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfigurationDescription: Swift.Equatable {
        /// Provides configuration information about the associated [InputLambdaProcessorDescription](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessorDescription.html).
        public var inputLambdaProcessorDescription: KinesisAnalyticsClientTypes.InputLambdaProcessorDescription?

        public init (
            inputLambdaProcessorDescription: KinesisAnalyticsClientTypes.InputLambdaProcessorDescription? = nil
        )
        {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }
    }

}

extension KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLambdaProcessorUpdate = "InputLambdaProcessorUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLambdaProcessorUpdate = self.inputLambdaProcessorUpdate {
            try encodeContainer.encode(inputLambdaProcessorUpdate, forKey: .inputLambdaProcessorUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputLambdaProcessorUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate.self, forKey: .inputLambdaProcessorUpdate)
        inputLambdaProcessorUpdate = inputLambdaProcessorUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to an [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html).
    public struct InputProcessingConfigurationUpdate: Swift.Equatable {
        /// Provides update information for an [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html).
        /// This member is required.
        public var inputLambdaProcessorUpdate: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate?

        public init (
            inputLambdaProcessorUpdate: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate? = nil
        )
        {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.InputSchemaUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumnUpdates = "RecordColumnUpdates"
        case recordEncodingUpdate = "RecordEncodingUpdate"
        case recordFormatUpdate = "RecordFormatUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumnUpdates = recordColumnUpdates {
            var recordColumnUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumnUpdates)
            for recordcolumn0 in recordColumnUpdates {
                try recordColumnUpdatesContainer.encode(recordcolumn0)
            }
        }
        if let recordEncodingUpdate = self.recordEncodingUpdate {
            try encodeContainer.encode(recordEncodingUpdate, forKey: .recordEncodingUpdate)
        }
        if let recordFormatUpdate = self.recordFormatUpdate {
            try encodeContainer.encode(recordFormatUpdate, forKey: .recordFormatUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.RecordFormat.self, forKey: .recordFormatUpdate)
        recordFormatUpdate = recordFormatUpdateDecoded
        let recordEncodingUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordEncodingUpdate)
        recordEncodingUpdate = recordEncodingUpdateDecoded
        let recordColumnUpdatesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.RecordColumn?].self, forKey: .recordColumnUpdates)
        var recordColumnUpdatesDecoded0:[KinesisAnalyticsClientTypes.RecordColumn]? = nil
        if let recordColumnUpdatesContainer = recordColumnUpdatesContainer {
            recordColumnUpdatesDecoded0 = [KinesisAnalyticsClientTypes.RecordColumn]()
            for structure0 in recordColumnUpdatesContainer {
                if let structure0 = structure0 {
                    recordColumnUpdatesDecoded0?.append(structure0)
                }
            }
        }
        recordColumnUpdates = recordColumnUpdatesDecoded0
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes updates for the application's input schema.
    public struct InputSchemaUpdate: Swift.Equatable {
        /// A list of RecordColumn objects. Each object describes the mapping of the streaming source element to the corresponding column in the in-application stream.
        public var recordColumnUpdates: [KinesisAnalyticsClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncodingUpdate: Swift.String?
        /// Specifies the format of the records on the streaming source.
        public var recordFormatUpdate: KinesisAnalyticsClientTypes.RecordFormat?

        public init (
            recordColumnUpdates: [KinesisAnalyticsClientTypes.RecordColumn]? = nil,
            recordEncodingUpdate: Swift.String? = nil,
            recordFormatUpdate: KinesisAnalyticsClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    public enum InputStartingPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lastStoppedPoint
        case now
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStartingPosition] {
            return [
                .lastStoppedPoint,
                .now,
                .trimHorizon,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lastStoppedPoint: return "LAST_STOPPED_POINT"
            case .now: return "NOW"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputStartingPosition(rawValue: rawValue) ?? InputStartingPosition.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsClientTypes.InputStartingPositionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStartingPosition = "InputStartingPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStartingPosition = self.inputStartingPosition {
            try encodeContainer.encode(inputStartingPosition.rawValue, forKey: .inputStartingPosition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStartingPositionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputStartingPosition.self, forKey: .inputStartingPosition)
        inputStartingPosition = inputStartingPositionDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the point at which the application reads from the streaming source.
    public struct InputStartingPositionConfiguration: Swift.Equatable {
        /// The starting position on the stream.
        ///
        /// * NOW - Start reading just after the most recent record in the stream, start at the request time stamp that the customer issued.
        ///
        /// * TRIM_HORIZON - Start reading at the last untrimmed record in the stream, which is the oldest record available in the stream. This option is not available for an Amazon Kinesis Firehose delivery stream.
        ///
        /// * LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public var inputStartingPosition: KinesisAnalyticsClientTypes.InputStartingPosition?

        public init (
            inputStartingPosition: KinesisAnalyticsClientTypes.InputStartingPosition? = nil
        )
        {
            self.inputStartingPosition = inputStartingPosition
        }
    }

}

extension KinesisAnalyticsClientTypes.InputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputId = "InputId"
        case inputParallelismUpdate = "InputParallelismUpdate"
        case inputProcessingConfigurationUpdate = "InputProcessingConfigurationUpdate"
        case inputSchemaUpdate = "InputSchemaUpdate"
        case kinesisFirehoseInputUpdate = "KinesisFirehoseInputUpdate"
        case kinesisStreamsInputUpdate = "KinesisStreamsInputUpdate"
        case namePrefixUpdate = "NamePrefixUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputId = self.inputId {
            try encodeContainer.encode(inputId, forKey: .inputId)
        }
        if let inputParallelismUpdate = self.inputParallelismUpdate {
            try encodeContainer.encode(inputParallelismUpdate, forKey: .inputParallelismUpdate)
        }
        if let inputProcessingConfigurationUpdate = self.inputProcessingConfigurationUpdate {
            try encodeContainer.encode(inputProcessingConfigurationUpdate, forKey: .inputProcessingConfigurationUpdate)
        }
        if let inputSchemaUpdate = self.inputSchemaUpdate {
            try encodeContainer.encode(inputSchemaUpdate, forKey: .inputSchemaUpdate)
        }
        if let kinesisFirehoseInputUpdate = self.kinesisFirehoseInputUpdate {
            try encodeContainer.encode(kinesisFirehoseInputUpdate, forKey: .kinesisFirehoseInputUpdate)
        }
        if let kinesisStreamsInputUpdate = self.kinesisStreamsInputUpdate {
            try encodeContainer.encode(kinesisStreamsInputUpdate, forKey: .kinesisStreamsInputUpdate)
        }
        if let namePrefixUpdate = self.namePrefixUpdate {
            try encodeContainer.encode(namePrefixUpdate, forKey: .namePrefixUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputId)
        inputId = inputIdDecoded
        let namePrefixUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namePrefixUpdate)
        namePrefixUpdate = namePrefixUpdateDecoded
        let inputProcessingConfigurationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate.self, forKey: .inputProcessingConfigurationUpdate)
        inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdateDecoded
        let kinesisStreamsInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate.self, forKey: .kinesisStreamsInputUpdate)
        kinesisStreamsInputUpdate = kinesisStreamsInputUpdateDecoded
        let kinesisFirehoseInputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate.self, forKey: .kinesisFirehoseInputUpdate)
        kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdateDecoded
        let inputSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputSchemaUpdate.self, forKey: .inputSchemaUpdate)
        inputSchemaUpdate = inputSchemaUpdateDecoded
        let inputParallelismUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.InputParallelismUpdate.self, forKey: .inputParallelismUpdate)
        inputParallelismUpdate = inputParallelismUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to a specific input configuration (identified by the InputId of an application).
    public struct InputUpdate: Swift.Equatable {
        /// Input ID of the application input to be updated.
        /// This member is required.
        public var inputId: Swift.String?
        /// Describes the parallelism updates (the number in-application streams Amazon Kinesis Analytics creates for the specific streaming source).
        public var inputParallelismUpdate: KinesisAnalyticsClientTypes.InputParallelismUpdate?
        /// Describes updates for an input processing configuration.
        public var inputProcessingConfigurationUpdate: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and how record elements on the streaming source map to columns of the in-application stream that is created.
        public var inputSchemaUpdate: KinesisAnalyticsClientTypes.InputSchemaUpdate?
        /// If an Amazon Kinesis Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN and IAM role ARN.
        public var kinesisFirehoseInputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate?
        /// If an Amazon Kinesis stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN) and IAM role ARN.
        public var kinesisStreamsInputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate?
        /// Name prefix for in-application streams that Amazon Kinesis Analytics creates for the specific streaming source.
        public var namePrefixUpdate: Swift.String?

        public init (
            inputId: Swift.String? = nil,
            inputParallelismUpdate: KinesisAnalyticsClientTypes.InputParallelismUpdate? = nil,
            inputProcessingConfigurationUpdate: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate? = nil,
            inputSchemaUpdate: KinesisAnalyticsClientTypes.InputSchemaUpdate? = nil,
            kinesisFirehoseInputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate? = nil,
            kinesisStreamsInputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate? = nil,
            namePrefixUpdate: Swift.String? = nil
        )
        {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }
    }

}

extension InvalidApplicationConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidApplicationConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User-provided application configuration is not valid.
public struct InvalidApplicationConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// test
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApplicationConfigurationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidApplicationConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Specified input parameter value is invalid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsClientTypes.JSONMappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordRowPath = "RecordRowPath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordRowPath = self.recordRowPath {
            try encodeContainer.encode(recordRowPath, forKey: .recordRowPath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordRowPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordRowPath)
        recordRowPath = recordRowPathDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    public struct JSONMappingParameters: Swift.Equatable {
        /// Path to the top-level parent that contains the records.
        /// This member is required.
        public var recordRowPath: Swift.String?

        public init (
            recordRowPath: Swift.String? = nil
        )
        {
            self.recordRowPath = recordRowPath
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Identifies an Amazon Kinesis Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN) and an IAM role ARN that enables Amazon Kinesis Analytics to access the stream on your behalf.
    public struct KinesisFirehoseInput: Swift.Equatable {
        /// ARN of the input delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to make sure that the role has the necessary permissions to access the stream.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the Amazon Kinesis Firehose delivery stream that is configured as the streaming source in the application input configuration.
    public struct KinesisFirehoseInputDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics assumes to access the stream.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When updating application input configuration, provides information about an Amazon Kinesis Firehose delivery stream as the streaming source.
    public struct KinesisFirehoseInputUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the input Amazon Kinesis Firehose delivery stream to read.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an Amazon Kinesis Firehose delivery stream as the destination. You provide the stream Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to write to the stream on your behalf.
    public struct KinesisFirehoseOutput: Swift.Equatable {
        /// ARN of the destination Amazon Kinesis Firehose delivery stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the Amazon Kinesis Firehose delivery stream configured as its destination.
    public struct KinesisFirehoseOutputDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an Amazon Kinesis Firehose delivery stream configured as the destination.
    public struct KinesisFirehoseOutputUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream to write to.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Identifies an Amazon Kinesis stream as the streaming source. You provide the stream's Amazon Resource Name (ARN) and an IAM role ARN that enables Amazon Kinesis Analytics to access the stream on your behalf.
    public struct KinesisStreamsInput: Swift.Equatable {
        /// ARN of the input Amazon Kinesis stream to read.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsInputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the Amazon Kinesis stream that is configured as the streaming source in the application input configuration.
    public struct KinesisStreamsInputDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When updating application input configuration, provides information about an Amazon Kinesis stream as the streaming source.
    public struct KinesisStreamsInputUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the input Amazon Kinesis stream to read.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an Amazon Kinesis stream as the destination. You provide the stream Amazon Resource Name (ARN) and also an IAM role ARN that Amazon Kinesis Analytics can use to write to the stream on your behalf.
    public struct KinesisStreamsOutput: Swift.Equatable {
        /// ARN of the destination Amazon Kinesis stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the Amazon Kinesis stream configured as its destination.
    public struct KinesisStreamsOutputDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an Amazon Kinesis stream configured as the destination.
    public struct KinesisStreamsOutputUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream where you want to write the output.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes.LambdaOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an AWS Lambda function as the destination. You provide the function Amazon Resource Name (ARN) and also an IAM role ARN that Amazon Kinesis Analytics can use to write to the function on your behalf.
    public struct LambdaOutput: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the destination Lambda function to write to. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.LambdaOutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the AWS Lambda function configured as its destination.
    public struct LambdaOutputDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the destination Lambda function.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function.
        public var roleARN: Swift.String?

        public init (
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.LambdaOutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARNUpdate = "ResourceARNUpdate"
        case roleARNUpdate = "RoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARNUpdate = self.resourceARNUpdate {
            try encodeContainer.encode(resourceARNUpdate, forKey: .resourceARNUpdate)
        }
        if let roleARNUpdate = self.roleARNUpdate {
            try encodeContainer.encode(roleARNUpdate, forKey: .roleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARNUpdate)
        resourceARNUpdate = resourceARNUpdateDecoded
        let roleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARNUpdate)
        roleARNUpdate = roleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an AWS Lambda function configured as the destination.
    public struct LambdaOutputUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the destination Lambda function. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init (
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exceeded the number of applications allowed.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartApplicationName = "ExclusiveStartApplicationName"
        case limit = "Limit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveStartApplicationName = self.exclusiveStartApplicationName {
            try encodeContainer.encode(exclusiveStartApplicationName, forKey: .exclusiveStartApplicationName)
        }
        if let limit = self.limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct ListApplicationsInput: Swift.Equatable {
    /// Name of the application to start the list with. When using pagination to retrieve the list, you don't need to specify this parameter in the first request. However, in subsequent requests, you add the last application name from the previous response to get the next page of applications.
    public var exclusiveStartApplicationName: Swift.String?
    /// Maximum number of applications to list.
    public var limit: Swift.Int?

    public init (
        exclusiveStartApplicationName: Swift.String? = nil,
        limit: Swift.Int? = nil
    )
    {
        self.exclusiveStartApplicationName = exclusiveStartApplicationName
        self.limit = limit
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let limit: Swift.Int?
    let exclusiveStartApplicationName: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveStartApplicationName = "ExclusiveStartApplicationName"
        case limit = "Limit"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let exclusiveStartApplicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveStartApplicationName)
        exclusiveStartApplicationName = exclusiveStartApplicationNameDecoded
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationSummaries = output.applicationSummaries
            self.hasMoreApplications = output.hasMoreApplications
        } else {
            self.applicationSummaries = nil
            self.hasMoreApplications = nil
        }
    }
}

///
public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// List of ApplicationSummary objects.
    /// This member is required.
    public var applicationSummaries: [KinesisAnalyticsClientTypes.ApplicationSummary]?
    /// Returns true if there are more applications to retrieve.
    /// This member is required.
    public var hasMoreApplications: Swift.Bool?

    public init (
        applicationSummaries: [KinesisAnalyticsClientTypes.ApplicationSummary]? = nil,
        hasMoreApplications: Swift.Bool? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.hasMoreApplications = hasMoreApplications
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let applicationSummaries: [KinesisAnalyticsClientTypes.ApplicationSummary]?
    let hasMoreApplications: Swift.Bool?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSummaries = "ApplicationSummaries"
        case hasMoreApplications = "HasMoreApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSummariesContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.ApplicationSummary?].self, forKey: .applicationSummaries)
        var applicationSummariesDecoded0:[KinesisAnalyticsClientTypes.ApplicationSummary]? = nil
        if let applicationSummariesContainer = applicationSummariesContainer {
            applicationSummariesDecoded0 = [KinesisAnalyticsClientTypes.ApplicationSummary]()
            for structure0 in applicationSummariesContainer {
                if let structure0 = structure0 {
                    applicationSummariesDecoded0?.append(structure0)
                }
            }
        }
        applicationSummaries = applicationSummariesDecoded0
        let hasMoreApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreApplications)
        hasMoreApplications = hasMoreApplicationsDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the application for which to retrieve tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The key-value tags assigned to the application.
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init (
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [KinesisAnalyticsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension KinesisAnalyticsClientTypes.MappingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvMappingParameters = "CSVMappingParameters"
        case jsonMappingParameters = "JSONMappingParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvMappingParameters = self.csvMappingParameters {
            try encodeContainer.encode(csvMappingParameters, forKey: .csvMappingParameters)
        }
        if let jsonMappingParameters = self.jsonMappingParameters {
            try encodeContainer.encode(jsonMappingParameters, forKey: .jsonMappingParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonMappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.JSONMappingParameters.self, forKey: .jsonMappingParameters)
        jsonMappingParameters = jsonMappingParametersDecoded
        let csvMappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.CSVMappingParameters.self, forKey: .csvMappingParameters)
        csvMappingParameters = csvMappingParametersDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When configuring application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    public struct MappingParameters: Swift.Equatable {
        /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
        public var csvMappingParameters: KinesisAnalyticsClientTypes.CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public var jsonMappingParameters: KinesisAnalyticsClientTypes.JSONMappingParameters?

        public init (
            csvMappingParameters: KinesisAnalyticsClientTypes.CSVMappingParameters? = nil,
            jsonMappingParameters: KinesisAnalyticsClientTypes.JSONMappingParameters? = nil
        )
        {
            self.csvMappingParameters = csvMappingParameters
            self.jsonMappingParameters = jsonMappingParameters
        }
    }

}

extension KinesisAnalyticsClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutput = "KinesisFirehoseOutput"
        case kinesisStreamsOutput = "KinesisStreamsOutput"
        case lambdaOutput = "LambdaOutput"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = self.destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutput = self.kinesisFirehoseOutput {
            try encodeContainer.encode(kinesisFirehoseOutput, forKey: .kinesisFirehoseOutput)
        }
        if let kinesisStreamsOutput = self.kinesisStreamsOutput {
            try encodeContainer.encode(kinesisStreamsOutput, forKey: .kinesisStreamsOutput)
        }
        if let lambdaOutput = self.lambdaOutput {
            try encodeContainer.encode(lambdaOutput, forKey: .lambdaOutput)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsOutput.self, forKey: .kinesisStreamsOutput)
        kinesisStreamsOutput = kinesisStreamsOutputDecoded
        let kinesisFirehoseOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseOutput.self, forKey: .kinesisFirehoseOutput)
        kinesisFirehoseOutput = kinesisFirehoseOutputDecoded
        let lambdaOutputDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.LambdaOutput.self, forKey: .lambdaOutput)
        lambdaOutput = lambdaOutputDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes application output configuration in which you identify an in-application stream and a destination where you want the in-application stream data to be written. The destination can be an Amazon Kinesis stream or an Amazon Kinesis Firehose delivery stream. For limits on how many destinations an application can write and other limitations, see [Limits](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html).
    public struct Output: Swift.Equatable {
        /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        /// This member is required.
        public var destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Identifies an Amazon Kinesis Firehose delivery stream as the destination.
        public var kinesisFirehoseOutput: KinesisAnalyticsClientTypes.KinesisFirehoseOutput?
        /// Identifies an Amazon Kinesis stream as the destination.
        public var kinesisStreamsOutput: KinesisAnalyticsClientTypes.KinesisStreamsOutput?
        /// Identifies an AWS Lambda function as the destination.
        public var lambdaOutput: KinesisAnalyticsClientTypes.LambdaOutput?
        /// Name of the in-application stream.
        /// This member is required.
        public var name: Swift.String?

        public init (
            destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutput: KinesisAnalyticsClientTypes.KinesisFirehoseOutput? = nil,
            kinesisStreamsOutput: KinesisAnalyticsClientTypes.KinesisStreamsOutput? = nil,
            lambdaOutput: KinesisAnalyticsClientTypes.LambdaOutput? = nil,
            name: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }
    }

}

extension KinesisAnalyticsClientTypes.OutputDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchema = "DestinationSchema"
        case kinesisFirehoseOutputDescription = "KinesisFirehoseOutputDescription"
        case kinesisStreamsOutputDescription = "KinesisStreamsOutputDescription"
        case lambdaOutputDescription = "LambdaOutputDescription"
        case name = "Name"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchema = self.destinationSchema {
            try encodeContainer.encode(destinationSchema, forKey: .destinationSchema)
        }
        if let kinesisFirehoseOutputDescription = self.kinesisFirehoseOutputDescription {
            try encodeContainer.encode(kinesisFirehoseOutputDescription, forKey: .kinesisFirehoseOutputDescription)
        }
        if let kinesisStreamsOutputDescription = self.kinesisStreamsOutputDescription {
            try encodeContainer.encode(kinesisStreamsOutputDescription, forKey: .kinesisStreamsOutputDescription)
        }
        if let lambdaOutputDescription = self.lambdaOutputDescription {
            try encodeContainer.encode(lambdaOutputDescription, forKey: .lambdaOutputDescription)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kinesisStreamsOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription.self, forKey: .kinesisStreamsOutputDescription)
        kinesisStreamsOutputDescription = kinesisStreamsOutputDescriptionDecoded
        let kinesisFirehoseOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription.self, forKey: .kinesisFirehoseOutputDescription)
        kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescriptionDecoded
        let lambdaOutputDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.LambdaOutputDescription.self, forKey: .lambdaOutputDescription)
        lambdaOutputDescription = lambdaOutputDescriptionDecoded
        let destinationSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.DestinationSchema.self, forKey: .destinationSchema)
        destinationSchema = destinationSchemaDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the application output configuration, which includes the in-application stream name and the destination where the stream data is written. The destination can be an Amazon Kinesis stream or an Amazon Kinesis Firehose delivery stream.
    public struct OutputDescription: Swift.Equatable {
        /// Data format used for writing data to the destination.
        public var destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Describes the Amazon Kinesis Firehose delivery stream configured as the destination where output is written.
        public var kinesisFirehoseOutputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription?
        /// Describes Amazon Kinesis stream configured as the destination where output is written.
        public var kinesisStreamsOutputDescription: KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription?
        /// Describes the AWS Lambda function configured as the destination where output is written.
        public var lambdaOutputDescription: KinesisAnalyticsClientTypes.LambdaOutputDescription?
        /// Name of the in-application stream configured as output.
        public var name: Swift.String?
        /// A unique identifier for the output configuration.
        public var outputId: Swift.String?

        public init (
            destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription? = nil,
            kinesisStreamsOutputDescription: KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription? = nil,
            lambdaOutputDescription: KinesisAnalyticsClientTypes.LambdaOutputDescription? = nil,
            name: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsClientTypes.OutputUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationSchemaUpdate = "DestinationSchemaUpdate"
        case kinesisFirehoseOutputUpdate = "KinesisFirehoseOutputUpdate"
        case kinesisStreamsOutputUpdate = "KinesisStreamsOutputUpdate"
        case lambdaOutputUpdate = "LambdaOutputUpdate"
        case nameUpdate = "NameUpdate"
        case outputId = "OutputId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationSchemaUpdate = self.destinationSchemaUpdate {
            try encodeContainer.encode(destinationSchemaUpdate, forKey: .destinationSchemaUpdate)
        }
        if let kinesisFirehoseOutputUpdate = self.kinesisFirehoseOutputUpdate {
            try encodeContainer.encode(kinesisFirehoseOutputUpdate, forKey: .kinesisFirehoseOutputUpdate)
        }
        if let kinesisStreamsOutputUpdate = self.kinesisStreamsOutputUpdate {
            try encodeContainer.encode(kinesisStreamsOutputUpdate, forKey: .kinesisStreamsOutputUpdate)
        }
        if let lambdaOutputUpdate = self.lambdaOutputUpdate {
            try encodeContainer.encode(lambdaOutputUpdate, forKey: .lambdaOutputUpdate)
        }
        if let nameUpdate = self.nameUpdate {
            try encodeContainer.encode(nameUpdate, forKey: .nameUpdate)
        }
        if let outputId = self.outputId {
            try encodeContainer.encode(outputId, forKey: .outputId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputId)
        outputId = outputIdDecoded
        let nameUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameUpdate)
        nameUpdate = nameUpdateDecoded
        let kinesisStreamsOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate.self, forKey: .kinesisStreamsOutputUpdate)
        kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdateDecoded
        let kinesisFirehoseOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate.self, forKey: .kinesisFirehoseOutputUpdate)
        kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdateDecoded
        let lambdaOutputUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.LambdaOutputUpdate.self, forKey: .lambdaOutputUpdate)
        lambdaOutputUpdate = lambdaOutputUpdateDecoded
        let destinationSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.DestinationSchema.self, forKey: .destinationSchemaUpdate)
        destinationSchemaUpdate = destinationSchemaUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to the output configuration identified by the OutputId.
    public struct OutputUpdate: Swift.Equatable {
        /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        public var destinationSchemaUpdate: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Describes an Amazon Kinesis Firehose delivery stream as the destination for the output.
        public var kinesisFirehoseOutputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate?
        /// Describes an Amazon Kinesis stream as the destination for the output.
        public var kinesisStreamsOutputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate?
        /// Describes an AWS Lambda function as the destination for the output.
        public var lambdaOutputUpdate: KinesisAnalyticsClientTypes.LambdaOutputUpdate?
        /// If you want to specify a different in-application stream for this output configuration, use this field to specify the new in-application stream name.
        public var nameUpdate: Swift.String?
        /// Identifies the specific output configuration that you want to update.
        /// This member is required.
        public var outputId: Swift.String?

        public init (
            destinationSchemaUpdate: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate? = nil,
            kinesisStreamsOutputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate? = nil,
            lambdaOutputUpdate: KinesisAnalyticsClientTypes.LambdaOutputUpdate? = nil,
            nameUpdate: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsClientTypes.RecordColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapping = "Mapping"
        case name = "Name"
        case sqlType = "SqlType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapping = self.mapping {
            try encodeContainer.encode(mapping, forKey: .mapping)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlType = self.sqlType {
            try encodeContainer.encode(sqlType, forKey: .sqlType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mappingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapping)
        mapping = mappingDecoded
        let sqlTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlType)
        sqlType = sqlTypeDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream. Also used to describe the format of the reference data source.
    public struct RecordColumn: Swift.Equatable {
        /// Reference to the data element in the streaming input or the reference data source. This element is required if the [RecordFormatType](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_RecordFormat.html#analytics-Type-RecordFormat-RecordFormatTypel) is JSON.
        public var mapping: Swift.String?
        /// Name of the column created in the in-application input stream or reference table.
        /// This member is required.
        public var name: Swift.String?
        /// Type of column created in the in-application input stream or reference table.
        /// This member is required.
        public var sqlType: Swift.String?

        public init (
            mapping: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlType: Swift.String? = nil
        )
        {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }
    }

}

extension KinesisAnalyticsClientTypes.RecordFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappingParameters = "MappingParameters"
        case recordFormatType = "RecordFormatType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mappingParameters = self.mappingParameters {
            try encodeContainer.encode(mappingParameters, forKey: .mappingParameters)
        }
        if let recordFormatType = self.recordFormatType {
            try encodeContainer.encode(recordFormatType.rawValue, forKey: .recordFormatType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatTypeDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.RecordFormatType.self, forKey: .recordFormatType)
        recordFormatType = recordFormatTypeDecoded
        let mappingParametersDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.MappingParameters.self, forKey: .mappingParameters)
        mappingParameters = mappingParametersDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
    public struct RecordFormat: Swift.Equatable {
        /// When configuring application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public var mappingParameters: KinesisAnalyticsClientTypes.MappingParameters?
        /// The type of record format.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType?

        public init (
            mappingParameters: KinesisAnalyticsClientTypes.MappingParameters? = nil,
            recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType? = nil
        )
        {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsClientTypes {
    public enum RecordFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordFormatType] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordFormatType(rawValue: rawValue) ?? RecordFormatType.sdkUnknown(rawValue)
        }
    }
}

extension KinesisAnalyticsClientTypes.ReferenceDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSource = "S3ReferenceDataSource"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceSchema = self.referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSource = self.s3ReferenceDataSource {
            try encodeContainer.encode(s3ReferenceDataSource, forKey: .s3ReferenceDataSource)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.S3ReferenceDataSource.self, forKey: .s3ReferenceDataSource)
        s3ReferenceDataSource = s3ReferenceDataSourceDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the reference data source by providing the source information (S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
    public struct ReferenceDataSource: Swift.Equatable {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        /// This member is required.
        public var referenceSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf. An Amazon Kinesis Analytics application loads reference data only once. If the data changes, you call the UpdateApplication operation to trigger reloading of data into your application.
        public var s3ReferenceDataSource: KinesisAnalyticsClientTypes.S3ReferenceDataSource?
        /// Name of the in-application table to create.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            referenceSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSource: KinesisAnalyticsClientTypes.S3ReferenceDataSource? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }
    }

}

extension KinesisAnalyticsClientTypes.ReferenceDataSourceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchema = "ReferenceSchema"
        case s3ReferenceDataSourceDescription = "S3ReferenceDataSourceDescription"
        case tableName = "TableName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchema = self.referenceSchema {
            try encodeContainer.encode(referenceSchema, forKey: .referenceSchema)
        }
        if let s3ReferenceDataSourceDescription = self.s3ReferenceDataSourceDescription {
            try encodeContainer.encode(s3ReferenceDataSourceDescription, forKey: .s3ReferenceDataSourceDescription)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let s3ReferenceDataSourceDescriptionDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription.self, forKey: .s3ReferenceDataSourceDescription)
        s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescriptionDecoded
        let referenceSchemaDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .referenceSchema)
        referenceSchema = referenceSchemaDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the reference data source configured for an application.
    public struct ReferenceDataSourceDescription: Swift.Equatable {
        /// ID of the reference data source. This is the ID that Amazon Kinesis Analytics assigns when you add the reference data source to your application using the [AddApplicationReferenceDataSource](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html) operation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Provides the S3 bucket name, the object key name that contains the reference data. It also provides the Amazon Resource Name (ARN) of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application reference table.
        /// This member is required.
        public var s3ReferenceDataSourceDescription: KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription?
        /// The in-application table name created by the specific reference data source configuration.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            referenceId: Swift.String? = nil,
            referenceSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceDescription: KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }
    }

}

extension KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referenceId = "ReferenceId"
        case referenceSchemaUpdate = "ReferenceSchemaUpdate"
        case s3ReferenceDataSourceUpdate = "S3ReferenceDataSourceUpdate"
        case tableNameUpdate = "TableNameUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let referenceSchemaUpdate = self.referenceSchemaUpdate {
            try encodeContainer.encode(referenceSchemaUpdate, forKey: .referenceSchemaUpdate)
        }
        if let s3ReferenceDataSourceUpdate = self.s3ReferenceDataSourceUpdate {
            try encodeContainer.encode(s3ReferenceDataSourceUpdate, forKey: .s3ReferenceDataSourceUpdate)
        }
        if let tableNameUpdate = self.tableNameUpdate {
            try encodeContainer.encode(tableNameUpdate, forKey: .tableNameUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let tableNameUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableNameUpdate)
        tableNameUpdate = tableNameUpdateDecoded
        let s3ReferenceDataSourceUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate.self, forKey: .s3ReferenceDataSourceUpdate)
        s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdateDecoded
        let referenceSchemaUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.SourceSchema.self, forKey: .referenceSchemaUpdate)
        referenceSchemaUpdate = referenceSchemaUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// When you update a reference data source configuration for an application, this object provides all the updated values (such as the source bucket name and object key name), the in-application table name that is created, and updated mapping information that maps the data in the Amazon S3 object to the in-application reference table that is created.
    public struct ReferenceDataSourceUpdate: Swift.Equatable {
        /// ID of the reference data source being updated. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get this value.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchemaUpdate: KinesisAnalyticsClientTypes.SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
        public var s3ReferenceDataSourceUpdate: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate?
        /// In-application table name that is created by this update.
        public var tableNameUpdate: Swift.String?

        public init (
            referenceId: Swift.String? = nil,
            referenceSchemaUpdate: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceUpdate: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate? = nil,
            tableNameUpdate: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Application is not available for this operation.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Specified application can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceProvisionedThroughputExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceProvisionedThroughputExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Discovery failed to get a record from the streaming source because of the Amazon Kinesis Streams ProvisionedThroughputExceededException. For more information, see [GetRecords](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html) in the Amazon Kinesis Streams API Reference.
public struct ResourceProvisionedThroughputExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceProvisionedThroughputExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceProvisionedThroughputExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsClientTypes.S3Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case roleARN = "RoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of an Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket, the ARN of the IAM role that is used to access the bucket, and the name of the Amazon S3 object that contains the data.
    public struct S3Configuration: Swift.Equatable {
        /// ARN of the S3 bucket that contains the data.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The name of the object that contains the data.
        /// This member is required.
        public var fileKey: Swift.String?
        /// IAM ARN of the role used to access the data.
        /// This member is required.
        public var roleARN: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = self.referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf. An Amazon Kinesis Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation to trigger reloading of data into your application.
    public struct S3ReferenceDataSource: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Object key name containing reference data.
        /// This member is required.
        public var fileKey: Swift.String?
        /// ARN of the IAM role that the service can assume to read data on your behalf. This role must have permission for the s3:GetObject action on the object and trust policy that allows Amazon Kinesis Analytics service principal to assume this role.
        /// This member is required.
        public var referenceRoleARN: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARN = "BucketARN"
        case fileKey = "FileKey"
        case referenceRoleARN = "ReferenceRoleARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARN = self.bucketARN {
            try encodeContainer.encode(bucketARN, forKey: .bucketARN)
        }
        if let fileKey = self.fileKey {
            try encodeContainer.encode(fileKey, forKey: .fileKey)
        }
        if let referenceRoleARN = self.referenceRoleARN {
            try encodeContainer.encode(referenceRoleARN, forKey: .referenceRoleARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARN)
        bucketARN = bucketARNDecoded
        let fileKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKey)
        fileKey = fileKeyDecoded
        let referenceRoleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceRoleARN)
        referenceRoleARN = referenceRoleARNDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides the bucket name and object key name that stores the reference data.
    public struct S3ReferenceDataSourceDescription: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Amazon S3 object key name.
        /// This member is required.
        public var fileKey: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table.
        /// This member is required.
        public var referenceRoleARN: Swift.String?

        public init (
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketARNUpdate = "BucketARNUpdate"
        case fileKeyUpdate = "FileKeyUpdate"
        case referenceRoleARNUpdate = "ReferenceRoleARNUpdate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketARNUpdate = self.bucketARNUpdate {
            try encodeContainer.encode(bucketARNUpdate, forKey: .bucketARNUpdate)
        }
        if let fileKeyUpdate = self.fileKeyUpdate {
            try encodeContainer.encode(fileKeyUpdate, forKey: .fileKeyUpdate)
        }
        if let referenceRoleARNUpdate = self.referenceRoleARNUpdate {
            try encodeContainer.encode(referenceRoleARNUpdate, forKey: .referenceRoleARNUpdate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketARNUpdate)
        bucketARNUpdate = bucketARNUpdateDecoded
        let fileKeyUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileKeyUpdate)
        fileKeyUpdate = fileKeyUpdateDecoded
        let referenceRoleARNUpdateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceRoleARNUpdate)
        referenceRoleARNUpdate = referenceRoleARNUpdateDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
    public struct S3ReferenceDataSourceUpdate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?
        /// Object key name.
        public var fileKeyUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application.
        public var referenceRoleARNUpdate: Swift.String?

        public init (
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil,
            referenceRoleARNUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.referenceRoleARNUpdate = referenceRoleARNUpdate
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is unavailable. Back off and retry the operation.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisAnalyticsClientTypes.SourceSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordColumns = "RecordColumns"
        case recordEncoding = "RecordEncoding"
        case recordFormat = "RecordFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordColumns = recordColumns {
            var recordColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordColumns)
            for recordcolumn0 in recordColumns {
                try recordColumnsContainer.encode(recordcolumn0)
            }
        }
        if let recordEncoding = self.recordEncoding {
            try encodeContainer.encode(recordEncoding, forKey: .recordEncoding)
        }
        if let recordFormat = self.recordFormat {
            try encodeContainer.encode(recordFormat, forKey: .recordFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordFormatDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.RecordFormat.self, forKey: .recordFormat)
        recordFormat = recordFormatDecoded
        let recordEncodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordEncoding)
        recordEncoding = recordEncodingDecoded
        let recordColumnsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.RecordColumn?].self, forKey: .recordColumns)
        var recordColumnsDecoded0:[KinesisAnalyticsClientTypes.RecordColumn]? = nil
        if let recordColumnsContainer = recordColumnsContainer {
            recordColumnsDecoded0 = [KinesisAnalyticsClientTypes.RecordColumn]()
            for structure0 in recordColumnsContainer {
                if let structure0 = structure0 {
                    recordColumnsDecoded0?.append(structure0)
                }
            }
        }
        recordColumns = recordColumnsDecoded0
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    public struct SourceSchema: Swift.Equatable {
        /// A list of RecordColumn objects.
        /// This member is required.
        public var recordColumns: [KinesisAnalyticsClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncoding: Swift.String?
        /// Specifies the format of the records on the streaming source.
        /// This member is required.
        public var recordFormat: KinesisAnalyticsClientTypes.RecordFormat?

        public init (
            recordColumns: [KinesisAnalyticsClientTypes.RecordColumn]? = nil,
            recordEncoding: Swift.String? = nil,
            recordFormat: KinesisAnalyticsClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }
    }

}

extension StartApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case inputConfigurations = "InputConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for inputconfiguration0 in inputConfigurations {
                try inputConfigurationsContainer.encode(inputconfiguration0)
            }
        }
    }
}

extension StartApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StartApplicationInput: Swift.Equatable {
    /// Name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Identifies the specific input, by ID, that the application starts consuming. Amazon Kinesis Analytics starts reading the streaming source associated with the input. You can also specify where in the streaming source you want Amazon Kinesis Analytics to start reading.
    /// This member is required.
    public var inputConfigurations: [KinesisAnalyticsClientTypes.InputConfiguration]?

    public init (
        applicationName: Swift.String? = nil,
        inputConfigurations: [KinesisAnalyticsClientTypes.InputConfiguration]? = nil
    )
    {
        self.applicationName = applicationName
        self.inputConfigurations = inputConfigurations
    }
}

struct StartApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let inputConfigurations: [KinesisAnalyticsClientTypes.InputConfiguration]?
}

extension StartApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case inputConfigurations = "InputConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.InputConfiguration?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[KinesisAnalyticsClientTypes.InputConfiguration]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [KinesisAnalyticsClientTypes.InputConfiguration]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
    }
}

extension StartApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidApplicationConfigurationException" : self = .invalidApplicationConfigurationException(try InvalidApplicationConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartApplicationOutputError: Swift.Error, Swift.Equatable {
    case invalidApplicationConfigurationException(InvalidApplicationConfigurationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct StartApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
    }
}

extension StopApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

///
public struct StopApplicationInput: Swift.Equatable {
    /// Name of the running application to stop.
    /// This member is required.
    public var applicationName: Swift.String?

    public init (
        applicationName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

struct StopApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
}

extension StopApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
    }
}

extension StopApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopApplicationOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct StopApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisAnalyticsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisAnalyticsClientTypes {
    /// A key-value pair (the value is optional) that you can define and assign to AWS resources. If you specify a tag that already exists, the tag value is replaced with the value that you specify in the request. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html).
    public struct Tag: Swift.Equatable {
        /// The key of the key-value tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value tag. The value is optional.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the application to assign the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value tags to assign to the application.
    /// This member is required.
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [KinesisAnalyticsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisAnalyticsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisAnalyticsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisAnalyticsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Application created with too many tags, or too many tags added to an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnableToDetectSchemaException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnableToDetectSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.processedInputRecords = output.processedInputRecords
            self.rawInputRecords = output.rawInputRecords
        } else {
            self.processedInputRecords = nil
            self.rawInputRecords = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Data format is not valid. Amazon Kinesis Analytics is not able to detect schema for the given streaming source.
public struct UnableToDetectSchemaException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var processedInputRecords: [Swift.String]?
    public var rawInputRecords: [Swift.String]?

    public init (
        message: Swift.String? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.message = message
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

struct UnableToDetectSchemaExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let rawInputRecords: [Swift.String]?
    let processedInputRecords: [Swift.String]?
}

extension UnableToDetectSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processedInputRecords = "ProcessedInputRecords"
        case rawInputRecords = "RawInputRecords"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let rawInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rawInputRecords)
        var rawInputRecordsDecoded0:[Swift.String]? = nil
        if let rawInputRecordsContainer = rawInputRecordsContainer {
            rawInputRecordsDecoded0 = [Swift.String]()
            for string0 in rawInputRecordsContainer {
                if let string0 = string0 {
                    rawInputRecordsDecoded0?.append(string0)
                }
            }
        }
        rawInputRecords = rawInputRecordsDecoded0
        let processedInputRecordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processedInputRecords)
        var processedInputRecordsDecoded0:[Swift.String]? = nil
        if let processedInputRecordsContainer = processedInputRecordsContainer {
            processedInputRecordsDecoded0 = [Swift.String]()
            for string0 in processedInputRecordsContainer {
                if let string0 = string0 {
                    processedInputRecordsDecoded0?.append(string0)
                }
            }
        }
        processedInputRecords = processedInputRecordsDecoded0
    }
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the Kinesis Analytics application from which to remove the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of keys of tags to remove from the specified application.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case applicationUpdate = "ApplicationUpdate"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let applicationUpdate = self.applicationUpdate {
            try encodeContainer.encode(applicationUpdate, forKey: .applicationUpdate)
        }
        if let currentApplicationVersionId = self.currentApplicationVersionId {
            try encodeContainer.encode(currentApplicationVersionId, forKey: .currentApplicationVersionId)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Name of the Amazon Kinesis Analytics application to update.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Describes application updates.
    /// This member is required.
    public var applicationUpdate: KinesisAnalyticsClientTypes.ApplicationUpdate?
    /// The current application version ID. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get this value.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init (
        applicationName: Swift.String? = nil,
        applicationUpdate: KinesisAnalyticsClientTypes.ApplicationUpdate? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationUpdate = applicationUpdate
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let applicationName: Swift.String?
    let currentApplicationVersionId: Swift.Int?
    let applicationUpdate: KinesisAnalyticsClientTypes.ApplicationUpdate?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case applicationUpdate = "ApplicationUpdate"
        case currentApplicationVersionId = "CurrentApplicationVersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let currentApplicationVersionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentApplicationVersionId)
        currentApplicationVersionId = currentApplicationVersionIdDecoded
        let applicationUpdateDecoded = try containerValues.decodeIfPresent(KinesisAnalyticsClientTypes.ApplicationUpdate.self, forKey: .applicationUpdate)
        applicationUpdate = applicationUpdateDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CodeValidationException" : self = .codeValidationException(try CodeValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case codeValidationException(CodeValidationException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {

    public init () { }
}
