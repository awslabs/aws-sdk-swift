//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// Exception thrown as a result of concurrent modification to an application. For example, two individuals attempting to edit the same application at the same time.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Specified input parameter value is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Application is not available for this operation.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Specified application can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because a specified parameter is not supported or a specified resource is not valid for this operation.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of CloudWatch logging options, including the log stream Amazon Resource Name (ARN) and the role ARN.
    public struct CloudWatchLoggingOption {
        /// ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role that is used must have the PutLogEvents policy action enabled.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

public struct AddApplicationCloudWatchLoggingOptionInput {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Provides the CloudWatch log stream Amazon Resource Name (ARN) and the IAM role ARN. Note: To write application messages to CloudWatch, the IAM role that is used must have the PutLogEvents policy action enabled.
    /// This member is required.
    public var cloudWatchLoggingOption: KinesisAnalyticsClientTypes.CloudWatchLoggingOption?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOption: KinesisAnalyticsClientTypes.CloudWatchLoggingOption? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOption = cloudWatchLoggingOption
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

public struct AddApplicationCloudWatchLoggingOptionOutput {

    public init() { }
}

/// User-provided application code (query) is invalid. This can be a simple syntax error.
public struct CodeValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Test
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CodeValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the number of in-application streams to create for a given streaming source. For information about parallelism, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct InputParallelism {
        /// Number of in-application streams to create. For more information, see [Limits](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html).
        public var count: Swift.Int?

        public init(
            count: Swift.Int? = nil
        )
        {
            self.count = count
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess records in the stream, and the ARN of the IAM role that is used to access the AWS Lambda function.
    public struct InputLambdaProcessor {
        /// The ARN of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that operates on records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        /// This member is required.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the AWS Lambda function.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is [AWS Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfiguration {
        /// The [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream before being processed by your application code.
        /// This member is required.
        public var inputLambdaProcessor: KinesisAnalyticsClientTypes.InputLambdaProcessor?

        public init(
            inputLambdaProcessor: KinesisAnalyticsClientTypes.InputLambdaProcessor? = nil
        )
        {
            self.inputLambdaProcessor = inputLambdaProcessor
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream. Also used to describe the format of the reference data source.
    public struct RecordColumn {
        /// Reference to the data element in the streaming input or the reference data source. This element is required if the [RecordFormatType](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_RecordFormat.html#analytics-Type-RecordFormat-RecordFormatTypel) is JSON.
        public var mapping: Swift.String?
        /// Name of the column created in the in-application input stream or reference table.
        /// This member is required.
        public var name: Swift.String?
        /// Type of column created in the in-application input stream or reference table.
        /// This member is required.
        public var sqlType: Swift.String?

        public init(
            mapping: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlType: Swift.String? = nil
        )
        {
            self.mapping = mapping
            self.name = name
            self.sqlType = sqlType
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter: "name1", "address1"
    ///     "name2", "address2"
    public struct CSVMappingParameters {
        /// Column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
        /// This member is required.
        public var recordColumnDelimiter: Swift.String?
        /// Row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
        /// This member is required.
        public var recordRowDelimiter: Swift.String?

        public init(
            recordColumnDelimiter: Swift.String? = nil,
            recordRowDelimiter: Swift.String? = nil
        )
        {
            self.recordColumnDelimiter = recordColumnDelimiter
            self.recordRowDelimiter = recordRowDelimiter
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides additional mapping information when JSON is the record format on the streaming source.
    public struct JSONMappingParameters {
        /// Path to the top-level parent that contains the records.
        /// This member is required.
        public var recordRowPath: Swift.String?

        public init(
            recordRowPath: Swift.String? = nil
        )
        {
            self.recordRowPath = recordRowPath
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When configuring application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
    public struct MappingParameters {
        /// Provides additional mapping information when the record format uses delimiters (for example, CSV).
        public var csvMappingParameters: KinesisAnalyticsClientTypes.CSVMappingParameters?
        /// Provides additional mapping information when JSON is the record format on the streaming source.
        public var jsonMappingParameters: KinesisAnalyticsClientTypes.JSONMappingParameters?

        public init(
            csvMappingParameters: KinesisAnalyticsClientTypes.CSVMappingParameters? = nil,
            jsonMappingParameters: KinesisAnalyticsClientTypes.JSONMappingParameters? = nil
        )
        {
            self.csvMappingParameters = csvMappingParameters
            self.jsonMappingParameters = jsonMappingParameters
        }
    }

}

extension KinesisAnalyticsClientTypes {

    public enum RecordFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordFormatType] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
    public struct RecordFormat {
        /// When configuring application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
        public var mappingParameters: KinesisAnalyticsClientTypes.MappingParameters?
        /// The type of record format.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType?

        public init(
            mappingParameters: KinesisAnalyticsClientTypes.MappingParameters? = nil,
            recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType? = nil
        )
        {
            self.mappingParameters = mappingParameters
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
    public struct SourceSchema {
        /// A list of RecordColumn objects.
        /// This member is required.
        public var recordColumns: [KinesisAnalyticsClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncoding: Swift.String?
        /// Specifies the format of the records on the streaming source.
        /// This member is required.
        public var recordFormat: KinesisAnalyticsClientTypes.RecordFormat?

        public init(
            recordColumns: [KinesisAnalyticsClientTypes.RecordColumn]? = nil,
            recordEncoding: Swift.String? = nil,
            recordFormat: KinesisAnalyticsClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumns = recordColumns
            self.recordEncoding = recordEncoding
            self.recordFormat = recordFormat
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Identifies an Amazon Kinesis Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN) and an IAM role ARN that enables Amazon Kinesis Analytics to access the stream on your behalf.
    public struct KinesisFirehoseInput {
        /// ARN of the input delivery stream.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to make sure that the role has the necessary permissions to access the stream.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Identifies an Amazon Kinesis stream as the streaming source. You provide the stream's Amazon Resource Name (ARN) and an IAM role ARN that enables Amazon Kinesis Analytics to access the stream on your behalf.
    public struct KinesisStreamsInput {
        /// ARN of the input Amazon Kinesis stream to read.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When you configure the application input, you specify the streaming source, the in-application stream name that is created, and the mapping between the two. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct Input {
        /// Describes the number of in-application streams to create. Data from your source is routed to these in-application input streams. (see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var inputParallelism: KinesisAnalyticsClientTypes.InputParallelism?
        /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html).
        public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created. Also used to describe the format of the reference data source.
        /// This member is required.
        public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// If the streaming source is an Amazon Kinesis Firehose delivery stream, identifies the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf. Note: Either KinesisStreamsInput or KinesisFirehoseInput is required.
        public var kinesisFirehoseInput: KinesisAnalyticsClientTypes.KinesisFirehoseInput?
        /// If the streaming source is an Amazon Kinesis stream, identifies the stream's Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf. Note: Either KinesisStreamsInput or KinesisFirehoseInput is required.
        public var kinesisStreamsInput: KinesisAnalyticsClientTypes.KinesisStreamsInput?
        /// Name prefix to use when creating an in-application stream. Suppose that you specify a prefix "MyInApplicationStream." Amazon Kinesis Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with names "MyInApplicationStream_001," "MyInApplicationStream_002," and so on.
        /// This member is required.
        public var namePrefix: Swift.String?

        public init(
            inputParallelism: KinesisAnalyticsClientTypes.InputParallelism? = nil,
            inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil,
            inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            kinesisFirehoseInput: KinesisAnalyticsClientTypes.KinesisFirehoseInput? = nil,
            kinesisStreamsInput: KinesisAnalyticsClientTypes.KinesisStreamsInput? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inputParallelism = inputParallelism
            self.inputProcessingConfiguration = inputProcessingConfiguration
            self.inputSchema = inputSchema
            self.kinesisFirehoseInput = kinesisFirehoseInput
            self.kinesisStreamsInput = kinesisStreamsInput
            self.namePrefix = namePrefix
        }
    }

}

///
public struct AddApplicationInputInput {
    /// Name of your existing Amazon Kinesis Analytics application to which you want to add the streaming source.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Current version of your Amazon Kinesis Analytics application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to find the current application version.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The [Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_Input.html) to add.
    /// This member is required.
    public var input: KinesisAnalyticsClientTypes.Input?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        input: KinesisAnalyticsClientTypes.Input? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.input = input
    }
}

///
public struct AddApplicationInputOutput {

    public init() { }
}

public struct AddApplicationInputProcessingConfigurationInput {
    /// Name of the application to which you want to add the input processing configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application to which you want to add the input processing configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration to add the input processing configuration to. You can get a list of the input IDs for an application using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var inputId: Swift.String?
    /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) to add to the application.
    /// This member is required.
    public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil,
        inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
        self.inputProcessingConfiguration = inputProcessingConfiguration
    }
}

public struct AddApplicationInputProcessingConfigurationOutput {

    public init() { }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
    public struct DestinationSchema {
        /// Specifies the format of the records on the output stream.
        /// This member is required.
        public var recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType?

        public init(
            recordFormatType: KinesisAnalyticsClientTypes.RecordFormatType? = nil
        )
        {
            self.recordFormatType = recordFormatType
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an Amazon Kinesis Firehose delivery stream as the destination. You provide the stream Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to write to the stream on your behalf.
    public struct KinesisFirehoseOutput {
        /// ARN of the destination Amazon Kinesis Firehose delivery stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an Amazon Kinesis stream as the destination. You provide the stream Amazon Resource Name (ARN) and also an IAM role ARN that Amazon Kinesis Analytics can use to write to the stream on your behalf.
    public struct KinesisStreamsOutput {
        /// ARN of the destination Amazon Kinesis stream to write to.
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination stream on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When configuring application output, identifies an AWS Lambda function as the destination. You provide the function Amazon Resource Name (ARN) and also an IAM role ARN that Amazon Kinesis Analytics can use to write to the function on your behalf.
    public struct LambdaOutput {
        /// Amazon Resource Name (ARN) of the destination Lambda function to write to. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        /// This member is required.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes application output configuration in which you identify an in-application stream and a destination where you want the in-application stream data to be written. The destination can be an Amazon Kinesis stream or an Amazon Kinesis Firehose delivery stream. For limits on how many destinations an application can write and other limitations, see [Limits](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/limits.html).
    public struct Output {
        /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        /// This member is required.
        public var destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Identifies an Amazon Kinesis Firehose delivery stream as the destination.
        public var kinesisFirehoseOutput: KinesisAnalyticsClientTypes.KinesisFirehoseOutput?
        /// Identifies an Amazon Kinesis stream as the destination.
        public var kinesisStreamsOutput: KinesisAnalyticsClientTypes.KinesisStreamsOutput?
        /// Identifies an AWS Lambda function as the destination.
        public var lambdaOutput: KinesisAnalyticsClientTypes.LambdaOutput?
        /// Name of the in-application stream.
        /// This member is required.
        public var name: Swift.String?

        public init(
            destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutput: KinesisAnalyticsClientTypes.KinesisFirehoseOutput? = nil,
            kinesisStreamsOutput: KinesisAnalyticsClientTypes.KinesisStreamsOutput? = nil,
            lambdaOutput: KinesisAnalyticsClientTypes.LambdaOutput? = nil,
            name: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutput = kinesisFirehoseOutput
            self.kinesisStreamsOutput = kinesisStreamsOutput
            self.lambdaOutput = lambdaOutput
            self.name = name
        }
    }

}

///
public struct AddApplicationOutputInput {
    /// Name of the application to which you want to add the output configuration.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application to which you want to add the output configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// An array of objects, each describing one output configuration. In the output configuration, you specify the name of an in-application stream, a destination (that is, an Amazon Kinesis stream, an Amazon Kinesis Firehose delivery stream, or an AWS Lambda function), and record the formation to use when writing to the destination.
    /// This member is required.
    public var output: KinesisAnalyticsClientTypes.Output?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        output: KinesisAnalyticsClientTypes.Output? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.output = output
    }
}

///
public struct AddApplicationOutputOutput {

    public init() { }
}

extension KinesisAnalyticsClientTypes {
    /// Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf. An Amazon Kinesis Analytics application loads reference data only once. If the data changes, you call the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation to trigger reloading of data into your application.
    public struct S3ReferenceDataSource {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Object key name containing reference data.
        /// This member is required.
        public var fileKey: Swift.String?
        /// ARN of the IAM role that the service can assume to read data on your behalf. This role must have permission for the s3:GetObject action on the object and trust policy that allows Amazon Kinesis Analytics service principal to assume this role.
        /// This member is required.
        public var referenceRoleARN: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the reference data source by providing the source information (S3 bucket name and object key name), the resulting in-application table name that is created, and the necessary schema to map the data elements in the Amazon S3 object to the in-application table.
    public struct ReferenceDataSource {
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        /// This member is required.
        public var referenceSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Identifies the S3 bucket and object that contains the reference data. Also identifies the IAM role Amazon Kinesis Analytics can assume to read this object on your behalf. An Amazon Kinesis Analytics application loads reference data only once. If the data changes, you call the UpdateApplication operation to trigger reloading of data into your application.
        public var s3ReferenceDataSource: KinesisAnalyticsClientTypes.S3ReferenceDataSource?
        /// Name of the in-application table to create.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            referenceSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSource: KinesisAnalyticsClientTypes.S3ReferenceDataSource? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSource = s3ReferenceDataSource
            self.tableName = tableName
        }
    }

}

///
public struct AddApplicationReferenceDataSourceInput {
    /// Name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application for which you are adding the reference data source. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The reference data source can be an object in your Amazon S3 bucket. Amazon Kinesis Analytics reads the object and copies the data into the in-application table that is created. You provide an S3 bucket, object key name, and the resulting in-application table that is created. You must also provide an IAM role with the necessary permissions that Amazon Kinesis Analytics can assume to read the object from your S3 bucket on your behalf.
    /// This member is required.
    public var referenceDataSource: KinesisAnalyticsClientTypes.ReferenceDataSource?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceDataSource: KinesisAnalyticsClientTypes.ReferenceDataSource? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceDataSource = referenceDataSource
    }
}

///
public struct AddApplicationReferenceDataSourceOutput {

    public init() { }
}

extension KinesisAnalyticsClientTypes {

    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case ready
        case running
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .deleting,
                .ready,
                .running,
                .starting,
                .stopping,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsClientTypes {
    /// Description of the CloudWatch logging option.
    public struct CloudWatchLoggingOptionDescription {
        /// ID of the CloudWatch logging option description.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// ARN of the CloudWatch log to receive application messages.
        /// This member is required.
        public var logStreamARN: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the PutLogEvents policy action enabled.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARN = logStreamARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// An object that contains the Amazon Resource Name (ARN) of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess records in the stream, and the ARN of the IAM role that is used to access the AWS Lambda expression.
    public struct InputLambdaProcessorDescription {
        /// The ARN of the [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess the records in the stream.
        public var resourceARN: Swift.String?
        /// The ARN of the IAM role that is used to access the AWS Lambda function.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides configuration information about an input processor. Currently, the only input processor available is [AWS Lambda](https://docs.aws.amazon.com/lambda/).
    public struct InputProcessingConfigurationDescription {
        /// Provides configuration information about the associated [InputLambdaProcessorDescription](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessorDescription.html).
        public var inputLambdaProcessorDescription: KinesisAnalyticsClientTypes.InputLambdaProcessorDescription?

        public init(
            inputLambdaProcessorDescription: KinesisAnalyticsClientTypes.InputLambdaProcessorDescription? = nil
        )
        {
            self.inputLambdaProcessorDescription = inputLambdaProcessorDescription
        }
    }

}

extension KinesisAnalyticsClientTypes {

    public enum InputStartingPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lastStoppedPoint
        case now
        case trimHorizon
        case sdkUnknown(Swift.String)

        public static var allCases: [InputStartingPosition] {
            return [
                .lastStoppedPoint,
                .now,
                .trimHorizon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lastStoppedPoint: return "LAST_STOPPED_POINT"
            case .now: return "NOW"
            case .trimHorizon: return "TRIM_HORIZON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisAnalyticsClientTypes {
    /// Describes the point at which the application reads from the streaming source.
    public struct InputStartingPositionConfiguration {
        /// The starting position on the stream.
        ///
        /// * NOW - Start reading just after the most recent record in the stream, start at the request time stamp that the customer issued.
        ///
        /// * TRIM_HORIZON - Start reading at the last untrimmed record in the stream, which is the oldest record available in the stream. This option is not available for an Amazon Kinesis Firehose delivery stream.
        ///
        /// * LAST_STOPPED_POINT - Resume reading from where the application last stopped reading.
        public var inputStartingPosition: KinesisAnalyticsClientTypes.InputStartingPosition?

        public init(
            inputStartingPosition: KinesisAnalyticsClientTypes.InputStartingPosition? = nil
        )
        {
            self.inputStartingPosition = inputStartingPosition
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the Amazon Kinesis Firehose delivery stream that is configured as the streaming source in the application input configuration.
    public struct KinesisFirehoseInputDescription {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics assumes to access the stream.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the Amazon Kinesis stream that is configured as the streaming source in the application input configuration.
    public struct KinesisStreamsInputDescription {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the application input configuration. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
    public struct InputDescription {
        /// Returns the in-application stream names that are mapped to the stream source.
        public var inAppStreamNames: [Swift.String]?
        /// Input ID associated with the application input. This is the ID that Amazon Kinesis Analytics assigns to each input configuration you add to your application.
        public var inputId: Swift.String?
        /// Describes the configured parallelism (number of in-application streams mapped to the streaming source).
        public var inputParallelism: KinesisAnalyticsClientTypes.InputParallelism?
        /// The description of the preprocessor that executes on records in this input before the application's code is run.
        public var inputProcessingConfigurationDescription: KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
        public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Point at which the application is configured to read from the input stream.
        public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?
        /// If an Amazon Kinesis Firehose delivery stream is configured as a streaming source, provides the delivery stream's ARN and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf.
        public var kinesisFirehoseInputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription?
        /// If an Amazon Kinesis stream is configured as streaming source, provides Amazon Kinesis stream's Amazon Resource Name (ARN) and an IAM role that enables Amazon Kinesis Analytics to access the stream on your behalf.
        public var kinesisStreamsInputDescription: KinesisAnalyticsClientTypes.KinesisStreamsInputDescription?
        /// In-application name prefix.
        public var namePrefix: Swift.String?

        public init(
            inAppStreamNames: [Swift.String]? = nil,
            inputId: Swift.String? = nil,
            inputParallelism: KinesisAnalyticsClientTypes.InputParallelism? = nil,
            inputProcessingConfigurationDescription: KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription? = nil,
            inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil,
            kinesisFirehoseInputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription? = nil,
            kinesisStreamsInputDescription: KinesisAnalyticsClientTypes.KinesisStreamsInputDescription? = nil,
            namePrefix: Swift.String? = nil
        )
        {
            self.inAppStreamNames = inAppStreamNames
            self.inputId = inputId
            self.inputParallelism = inputParallelism
            self.inputProcessingConfigurationDescription = inputProcessingConfigurationDescription
            self.inputSchema = inputSchema
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
            self.kinesisFirehoseInputDescription = kinesisFirehoseInputDescription
            self.kinesisStreamsInputDescription = kinesisStreamsInputDescription
            self.namePrefix = namePrefix
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the Amazon Kinesis Firehose delivery stream configured as its destination.
    public struct KinesisFirehoseOutputDescription {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the Amazon Kinesis stream configured as its destination.
    public struct KinesisStreamsOutputDescription {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// For an application output, describes the AWS Lambda function configured as its destination.
    public struct LambdaOutputDescription {
        /// Amazon Resource Name (ARN) of the destination Lambda function.
        public var resourceARN: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function.
        public var roleARN: Swift.String?

        public init(
            resourceARN: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.resourceARN = resourceARN
            self.roleARN = roleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the application output configuration, which includes the in-application stream name and the destination where the stream data is written. The destination can be an Amazon Kinesis stream or an Amazon Kinesis Firehose delivery stream.
    public struct OutputDescription {
        /// Data format used for writing data to the destination.
        public var destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Describes the Amazon Kinesis Firehose delivery stream configured as the destination where output is written.
        public var kinesisFirehoseOutputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription?
        /// Describes Amazon Kinesis stream configured as the destination where output is written.
        public var kinesisStreamsOutputDescription: KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription?
        /// Describes the AWS Lambda function configured as the destination where output is written.
        public var lambdaOutputDescription: KinesisAnalyticsClientTypes.LambdaOutputDescription?
        /// Name of the in-application stream configured as output.
        public var name: Swift.String?
        /// A unique identifier for the output configuration.
        public var outputId: Swift.String?

        public init(
            destinationSchema: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputDescription: KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription? = nil,
            kinesisStreamsOutputDescription: KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription? = nil,
            lambdaOutputDescription: KinesisAnalyticsClientTypes.LambdaOutputDescription? = nil,
            name: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchema = destinationSchema
            self.kinesisFirehoseOutputDescription = kinesisFirehoseOutputDescription
            self.kinesisStreamsOutputDescription = kinesisStreamsOutputDescription
            self.lambdaOutputDescription = lambdaOutputDescription
            self.name = name
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides the bucket name and object key name that stores the reference data.
    public struct S3ReferenceDataSourceDescription {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// Amazon S3 object key name.
        /// This member is required.
        public var fileKey: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf to populate the in-application reference table.
        /// This member is required.
        public var referenceRoleARN: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            referenceRoleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.referenceRoleARN = referenceRoleARN
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the reference data source configured for an application.
    public struct ReferenceDataSourceDescription {
        /// ID of the reference data source. This is the ID that Amazon Kinesis Analytics assigns when you add the reference data source to your application using the [AddApplicationReferenceDataSource](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html) operation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchema: KinesisAnalyticsClientTypes.SourceSchema?
        /// Provides the S3 bucket name, the object key name that contains the reference data. It also provides the Amazon Resource Name (ARN) of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application reference table.
        /// This member is required.
        public var s3ReferenceDataSourceDescription: KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription?
        /// The in-application table name created by the specific reference data source configuration.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            referenceId: Swift.String? = nil,
            referenceSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceDescription: KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchema = referenceSchema
            self.s3ReferenceDataSourceDescription = s3ReferenceDataSourceDescription
            self.tableName = tableName
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see [Amazon Kinesis Data Analytics API V2 Documentation]. Provides a description of the application, including the application Amazon Resource Name (ARN), status, latest version, and input and output configuration.
    public struct ApplicationDetail {
        /// ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Returns the application code that you provided to perform data analysis on any of the in-application streams in your application.
        public var applicationCode: Swift.String?
        /// Description of the application.
        public var applicationDescription: Swift.String?
        /// Name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// Status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus?
        /// Provides the current application version.
        /// This member is required.
        public var applicationVersionId: Swift.Int?
        /// Describes the CloudWatch log streams that are configured to receive application messages. For more information about using CloudWatch log streams with Amazon Kinesis Analytics applications, see [Working with Amazon CloudWatch Logs](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html).
        public var cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]?
        /// Time stamp when the application version was created.
        public var createTimestamp: Foundation.Date?
        /// Describes the application input configuration. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var inputDescriptions: [KinesisAnalyticsClientTypes.InputDescription]?
        /// Time stamp when the application was last updated.
        public var lastUpdateTimestamp: Foundation.Date?
        /// Describes the application output configuration. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        public var outputDescriptions: [KinesisAnalyticsClientTypes.OutputDescription]?
        /// Describes reference data sources configured for the application. For more information, see [Configuring Application Input](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-input.html).
        public var referenceDataSourceDescriptions: [KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]?

        public init(
            applicationARN: Swift.String? = nil,
            applicationCode: Swift.String? = nil,
            applicationDescription: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus? = nil,
            applicationVersionId: Swift.Int? = nil,
            cloudWatchLoggingOptionDescriptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription]? = nil,
            createTimestamp: Foundation.Date? = nil,
            inputDescriptions: [KinesisAnalyticsClientTypes.InputDescription]? = nil,
            lastUpdateTimestamp: Foundation.Date? = nil,
            outputDescriptions: [KinesisAnalyticsClientTypes.OutputDescription]? = nil,
            referenceDataSourceDescriptions: [KinesisAnalyticsClientTypes.ReferenceDataSourceDescription]? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationCode = applicationCode
            self.applicationDescription = applicationDescription
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
            self.applicationVersionId = applicationVersionId
            self.cloudWatchLoggingOptionDescriptions = cloudWatchLoggingOptionDescriptions
            self.createTimestamp = createTimestamp
            self.inputDescriptions = inputDescriptions
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.outputDescriptions = outputDescriptions
            self.referenceDataSourceDescriptions = referenceDataSourceDescriptions
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// This documentation is for version 1 of the Amazon Kinesis Data Analytics API, which only supports SQL applications. Version 2 of the API supports SQL and Java applications. For more information about version 2, see [Amazon Kinesis Data Analytics API V2 Documentation]. Provides application summary information, including the application Amazon Resource Name (ARN), name, and status.
    public struct ApplicationSummary {
        /// ARN of the application.
        /// This member is required.
        public var applicationARN: Swift.String?
        /// Name of the application.
        /// This member is required.
        public var applicationName: Swift.String?
        /// Status of the application.
        /// This member is required.
        public var applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus?

        public init(
            applicationARN: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            applicationStatus: KinesisAnalyticsClientTypes.ApplicationStatus? = nil
        )
        {
            self.applicationARN = applicationARN
            self.applicationName = applicationName
            self.applicationStatus = applicationStatus
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes CloudWatch logging option updates.
    public struct CloudWatchLoggingOptionUpdate {
        /// ID of the CloudWatch logging option to update
        /// This member is required.
        public var cloudWatchLoggingOptionId: Swift.String?
        /// ARN of the CloudWatch log to receive application messages.
        public var logStreamARNUpdate: Swift.String?
        /// IAM ARN of the role to use to send application messages. Note: To write application messages to CloudWatch, the IAM role used must have the PutLogEvents policy action enabled.
        public var roleARNUpdate: Swift.String?

        public init(
            cloudWatchLoggingOptionId: Swift.String? = nil,
            logStreamARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
            self.logStreamARNUpdate = logStreamARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Provides updates to the parallelism count.
    public struct InputParallelismUpdate {
        /// Number of in-application streams to create for the specified streaming source.
        public var countUpdate: Swift.Int?

        public init(
            countUpdate: Swift.Int? = nil
        )
        {
            self.countUpdate = countUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Represents an update to the [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html) that is used to preprocess the records in the stream.
    public struct InputLambdaProcessorUpdate {
        /// The Amazon Resource Name (ARN) of the new [AWS Lambda](https://docs.aws.amazon.com/lambda/) function that is used to preprocess the records in the stream. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        public var resourceARNUpdate: Swift.String?
        /// The ARN of the new IAM role that is used to access the AWS Lambda function.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to an [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html).
    public struct InputProcessingConfigurationUpdate {
        /// Provides update information for an [InputLambdaProcessor](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputLambdaProcessor.html).
        /// This member is required.
        public var inputLambdaProcessorUpdate: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate?

        public init(
            inputLambdaProcessorUpdate: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate? = nil
        )
        {
            self.inputLambdaProcessorUpdate = inputLambdaProcessorUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes updates for the application's input schema.
    public struct InputSchemaUpdate {
        /// A list of RecordColumn objects. Each object describes the mapping of the streaming source element to the corresponding column in the in-application stream.
        public var recordColumnUpdates: [KinesisAnalyticsClientTypes.RecordColumn]?
        /// Specifies the encoding of the records in the streaming source. For example, UTF-8.
        public var recordEncodingUpdate: Swift.String?
        /// Specifies the format of the records on the streaming source.
        public var recordFormatUpdate: KinesisAnalyticsClientTypes.RecordFormat?

        public init(
            recordColumnUpdates: [KinesisAnalyticsClientTypes.RecordColumn]? = nil,
            recordEncodingUpdate: Swift.String? = nil,
            recordFormatUpdate: KinesisAnalyticsClientTypes.RecordFormat? = nil
        )
        {
            self.recordColumnUpdates = recordColumnUpdates
            self.recordEncodingUpdate = recordEncodingUpdate
            self.recordFormatUpdate = recordFormatUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When updating application input configuration, provides information about an Amazon Kinesis Firehose delivery stream as the streaming source.
    public struct KinesisFirehoseInputUpdate {
        /// Amazon Resource Name (ARN) of the input Amazon Kinesis Firehose delivery stream to read.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When updating application input configuration, provides information about an Amazon Kinesis stream as the streaming source.
    public struct KinesisStreamsInputUpdate {
        /// Amazon Resource Name (ARN) of the input Amazon Kinesis stream to read.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to a specific input configuration (identified by the InputId of an application).
    public struct InputUpdate {
        /// Input ID of the application input to be updated.
        /// This member is required.
        public var inputId: Swift.String?
        /// Describes the parallelism updates (the number in-application streams Amazon Kinesis Analytics creates for the specific streaming source).
        public var inputParallelismUpdate: KinesisAnalyticsClientTypes.InputParallelismUpdate?
        /// Describes updates for an input processing configuration.
        public var inputProcessingConfigurationUpdate: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate?
        /// Describes the data format on the streaming source, and how record elements on the streaming source map to columns of the in-application stream that is created.
        public var inputSchemaUpdate: KinesisAnalyticsClientTypes.InputSchemaUpdate?
        /// If an Amazon Kinesis Firehose delivery stream is the streaming source to be updated, provides an updated stream ARN and IAM role ARN.
        public var kinesisFirehoseInputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate?
        /// If an Amazon Kinesis stream is the streaming source to be updated, provides an updated stream Amazon Resource Name (ARN) and IAM role ARN.
        public var kinesisStreamsInputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate?
        /// Name prefix for in-application streams that Amazon Kinesis Analytics creates for the specific streaming source.
        public var namePrefixUpdate: Swift.String?

        public init(
            inputId: Swift.String? = nil,
            inputParallelismUpdate: KinesisAnalyticsClientTypes.InputParallelismUpdate? = nil,
            inputProcessingConfigurationUpdate: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate? = nil,
            inputSchemaUpdate: KinesisAnalyticsClientTypes.InputSchemaUpdate? = nil,
            kinesisFirehoseInputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate? = nil,
            kinesisStreamsInputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate? = nil,
            namePrefixUpdate: Swift.String? = nil
        )
        {
            self.inputId = inputId
            self.inputParallelismUpdate = inputParallelismUpdate
            self.inputProcessingConfigurationUpdate = inputProcessingConfigurationUpdate
            self.inputSchemaUpdate = inputSchemaUpdate
            self.kinesisFirehoseInputUpdate = kinesisFirehoseInputUpdate
            self.kinesisStreamsInputUpdate = kinesisStreamsInputUpdate
            self.namePrefixUpdate = namePrefixUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an Amazon Kinesis Firehose delivery stream configured as the destination.
    public struct KinesisFirehoseOutputUpdate {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis Firehose delivery stream to write to.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an Amazon Kinesis stream configured as the destination.
    public struct KinesisStreamsOutputUpdate {
        /// Amazon Resource Name (ARN) of the Amazon Kinesis stream where you want to write the output.
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When updating an output configuration using the [UpdateApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_UpdateApplication.html) operation, provides information about an AWS Lambda function configured as the destination.
    public struct LambdaOutputUpdate {
        /// Amazon Resource Name (ARN) of the destination Lambda function. To specify an earlier version of the Lambda function than the latest, include the Lambda function version in the Lambda function ARN. For more information about Lambda ARNs, see [Example ARNs: AWS Lambda]
        public var resourceARNUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to write to the destination function on your behalf. You need to grant the necessary permissions to this role.
        public var roleARNUpdate: Swift.String?

        public init(
            resourceARNUpdate: Swift.String? = nil,
            roleARNUpdate: Swift.String? = nil
        )
        {
            self.resourceARNUpdate = resourceARNUpdate
            self.roleARNUpdate = roleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to the output configuration identified by the OutputId.
    public struct OutputUpdate {
        /// Describes the data format when records are written to the destination. For more information, see [Configuring Application Output](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-output.html).
        public var destinationSchemaUpdate: KinesisAnalyticsClientTypes.DestinationSchema?
        /// Describes an Amazon Kinesis Firehose delivery stream as the destination for the output.
        public var kinesisFirehoseOutputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate?
        /// Describes an Amazon Kinesis stream as the destination for the output.
        public var kinesisStreamsOutputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate?
        /// Describes an AWS Lambda function as the destination for the output.
        public var lambdaOutputUpdate: KinesisAnalyticsClientTypes.LambdaOutputUpdate?
        /// If you want to specify a different in-application stream for this output configuration, use this field to specify the new in-application stream name.
        public var nameUpdate: Swift.String?
        /// Identifies the specific output configuration that you want to update.
        /// This member is required.
        public var outputId: Swift.String?

        public init(
            destinationSchemaUpdate: KinesisAnalyticsClientTypes.DestinationSchema? = nil,
            kinesisFirehoseOutputUpdate: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate? = nil,
            kinesisStreamsOutputUpdate: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate? = nil,
            lambdaOutputUpdate: KinesisAnalyticsClientTypes.LambdaOutputUpdate? = nil,
            nameUpdate: Swift.String? = nil,
            outputId: Swift.String? = nil
        )
        {
            self.destinationSchemaUpdate = destinationSchemaUpdate
            self.kinesisFirehoseOutputUpdate = kinesisFirehoseOutputUpdate
            self.kinesisStreamsOutputUpdate = kinesisStreamsOutputUpdate
            self.lambdaOutputUpdate = lambdaOutputUpdate
            self.nameUpdate = nameUpdate
            self.outputId = outputId
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
    public struct S3ReferenceDataSourceUpdate {
        /// Amazon Resource Name (ARN) of the S3 bucket.
        public var bucketARNUpdate: Swift.String?
        /// Object key name.
        public var fileKeyUpdate: Swift.String?
        /// ARN of the IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object and populate the in-application.
        public var referenceRoleARNUpdate: Swift.String?

        public init(
            bucketARNUpdate: Swift.String? = nil,
            fileKeyUpdate: Swift.String? = nil,
            referenceRoleARNUpdate: Swift.String? = nil
        )
        {
            self.bucketARNUpdate = bucketARNUpdate
            self.fileKeyUpdate = fileKeyUpdate
            self.referenceRoleARNUpdate = referenceRoleARNUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// When you update a reference data source configuration for an application, this object provides all the updated values (such as the source bucket name and object key name), the in-application table name that is created, and updated mapping information that maps the data in the Amazon S3 object to the in-application reference table that is created.
    public struct ReferenceDataSourceUpdate {
        /// ID of the reference data source being updated. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get this value.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
        public var referenceSchemaUpdate: KinesisAnalyticsClientTypes.SourceSchema?
        /// Describes the S3 bucket name, object key name, and IAM role that Amazon Kinesis Analytics can assume to read the Amazon S3 object on your behalf and populate the in-application reference table.
        public var s3ReferenceDataSourceUpdate: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate?
        /// In-application table name that is created by this update.
        public var tableNameUpdate: Swift.String?

        public init(
            referenceId: Swift.String? = nil,
            referenceSchemaUpdate: KinesisAnalyticsClientTypes.SourceSchema? = nil,
            s3ReferenceDataSourceUpdate: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate? = nil,
            tableNameUpdate: Swift.String? = nil
        )
        {
            self.referenceId = referenceId
            self.referenceSchemaUpdate = referenceSchemaUpdate
            self.s3ReferenceDataSourceUpdate = s3ReferenceDataSourceUpdate
            self.tableNameUpdate = tableNameUpdate
        }
    }

}

extension KinesisAnalyticsClientTypes {
    /// Describes updates to apply to an existing Amazon Kinesis Analytics application.
    public struct ApplicationUpdate {
        /// Describes application code updates.
        public var applicationCodeUpdate: Swift.String?
        /// Describes application CloudWatch logging option updates.
        public var cloudWatchLoggingOptionUpdates: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]?
        /// Describes application input configuration updates.
        public var inputUpdates: [KinesisAnalyticsClientTypes.InputUpdate]?
        /// Describes application output configuration updates.
        public var outputUpdates: [KinesisAnalyticsClientTypes.OutputUpdate]?
        /// Describes application reference data source updates.
        public var referenceDataSourceUpdates: [KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]?

        public init(
            applicationCodeUpdate: Swift.String? = nil,
            cloudWatchLoggingOptionUpdates: [KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate]? = nil,
            inputUpdates: [KinesisAnalyticsClientTypes.InputUpdate]? = nil,
            outputUpdates: [KinesisAnalyticsClientTypes.OutputUpdate]? = nil,
            referenceDataSourceUpdates: [KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate]? = nil
        )
        {
            self.applicationCodeUpdate = applicationCodeUpdate
            self.cloudWatchLoggingOptionUpdates = cloudWatchLoggingOptionUpdates
            self.inputUpdates = inputUpdates
            self.outputUpdates = outputUpdates
            self.referenceDataSourceUpdates = referenceDataSourceUpdates
        }
    }

}

/// Exceeded the number of applications allowed.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Application created with too many tags, or too many tags added to an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisAnalyticsClientTypes {
    /// A key-value pair (the value is optional) that you can define and assign to AWS resources. If you specify a tag that already exists, the tag value is replaced with the value that you specify in the request. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html).
    public struct Tag {
        /// The key of the key-value tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key-value tag. The value is optional.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

/// TBD
public struct CreateApplicationInput {
    /// One or more SQL statements that read input data, transform it, and generate output. For example, you can write a SQL statement that reads data from one in-application stream, generates a running average of the number of advertisement clicks by vendor, and insert resulting rows in another in-application stream using pumps. For more information about the typical pattern, see [Application Code](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-it-works-app-code.html). You can provide such series of SQL statements, where output of one statement can be used as the input for the next statement. You store intermediate results by creating in-application streams and pumps. Note that the application code must create the streams with names specified in the Outputs. For example, if your Outputs defines output streams named ExampleOutputStream1 and ExampleOutputStream2, then your application code must create these streams.
    public var applicationCode: Swift.String?
    /// Summary description of the application.
    public var applicationDescription: Swift.String?
    /// Name of your Amazon Kinesis Analytics application (for example, sample-app).
    /// This member is required.
    public var applicationName: Swift.String?
    /// Use this parameter to configure a CloudWatch log stream to monitor application configuration errors. For more information, see [Working with Amazon CloudWatch Logs](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/cloudwatch-logs.html).
    public var cloudWatchLoggingOptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]?
    /// Use this parameter to configure the application input. You can configure your application to receive input from a single streaming source. In this configuration, you map this streaming source to an in-application stream that is created. Your application code can then query the in-application stream like a table (you can think of it as a constantly updating table). For the streaming source, you provide its Amazon Resource Name (ARN) and format of data on the stream (for example, JSON, CSV, etc.). You also must provide an IAM role that Amazon Kinesis Analytics can assume to read this stream on your behalf. To create the in-application stream, you need to specify a schema to transform your data into a schematized version used in SQL. In the schema, you provide the necessary mapping of the data elements in the streaming source to record columns in the in-app stream.
    public var inputs: [KinesisAnalyticsClientTypes.Input]?
    /// You can configure application output to write data from any of the in-application streams to up to three destinations. These destinations can be Amazon Kinesis streams, Amazon Kinesis Firehose delivery streams, AWS Lambda destinations, or any combination of the three. In the configuration, you specify the in-application stream name, the destination stream or Lambda function Amazon Resource Name (ARN), and the format to use when writing data. You must also provide an IAM role that Amazon Kinesis Analytics can assume to write to the destination stream or Lambda function on your behalf. In the output configuration, you also provide the output stream or Lambda function ARN. For stream destinations, you provide the format of data in the stream (for example, JSON, CSV). You also must provide an IAM role that Amazon Kinesis Analytics can assume to write to the stream or Lambda function on your behalf.
    public var outputs: [KinesisAnalyticsClientTypes.Output]?
    /// A list of one or more tags to assign to the application. A tag is a key-value pair that identifies an application. Note that the maximum number of application tags includes system tags. The maximum number of user-defined application tags is 50. For more information, see [Using Tagging](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/how-tagging.html).
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init(
        applicationCode: Swift.String? = nil,
        applicationDescription: Swift.String? = nil,
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptions: [KinesisAnalyticsClientTypes.CloudWatchLoggingOption]? = nil,
        inputs: [KinesisAnalyticsClientTypes.Input]? = nil,
        outputs: [KinesisAnalyticsClientTypes.Output]? = nil,
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.applicationCode = applicationCode
        self.applicationDescription = applicationDescription
        self.applicationName = applicationName
        self.cloudWatchLoggingOptions = cloudWatchLoggingOptions
        self.inputs = inputs
        self.outputs = outputs
        self.tags = tags
    }
}

/// TBD
public struct CreateApplicationOutput {
    /// In response to your CreateApplication request, Amazon Kinesis Analytics returns a response with a summary of the application it created, including the application Amazon Resource Name (ARN), name, and status.
    /// This member is required.
    public var applicationSummary: KinesisAnalyticsClientTypes.ApplicationSummary?

    public init(
        applicationSummary: KinesisAnalyticsClientTypes.ApplicationSummary? = nil
    )
    {
        self.applicationSummary = applicationSummary
    }
}

///
public struct DeleteApplicationInput {
    /// Name of the Amazon Kinesis Analytics application to delete.
    /// This member is required.
    public var applicationName: Swift.String?
    /// You can use the DescribeApplication operation to get this value.
    /// This member is required.
    public var createTimestamp: Foundation.Date?

    public init(
        applicationName: Swift.String? = nil,
        createTimestamp: Foundation.Date? = nil
    )
    {
        self.applicationName = applicationName
        self.createTimestamp = createTimestamp
    }
}

///
public struct DeleteApplicationOutput {

    public init() { }
}

public struct DeleteApplicationCloudWatchLoggingOptionInput {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The CloudWatchLoggingOptionId of the CloudWatch logging option to delete. You can get the CloudWatchLoggingOptionId by using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var cloudWatchLoggingOptionId: Swift.String?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        cloudWatchLoggingOptionId: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.cloudWatchLoggingOptionId = cloudWatchLoggingOptionId
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

public struct DeleteApplicationCloudWatchLoggingOptionOutput {

    public init() { }
}

public struct DeleteApplicationInputProcessingConfigurationInput {
    /// The Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// The version ID of the Kinesis Analytics application.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the input configuration from which to delete the input processing configuration. You can get a list of the input IDs for an application by using the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
    /// This member is required.
    public var inputId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        inputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.inputId = inputId
    }
}

public struct DeleteApplicationInputProcessingConfigurationOutput {

    public init() { }
}

///
public struct DeleteApplicationOutputInput {
    /// Amazon Kinesis Analytics application name.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Amazon Kinesis Analytics application version. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// The ID of the configuration to delete. Each output configuration that is added to the application, either when the application is created or later using the [AddApplicationOutput](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationOutput.html) operation, has a unique ID. You need to provide the ID to uniquely identify the output configuration that you want to delete from the application configuration. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the specific OutputId.
    /// This member is required.
    public var outputId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        outputId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.outputId = outputId
    }
}

///
public struct DeleteApplicationOutputOutput {

    public init() { }
}

public struct DeleteApplicationReferenceDataSourceInput {
    /// Name of an existing application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Version of the application. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the current application version. If the version specified is not the current version, the ConcurrentModificationException is returned.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?
    /// ID of the reference data source. When you add a reference data source to your application using the [AddApplicationReferenceDataSource](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_AddApplicationReferenceDataSource.html), Amazon Kinesis Analytics assigns an ID. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get the reference ID.
    /// This member is required.
    public var referenceId: Swift.String?

    public init(
        applicationName: Swift.String? = nil,
        currentApplicationVersionId: Swift.Int? = nil,
        referenceId: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
        self.currentApplicationVersionId = currentApplicationVersionId
        self.referenceId = referenceId
    }
}

public struct DeleteApplicationReferenceDataSourceOutput {

    public init() { }
}

///
public struct DescribeApplicationInput {
    /// Name of the application.
    /// This member is required.
    public var applicationName: Swift.String?

    public init(
        applicationName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

///
public struct DescribeApplicationOutput {
    /// Provides a description of the application, such as the application Amazon Resource Name (ARN), status, latest version, and input and output configuration details.
    /// This member is required.
    public var applicationDetail: KinesisAnalyticsClientTypes.ApplicationDetail?

    public init(
        applicationDetail: KinesisAnalyticsClientTypes.ApplicationDetail? = nil
    )
    {
        self.applicationDetail = applicationDetail
    }
}

/// Discovery failed to get a record from the streaming source because of the Amazon Kinesis Streams ProvisionedThroughputExceededException. For more information, see [GetRecords](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html) in the Amazon Kinesis Streams API Reference.
public struct ResourceProvisionedThroughputExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceProvisionedThroughputExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is unavailable. Back off and retry the operation.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Data format is not valid. Amazon Kinesis Analytics is not able to detect schema for the given streaming source.
public struct UnableToDetectSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var processedInputRecords: [Swift.String]? = nil
        public internal(set) var rawInputRecords: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnableToDetectSchemaException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.properties.message = message
        self.properties.processedInputRecords = processedInputRecords
        self.properties.rawInputRecords = rawInputRecords
    }
}

extension KinesisAnalyticsClientTypes {
    /// Provides a description of an Amazon S3 data source, including the Amazon Resource Name (ARN) of the S3 bucket, the ARN of the IAM role that is used to access the bucket, and the name of the Amazon S3 object that contains the data.
    public struct S3Configuration {
        /// ARN of the S3 bucket that contains the data.
        /// This member is required.
        public var bucketARN: Swift.String?
        /// The name of the object that contains the data.
        /// This member is required.
        public var fileKey: Swift.String?
        /// IAM ARN of the role used to access the data.
        /// This member is required.
        public var roleARN: Swift.String?

        public init(
            bucketARN: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.bucketARN = bucketARN
            self.fileKey = fileKey
            self.roleARN = roleARN
        }
    }

}

public struct DiscoverInputSchemaInput {
    /// The [InputProcessingConfiguration](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_InputProcessingConfiguration.html) to use to preprocess the records before discovering the schema of the records.
    public var inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration?
    /// Point at which you want Amazon Kinesis Analytics to start reading records from the specified streaming source discovery purposes.
    public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?
    /// Amazon Resource Name (ARN) of the streaming source.
    public var resourceARN: Swift.String?
    /// ARN of the IAM role that Amazon Kinesis Analytics can assume to access the stream on your behalf.
    public var roleARN: Swift.String?
    /// Specify this parameter to discover a schema from data in an Amazon S3 object.
    public var s3Configuration: KinesisAnalyticsClientTypes.S3Configuration?

    public init(
        inputProcessingConfiguration: KinesisAnalyticsClientTypes.InputProcessingConfiguration? = nil,
        inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil,
        resourceARN: Swift.String? = nil,
        roleARN: Swift.String? = nil,
        s3Configuration: KinesisAnalyticsClientTypes.S3Configuration? = nil
    )
    {
        self.inputProcessingConfiguration = inputProcessingConfiguration
        self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        self.resourceARN = resourceARN
        self.roleARN = roleARN
        self.s3Configuration = s3Configuration
    }
}

///
public struct DiscoverInputSchemaOutput {
    /// Schema inferred from the streaming source. It identifies the format of the data in the streaming source and how each data element maps to corresponding columns in the in-application stream that you can create.
    public var inputSchema: KinesisAnalyticsClientTypes.SourceSchema?
    /// An array of elements, where each element corresponds to a row in a stream record (a stream record can have more than one row).
    public var parsedInputRecords: [[Swift.String]]?
    /// Stream data that was modified by the processor specified in the InputProcessingConfiguration parameter.
    public var processedInputRecords: [Swift.String]?
    /// Raw stream data that was sampled to infer the schema.
    public var rawInputRecords: [Swift.String]?

    public init(
        inputSchema: KinesisAnalyticsClientTypes.SourceSchema? = nil,
        parsedInputRecords: [[Swift.String]]? = nil,
        processedInputRecords: [Swift.String]? = nil,
        rawInputRecords: [Swift.String]? = nil
    )
    {
        self.inputSchema = inputSchema
        self.parsedInputRecords = parsedInputRecords
        self.processedInputRecords = processedInputRecords
        self.rawInputRecords = rawInputRecords
    }
}

extension KinesisAnalyticsClientTypes {
    /// When you start your application, you provide this configuration, which identifies the input source and the point in the input source at which you want the application to start processing records.
    public struct InputConfiguration {
        /// Input source ID. You can get this ID by calling the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation.
        /// This member is required.
        public var id: Swift.String?
        /// Point at which you want the application to start processing records from the streaming source.
        /// This member is required.
        public var inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?

        public init(
            id: Swift.String? = nil,
            inputStartingPositionConfiguration: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration? = nil
        )
        {
            self.id = id
            self.inputStartingPositionConfiguration = inputStartingPositionConfiguration
        }
    }

}

/// User-provided application configuration is not valid.
public struct InvalidApplicationConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// test
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidApplicationConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ListApplicationsInput {
    /// Name of the application to start the list with. When using pagination to retrieve the list, you don't need to specify this parameter in the first request. However, in subsequent requests, you add the last application name from the previous response to get the next page of applications.
    public var exclusiveStartApplicationName: Swift.String?
    /// Maximum number of applications to list.
    public var limit: Swift.Int?

    public init(
        exclusiveStartApplicationName: Swift.String? = nil,
        limit: Swift.Int? = nil
    )
    {
        self.exclusiveStartApplicationName = exclusiveStartApplicationName
        self.limit = limit
    }
}

///
public struct ListApplicationsOutput {
    /// List of ApplicationSummary objects.
    /// This member is required.
    public var applicationSummaries: [KinesisAnalyticsClientTypes.ApplicationSummary]?
    /// Returns true if there are more applications to retrieve.
    /// This member is required.
    public var hasMoreApplications: Swift.Bool?

    public init(
        applicationSummaries: [KinesisAnalyticsClientTypes.ApplicationSummary]? = nil,
        hasMoreApplications: Swift.Bool? = nil
    )
    {
        self.applicationSummaries = applicationSummaries
        self.hasMoreApplications = hasMoreApplications
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the application for which to retrieve tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value tags assigned to the application.
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init(
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

///
public struct StartApplicationInput {
    /// Name of the application.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Identifies the specific input, by ID, that the application starts consuming. Amazon Kinesis Analytics starts reading the streaming source associated with the input. You can also specify where in the streaming source you want Amazon Kinesis Analytics to start reading.
    /// This member is required.
    public var inputConfigurations: [KinesisAnalyticsClientTypes.InputConfiguration]?

    public init(
        applicationName: Swift.String? = nil,
        inputConfigurations: [KinesisAnalyticsClientTypes.InputConfiguration]? = nil
    )
    {
        self.applicationName = applicationName
        self.inputConfigurations = inputConfigurations
    }
}

///
public struct StartApplicationOutput {

    public init() { }
}

///
public struct StopApplicationInput {
    /// Name of the running application to stop.
    /// This member is required.
    public var applicationName: Swift.String?

    public init(
        applicationName: Swift.String? = nil
    )
    {
        self.applicationName = applicationName
    }
}

///
public struct StopApplicationOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The ARN of the application to assign the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value tags to assign to the application.
    /// This member is required.
    public var tags: [KinesisAnalyticsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [KinesisAnalyticsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the Kinesis Analytics application from which to remove the tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of keys of tags to remove from the specified application.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateApplicationInput {
    /// Name of the Amazon Kinesis Analytics application to update.
    /// This member is required.
    public var applicationName: Swift.String?
    /// Describes application updates.
    /// This member is required.
    public var applicationUpdate: KinesisAnalyticsClientTypes.ApplicationUpdate?
    /// The current application version ID. You can use the [DescribeApplication](https://docs.aws.amazon.com/kinesisanalytics/latest/dev/API_DescribeApplication.html) operation to get this value.
    /// This member is required.
    public var currentApplicationVersionId: Swift.Int?

    public init(
        applicationName: Swift.String? = nil,
        applicationUpdate: KinesisAnalyticsClientTypes.ApplicationUpdate? = nil,
        currentApplicationVersionId: Swift.Int? = nil
    )
    {
        self.applicationName = applicationName
        self.applicationUpdate = applicationUpdate
        self.currentApplicationVersionId = currentApplicationVersionId
    }
}

public struct UpdateApplicationOutput {

    public init() { }
}

extension AddApplicationCloudWatchLoggingOptionInput {

    static func urlPathProvider(_ value: AddApplicationCloudWatchLoggingOptionInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationInputInput {

    static func urlPathProvider(_ value: AddApplicationInputInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationInputProcessingConfigurationInput {

    static func urlPathProvider(_ value: AddApplicationInputProcessingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationOutputInput {

    static func urlPathProvider(_ value: AddApplicationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationReferenceDataSourceInput {

    static func urlPathProvider(_ value: AddApplicationReferenceDataSourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput {

    static func urlPathProvider(_ value: DeleteApplicationCloudWatchLoggingOptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInputProcessingConfigurationInput {

    static func urlPathProvider(_ value: DeleteApplicationInputProcessingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationOutputInput {

    static func urlPathProvider(_ value: DeleteApplicationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationReferenceDataSourceInput {

    static func urlPathProvider(_ value: DeleteApplicationReferenceDataSourceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DiscoverInputSchemaInput {

    static func urlPathProvider(_ value: DiscoverInputSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension StartApplicationInput {

    static func urlPathProvider(_ value: StartApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StopApplicationInput {

    static func urlPathProvider(_ value: StopApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension AddApplicationCloudWatchLoggingOptionInput {

    static func write(value: AddApplicationCloudWatchLoggingOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOption"].write(value.cloudWatchLoggingOption, with: KinesisAnalyticsClientTypes.CloudWatchLoggingOption.write(value:to:))
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension AddApplicationInputInput {

    static func write(value: AddApplicationInputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["Input"].write(value.input, with: KinesisAnalyticsClientTypes.Input.write(value:to:))
    }
}

extension AddApplicationInputProcessingConfigurationInput {

    static func write(value: AddApplicationInputProcessingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["InputId"].write(value.inputId)
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsClientTypes.InputProcessingConfiguration.write(value:to:))
    }
}

extension AddApplicationOutputInput {

    static func write(value: AddApplicationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["Output"].write(value.output, with: KinesisAnalyticsClientTypes.Output.write(value:to:))
    }
}

extension AddApplicationReferenceDataSourceInput {

    static func write(value: AddApplicationReferenceDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["ReferenceDataSource"].write(value.referenceDataSource, with: KinesisAnalyticsClientTypes.ReferenceDataSource.write(value:to:))
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationCode"].write(value.applicationCode)
        try writer["ApplicationDescription"].write(value.applicationDescription)
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOptions"].writeList(value.cloudWatchLoggingOptions, memberWritingClosure: KinesisAnalyticsClientTypes.CloudWatchLoggingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Inputs"].writeList(value.inputs, memberWritingClosure: KinesisAnalyticsClientTypes.Input.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: KinesisAnalyticsClientTypes.Output.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisAnalyticsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CreateTimestamp"].writeTimestamp(value.createTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DeleteApplicationCloudWatchLoggingOptionInput {

    static func write(value: DeleteApplicationCloudWatchLoggingOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CloudWatchLoggingOptionId"].write(value.cloudWatchLoggingOptionId)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension DeleteApplicationInputProcessingConfigurationInput {

    static func write(value: DeleteApplicationInputProcessingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["InputId"].write(value.inputId)
    }
}

extension DeleteApplicationOutputInput {

    static func write(value: DeleteApplicationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["OutputId"].write(value.outputId)
    }
}

extension DeleteApplicationReferenceDataSourceInput {

    static func write(value: DeleteApplicationReferenceDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
        try writer["ReferenceId"].write(value.referenceId)
    }
}

extension DescribeApplicationInput {

    static func write(value: DescribeApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
    }
}

extension DiscoverInputSchemaInput {

    static func write(value: DiscoverInputSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsClientTypes.InputProcessingConfiguration.write(value:to:))
        try writer["InputStartingPositionConfiguration"].write(value.inputStartingPositionConfiguration, with: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.write(value:to:))
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
        try writer["S3Configuration"].write(value.s3Configuration, with: KinesisAnalyticsClientTypes.S3Configuration.write(value:to:))
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusiveStartApplicationName"].write(value.exclusiveStartApplicationName)
        try writer["Limit"].write(value.limit)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension StartApplicationInput {

    static func write(value: StartApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["InputConfigurations"].writeList(value.inputConfigurations, memberWritingClosure: KinesisAnalyticsClientTypes.InputConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StopApplicationInput {

    static func write(value: StopApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisAnalyticsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["ApplicationUpdate"].write(value.applicationUpdate, with: KinesisAnalyticsClientTypes.ApplicationUpdate.write(value:to:))
        try writer["CurrentApplicationVersionId"].write(value.currentApplicationVersionId)
    }
}

extension AddApplicationCloudWatchLoggingOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationCloudWatchLoggingOptionOutput {
        return AddApplicationCloudWatchLoggingOptionOutput()
    }
}

extension AddApplicationInputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationInputOutput {
        return AddApplicationInputOutput()
    }
}

extension AddApplicationInputProcessingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationInputProcessingConfigurationOutput {
        return AddApplicationInputProcessingConfigurationOutput()
    }
}

extension AddApplicationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationOutputOutput {
        return AddApplicationOutputOutput()
    }
}

extension AddApplicationReferenceDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddApplicationReferenceDataSourceOutput {
        return AddApplicationReferenceDataSourceOutput()
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationSummary = try reader["ApplicationSummary"].readIfPresent(with: KinesisAnalyticsClientTypes.ApplicationSummary.read(from:))
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteApplicationCloudWatchLoggingOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationCloudWatchLoggingOptionOutput {
        return DeleteApplicationCloudWatchLoggingOptionOutput()
    }
}

extension DeleteApplicationInputProcessingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationInputProcessingConfigurationOutput {
        return DeleteApplicationInputProcessingConfigurationOutput()
    }
}

extension DeleteApplicationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutputOutput {
        return DeleteApplicationOutputOutput()
    }
}

extension DeleteApplicationReferenceDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationReferenceDataSourceOutput {
        return DeleteApplicationReferenceDataSourceOutput()
    }
}

extension DescribeApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOutput()
        value.applicationDetail = try reader["ApplicationDetail"].readIfPresent(with: KinesisAnalyticsClientTypes.ApplicationDetail.read(from:))
        return value
    }
}

extension DiscoverInputSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DiscoverInputSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DiscoverInputSchemaOutput()
        value.inputSchema = try reader["InputSchema"].readIfPresent(with: KinesisAnalyticsClientTypes.SourceSchema.read(from:))
        value.parsedInputRecords = try reader["ParsedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.processedInputRecords = try reader["ProcessedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rawInputRecords = try reader["RawInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applicationSummaries = try reader["ApplicationSummaries"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.hasMoreApplications = try reader["HasMoreApplications"].readIfPresent() ?? false
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartApplicationOutput {
        return StartApplicationOutput()
    }
}

extension StopApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopApplicationOutput {
        return StopApplicationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

enum AddApplicationCloudWatchLoggingOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationInputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationInputProcessingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddApplicationReferenceDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationCloudWatchLoggingOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationInputProcessingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationReferenceDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DiscoverInputSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceProvisionedThroughputExceededException": return try ResourceProvisionedThroughputExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnableToDetectSchemaException": return try UnableToDetectSchemaException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidApplicationConfigurationException": return try InvalidApplicationConfigurationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CodeValidationException": return try CodeValidationException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CodeValidationException {
        let reader = baseError.errorBodyReader
        var value = CodeValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnableToDetectSchemaException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnableToDetectSchemaException {
        let reader = baseError.errorBodyReader
        var value = UnableToDetectSchemaException()
        value.properties.processedInputRecords = try reader["ProcessedInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.rawInputRecords = try reader["RawInputRecords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceProvisionedThroughputExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceProvisionedThroughputExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceProvisionedThroughputExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidApplicationConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidApplicationConfigurationException {
        let reader = baseError.errorBodyReader
        var value = InvalidApplicationConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KinesisAnalyticsClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.ApplicationSummary()
        value.applicationName = try reader["ApplicationName"].readIfPresent() ?? ""
        value.applicationARN = try reader["ApplicationARN"].readIfPresent() ?? ""
        value.applicationStatus = try reader["ApplicationStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisAnalyticsClientTypes.ApplicationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.ApplicationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.ApplicationDetail()
        value.applicationName = try reader["ApplicationName"].readIfPresent() ?? ""
        value.applicationDescription = try reader["ApplicationDescription"].readIfPresent()
        value.applicationARN = try reader["ApplicationARN"].readIfPresent() ?? ""
        value.applicationStatus = try reader["ApplicationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createTimestamp = try reader["CreateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTimestamp = try reader["LastUpdateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inputDescriptions = try reader["InputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.InputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputDescriptions = try reader["OutputDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.OutputDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.referenceDataSourceDescriptions = try reader["ReferenceDataSourceDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.ReferenceDataSourceDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cloudWatchLoggingOptionDescriptions = try reader["CloudWatchLoggingOptionDescriptions"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationCode = try reader["ApplicationCode"].readIfPresent()
        value.applicationVersionId = try reader["ApplicationVersionId"].readIfPresent() ?? 0
        return value
    }
}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.CloudWatchLoggingOptionDescription()
        value.cloudWatchLoggingOptionId = try reader["CloudWatchLoggingOptionId"].readIfPresent()
        value.logStreamARN = try reader["LogStreamARN"].readIfPresent() ?? ""
        value.roleARN = try reader["RoleARN"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsClientTypes.ReferenceDataSourceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.ReferenceDataSourceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.ReferenceDataSourceDescription()
        value.referenceId = try reader["ReferenceId"].readIfPresent() ?? ""
        value.tableName = try reader["TableName"].readIfPresent() ?? ""
        value.s3ReferenceDataSourceDescription = try reader["S3ReferenceDataSourceDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription.read(from:))
        value.referenceSchema = try reader["ReferenceSchema"].readIfPresent(with: KinesisAnalyticsClientTypes.SourceSchema.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.SourceSchema {

    static func write(value: KinesisAnalyticsClientTypes.SourceSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumns"].writeList(value.recordColumns, memberWritingClosure: KinesisAnalyticsClientTypes.RecordColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordEncoding"].write(value.recordEncoding)
        try writer["RecordFormat"].write(value.recordFormat, with: KinesisAnalyticsClientTypes.RecordFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.SourceSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.SourceSchema()
        value.recordFormat = try reader["RecordFormat"].readIfPresent(with: KinesisAnalyticsClientTypes.RecordFormat.read(from:))
        value.recordEncoding = try reader["RecordEncoding"].readIfPresent()
        value.recordColumns = try reader["RecordColumns"].readListIfPresent(memberReadingClosure: KinesisAnalyticsClientTypes.RecordColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension KinesisAnalyticsClientTypes.RecordColumn {

    static func write(value: KinesisAnalyticsClientTypes.RecordColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mapping"].write(value.mapping)
        try writer["Name"].write(value.name)
        try writer["SqlType"].write(value.sqlType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.RecordColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.RecordColumn()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.mapping = try reader["Mapping"].readIfPresent()
        value.sqlType = try reader["SqlType"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsClientTypes.RecordFormat {

    static func write(value: KinesisAnalyticsClientTypes.RecordFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MappingParameters"].write(value.mappingParameters, with: KinesisAnalyticsClientTypes.MappingParameters.write(value:to:))
        try writer["RecordFormatType"].write(value.recordFormatType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.RecordFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.RecordFormat()
        value.recordFormatType = try reader["RecordFormatType"].readIfPresent() ?? .sdkUnknown("")
        value.mappingParameters = try reader["MappingParameters"].readIfPresent(with: KinesisAnalyticsClientTypes.MappingParameters.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.MappingParameters {

    static func write(value: KinesisAnalyticsClientTypes.MappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CSVMappingParameters"].write(value.csvMappingParameters, with: KinesisAnalyticsClientTypes.CSVMappingParameters.write(value:to:))
        try writer["JSONMappingParameters"].write(value.jsonMappingParameters, with: KinesisAnalyticsClientTypes.JSONMappingParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.MappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.MappingParameters()
        value.jsonMappingParameters = try reader["JSONMappingParameters"].readIfPresent(with: KinesisAnalyticsClientTypes.JSONMappingParameters.read(from:))
        value.csvMappingParameters = try reader["CSVMappingParameters"].readIfPresent(with: KinesisAnalyticsClientTypes.CSVMappingParameters.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.CSVMappingParameters {

    static func write(value: KinesisAnalyticsClientTypes.CSVMappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumnDelimiter"].write(value.recordColumnDelimiter)
        try writer["RecordRowDelimiter"].write(value.recordRowDelimiter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.CSVMappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.CSVMappingParameters()
        value.recordRowDelimiter = try reader["RecordRowDelimiter"].readIfPresent() ?? ""
        value.recordColumnDelimiter = try reader["RecordColumnDelimiter"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsClientTypes.JSONMappingParameters {

    static func write(value: KinesisAnalyticsClientTypes.JSONMappingParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordRowPath"].write(value.recordRowPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.JSONMappingParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.JSONMappingParameters()
        value.recordRowPath = try reader["RecordRowPath"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.S3ReferenceDataSourceDescription()
        value.bucketARN = try reader["BucketARN"].readIfPresent() ?? ""
        value.fileKey = try reader["FileKey"].readIfPresent() ?? ""
        value.referenceRoleARN = try reader["ReferenceRoleARN"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisAnalyticsClientTypes.OutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.OutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.OutputDescription()
        value.outputId = try reader["OutputId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.kinesisStreamsOutputDescription = try reader["KinesisStreamsOutputDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription.read(from:))
        value.kinesisFirehoseOutputDescription = try reader["KinesisFirehoseOutputDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription.read(from:))
        value.lambdaOutputDescription = try reader["LambdaOutputDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.LambdaOutputDescription.read(from:))
        value.destinationSchema = try reader["DestinationSchema"].readIfPresent(with: KinesisAnalyticsClientTypes.DestinationSchema.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.DestinationSchema {

    static func write(value: KinesisAnalyticsClientTypes.DestinationSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordFormatType"].write(value.recordFormatType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.DestinationSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.DestinationSchema()
        value.recordFormatType = try reader["RecordFormatType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisAnalyticsClientTypes.LambdaOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.LambdaOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.LambdaOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.KinesisFirehoseOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.KinesisStreamsOutputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.InputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.InputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.InputDescription()
        value.inputId = try reader["InputId"].readIfPresent()
        value.namePrefix = try reader["NamePrefix"].readIfPresent()
        value.inAppStreamNames = try reader["InAppStreamNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputProcessingConfigurationDescription = try reader["InputProcessingConfigurationDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription.read(from:))
        value.kinesisStreamsInputDescription = try reader["KinesisStreamsInputDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.KinesisStreamsInputDescription.read(from:))
        value.kinesisFirehoseInputDescription = try reader["KinesisFirehoseInputDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription.read(from:))
        value.inputSchema = try reader["InputSchema"].readIfPresent(with: KinesisAnalyticsClientTypes.SourceSchema.read(from:))
        value.inputParallelism = try reader["InputParallelism"].readIfPresent(with: KinesisAnalyticsClientTypes.InputParallelism.read(from:))
        value.inputStartingPositionConfiguration = try reader["InputStartingPositionConfiguration"].readIfPresent(with: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.InputStartingPositionConfiguration {

    static func write(value: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputStartingPosition"].write(value.inputStartingPosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.InputStartingPositionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.InputStartingPositionConfiguration()
        value.inputStartingPosition = try reader["InputStartingPosition"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.InputParallelism {

    static func write(value: KinesisAnalyticsClientTypes.InputParallelism?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Count"].write(value.count)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.InputParallelism {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.InputParallelism()
        value.count = try reader["Count"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.KinesisFirehoseInputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsInputDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.KinesisStreamsInputDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.KinesisStreamsInputDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.InputProcessingConfigurationDescription()
        value.inputLambdaProcessorDescription = try reader["InputLambdaProcessorDescription"].readIfPresent(with: KinesisAnalyticsClientTypes.InputLambdaProcessorDescription.read(from:))
        return value
    }
}

extension KinesisAnalyticsClientTypes.InputLambdaProcessorDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.InputLambdaProcessorDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.InputLambdaProcessorDescription()
        value.resourceARN = try reader["ResourceARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.Tag {

    static func write(value: KinesisAnalyticsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisAnalyticsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisAnalyticsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOption {

    static func write(value: KinesisAnalyticsClientTypes.CloudWatchLoggingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogStreamARN"].write(value.logStreamARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.Input {

    static func write(value: KinesisAnalyticsClientTypes.Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputParallelism"].write(value.inputParallelism, with: KinesisAnalyticsClientTypes.InputParallelism.write(value:to:))
        try writer["InputProcessingConfiguration"].write(value.inputProcessingConfiguration, with: KinesisAnalyticsClientTypes.InputProcessingConfiguration.write(value:to:))
        try writer["InputSchema"].write(value.inputSchema, with: KinesisAnalyticsClientTypes.SourceSchema.write(value:to:))
        try writer["KinesisFirehoseInput"].write(value.kinesisFirehoseInput, with: KinesisAnalyticsClientTypes.KinesisFirehoseInput.write(value:to:))
        try writer["KinesisStreamsInput"].write(value.kinesisStreamsInput, with: KinesisAnalyticsClientTypes.KinesisStreamsInput.write(value:to:))
        try writer["NamePrefix"].write(value.namePrefix)
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInput {

    static func write(value: KinesisAnalyticsClientTypes.KinesisFirehoseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsInput {

    static func write(value: KinesisAnalyticsClientTypes.KinesisStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.InputProcessingConfiguration {

    static func write(value: KinesisAnalyticsClientTypes.InputProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputLambdaProcessor"].write(value.inputLambdaProcessor, with: KinesisAnalyticsClientTypes.InputLambdaProcessor.write(value:to:))
    }
}

extension KinesisAnalyticsClientTypes.InputLambdaProcessor {

    static func write(value: KinesisAnalyticsClientTypes.InputLambdaProcessor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.Output {

    static func write(value: KinesisAnalyticsClientTypes.Output?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationSchema"].write(value.destinationSchema, with: KinesisAnalyticsClientTypes.DestinationSchema.write(value:to:))
        try writer["KinesisFirehoseOutput"].write(value.kinesisFirehoseOutput, with: KinesisAnalyticsClientTypes.KinesisFirehoseOutput.write(value:to:))
        try writer["KinesisStreamsOutput"].write(value.kinesisStreamsOutput, with: KinesisAnalyticsClientTypes.KinesisStreamsOutput.write(value:to:))
        try writer["LambdaOutput"].write(value.lambdaOutput, with: KinesisAnalyticsClientTypes.LambdaOutput.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension KinesisAnalyticsClientTypes.LambdaOutput {

    static func write(value: KinesisAnalyticsClientTypes.LambdaOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutput {

    static func write(value: KinesisAnalyticsClientTypes.KinesisFirehoseOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutput {

    static func write(value: KinesisAnalyticsClientTypes.KinesisStreamsOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.ReferenceDataSource {

    static func write(value: KinesisAnalyticsClientTypes.ReferenceDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReferenceSchema"].write(value.referenceSchema, with: KinesisAnalyticsClientTypes.SourceSchema.write(value:to:))
        try writer["S3ReferenceDataSource"].write(value.s3ReferenceDataSource, with: KinesisAnalyticsClientTypes.S3ReferenceDataSource.write(value:to:))
        try writer["TableName"].write(value.tableName)
    }
}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSource {

    static func write(value: KinesisAnalyticsClientTypes.S3ReferenceDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARN"].write(value.bucketARN)
        try writer["FileKey"].write(value.fileKey)
        try writer["ReferenceRoleARN"].write(value.referenceRoleARN)
    }
}

extension KinesisAnalyticsClientTypes.S3Configuration {

    static func write(value: KinesisAnalyticsClientTypes.S3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARN"].write(value.bucketARN)
        try writer["FileKey"].write(value.fileKey)
        try writer["RoleARN"].write(value.roleARN)
    }
}

extension KinesisAnalyticsClientTypes.InputConfiguration {

    static func write(value: KinesisAnalyticsClientTypes.InputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["InputStartingPositionConfiguration"].write(value.inputStartingPositionConfiguration, with: KinesisAnalyticsClientTypes.InputStartingPositionConfiguration.write(value:to:))
    }
}

extension KinesisAnalyticsClientTypes.ApplicationUpdate {

    static func write(value: KinesisAnalyticsClientTypes.ApplicationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationCodeUpdate"].write(value.applicationCodeUpdate)
        try writer["CloudWatchLoggingOptionUpdates"].writeList(value.cloudWatchLoggingOptionUpdates, memberWritingClosure: KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InputUpdates"].writeList(value.inputUpdates, memberWritingClosure: KinesisAnalyticsClientTypes.InputUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutputUpdates"].writeList(value.outputUpdates, memberWritingClosure: KinesisAnalyticsClientTypes.OutputUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReferenceDataSourceUpdates"].writeList(value.referenceDataSourceUpdates, memberWritingClosure: KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate {

    static func write(value: KinesisAnalyticsClientTypes.CloudWatchLoggingOptionUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLoggingOptionId"].write(value.cloudWatchLoggingOptionId)
        try writer["LogStreamARNUpdate"].write(value.logStreamARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate {

    static func write(value: KinesisAnalyticsClientTypes.ReferenceDataSourceUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReferenceId"].write(value.referenceId)
        try writer["ReferenceSchemaUpdate"].write(value.referenceSchemaUpdate, with: KinesisAnalyticsClientTypes.SourceSchema.write(value:to:))
        try writer["S3ReferenceDataSourceUpdate"].write(value.s3ReferenceDataSourceUpdate, with: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate.write(value:to:))
        try writer["TableNameUpdate"].write(value.tableNameUpdate)
    }
}

extension KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate {

    static func write(value: KinesisAnalyticsClientTypes.S3ReferenceDataSourceUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketARNUpdate"].write(value.bucketARNUpdate)
        try writer["FileKeyUpdate"].write(value.fileKeyUpdate)
        try writer["ReferenceRoleARNUpdate"].write(value.referenceRoleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.OutputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.OutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationSchemaUpdate"].write(value.destinationSchemaUpdate, with: KinesisAnalyticsClientTypes.DestinationSchema.write(value:to:))
        try writer["KinesisFirehoseOutputUpdate"].write(value.kinesisFirehoseOutputUpdate, with: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate.write(value:to:))
        try writer["KinesisStreamsOutputUpdate"].write(value.kinesisStreamsOutputUpdate, with: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate.write(value:to:))
        try writer["LambdaOutputUpdate"].write(value.lambdaOutputUpdate, with: KinesisAnalyticsClientTypes.LambdaOutputUpdate.write(value:to:))
        try writer["NameUpdate"].write(value.nameUpdate)
        try writer["OutputId"].write(value.outputId)
    }
}

extension KinesisAnalyticsClientTypes.LambdaOutputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.LambdaOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.KinesisFirehoseOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.KinesisStreamsOutputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.InputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.InputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputId"].write(value.inputId)
        try writer["InputParallelismUpdate"].write(value.inputParallelismUpdate, with: KinesisAnalyticsClientTypes.InputParallelismUpdate.write(value:to:))
        try writer["InputProcessingConfigurationUpdate"].write(value.inputProcessingConfigurationUpdate, with: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate.write(value:to:))
        try writer["InputSchemaUpdate"].write(value.inputSchemaUpdate, with: KinesisAnalyticsClientTypes.InputSchemaUpdate.write(value:to:))
        try writer["KinesisFirehoseInputUpdate"].write(value.kinesisFirehoseInputUpdate, with: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate.write(value:to:))
        try writer["KinesisStreamsInputUpdate"].write(value.kinesisStreamsInputUpdate, with: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate.write(value:to:))
        try writer["NamePrefixUpdate"].write(value.namePrefixUpdate)
    }
}

extension KinesisAnalyticsClientTypes.InputParallelismUpdate {

    static func write(value: KinesisAnalyticsClientTypes.InputParallelismUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountUpdate"].write(value.countUpdate)
    }
}

extension KinesisAnalyticsClientTypes.InputSchemaUpdate {

    static func write(value: KinesisAnalyticsClientTypes.InputSchemaUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecordColumnUpdates"].writeList(value.recordColumnUpdates, memberWritingClosure: KinesisAnalyticsClientTypes.RecordColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordEncodingUpdate"].write(value.recordEncodingUpdate)
        try writer["RecordFormatUpdate"].write(value.recordFormatUpdate, with: KinesisAnalyticsClientTypes.RecordFormat.write(value:to:))
    }
}

extension KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.KinesisFirehoseInputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate {

    static func write(value: KinesisAnalyticsClientTypes.KinesisStreamsInputUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

extension KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate {

    static func write(value: KinesisAnalyticsClientTypes.InputProcessingConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InputLambdaProcessorUpdate"].write(value.inputLambdaProcessorUpdate, with: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate.write(value:to:))
    }
}

extension KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate {

    static func write(value: KinesisAnalyticsClientTypes.InputLambdaProcessorUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARNUpdate"].write(value.resourceARNUpdate)
        try writer["RoleARNUpdate"].write(value.roleARNUpdate)
    }
}

public enum KinesisAnalyticsClientTypes {}
