// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CostandUsageReportClientTypes {
    /// The region of the S3 bucket that AWS delivers the report into.
    public enum AWSRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bahrain
        case beijing
        case canadaCentral
        case capeTown
        case frankfurt
        case hongKong
        case hyderabad
        case ireland
        case jakarta
        case london
        case milano
        case mumbai
        case ningxia
        case northernCalifornia
        case ohio
        case oregon
        case osaka
        case paris
        case saoPaulo
        case seoul
        case singapore
        case spain
        case stockholm
        case sydney
        case tokyo
        case uae
        case usStandard
        case zurich
        case sdkUnknown(Swift.String)

        public static var allCases: [AWSRegion] {
            return [
                .bahrain,
                .beijing,
                .canadaCentral,
                .capeTown,
                .frankfurt,
                .hongKong,
                .hyderabad,
                .ireland,
                .jakarta,
                .london,
                .milano,
                .mumbai,
                .ningxia,
                .northernCalifornia,
                .ohio,
                .oregon,
                .osaka,
                .paris,
                .saoPaulo,
                .seoul,
                .singapore,
                .spain,
                .stockholm,
                .sydney,
                .tokyo,
                .uae,
                .usStandard,
                .zurich,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bahrain: return "me-south-1"
            case .beijing: return "cn-north-1"
            case .canadaCentral: return "ca-central-1"
            case .capeTown: return "af-south-1"
            case .frankfurt: return "eu-central-1"
            case .hongKong: return "ap-east-1"
            case .hyderabad: return "ap-south-2"
            case .ireland: return "eu-west-1"
            case .jakarta: return "ap-southeast-3"
            case .london: return "eu-west-2"
            case .milano: return "eu-south-1"
            case .mumbai: return "ap-south-1"
            case .ningxia: return "cn-northwest-1"
            case .northernCalifornia: return "us-west-1"
            case .ohio: return "us-east-2"
            case .oregon: return "us-west-2"
            case .osaka: return "ap-northeast-3"
            case .paris: return "eu-west-3"
            case .saoPaulo: return "sa-east-1"
            case .seoul: return "ap-northeast-2"
            case .singapore: return "ap-southeast-1"
            case .spain: return "eu-south-2"
            case .stockholm: return "eu-north-1"
            case .sydney: return "ap-southeast-2"
            case .tokyo: return "ap-northeast-1"
            case .uae: return "me-central-1"
            case .usStandard: return "us-east-1"
            case .zurich: return "eu-central-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AWSRegion(rawValue: rawValue) ?? AWSRegion.sdkUnknown(rawValue)
        }
    }
}

extension CostandUsageReportClientTypes {
    /// The types of manifest that you want AWS to create for this report.
    public enum AdditionalArtifact: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case athena
        case quicksight
        case redshift
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalArtifact] {
            return [
                .athena,
                .quicksight,
                .redshift,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .athena: return "ATHENA"
            case .quicksight: return "QUICKSIGHT"
            case .redshift: return "REDSHIFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalArtifact(rawValue: rawValue) ?? AdditionalArtifact.sdkUnknown(rawValue)
        }
    }
}

extension CostandUsageReportClientTypes {
    /// The compression format that AWS uses for the report.
    public enum CompressionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case parquet
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [CompressionFormat] {
            return [
                .gzip,
                .parquet,
                .zip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .parquet: return "Parquet"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CompressionFormat(rawValue: rawValue) ?? CompressionFormat.sdkUnknown(rawValue)
        }
    }
}

extension DeleteReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportName = "ReportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportName = self.reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

extension DeleteReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Deletes the specified report.
public struct DeleteReportDefinitionInput: Swift.Equatable {
    /// The name of the report that you want to delete. The name must be unique, is case sensitive, and can't include spaces.
    public var reportName: Swift.String?

    public init(
        reportName: Swift.String? = nil
    )
    {
        self.reportName = reportName
    }
}

struct DeleteReportDefinitionInputBody: Swift.Equatable {
    let reportName: Swift.String?
}

extension DeleteReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportName = "ReportName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
    }
}

extension DeleteReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReportDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.responseMessage = output.responseMessage
        } else {
            self.responseMessage = nil
        }
    }
}

/// If the action is successful, the service sends back an HTTP 200 response.
public struct DeleteReportDefinitionOutput: Swift.Equatable {
    /// Whether the deletion was successful or not.
    public var responseMessage: Swift.String?

    public init(
        responseMessage: Swift.String? = nil
    )
    {
        self.responseMessage = responseMessage
    }
}

struct DeleteReportDefinitionOutputBody: Swift.Equatable {
    let responseMessage: Swift.String?
}

extension DeleteReportDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseMessage = "ResponseMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseMessage)
        responseMessage = responseMessageDecoded
    }
}

enum DeleteReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReportDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeReportDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Requests a list of AWS Cost and Usage reports owned by the account.
public struct DescribeReportDefinitionsInput: Swift.Equatable {
    /// The maximum number of results that AWS returns for the operation.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeReportDefinitionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeReportDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReportDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReportDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

/// If the action is successful, the service sends back an HTTP 200 response.
public struct DescribeReportDefinitionsOutput: Swift.Equatable {
    /// A generic string.
    public var nextToken: Swift.String?
    /// A list of AWS Cost and Usage reports owned by the account.
    public var reportDefinitions: [CostandUsageReportClientTypes.ReportDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        reportDefinitions: [CostandUsageReportClientTypes.ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct DescribeReportDefinitionsOutputBody: Swift.Equatable {
    let reportDefinitions: [CostandUsageReportClientTypes.ReportDefinition]?
    let nextToken: Swift.String?
}

extension DescribeReportDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportDefinitions = "ReportDefinitions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([CostandUsageReportClientTypes.ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[CostandUsageReportClientTypes.ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [CostandUsageReportClientTypes.ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeReportDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateReportNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateReportNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A report with the specified name already exists in the account. Specify a different report name.
public struct DuplicateReportNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message to show the detail of the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateReportNameException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateReportNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateReportNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message to show the detail of the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ModifyReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = self.reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
        if let reportName = self.reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
    }
}

extension ModifyReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ModifyReportDefinitionInput: Swift.Equatable {
    /// The definition of AWS Cost and Usage Report. You can specify the report name, time unit, report format, compression format, S3 bucket, additional artifacts, and schema elements in the definition.
    /// This member is required.
    public var reportDefinition: CostandUsageReportClientTypes.ReportDefinition?
    /// The name of the report that you want to create. The name must be unique, is case sensitive, and can't include spaces.
    /// This member is required.
    public var reportName: Swift.String?

    public init(
        reportDefinition: CostandUsageReportClientTypes.ReportDefinition? = nil,
        reportName: Swift.String? = nil
    )
    {
        self.reportDefinition = reportDefinition
        self.reportName = reportName
    }
}

struct ModifyReportDefinitionInputBody: Swift.Equatable {
    let reportName: Swift.String?
    let reportDefinition: CostandUsageReportClientTypes.ReportDefinition?
}

extension ModifyReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
        case reportName = "ReportName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension ModifyReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyReportDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum ModifyReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportDefinition = self.reportDefinition {
            try encodeContainer.encode(reportDefinition, forKey: .reportDefinition)
        }
    }
}

extension PutReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Creates a Cost and Usage Report.
public struct PutReportDefinitionInput: Swift.Equatable {
    /// Represents the output of the PutReportDefinition operation. The content consists of the detailed metadata and data file information.
    /// This member is required.
    public var reportDefinition: CostandUsageReportClientTypes.ReportDefinition?

    public init(
        reportDefinition: CostandUsageReportClientTypes.ReportDefinition? = nil
    )
    {
        self.reportDefinition = reportDefinition
    }
}

struct PutReportDefinitionInputBody: Swift.Equatable {
    let reportDefinition: CostandUsageReportClientTypes.ReportDefinition?
}

extension PutReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportDefinition = "ReportDefinition"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.ReportDefinition.self, forKey: .reportDefinition)
        reportDefinition = reportDefinitionDecoded
    }
}

extension PutReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
public struct PutReportDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum PutReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DuplicateReportNameException": return try await DuplicateReportNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReportLimitReachedException": return try await ReportLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostandUsageReportClientTypes.ReportDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalArtifacts = "AdditionalArtifacts"
        case additionalSchemaElements = "AdditionalSchemaElements"
        case billingViewArn = "BillingViewArn"
        case compression = "Compression"
        case format = "Format"
        case refreshClosedReports = "RefreshClosedReports"
        case reportName = "ReportName"
        case reportVersioning = "ReportVersioning"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case s3Region = "S3Region"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalArtifacts = additionalArtifacts {
            var additionalArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalArtifacts)
            for additionalartifact0 in additionalArtifacts {
                try additionalArtifactsContainer.encode(additionalartifact0.rawValue)
            }
        }
        if let additionalSchemaElements = additionalSchemaElements {
            var additionalSchemaElementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalSchemaElements)
            for schemaelement0 in additionalSchemaElements {
                try additionalSchemaElementsContainer.encode(schemaelement0.rawValue)
            }
        }
        if let billingViewArn = self.billingViewArn {
            try encodeContainer.encode(billingViewArn, forKey: .billingViewArn)
        }
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let refreshClosedReports = self.refreshClosedReports {
            try encodeContainer.encode(refreshClosedReports, forKey: .refreshClosedReports)
        }
        if let reportName = self.reportName {
            try encodeContainer.encode(reportName, forKey: .reportName)
        }
        if let reportVersioning = self.reportVersioning {
            try encodeContainer.encode(reportVersioning.rawValue, forKey: .reportVersioning)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
        if let s3Region = self.s3Region {
            try encodeContainer.encode(s3Region.rawValue, forKey: .s3Region)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportName)
        reportName = reportNameDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.ReportFormat.self, forKey: .format)
        format = formatDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.CompressionFormat.self, forKey: .compression)
        compression = compressionDecoded
        let additionalSchemaElementsContainer = try containerValues.decodeIfPresent([CostandUsageReportClientTypes.SchemaElement?].self, forKey: .additionalSchemaElements)
        var additionalSchemaElementsDecoded0:[CostandUsageReportClientTypes.SchemaElement]? = nil
        if let additionalSchemaElementsContainer = additionalSchemaElementsContainer {
            additionalSchemaElementsDecoded0 = [CostandUsageReportClientTypes.SchemaElement]()
            for enum0 in additionalSchemaElementsContainer {
                if let enum0 = enum0 {
                    additionalSchemaElementsDecoded0?.append(enum0)
                }
            }
        }
        additionalSchemaElements = additionalSchemaElementsDecoded0
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3RegionDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.AWSRegion.self, forKey: .s3Region)
        s3Region = s3RegionDecoded
        let additionalArtifactsContainer = try containerValues.decodeIfPresent([CostandUsageReportClientTypes.AdditionalArtifact?].self, forKey: .additionalArtifacts)
        var additionalArtifactsDecoded0:[CostandUsageReportClientTypes.AdditionalArtifact]? = nil
        if let additionalArtifactsContainer = additionalArtifactsContainer {
            additionalArtifactsDecoded0 = [CostandUsageReportClientTypes.AdditionalArtifact]()
            for enum0 in additionalArtifactsContainer {
                if let enum0 = enum0 {
                    additionalArtifactsDecoded0?.append(enum0)
                }
            }
        }
        additionalArtifacts = additionalArtifactsDecoded0
        let refreshClosedReportsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .refreshClosedReports)
        refreshClosedReports = refreshClosedReportsDecoded
        let reportVersioningDecoded = try containerValues.decodeIfPresent(CostandUsageReportClientTypes.ReportVersioning.self, forKey: .reportVersioning)
        reportVersioning = reportVersioningDecoded
        let billingViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingViewArn)
        billingViewArn = billingViewArnDecoded
    }
}

extension CostandUsageReportClientTypes {
    /// The definition of AWS Cost and Usage Report. You can specify the report name, time unit, report format, compression format, S3 bucket, additional artifacts, and schema elements in the definition.
    public struct ReportDefinition: Swift.Equatable {
        /// A list of manifests that you want Amazon Web Services to create for this report.
        public var additionalArtifacts: [CostandUsageReportClientTypes.AdditionalArtifact]?
        /// A list of strings that indicate additional content that Amazon Web Services includes in the report, such as individual resource IDs.
        /// This member is required.
        public var additionalSchemaElements: [CostandUsageReportClientTypes.SchemaElement]?
        /// The Amazon resource name of the billing view. You can get this value by using the billing view service public APIs.
        public var billingViewArn: Swift.String?
        /// The compression format that AWS uses for the report.
        /// This member is required.
        public var compression: CostandUsageReportClientTypes.CompressionFormat?
        /// The format that AWS saves the report in.
        /// This member is required.
        public var format: CostandUsageReportClientTypes.ReportFormat?
        /// Whether you want Amazon Web Services to update your reports after they have been finalized if Amazon Web Services detects charges related to previous months. These charges can include refunds, credits, or support fees.
        public var refreshClosedReports: Swift.Bool?
        /// The name of the report that you want to create. The name must be unique, is case sensitive, and can't include spaces.
        /// This member is required.
        public var reportName: Swift.String?
        /// Whether you want Amazon Web Services to overwrite the previous version of each report or to deliver the report in addition to the previous versions.
        public var reportVersioning: CostandUsageReportClientTypes.ReportVersioning?
        /// The S3 bucket where AWS delivers the report.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The prefix that AWS adds to the report name when AWS delivers the report. Your prefix can't include spaces.
        /// This member is required.
        public var s3Prefix: Swift.String?
        /// The region of the S3 bucket that AWS delivers the report into.
        /// This member is required.
        public var s3Region: CostandUsageReportClientTypes.AWSRegion?
        /// The length of time covered by the report.
        /// This member is required.
        public var timeUnit: CostandUsageReportClientTypes.TimeUnit?

        public init(
            additionalArtifacts: [CostandUsageReportClientTypes.AdditionalArtifact]? = nil,
            additionalSchemaElements: [CostandUsageReportClientTypes.SchemaElement]? = nil,
            billingViewArn: Swift.String? = nil,
            compression: CostandUsageReportClientTypes.CompressionFormat? = nil,
            format: CostandUsageReportClientTypes.ReportFormat? = nil,
            refreshClosedReports: Swift.Bool? = nil,
            reportName: Swift.String? = nil,
            reportVersioning: CostandUsageReportClientTypes.ReportVersioning? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil,
            s3Region: CostandUsageReportClientTypes.AWSRegion? = nil,
            timeUnit: CostandUsageReportClientTypes.TimeUnit? = nil
        )
        {
            self.additionalArtifacts = additionalArtifacts
            self.additionalSchemaElements = additionalSchemaElements
            self.billingViewArn = billingViewArn
            self.compression = compression
            self.format = format
            self.refreshClosedReports = refreshClosedReports
            self.reportName = reportName
            self.reportVersioning = reportVersioning
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.s3Region = s3Region
            self.timeUnit = timeUnit
        }
    }

}

extension CostandUsageReportClientTypes {
    /// The format that AWS saves the report in.
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "textORcsv"
            case .parquet: return "Parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension ReportLimitReachedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReportLimitReachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This account already has five reports defined. To define a new report, you must delete an existing report.
public struct ReportLimitReachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message to show the detail of the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReportLimitReachedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReportLimitReachedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReportLimitReachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostandUsageReportClientTypes {
    public enum ReportVersioning: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createNewReport
        case overwriteReport
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportVersioning] {
            return [
                .createNewReport,
                .overwriteReport,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createNewReport: return "CREATE_NEW_REPORT"
            case .overwriteReport: return "OVERWRITE_REPORT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportVersioning(rawValue: rawValue) ?? ReportVersioning.sdkUnknown(rawValue)
        }
    }
}

extension CostandUsageReportClientTypes {
    /// Whether or not AWS includes resource IDs in the report.
    public enum SchemaElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resources
        case splitCostAllocationData
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaElement] {
            return [
                .resources,
                .splitCostAllocationData,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resources: return "RESOURCES"
            case .splitCostAllocationData: return "SPLIT_COST_ALLOCATION_DATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaElement(rawValue: rawValue) ?? SchemaElement.sdkUnknown(rawValue)
        }
    }
}

extension CostandUsageReportClientTypes {
    /// The length of time covered by the report.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .daily,
                .hourly,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message to show the detail of the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
