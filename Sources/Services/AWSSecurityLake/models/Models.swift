// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action. Access denied errors appear when Amazon Security Lake explicitly or implicitly denies an authorization request. An explicit denial occurs when a policy contains a Deny statement for the specific Amazon Web Services action. An implicit denial occurs when there is no applicable Deny statement and also no applicable Allow statement.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A coded string to provide more information about the access denied exception. You can use the error code to check the exception type.
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let errorCode: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension SecurityLakeClientTypes {
    public enum AccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lakeformation
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .lakeformation,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lakeformation: return "LAKEFORMATION"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessType(rawValue: rawValue) ?? AccessType.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.AwsIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId
        case principal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The AWS identity.
    public struct AwsIdentity: Swift.Equatable {
        /// The external ID used to estalish trust relationship with the AWS identity.
        /// This member is required.
        public var externalId: Swift.String?
        /// The AWS identity principal.
        /// This member is required.
        public var principal: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            principal: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.principal = principal
        }
    }

}

extension SecurityLakeClientTypes.AwsLogSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case regions
        case sourceName
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for awsaccountid0 in accounts {
                try accountsContainer.encode(awsaccountid0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName.rawValue, forKey: .sourceName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let sourceNameDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsLogSourceName.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The Security Lake logs source configuration file describes the information needed to generate Security Lake logs.
    public struct AwsLogSourceConfiguration: Swift.Equatable {
        /// Specify the Amazon Web Services account information where you want to enable Security Lake.
        public var accounts: [Swift.String]?
        /// Specify the Regions where you want to enable Security Lake.
        /// This member is required.
        public var regions: [Swift.String]?
        /// The name for a Amazon Web Services source. This must be a Regionally unique value.
        /// This member is required.
        public var sourceName: SecurityLakeClientTypes.AwsLogSourceName?
        /// The version for a Amazon Web Services source. This must be a Regionally unique value.
        public var sourceVersion: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            regions: [Swift.String]? = nil,
            sourceName: SecurityLakeClientTypes.AwsLogSourceName? = nil,
            sourceVersion: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.regions = regions
            self.sourceName = sourceName
            self.sourceVersion = sourceVersion
        }
    }

}

extension SecurityLakeClientTypes {
    public enum AwsLogSourceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrailMgmt
        case lambdaExecution
        case route53
        case s3Data
        case shFindings
        case vpcFlow
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsLogSourceName] {
            return [
                .cloudTrailMgmt,
                .lambdaExecution,
                .route53,
                .s3Data,
                .shFindings,
                .vpcFlow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrailMgmt: return "CLOUD_TRAIL_MGMT"
            case .lambdaExecution: return "LAMBDA_EXECUTION"
            case .route53: return "ROUTE53"
            case .s3Data: return "S3_DATA"
            case .shFindings: return "SH_FINDINGS"
            case .vpcFlow: return "VPC_FLOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsLogSourceName(rawValue: rawValue) ?? AwsLogSourceName.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.AwsLogSourceResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceName
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName.rawValue, forKey: .sourceName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsLogSourceName.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Amazon Security Lake can collect logs and events from natively-supported Amazon Web Services services.
    public struct AwsLogSourceResource: Swift.Equatable {
        /// The name for a Amazon Web Services source. This must be a Regionally unique value.
        public var sourceName: SecurityLakeClientTypes.AwsLogSourceName?
        /// The version for a Amazon Web Services source. This must be a Regionally unique value.
        public var sourceVersion: Swift.String?

        public init(
            sourceName: SecurityLakeClientTypes.AwsLogSourceName? = nil,
            sourceVersion: Swift.String? = nil
        )
        {
            self.sourceName = sourceName
            self.sourceVersion = sourceVersion
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The resource name.
        public internal(set) var resourceName: Swift.String? = nil
        /// The resource type.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAwsLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for awslogsourceconfiguration0 in sources {
                try sourcesContainer.encode(awslogsourceconfiguration0)
            }
        }
    }
}

extension CreateAwsLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/logsources/aws"
    }
}

public struct CreateAwsLogSourceInput: Swift.Equatable {
    /// Specify the natively-supported Amazon Web Services service to add as a source in Security Lake.
    /// This member is required.
    public var sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]?

    public init(
        sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]? = nil
    )
    {
        self.sources = sources
    }
}

struct CreateAwsLogSourceInputBody: Swift.Equatable {
    let sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]?
}

extension CreateAwsLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AwsLogSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.AwsLogSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.AwsLogSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension CreateAwsLogSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAwsLogSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
        } else {
            self.failed = nil
        }
    }
}

public struct CreateAwsLogSourceOutput: Swift.Equatable {
    /// Lists all accounts in which enabling a natively supported Amazon Web Service as a Security Lake source failed. The failure occurred as these accounts are not part of an organization.
    public var failed: [Swift.String]?

    public init(
        failed: [Swift.String]? = nil
    )
    {
        self.failed = failed
    }
}

struct CreateAwsLogSourceOutputBody: Swift.Equatable {
    let failed: [Swift.String]?
}

extension CreateAwsLogSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failed)
        var failedDecoded0:[Swift.String]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [Swift.String]()
            for string0 in failedContainer {
                if let string0 = string0 {
                    failedDecoded0?.append(string0)
                }
            }
        }
        failed = failedDecoded0
    }
}

enum CreateAwsLogSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case eventClasses
        case sourceName
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let eventClasses = eventClasses {
            var eventClassesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventClasses)
            for ocsfeventclass0 in eventClasses {
                try eventClassesContainer.encode(ocsfeventclass0)
            }
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }
}

extension CreateCustomLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/logsources/custom"
    }
}

public struct CreateCustomLogSourceInput: Swift.Equatable {
    /// The configuration for the third-party custom source.
    public var configuration: SecurityLakeClientTypes.CustomLogSourceConfiguration?
    /// The Open Cybersecurity Schema Framework (OCSF) event classes which describes the type of data that the custom source will send to Security Lake. The supported event classes are:
    ///
    /// * ACCESS_ACTIVITY
    ///
    /// * FILE_ACTIVITY
    ///
    /// * KERNEL_ACTIVITY
    ///
    /// * KERNEL_EXTENSION
    ///
    /// * MEMORY_ACTIVITY
    ///
    /// * MODULE_ACTIVITY
    ///
    /// * PROCESS_ACTIVITY
    ///
    /// * REGISTRY_KEY_ACTIVITY
    ///
    /// * REGISTRY_VALUE_ACTIVITY
    ///
    /// * RESOURCE_ACTIVITY
    ///
    /// * SCHEDULED_JOB_ACTIVITY
    ///
    /// * SECURITY_FINDING
    ///
    /// * ACCOUNT_CHANGE
    ///
    /// * AUTHENTICATION
    ///
    /// * AUTHORIZATION
    ///
    /// * ENTITY_MANAGEMENT_AUDIT
    ///
    /// * DHCP_ACTIVITY
    ///
    /// * NETWORK_ACTIVITY
    ///
    /// * DNS_ACTIVITY
    ///
    /// * FTP_ACTIVITY
    ///
    /// * HTTP_ACTIVITY
    ///
    /// * RDP_ACTIVITY
    ///
    /// * SMB_ACTIVITY
    ///
    /// * SSH_ACTIVITY
    ///
    /// * CONFIG_STATE
    ///
    /// * INVENTORY_INFO
    ///
    /// * EMAIL_ACTIVITY
    ///
    /// * API_ACTIVITY
    ///
    /// * CLOUD_API
    public var eventClasses: [Swift.String]?
    /// Specify the name for a third-party custom source. This must be a Regionally unique value.
    /// This member is required.
    public var sourceName: Swift.String?
    /// Specify the source version for the third-party custom source, to limit log collection to a specific version of custom data source.
    public var sourceVersion: Swift.String?

    public init(
        configuration: SecurityLakeClientTypes.CustomLogSourceConfiguration? = nil,
        eventClasses: [Swift.String]? = nil,
        sourceName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.eventClasses = eventClasses
        self.sourceName = sourceName
        self.sourceVersion = sourceVersion
    }
}

struct CreateCustomLogSourceInputBody: Swift.Equatable {
    let sourceName: Swift.String?
    let sourceVersion: Swift.String?
    let eventClasses: [Swift.String]?
    let configuration: SecurityLakeClientTypes.CustomLogSourceConfiguration?
}

extension CreateCustomLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case eventClasses
        case sourceName
        case sourceVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let eventClassesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventClasses)
        var eventClassesDecoded0:[Swift.String]? = nil
        if let eventClassesContainer = eventClassesContainer {
            eventClassesDecoded0 = [Swift.String]()
            for string0 in eventClassesContainer {
                if let string0 = string0 {
                    eventClassesDecoded0?.append(string0)
                }
            }
        }
        eventClasses = eventClassesDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateCustomLogSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomLogSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.source = output.source
        } else {
            self.source = nil
        }
    }
}

public struct CreateCustomLogSourceOutput: Swift.Equatable {
    /// The created third-party custom source.
    public var source: SecurityLakeClientTypes.CustomLogSourceResource?

    public init(
        source: SecurityLakeClientTypes.CustomLogSourceResource? = nil
    )
    {
        self.source = source
    }
}

struct CreateCustomLogSourceOutputBody: Swift.Equatable {
    let source: SecurityLakeClientTypes.CustomLogSourceResource?
}

extension CreateCustomLogSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceResource.self, forKey: .source)
        source = sourceDecoded
    }
}

enum CreateCustomLogSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataLakeExceptionSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionTimeToLive
        case notificationEndpoint
        case subscriptionProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionTimeToLive = self.exceptionTimeToLive {
            try encodeContainer.encode(exceptionTimeToLive, forKey: .exceptionTimeToLive)
        }
        if let notificationEndpoint = self.notificationEndpoint {
            try encodeContainer.encode(notificationEndpoint, forKey: .notificationEndpoint)
        }
        if let subscriptionProtocol = self.subscriptionProtocol {
            try encodeContainer.encode(subscriptionProtocol, forKey: .subscriptionProtocol)
        }
    }
}

extension CreateDataLakeExceptionSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct CreateDataLakeExceptionSubscriptionInput: Swift.Equatable {
    /// The expiration period and time-to-live (TTL).
    public var exceptionTimeToLive: Swift.Int?
    /// The Amazon Web Services account where you want to receive exception notifications.
    /// This member is required.
    public var notificationEndpoint: Swift.String?
    /// The subscription protocol to which exception notifications are posted.
    /// This member is required.
    public var subscriptionProtocol: Swift.String?

    public init(
        exceptionTimeToLive: Swift.Int? = nil,
        notificationEndpoint: Swift.String? = nil,
        subscriptionProtocol: Swift.String? = nil
    )
    {
        self.exceptionTimeToLive = exceptionTimeToLive
        self.notificationEndpoint = notificationEndpoint
        self.subscriptionProtocol = subscriptionProtocol
    }
}

struct CreateDataLakeExceptionSubscriptionInputBody: Swift.Equatable {
    let subscriptionProtocol: Swift.String?
    let notificationEndpoint: Swift.String?
    let exceptionTimeToLive: Swift.Int?
}

extension CreateDataLakeExceptionSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionTimeToLive
        case notificationEndpoint
        case subscriptionProtocol
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let notificationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEndpoint)
        notificationEndpoint = notificationEndpointDecoded
        let exceptionTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exceptionTimeToLive)
        exceptionTimeToLive = exceptionTimeToLiveDecoded
    }
}

extension CreateDataLakeExceptionSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateDataLakeExceptionSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum CreateDataLakeExceptionSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataLakeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case metaStoreManagerRoleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for datalakeconfiguration0 in configurations {
                try configurationsContainer.encode(datalakeconfiguration0)
            }
        }
        if let metaStoreManagerRoleArn = self.metaStoreManagerRoleArn {
            try encodeContainer.encode(metaStoreManagerRoleArn, forKey: .metaStoreManagerRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDataLakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct CreateDataLakeInput: Swift.Equatable {
    /// Specify the Region or Regions that will contribute data to the rollup region.
    /// This member is required.
    public var configurations: [SecurityLakeClientTypes.DataLakeConfiguration]?
    /// The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.
    /// This member is required.
    public var metaStoreManagerRoleArn: Swift.String?
    /// An array of objects, one for each tag to associate with the data lake configuration. For each tag, you must specify both a tag key and a tag value. A tag value cannot be null, but it can be an empty string.
    public var tags: [SecurityLakeClientTypes.Tag]?

    public init(
        configurations: [SecurityLakeClientTypes.DataLakeConfiguration]? = nil,
        metaStoreManagerRoleArn: Swift.String? = nil,
        tags: [SecurityLakeClientTypes.Tag]? = nil
    )
    {
        self.configurations = configurations
        self.metaStoreManagerRoleArn = metaStoreManagerRoleArn
        self.tags = tags
    }
}

struct CreateDataLakeInputBody: Swift.Equatable {
    let configurations: [SecurityLakeClientTypes.DataLakeConfiguration]?
    let metaStoreManagerRoleArn: Swift.String?
    let tags: [SecurityLakeClientTypes.Tag]?
}

extension CreateDataLakeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case metaStoreManagerRoleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeConfiguration?].self, forKey: .configurations)
        var configurationsDecoded0:[SecurityLakeClientTypes.DataLakeConfiguration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [SecurityLakeClientTypes.DataLakeConfiguration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let metaStoreManagerRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metaStoreManagerRoleArn)
        metaStoreManagerRoleArn = metaStoreManagerRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecurityLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecurityLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataLakeOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnableNewAccount = autoEnableNewAccount {
            var autoEnableNewAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoEnableNewAccount)
            for datalakeautoenablenewaccountconfiguration0 in autoEnableNewAccount {
                try autoEnableNewAccountContainer.encode(datalakeautoenablenewaccountconfiguration0)
            }
        }
    }
}

extension CreateDataLakeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/organization/configuration"
    }
}

public struct CreateDataLakeOrganizationConfigurationInput: Swift.Equatable {
    /// Enable Security Lake with the specified configuration settings, to begin collecting security data for new accounts in your organization.
    /// This member is required.
    public var autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?

    public init(
        autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
    )
    {
        self.autoEnableNewAccount = autoEnableNewAccount
    }
}

struct CreateDataLakeOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?
}

extension CreateDataLakeOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableNewAccountContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration?].self, forKey: .autoEnableNewAccount)
        var autoEnableNewAccountDecoded0:[SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
        if let autoEnableNewAccountContainer = autoEnableNewAccountContainer {
            autoEnableNewAccountDecoded0 = [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]()
            for structure0 in autoEnableNewAccountContainer {
                if let structure0 = structure0 {
                    autoEnableNewAccountDecoded0?.append(structure0)
                }
            }
        }
        autoEnableNewAccount = autoEnableNewAccountDecoded0
    }
}

extension CreateDataLakeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateDataLakeOrganizationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum CreateDataLakeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataLakeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataLakeOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataLakes = output.dataLakes
        } else {
            self.dataLakes = nil
        }
    }
}

public struct CreateDataLakeOutput: Swift.Equatable {
    /// The created Security Lake configuration object.
    public var dataLakes: [SecurityLakeClientTypes.DataLakeResource]?

    public init(
        dataLakes: [SecurityLakeClientTypes.DataLakeResource]? = nil
    )
    {
        self.dataLakes = dataLakes
    }
}

struct CreateDataLakeOutputBody: Swift.Equatable {
    let dataLakes: [SecurityLakeClientTypes.DataLakeResource]?
}

extension CreateDataLakeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeResource?].self, forKey: .dataLakes)
        var dataLakesDecoded0:[SecurityLakeClientTypes.DataLakeResource]? = nil
        if let dataLakesContainer = dataLakesContainer {
            dataLakesDecoded0 = [SecurityLakeClientTypes.DataLakeResource]()
            for structure0 in dataLakesContainer {
                if let structure0 = structure0 {
                    dataLakesDecoded0?.append(structure0)
                }
            }
        }
        dataLakes = dataLakesDecoded0
    }
}

enum CreateDataLakeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case sources
        case subscriberDescription
        case subscriberIdentity
        case subscriberName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTypes = accessTypes {
            var accessTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessTypes)
            for accesstype0 in accessTypes {
                try accessTypesContainer.encode(accesstype0.rawValue)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for logsourceresource0 in sources {
                try sourcesContainer.encode(logsourceresource0)
            }
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberIdentity = self.subscriberIdentity {
            try encodeContainer.encode(subscriberIdentity, forKey: .subscriberIdentity)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/subscribers"
    }
}

public struct CreateSubscriberInput: Swift.Equatable {
    /// The Amazon S3 or Lake Formation access type.
    public var accessTypes: [SecurityLakeClientTypes.AccessType]?
    /// The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.
    /// This member is required.
    public var sources: [SecurityLakeClientTypes.LogSourceResource]?
    /// The description for your subscriber account in Security Lake.
    public var subscriberDescription: Swift.String?
    /// The AWS identity used to access your data.
    /// This member is required.
    public var subscriberIdentity: SecurityLakeClientTypes.AwsIdentity?
    /// The name of your Security Lake subscriber account.
    /// This member is required.
    public var subscriberName: Swift.String?
    /// An array of objects, one for each tag to associate with the subscriber. For each tag, you must specify both a tag key and a tag value. A tag value cannot be null, but it can be an empty string.
    public var tags: [SecurityLakeClientTypes.Tag]?

    public init(
        accessTypes: [SecurityLakeClientTypes.AccessType]? = nil,
        sources: [SecurityLakeClientTypes.LogSourceResource]? = nil,
        subscriberDescription: Swift.String? = nil,
        subscriberIdentity: SecurityLakeClientTypes.AwsIdentity? = nil,
        subscriberName: Swift.String? = nil,
        tags: [SecurityLakeClientTypes.Tag]? = nil
    )
    {
        self.accessTypes = accessTypes
        self.sources = sources
        self.subscriberDescription = subscriberDescription
        self.subscriberIdentity = subscriberIdentity
        self.subscriberName = subscriberName
        self.tags = tags
    }
}

struct CreateSubscriberInputBody: Swift.Equatable {
    let subscriberIdentity: SecurityLakeClientTypes.AwsIdentity?
    let subscriberName: Swift.String?
    let subscriberDescription: Swift.String?
    let sources: [SecurityLakeClientTypes.LogSourceResource]?
    let accessTypes: [SecurityLakeClientTypes.AccessType]?
    let tags: [SecurityLakeClientTypes.Tag]?
}

extension CreateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case sources
        case subscriberDescription
        case subscriberIdentity
        case subscriberName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberIdentityDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsIdentity.self, forKey: .subscriberIdentity)
        subscriberIdentity = subscriberIdentityDecoded
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSourceResource]()
            for union0 in sourcesContainer {
                if let union0 = union0 {
                    sourcesDecoded0?.append(union0)
                }
            }
        }
        sources = sourcesDecoded0
        let accessTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AccessType?].self, forKey: .accessTypes)
        var accessTypesDecoded0:[SecurityLakeClientTypes.AccessType]? = nil
        if let accessTypesContainer = accessTypesContainer {
            accessTypesDecoded0 = [SecurityLakeClientTypes.AccessType]()
            for enum0 in accessTypesContainer {
                if let enum0 = enum0 {
                    accessTypesDecoded0?.append(enum0)
                }
            }
        }
        accessTypes = accessTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecurityLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecurityLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSubscriberNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

extension CreateSubscriberNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())/notification"
    }
}

public struct CreateSubscriberNotificationInput: Swift.Equatable {
    /// Specify the configuration using which you want to create the subscriber notification.
    /// This member is required.
    public var configuration: SecurityLakeClientTypes.NotificationConfiguration?
    /// The subscriber ID for the notification subscription.
    /// This member is required.
    public var subscriberId: Swift.String?

    public init(
        configuration: SecurityLakeClientTypes.NotificationConfiguration? = nil,
        subscriberId: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.subscriberId = subscriberId
    }
}

struct CreateSubscriberNotificationInputBody: Swift.Equatable {
    let configuration: SecurityLakeClientTypes.NotificationConfiguration?
}

extension CreateSubscriberNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.NotificationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateSubscriberNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriberNotificationOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriberEndpoint = output.subscriberEndpoint
        } else {
            self.subscriberEndpoint = nil
        }
    }
}

public struct CreateSubscriberNotificationOutput: Swift.Equatable {
    /// The subscriber endpoint to which exception messages are posted.
    public var subscriberEndpoint: Swift.String?

    public init(
        subscriberEndpoint: Swift.String? = nil
    )
    {
        self.subscriberEndpoint = subscriberEndpoint
    }
}

struct CreateSubscriberNotificationOutputBody: Swift.Equatable {
    let subscriberEndpoint: Swift.String?
}

extension CreateSubscriberNotificationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriberEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberEndpoint)
        subscriberEndpoint = subscriberEndpointDecoded
    }
}

enum CreateSubscriberNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriberOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriber = output.subscriber
        } else {
            self.subscriber = nil
        }
    }
}

public struct CreateSubscriberOutput: Swift.Equatable {
    /// Retrieve information about the subscriber created using the CreateSubscriber API.
    public var subscriber: SecurityLakeClientTypes.SubscriberResource?

    public init(
        subscriber: SecurityLakeClientTypes.SubscriberResource? = nil
    )
    {
        self.subscriber = subscriber
    }
}

struct CreateSubscriberOutputBody: Swift.Equatable {
    let subscriber: SecurityLakeClientTypes.SubscriberResource?
}

extension CreateSubscriberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberResource.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

enum CreateSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SecurityLakeClientTypes.CustomLogSourceAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlerArn
        case databaseArn
        case tableArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerArn = self.crawlerArn {
            try encodeContainer.encode(crawlerArn, forKey: .crawlerArn)
        }
        if let databaseArn = self.databaseArn {
            try encodeContainer.encode(databaseArn, forKey: .databaseArn)
        }
        if let tableArn = self.tableArn {
            try encodeContainer.encode(tableArn, forKey: .tableArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crawlerArn)
        crawlerArn = crawlerArnDecoded
        let databaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseArn)
        databaseArn = databaseArnDecoded
        let tableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableArn)
        tableArn = tableArnDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The attributes of a third-party custom source.
    public struct CustomLogSourceAttributes: Swift.Equatable {
        /// The ARN of the Glue crawler.
        public var crawlerArn: Swift.String?
        /// The ARN of the Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
        public var databaseArn: Swift.String?
        /// The ARN of the Glue table.
        public var tableArn: Swift.String?

        public init(
            crawlerArn: Swift.String? = nil,
            databaseArn: Swift.String? = nil,
            tableArn: Swift.String? = nil
        )
        {
            self.crawlerArn = crawlerArn
            self.databaseArn = databaseArn
            self.tableArn = tableArn
        }
    }

}

extension SecurityLakeClientTypes.CustomLogSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crawlerConfiguration
        case providerIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crawlerConfiguration = self.crawlerConfiguration {
            try encodeContainer.encode(crawlerConfiguration, forKey: .crawlerConfiguration)
        }
        if let providerIdentity = self.providerIdentity {
            try encodeContainer.encode(providerIdentity, forKey: .providerIdentity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crawlerConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceCrawlerConfiguration.self, forKey: .crawlerConfiguration)
        crawlerConfiguration = crawlerConfigurationDecoded
        let providerIdentityDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsIdentity.self, forKey: .providerIdentity)
        providerIdentity = providerIdentityDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The configuration for the third-party custom source.
    public struct CustomLogSourceConfiguration: Swift.Equatable {
        /// The configuration for the Glue Crawler for the third-party custom source.
        /// This member is required.
        public var crawlerConfiguration: SecurityLakeClientTypes.CustomLogSourceCrawlerConfiguration?
        /// The identity of the log provider for the third-party custom source.
        /// This member is required.
        public var providerIdentity: SecurityLakeClientTypes.AwsIdentity?

        public init(
            crawlerConfiguration: SecurityLakeClientTypes.CustomLogSourceCrawlerConfiguration? = nil,
            providerIdentity: SecurityLakeClientTypes.AwsIdentity? = nil
        )
        {
            self.crawlerConfiguration = crawlerConfiguration
            self.providerIdentity = providerIdentity
        }
    }

}

extension SecurityLakeClientTypes.CustomLogSourceCrawlerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The configuration for the Glue Crawler for the third-party custom source.
    public struct CustomLogSourceCrawlerConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:
        ///
        /// * The managed policy AWSGlueServiceRole
        ///
        /// * A custom policy granting access to your Amazon S3 Data Lake
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension SecurityLakeClientTypes.CustomLogSourceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The details of the log provider for a third-party custom source.
    public struct CustomLogSourceProvider: Swift.Equatable {
        /// The location of the partition in the Amazon S3 bucket for Security Lake.
        public var location: Swift.String?
        /// The ARN of the IAM role to be used by the entity putting logs into your custom source partition. Security Lake will apply the correct access policies to this role, but you must first manually create the trust policy for this role. The IAM role name must start with the text 'Security Lake'. The IAM role must trust the logProviderAccountId to assume the role.
        public var roleArn: Swift.String?

        public init(
            location: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.location = location
            self.roleArn = roleArn
        }
    }

}

extension SecurityLakeClientTypes.CustomLogSourceResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case provider
        case sourceName
        case sourceVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceProvider.self, forKey: .provider)
        provider = providerDecoded
        let attributesDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Amazon Security Lake can collect logs and events from third-party custom sources.
    public struct CustomLogSourceResource: Swift.Equatable {
        /// The attributes of a third-party custom source.
        public var attributes: SecurityLakeClientTypes.CustomLogSourceAttributes?
        /// The details of the log provider for a third-party custom source.
        public var provider: SecurityLakeClientTypes.CustomLogSourceProvider?
        /// The name for a third-party custom source. This must be a Regionally unique value.
        public var sourceName: Swift.String?
        /// The version for a third-party custom source. This must be a Regionally unique value.
        public var sourceVersion: Swift.String?

        public init(
            attributes: SecurityLakeClientTypes.CustomLogSourceAttributes? = nil,
            provider: SecurityLakeClientTypes.CustomLogSourceProvider? = nil,
            sourceName: Swift.String? = nil,
            sourceVersion: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.provider = provider
            self.sourceName = sourceName
            self.sourceVersion = sourceVersion
        }
    }

}

extension SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for awslogsourceresource0 in sources {
                try sourcesContainer.encode(awslogsourceresource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AwsLogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.AwsLogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.AwsLogSourceResource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Automatically enable new organization accounts as member accounts from an Amazon Security Lake administrator account.
    public struct DataLakeAutoEnableNewAccountConfiguration: Swift.Equatable {
        /// The Amazon Web Services Regions where Security Lake is automatically enabled.
        /// This member is required.
        public var region: Swift.String?
        /// The Amazon Web Services sources that are automatically enabled in Security Lake.
        /// This member is required.
        public var sources: [SecurityLakeClientTypes.AwsLogSourceResource]?

        public init(
            region: Swift.String? = nil,
            sources: [SecurityLakeClientTypes.AwsLogSourceResource]? = nil
        )
        {
            self.region = region
            self.sources = sources
        }
    }

}

extension SecurityLakeClientTypes.DataLakeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration
        case lifecycleConfiguration
        case region
        case replicationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let lifecycleConfiguration = self.lifecycleConfiguration {
            try encodeContainer.encode(lifecycleConfiguration, forKey: .lifecycleConfiguration)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let replicationConfiguration = self.replicationConfiguration {
            try encodeContainer.encode(replicationConfiguration, forKey: .replicationConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeLifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details of Amazon Security Lake object.
    public struct DataLakeConfiguration: Swift.Equatable {
        /// Provides encryption details of Amazon Security Lake object.
        public var encryptionConfiguration: SecurityLakeClientTypes.DataLakeEncryptionConfiguration?
        /// Provides lifecycle details of Amazon Security Lake object.
        public var lifecycleConfiguration: SecurityLakeClientTypes.DataLakeLifecycleConfiguration?
        /// The Amazon Web Services Regions where Security Lake is automatically enabled.
        /// This member is required.
        public var region: Swift.String?
        /// Provides replication details of Amazon Security Lake object.
        public var replicationConfiguration: SecurityLakeClientTypes.DataLakeReplicationConfiguration?

        public init(
            encryptionConfiguration: SecurityLakeClientTypes.DataLakeEncryptionConfiguration? = nil,
            lifecycleConfiguration: SecurityLakeClientTypes.DataLakeLifecycleConfiguration? = nil,
            region: Swift.String? = nil,
            replicationConfiguration: SecurityLakeClientTypes.DataLakeReplicationConfiguration? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
            self.lifecycleConfiguration = lifecycleConfiguration
            self.region = region
            self.replicationConfiguration = replicationConfiguration
        }
    }

}

extension SecurityLakeClientTypes.DataLakeEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides encryption details of Amazon Security Lake object.
    public struct DataLakeEncryptionConfiguration: Swift.Equatable {
        /// The id of KMS encryption key used by Amazon Security Lake to encrypt the Security Lake object.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension SecurityLakeClientTypes.DataLakeException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exception
        case region
        case remediation
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exception = self.exception {
            try encodeContainer.encode(exception, forKey: .exception)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let exceptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exception)
        exception = exceptionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediation)
        remediation = remediationDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The details for an Amazon Security Lake exception.
    public struct DataLakeException: Swift.Equatable {
        /// The underlying exception of a Security Lake exception.
        public var exception: Swift.String?
        /// The Amazon Web Services Regions where the exception occurred.
        public var region: Swift.String?
        /// List of all remediation steps for a Security Lake exception.
        public var remediation: Swift.String?
        /// This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.
        public var timestamp: ClientRuntime.Date?

        public init(
            exception: Swift.String? = nil,
            region: Swift.String? = nil,
            remediation: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.exception = exception
            self.region = region
            self.remediation = remediation
            self.timestamp = timestamp
        }
    }

}

extension SecurityLakeClientTypes.DataLakeLifecycleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiration
        case transitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiration = self.expiration {
            try encodeContainer.encode(expiration, forKey: .expiration)
        }
        if let transitions = transitions {
            var transitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitions)
            for datalakelifecycletransition0 in transitions {
                try transitionsContainer.encode(datalakelifecycletransition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeLifecycleExpiration.self, forKey: .expiration)
        expiration = expirationDecoded
        let transitionsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeLifecycleTransition?].self, forKey: .transitions)
        var transitionsDecoded0:[SecurityLakeClientTypes.DataLakeLifecycleTransition]? = nil
        if let transitionsContainer = transitionsContainer {
            transitionsDecoded0 = [SecurityLakeClientTypes.DataLakeLifecycleTransition]()
            for structure0 in transitionsContainer {
                if let structure0 = structure0 {
                    transitionsDecoded0?.append(structure0)
                }
            }
        }
        transitions = transitionsDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Provides lifecycle details of Amazon Security Lake object.
    public struct DataLakeLifecycleConfiguration: Swift.Equatable {
        /// Provides data expiration details of Amazon Security Lake object.
        public var expiration: SecurityLakeClientTypes.DataLakeLifecycleExpiration?
        /// Provides data storage transition details of Amazon Security Lake object.
        public var transitions: [SecurityLakeClientTypes.DataLakeLifecycleTransition]?

        public init(
            expiration: SecurityLakeClientTypes.DataLakeLifecycleExpiration? = nil,
            transitions: [SecurityLakeClientTypes.DataLakeLifecycleTransition]? = nil
        )
        {
            self.expiration = expiration
            self.transitions = transitions
        }
    }

}

extension SecurityLakeClientTypes.DataLakeLifecycleExpiration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case days
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let days = self.days {
            try encodeContainer.encode(days, forKey: .days)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days)
        days = daysDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provide expiration lifecycle details of Amazon Security Lake object.
    public struct DataLakeLifecycleExpiration: Swift.Equatable {
        /// Number of days before data expires in the Amazon Security Lake object.
        public var days: Swift.Int?

        public init(
            days: Swift.Int? = nil
        )
        {
            self.days = days
        }
    }

}

extension SecurityLakeClientTypes.DataLakeLifecycleTransition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case days
        case storageClass
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let days = self.days {
            try encodeContainer.encode(days, forKey: .days)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days)
        days = daysDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provide transition lifecycle details of Amazon Security Lake object.
    public struct DataLakeLifecycleTransition: Swift.Equatable {
        /// Number of days before data transitions to a different S3 Storage Class in the Amazon Security Lake object.
        public var days: Swift.Int?
        /// The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.
        public var storageClass: Swift.String?

        public init(
            days: Swift.Int? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension SecurityLakeClientTypes.DataLakeReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regions
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides replication details of Amazon Security Lake object.
    public struct DataLakeReplicationConfiguration: Swift.Equatable {
        /// Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket. Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region.
        public var regions: [Swift.String]?
        /// Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct.
        public var roleArn: Swift.String?

        public init(
            regions: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.regions = regions
            self.roleArn = roleArn
        }
    }

}

extension SecurityLakeClientTypes.DataLakeResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createStatus
        case dataLakeArn
        case encryptionConfiguration
        case lifecycleConfiguration
        case region
        case replicationConfiguration
        case s3BucketArn
        case updateStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createStatus = self.createStatus {
            try encodeContainer.encode(createStatus.rawValue, forKey: .createStatus)
        }
        if let dataLakeArn = self.dataLakeArn {
            try encodeContainer.encode(dataLakeArn, forKey: .dataLakeArn)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let lifecycleConfiguration = self.lifecycleConfiguration {
            try encodeContainer.encode(lifecycleConfiguration, forKey: .lifecycleConfiguration)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let replicationConfiguration = self.replicationConfiguration {
            try encodeContainer.encode(replicationConfiguration, forKey: .replicationConfiguration)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus, forKey: .updateStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLakeArn)
        dataLakeArn = dataLakeArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let lifecycleConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeLifecycleConfiguration.self, forKey: .lifecycleConfiguration)
        lifecycleConfiguration = lifecycleConfigurationDecoded
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
        let createStatusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeStatus.self, forKey: .createStatus)
        createStatus = createStatusDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeUpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details of Amazon Security Lake object.
    public struct DataLakeResource: Swift.Equatable {
        /// Retrieves the status of the configuration operation for an account in Amazon Security Lake.
        public var createStatus: SecurityLakeClientTypes.DataLakeStatus?
        /// The Amazon Resource Name (ARN) created by you to provide to the subscriber. For more information about ARNs and how to use them in policies, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html).
        /// This member is required.
        public var dataLakeArn: Swift.String?
        /// Provides encryption details of Amazon Security Lake object.
        public var encryptionConfiguration: SecurityLakeClientTypes.DataLakeEncryptionConfiguration?
        /// Provides lifecycle details of Amazon Security Lake object.
        public var lifecycleConfiguration: SecurityLakeClientTypes.DataLakeLifecycleConfiguration?
        /// The Amazon Web Services Regions where Security Lake is enabled.
        /// This member is required.
        public var region: Swift.String?
        /// Provides replication details of Amazon Security Lake object.
        public var replicationConfiguration: SecurityLakeClientTypes.DataLakeReplicationConfiguration?
        /// The ARN for the Amazon Security Lake Amazon S3 bucket.
        public var s3BucketArn: Swift.String?
        /// The status of the last UpdateDataLake or DeleteDataLake API request.
        public var updateStatus: SecurityLakeClientTypes.DataLakeUpdateStatus?

        public init(
            createStatus: SecurityLakeClientTypes.DataLakeStatus? = nil,
            dataLakeArn: Swift.String? = nil,
            encryptionConfiguration: SecurityLakeClientTypes.DataLakeEncryptionConfiguration? = nil,
            lifecycleConfiguration: SecurityLakeClientTypes.DataLakeLifecycleConfiguration? = nil,
            region: Swift.String? = nil,
            replicationConfiguration: SecurityLakeClientTypes.DataLakeReplicationConfiguration? = nil,
            s3BucketArn: Swift.String? = nil,
            updateStatus: SecurityLakeClientTypes.DataLakeUpdateStatus? = nil
        )
        {
            self.createStatus = createStatus
            self.dataLakeArn = dataLakeArn
            self.encryptionConfiguration = encryptionConfiguration
            self.lifecycleConfiguration = lifecycleConfiguration
            self.region = region
            self.replicationConfiguration = replicationConfiguration
            self.s3BucketArn = s3BucketArn
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityLakeClientTypes.DataLakeSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
        case eventClasses
        case sourceName
        case sourceStatuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let eventClasses = eventClasses {
            var eventClassesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventClasses)
            for ocsfeventclass0 in eventClasses {
                try eventClassesContainer.encode(ocsfeventclass0)
            }
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceStatuses = sourceStatuses {
            var sourceStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceStatuses)
            for datalakesourcestatus0 in sourceStatuses {
                try sourceStatusesContainer.encode(datalakesourcestatus0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let eventClassesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventClasses)
        var eventClassesDecoded0:[Swift.String]? = nil
        if let eventClassesContainer = eventClassesContainer {
            eventClassesDecoded0 = [Swift.String]()
            for string0 in eventClassesContainer {
                if let string0 = string0 {
                    eventClassesDecoded0?.append(string0)
                }
            }
        }
        eventClasses = eventClassesDecoded0
        let sourceStatusesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeSourceStatus?].self, forKey: .sourceStatuses)
        var sourceStatusesDecoded0:[SecurityLakeClientTypes.DataLakeSourceStatus]? = nil
        if let sourceStatusesContainer = sourceStatusesContainer {
            sourceStatusesDecoded0 = [SecurityLakeClientTypes.DataLakeSourceStatus]()
            for structure0 in sourceStatusesContainer {
                if let structure0 = structure0 {
                    sourceStatusesDecoded0?.append(structure0)
                }
            }
        }
        sourceStatuses = sourceStatusesDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Amazon Security Lake collects logs and events from supported Amazon Web Services and custom sources. For the list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    public struct DataLakeSource: Swift.Equatable {
        /// The ID of the Security Lake account for which logs are collected.
        public var account: Swift.String?
        /// The Open Cybersecurity Schema Framework (OCSF) event classes which describes the type of data that the custom source will send to Security Lake. The supported event classes are:
        ///
        /// * ACCESS_ACTIVITY
        ///
        /// * FILE_ACTIVITY
        ///
        /// * KERNEL_ACTIVITY
        ///
        /// * KERNEL_EXTENSION
        ///
        /// * MEMORY_ACTIVITY
        ///
        /// * MODULE_ACTIVITY
        ///
        /// * PROCESS_ACTIVITY
        ///
        /// * REGISTRY_KEY_ACTIVITY
        ///
        /// * REGISTRY_VALUE_ACTIVITY
        ///
        /// * RESOURCE_ACTIVITY
        ///
        /// * SCHEDULED_JOB_ACTIVITY
        ///
        /// * SECURITY_FINDING
        ///
        /// * ACCOUNT_CHANGE
        ///
        /// * AUTHENTICATION
        ///
        /// * AUTHORIZATION
        ///
        /// * ENTITY_MANAGEMENT_AUDIT
        ///
        /// * DHCP_ACTIVITY
        ///
        /// * NETWORK_ACTIVITY
        ///
        /// * DNS_ACTIVITY
        ///
        /// * FTP_ACTIVITY
        ///
        /// * HTTP_ACTIVITY
        ///
        /// * RDP_ACTIVITY
        ///
        /// * SMB_ACTIVITY
        ///
        /// * SSH_ACTIVITY
        ///
        /// * CONFIG_STATE
        ///
        /// * INVENTORY_INFO
        ///
        /// * EMAIL_ACTIVITY
        ///
        /// * API_ACTIVITY
        ///
        /// * CLOUD_API
        public var eventClasses: [Swift.String]?
        /// The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services.
        public var sourceName: Swift.String?
        /// The log status for the Security Lake account.
        public var sourceStatuses: [SecurityLakeClientTypes.DataLakeSourceStatus]?

        public init(
            account: Swift.String? = nil,
            eventClasses: [Swift.String]? = nil,
            sourceName: Swift.String? = nil,
            sourceStatuses: [SecurityLakeClientTypes.DataLakeSourceStatus]? = nil
        )
        {
            self.account = account
            self.eventClasses = eventClasses
            self.sourceName = sourceName
            self.sourceStatuses = sourceStatuses
        }
    }

}

extension SecurityLakeClientTypes.DataLakeSourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SourceCollectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Retrieves the Logs status for the Amazon Security Lake account.
    public struct DataLakeSourceStatus: Swift.Equatable {
        /// Defines path the stored logs are available which has information on your systems, applications, and services.
        public var resource: Swift.String?
        /// The health status of services, including error codes and patterns.
        public var status: SecurityLakeClientTypes.SourceCollectionStatus?

        public init(
            resource: Swift.String? = nil,
            status: SecurityLakeClientTypes.SourceCollectionStatus? = nil
        )
        {
            self.resource = resource
            self.status = status
        }
    }

}

extension SecurityLakeClientTypes {
    public enum DataLakeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initialized
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLakeStatus] {
            return [
                .completed,
                .failed,
                .initialized,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLakeStatus(rawValue: rawValue) ?? DataLakeStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.DataLakeUpdateException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The details of the last UpdateDataLake or DeleteDataLake API request which failed.
    public struct DataLakeUpdateException: Swift.Equatable {
        /// The reason code for the exception of the last UpdateDataLake or DeleteDataLake API request.
        public var code: Swift.String?
        /// The reason for the exception of the last UpdateDataLakeor DeleteDataLake API request.
        public var reason: Swift.String?

        public init(
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension SecurityLakeClientTypes.DataLakeUpdateStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exception
        case requestId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exception = self.exception {
            try encodeContainer.encode(exception, forKey: .exception)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeStatus.self, forKey: .status)
        status = statusDecoded
        let exceptionDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.DataLakeUpdateException.self, forKey: .exception)
        exception = exceptionDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The status of the last UpdateDataLake or DeleteDataLake API request. This is set to Completed after the configuration is updated, or removed if deletion of the data lake is successful.
    public struct DataLakeUpdateStatus: Swift.Equatable {
        /// The details of the last UpdateDataLakeor DeleteDataLake API request which failed.
        public var exception: SecurityLakeClientTypes.DataLakeUpdateException?
        /// The unique ID for the last UpdateDataLake or DeleteDataLake API request.
        public var requestId: Swift.String?
        /// The status of the last UpdateDataLake or DeleteDataLake API request that was requested.
        public var status: SecurityLakeClientTypes.DataLakeStatus?

        public init(
            exception: SecurityLakeClientTypes.DataLakeUpdateException? = nil,
            requestId: Swift.String? = nil,
            status: SecurityLakeClientTypes.DataLakeStatus? = nil
        )
        {
            self.exception = exception
            self.requestId = requestId
            self.status = status
        }
    }

}

extension DeleteAwsLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for awslogsourceconfiguration0 in sources {
                try sourcesContainer.encode(awslogsourceconfiguration0)
            }
        }
    }
}

extension DeleteAwsLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/logsources/aws/delete"
    }
}

public struct DeleteAwsLogSourceInput: Swift.Equatable {
    /// Specify the natively-supported Amazon Web Services service to remove as a source in Security Lake.
    /// This member is required.
    public var sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]?

    public init(
        sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]? = nil
    )
    {
        self.sources = sources
    }
}

struct DeleteAwsLogSourceInputBody: Swift.Equatable {
    let sources: [SecurityLakeClientTypes.AwsLogSourceConfiguration]?
}

extension DeleteAwsLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AwsLogSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.AwsLogSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.AwsLogSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension DeleteAwsLogSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAwsLogSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
        } else {
            self.failed = nil
        }
    }
}

public struct DeleteAwsLogSourceOutput: Swift.Equatable {
    /// Deletion of the Amazon Web Services sources failed as the account is not a part of the organization.
    public var failed: [Swift.String]?

    public init(
        failed: [Swift.String]? = nil
    )
    {
        self.failed = failed
    }
}

struct DeleteAwsLogSourceOutputBody: Swift.Equatable {
    let failed: [Swift.String]?
}

extension DeleteAwsLogSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failed)
        var failedDecoded0:[Swift.String]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [Swift.String]()
            for string0 in failedContainer {
                if let string0 = string0 {
                    failedDecoded0?.append(string0)
                }
            }
        }
        failed = failedDecoded0
    }
}

enum DeleteAwsLogSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomLogSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sourceVersion = sourceVersion {
                let sourceVersionQueryItem = ClientRuntime.URLQueryItem(name: "sourceVersion".urlPercentEncoding(), value: Swift.String(sourceVersion).urlPercentEncoding())
                items.append(sourceVersionQueryItem)
            }
            return items
        }
    }
}

extension DeleteCustomLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceName = sourceName else {
            return nil
        }
        return "/v1/datalake/logsources/custom/\(sourceName.urlPercentEncoding())"
    }
}

public struct DeleteCustomLogSourceInput: Swift.Equatable {
    /// The source name of custom log source that you want to delete.
    /// This member is required.
    public var sourceName: Swift.String?
    /// The source version for the third-party custom source. You can limit the custom source removal to the specified source version.
    public var sourceVersion: Swift.String?

    public init(
        sourceName: Swift.String? = nil,
        sourceVersion: Swift.String? = nil
    )
    {
        self.sourceName = sourceName
        self.sourceVersion = sourceVersion
    }
}

struct DeleteCustomLogSourceInputBody: Swift.Equatable {
}

extension DeleteCustomLogSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomLogSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCustomLogSourceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCustomLogSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataLakeExceptionSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct DeleteDataLakeExceptionSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct DeleteDataLakeExceptionSubscriptionInputBody: Swift.Equatable {
}

extension DeleteDataLakeExceptionSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataLakeExceptionSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataLakeExceptionSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataLakeExceptionSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataLakeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
    }
}

extension DeleteDataLakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/delete"
    }
}

public struct DeleteDataLakeInput: Swift.Equatable {
    /// The list of Regions where Security Lake is enabled.
    /// This member is required.
    public var regions: [Swift.String]?

    public init(
        regions: [Swift.String]? = nil
    )
    {
        self.regions = regions
    }
}

struct DeleteDataLakeInputBody: Swift.Equatable {
    let regions: [Swift.String]?
}

extension DeleteDataLakeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension DeleteDataLakeOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnableNewAccount = autoEnableNewAccount {
            var autoEnableNewAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoEnableNewAccount)
            for datalakeautoenablenewaccountconfiguration0 in autoEnableNewAccount {
                try autoEnableNewAccountContainer.encode(datalakeautoenablenewaccountconfiguration0)
            }
        }
    }
}

extension DeleteDataLakeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/organization/configuration/delete"
    }
}

public struct DeleteDataLakeOrganizationConfigurationInput: Swift.Equatable {
    /// Turns off automatic enablement of Security Lake for member accounts that are added to an organization.
    /// This member is required.
    public var autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?

    public init(
        autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
    )
    {
        self.autoEnableNewAccount = autoEnableNewAccount
    }
}

struct DeleteDataLakeOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?
}

extension DeleteDataLakeOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableNewAccountContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration?].self, forKey: .autoEnableNewAccount)
        var autoEnableNewAccountDecoded0:[SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
        if let autoEnableNewAccountContainer = autoEnableNewAccountContainer {
            autoEnableNewAccountDecoded0 = [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]()
            for structure0 in autoEnableNewAccountContainer {
                if let structure0 = structure0 {
                    autoEnableNewAccountDecoded0?.append(structure0)
                }
            }
        }
        autoEnableNewAccount = autoEnableNewAccountDecoded0
    }
}

extension DeleteDataLakeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataLakeOrganizationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataLakeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataLakeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDataLakeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDataLakeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())"
    }
}

public struct DeleteSubscriberInput: Swift.Equatable {
    /// A value created by Security Lake that uniquely identifies your DeleteSubscriber API request.
    /// This member is required.
    public var subscriberId: Swift.String?

    public init(
        subscriberId: Swift.String? = nil
    )
    {
        self.subscriberId = subscriberId
    }
}

struct DeleteSubscriberInputBody: Swift.Equatable {
}

extension DeleteSubscriberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriberNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())/notification"
    }
}

public struct DeleteSubscriberNotificationInput: Swift.Equatable {
    /// The ID of the Security Lake subscriber account.
    /// This member is required.
    public var subscriberId: Swift.String?

    public init(
        subscriberId: Swift.String? = nil
    )
    {
        self.subscriberId = subscriberId
    }
}

struct DeleteSubscriberNotificationInputBody: Swift.Equatable {
}

extension DeleteSubscriberNotificationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriberNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSubscriberNotificationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriberNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSubscriberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterDataLakeDelegatedAdministratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/delegate"
    }
}

public struct DeregisterDataLakeDelegatedAdministratorInput: Swift.Equatable {

    public init() { }
}

struct DeregisterDataLakeDelegatedAdministratorInputBody: Swift.Equatable {
}

extension DeregisterDataLakeDelegatedAdministratorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterDataLakeDelegatedAdministratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterDataLakeDelegatedAdministratorOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterDataLakeDelegatedAdministratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataLakeExceptionSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct GetDataLakeExceptionSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct GetDataLakeExceptionSubscriptionInputBody: Swift.Equatable {
}

extension GetDataLakeExceptionSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataLakeExceptionSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataLakeExceptionSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.exceptionTimeToLive = output.exceptionTimeToLive
            self.notificationEndpoint = output.notificationEndpoint
            self.subscriptionProtocol = output.subscriptionProtocol
        } else {
            self.exceptionTimeToLive = nil
            self.notificationEndpoint = nil
            self.subscriptionProtocol = nil
        }
    }
}

public struct GetDataLakeExceptionSubscriptionOutput: Swift.Equatable {
    /// The expiration period and time-to-live (TTL).
    public var exceptionTimeToLive: Swift.Int?
    /// The Amazon Web Services account where you receive exception notifications.
    public var notificationEndpoint: Swift.String?
    /// The subscription protocol to which exception notifications are posted.
    public var subscriptionProtocol: Swift.String?

    public init(
        exceptionTimeToLive: Swift.Int? = nil,
        notificationEndpoint: Swift.String? = nil,
        subscriptionProtocol: Swift.String? = nil
    )
    {
        self.exceptionTimeToLive = exceptionTimeToLive
        self.notificationEndpoint = notificationEndpoint
        self.subscriptionProtocol = subscriptionProtocol
    }
}

struct GetDataLakeExceptionSubscriptionOutputBody: Swift.Equatable {
    let subscriptionProtocol: Swift.String?
    let notificationEndpoint: Swift.String?
    let exceptionTimeToLive: Swift.Int?
}

extension GetDataLakeExceptionSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionTimeToLive
        case notificationEndpoint
        case subscriptionProtocol
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let notificationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEndpoint)
        notificationEndpoint = notificationEndpointDecoded
        let exceptionTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exceptionTimeToLive)
        exceptionTimeToLive = exceptionTimeToLiveDecoded
    }
}

enum GetDataLakeExceptionSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataLakeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/organization/configuration"
    }
}

public struct GetDataLakeOrganizationConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetDataLakeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension GetDataLakeOrganizationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataLakeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataLakeOrganizationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoEnableNewAccount = output.autoEnableNewAccount
        } else {
            self.autoEnableNewAccount = nil
        }
    }
}

public struct GetDataLakeOrganizationConfigurationOutput: Swift.Equatable {
    /// The configuration for new accounts.
    public var autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?

    public init(
        autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
    )
    {
        self.autoEnableNewAccount = autoEnableNewAccount
    }
}

struct GetDataLakeOrganizationConfigurationOutputBody: Swift.Equatable {
    let autoEnableNewAccount: [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]?
}

extension GetDataLakeOrganizationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccount
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableNewAccountContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration?].self, forKey: .autoEnableNewAccount)
        var autoEnableNewAccountDecoded0:[SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]? = nil
        if let autoEnableNewAccountContainer = autoEnableNewAccountContainer {
            autoEnableNewAccountDecoded0 = [SecurityLakeClientTypes.DataLakeAutoEnableNewAccountConfiguration]()
            for structure0 in autoEnableNewAccountContainer {
                if let structure0 = structure0 {
                    autoEnableNewAccountDecoded0?.append(structure0)
                }
            }
        }
        autoEnableNewAccount = autoEnableNewAccountDecoded0
    }
}

enum GetDataLakeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataLakeSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for awsaccountid0 in accounts {
                try accountsContainer.encode(awsaccountid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetDataLakeSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/sources"
    }
}

public struct GetDataLakeSourcesInput: Swift.Equatable {
    /// The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.
    public var accounts: [Swift.String]?
    /// The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.
    public var maxResults: Swift.Int?
    /// Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        accounts: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDataLakeSourcesInputBody: Swift.Equatable {
    let accounts: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetDataLakeSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDataLakeSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataLakeSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataLakeArn = output.dataLakeArn
            self.dataLakeSources = output.dataLakeSources
            self.nextToken = output.nextToken
        } else {
            self.dataLakeArn = nil
            self.dataLakeSources = nil
            self.nextToken = nil
        }
    }
}

public struct GetDataLakeSourcesOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) created by you to provide to the subscriber. For more information about ARNs and how to use them in policies, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html).
    public var dataLakeArn: Swift.String?
    /// The list of enabled accounts and enabled sources.
    public var dataLakeSources: [SecurityLakeClientTypes.DataLakeSource]?
    /// Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        dataLakeArn: Swift.String? = nil,
        dataLakeSources: [SecurityLakeClientTypes.DataLakeSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataLakeArn = dataLakeArn
        self.dataLakeSources = dataLakeSources
        self.nextToken = nextToken
    }
}

struct GetDataLakeSourcesOutputBody: Swift.Equatable {
    let dataLakeArn: Swift.String?
    let dataLakeSources: [SecurityLakeClientTypes.DataLakeSource]?
    let nextToken: Swift.String?
}

extension GetDataLakeSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakeArn
        case dataLakeSources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLakeArn)
        dataLakeArn = dataLakeArnDecoded
        let dataLakeSourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeSource?].self, forKey: .dataLakeSources)
        var dataLakeSourcesDecoded0:[SecurityLakeClientTypes.DataLakeSource]? = nil
        if let dataLakeSourcesContainer = dataLakeSourcesContainer {
            dataLakeSourcesDecoded0 = [SecurityLakeClientTypes.DataLakeSource]()
            for structure0 in dataLakeSourcesContainer {
                if let structure0 = structure0 {
                    dataLakeSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataLakeSources = dataLakeSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDataLakeSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())"
    }
}

public struct GetSubscriberInput: Swift.Equatable {
    /// A value created by Amazon Security Lake that uniquely identifies your GetSubscriber API request.
    /// This member is required.
    public var subscriberId: Swift.String?

    public init(
        subscriberId: Swift.String? = nil
    )
    {
        self.subscriberId = subscriberId
    }
}

struct GetSubscriberInputBody: Swift.Equatable {
}

extension GetSubscriberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriberOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriber = output.subscriber
        } else {
            self.subscriber = nil
        }
    }
}

public struct GetSubscriberOutput: Swift.Equatable {
    /// The subscriber information for the specified subscriber ID.
    public var subscriber: SecurityLakeClientTypes.SubscriberResource?

    public init(
        subscriber: SecurityLakeClientTypes.SubscriberResource? = nil
    )
    {
        self.subscriber = subscriber
    }
}

struct GetSubscriberOutputBody: Swift.Equatable {
    let subscriber: SecurityLakeClientTypes.SubscriberResource?
}

extension GetSubscriberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberResource.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

enum GetSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SecurityLakeClientTypes {
    public enum HttpMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpMethod] {
            return [
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpMethod(rawValue: rawValue) ?? HttpMethod.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.HttpsNotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationApiKeyName
        case authorizationApiKeyValue
        case endpoint
        case httpMethod
        case targetRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationApiKeyName = self.authorizationApiKeyName {
            try encodeContainer.encode(authorizationApiKeyName, forKey: .authorizationApiKeyName)
        }
        if let authorizationApiKeyValue = self.authorizationApiKeyValue {
            try encodeContainer.encode(authorizationApiKeyValue, forKey: .authorizationApiKeyValue)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let targetRoleArn = self.targetRoleArn {
            try encodeContainer.encode(targetRoleArn, forKey: .targetRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let authorizationApiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationApiKeyName)
        authorizationApiKeyName = authorizationApiKeyNameDecoded
        let authorizationApiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationApiKeyValue)
        authorizationApiKeyValue = authorizationApiKeyValueDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.HttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let targetRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRoleArn)
        targetRoleArn = targetRoleArnDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The configurations for HTTPS subscriber notification.
    public struct HttpsNotificationConfiguration: Swift.Equatable {
        /// The key name for the notification subscription.
        public var authorizationApiKeyName: Swift.String?
        /// The key value for the notification subscription.
        public var authorizationApiKeyValue: Swift.String?
        /// The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The HTTPS method used for the notification subscription.
        public var httpMethod: SecurityLakeClientTypes.HttpMethod?
        /// The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created. For more information about ARNs and how to use them in policies, see [Managing data access](https://docs.aws.amazon.com//security-lake/latest/userguide/subscriber-data-access.html) and [Amazon Web Services Managed Policies](https://docs.aws.amazon.com/security-lake/latest/userguide/security-iam-awsmanpol.html) in the Amazon Security Lake User Guide.
        /// This member is required.
        public var targetRoleArn: Swift.String?

        public init(
            authorizationApiKeyName: Swift.String? = nil,
            authorizationApiKeyValue: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            httpMethod: SecurityLakeClientTypes.HttpMethod? = nil,
            targetRoleArn: Swift.String? = nil
        )
        {
            self.authorizationApiKeyName = authorizationApiKeyName
            self.authorizationApiKeyValue = authorizationApiKeyValue
            self.endpoint = endpoint
            self.httpMethod = httpMethod
            self.targetRoleArn = targetRoleArn
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Internal service exceptions are sometimes caused by transient issues. Before you start troubleshooting, perform the operation again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDataLakeExceptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
    }
}

extension ListDataLakeExceptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions"
    }
}

public struct ListDataLakeExceptionsInput: Swift.Equatable {
    /// List the maximum number of failures in Security Lake.
    public var maxResults: Swift.Int?
    /// List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// List the Amazon Web Services Regions from which exceptions are retrieved.
    public var regions: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regions = regions
    }
}

struct ListDataLakeExceptionsInputBody: Swift.Equatable {
    let regions: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDataLakeExceptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case regions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataLakeExceptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataLakeExceptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.exceptions = output.exceptions
            self.nextToken = output.nextToken
        } else {
            self.exceptions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataLakeExceptionsOutput: Swift.Equatable {
    /// Lists the failures that cannot be retried in the current Region.
    public var exceptions: [SecurityLakeClientTypes.DataLakeException]?
    /// List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        exceptions: [SecurityLakeClientTypes.DataLakeException]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exceptions = exceptions
        self.nextToken = nextToken
    }
}

struct ListDataLakeExceptionsOutputBody: Swift.Equatable {
    let exceptions: [SecurityLakeClientTypes.DataLakeException]?
    let nextToken: Swift.String?
}

extension ListDataLakeExceptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeException?].self, forKey: .exceptions)
        var exceptionsDecoded0:[SecurityLakeClientTypes.DataLakeException]? = nil
        if let exceptionsContainer = exceptionsContainer {
            exceptionsDecoded0 = [SecurityLakeClientTypes.DataLakeException]()
            for structure0 in exceptionsContainer {
                if let structure0 = structure0 {
                    exceptionsDecoded0?.append(structure0)
                }
            }
        }
        exceptions = exceptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataLakeExceptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataLakesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let regions = regions {
                regions.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "regions".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListDataLakesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalakes"
    }
}

public struct ListDataLakesInput: Swift.Equatable {
    /// The list of regions where Security Lake is enabled.
    public var regions: [Swift.String]?

    public init(
        regions: [Swift.String]? = nil
    )
    {
        self.regions = regions
    }
}

struct ListDataLakesInputBody: Swift.Equatable {
}

extension ListDataLakesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataLakesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataLakesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataLakes = output.dataLakes
        } else {
            self.dataLakes = nil
        }
    }
}

public struct ListDataLakesOutput: Swift.Equatable {
    /// Retrieves the Security Lake configuration object.
    public var dataLakes: [SecurityLakeClientTypes.DataLakeResource]?

    public init(
        dataLakes: [SecurityLakeClientTypes.DataLakeResource]? = nil
    )
    {
        self.dataLakes = dataLakes
    }
}

struct ListDataLakesOutputBody: Swift.Equatable {
    let dataLakes: [SecurityLakeClientTypes.DataLakeResource]?
}

extension ListDataLakesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeResource?].self, forKey: .dataLakes)
        var dataLakesDecoded0:[SecurityLakeClientTypes.DataLakeResource]? = nil
        if let dataLakesContainer = dataLakesContainer {
            dataLakesDecoded0 = [SecurityLakeClientTypes.DataLakeResource]()
            for structure0 in dataLakesContainer {
                if let structure0 = structure0 {
                    dataLakesDecoded0?.append(structure0)
                }
            }
        }
        dataLakes = dataLakesDecoded0
    }
}

enum ListDataLakesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLogSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case maxResults
        case nextToken
        case regions
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for awsaccountid0 in accounts {
                try accountsContainer.encode(awsaccountid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for logsourceresource0 in sources {
                try sourcesContainer.encode(logsourceresource0)
            }
        }
    }
}

extension ListLogSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/logsources/list"
    }
}

public struct ListLogSourcesInput: Swift.Equatable {
    /// The list of Amazon Web Services accounts for which log sources are displayed.
    public var accounts: [Swift.String]?
    /// The maximum number of accounts for which the log sources are displayed.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The list of regions for which log sources are displayed.
    public var regions: [Swift.String]?
    /// The list of sources for which log sources are displayed.
    public var sources: [SecurityLakeClientTypes.LogSourceResource]?

    public init(
        accounts: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        sources: [SecurityLakeClientTypes.LogSourceResource]? = nil
    )
    {
        self.accounts = accounts
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regions = regions
        self.sources = sources
    }
}

struct ListLogSourcesInputBody: Swift.Equatable {
    let accounts: [Swift.String]?
    let regions: [Swift.String]?
    let sources: [SecurityLakeClientTypes.LogSourceResource]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLogSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case maxResults
        case nextToken
        case regions
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSourceResource]()
            for union0 in sourcesContainer {
                if let union0 = union0 {
                    sourcesDecoded0?.append(union0)
                }
            }
        }
        sources = sourcesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLogSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sources = output.sources
        } else {
            self.nextToken = nil
            self.sources = nil
        }
    }
}

public struct ListLogSourcesOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The list of log sources in your organization that send data to the data lake.
    public var sources: [SecurityLakeClientTypes.LogSource]?

    public init(
        nextToken: Swift.String? = nil,
        sources: [SecurityLakeClientTypes.LogSource]? = nil
    )
    {
        self.nextToken = nextToken
        self.sources = sources
    }
}

struct ListLogSourcesOutputBody: Swift.Equatable {
    let sources: [SecurityLakeClientTypes.LogSource]?
    let nextToken: Swift.String?
}

extension ListLogSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLogSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscribersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscribersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/subscribers"
    }
}

public struct ListSubscribersInput: Swift.Equatable {
    /// The maximum number of accounts for which the configuration is displayed.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubscribersInputBody: Swift.Equatable {
}

extension ListSubscribersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscribersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscribersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

public struct ListSubscribersOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The subscribers available for the specified Security Lake account ID.
    public var subscribers: [SecurityLakeClientTypes.SubscriberResource]?

    public init(
        nextToken: Swift.String? = nil,
        subscribers: [SecurityLakeClientTypes.SubscriberResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct ListSubscribersOutputBody: Swift.Equatable {
    let subscribers: [SecurityLakeClientTypes.SubscriberResource]?
    let nextToken: Swift.String?
}

extension ListSubscribersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subscribers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.SubscriberResource?].self, forKey: .subscribers)
        var subscribersDecoded0:[SecurityLakeClientTypes.SubscriberResource]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [SecurityLakeClientTypes.SubscriberResource]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscribersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Security Lake resource to retrieve the tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An array of objects, one for each tag (key and value) thats associated with the Amazon Security Lake resource.
    public var tags: [SecurityLakeClientTypes.Tag]?

    public init(
        tags: [SecurityLakeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [SecurityLakeClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecurityLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecurityLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SecurityLakeClientTypes.LogSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
        case region
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for logsourceresource0 in sources {
                try sourcesContainer.encode(logsourceresource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSourceResource]()
            for union0 in sourcesContainer {
                if let union0 = union0 {
                    sourcesDecoded0?.append(union0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Amazon Security Lake can collect logs and events from natively-supported Amazon Web Services services and custom sources.
    public struct LogSource: Swift.Equatable {
        /// Specify the account from which you want to collect logs.
        public var account: Swift.String?
        /// Specify the Regions from which you want to collect logs.
        public var region: Swift.String?
        /// Specify the sources from which you want to collect logs.
        public var sources: [SecurityLakeClientTypes.LogSourceResource]?

        public init(
            account: Swift.String? = nil,
            region: Swift.String? = nil,
            sources: [SecurityLakeClientTypes.LogSourceResource]? = nil
        )
        {
            self.account = account
            self.region = region
            self.sources = sources
        }
    }

}

extension SecurityLakeClientTypes.LogSourceResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awslogsource = "awsLogSource"
        case customlogsource = "customLogSource"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awslogsource(awslogsource):
                try container.encode(awslogsource, forKey: .awslogsource)
            case let .customlogsource(customlogsource):
                try container.encode(customlogsource, forKey: .customlogsource)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let awslogsourceDecoded = try values.decodeIfPresent(SecurityLakeClientTypes.AwsLogSourceResource.self, forKey: .awslogsource)
        if let awslogsource = awslogsourceDecoded {
            self = .awslogsource(awslogsource)
            return
        }
        let customlogsourceDecoded = try values.decodeIfPresent(SecurityLakeClientTypes.CustomLogSourceResource.self, forKey: .customlogsource)
        if let customlogsource = customlogsourceDecoded {
            self = .customlogsource(customlogsource)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SecurityLakeClientTypes {
    /// The supported source types from which logs and events are collected in Amazon Security Lake. For a list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    public enum LogSourceResource: Swift.Equatable {
        /// Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
        case awslogsource(SecurityLakeClientTypes.AwsLogSourceResource)
        /// Amazon Security Lake supports custom source types. For more information, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/custom-sources.html).
        case customlogsource(SecurityLakeClientTypes.CustomLogSourceResource)
        case sdkUnknown(Swift.String)
    }

}

extension SecurityLakeClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpsnotificationconfiguration = "httpsNotificationConfiguration"
        case sdkUnknown
        case sqsnotificationconfiguration = "sqsNotificationConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .httpsnotificationconfiguration(httpsnotificationconfiguration):
                try container.encode(httpsnotificationconfiguration, forKey: .httpsnotificationconfiguration)
            case let .sqsnotificationconfiguration(sqsnotificationconfiguration):
                try container.encode(sqsnotificationconfiguration, forKey: .sqsnotificationconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sqsnotificationconfigurationDecoded = try values.decodeIfPresent(SecurityLakeClientTypes.SqsNotificationConfiguration.self, forKey: .sqsnotificationconfiguration)
        if let sqsnotificationconfiguration = sqsnotificationconfigurationDecoded {
            self = .sqsnotificationconfiguration(sqsnotificationconfiguration)
            return
        }
        let httpsnotificationconfigurationDecoded = try values.decodeIfPresent(SecurityLakeClientTypes.HttpsNotificationConfiguration.self, forKey: .httpsnotificationconfiguration)
        if let httpsnotificationconfiguration = httpsnotificationconfigurationDecoded {
            self = .httpsnotificationconfiguration(httpsnotificationconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SecurityLakeClientTypes {
    /// Specify the configurations you want to use for subscriber notification to notify the subscriber when new data is written to the data lake for sources that the subscriber consumes in Security Lake.
    public enum NotificationConfiguration: Swift.Equatable {
        /// The configurations for SQS subscriber notification.
        case sqsnotificationconfiguration(SecurityLakeClientTypes.SqsNotificationConfiguration)
        /// The configurations for HTTPS subscriber notification.
        case httpsnotificationconfiguration(SecurityLakeClientTypes.HttpsNotificationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension RegisterDataLakeDelegatedAdministratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension RegisterDataLakeDelegatedAdministratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/delegate"
    }
}

public struct RegisterDataLakeDelegatedAdministratorInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Security Lake delegated administrator.
    /// This member is required.
    public var accountId: Swift.String?

    public init(
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct RegisterDataLakeDelegatedAdministratorInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension RegisterDataLakeDelegatedAdministratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension RegisterDataLakeDelegatedAdministratorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterDataLakeDelegatedAdministratorOutput: Swift.Equatable {

    public init() { }
}

enum RegisterDataLakeDelegatedAdministratorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that could not be found.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of the resource that could not be found.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SecurityLakeClientTypes {
    public enum SourceCollectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collecting
        case misconfigured
        case notCollecting
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCollectionStatus] {
            return [
                .collecting,
                .misconfigured,
                .notCollecting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collecting: return "COLLECTING"
            case .misconfigured: return "MISCONFIGURED"
            case .notCollecting: return "NOT_COLLECTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceCollectionStatus(rawValue: rawValue) ?? SourceCollectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.SqsNotificationConfiguration: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SecurityLakeClientTypes {
    /// The configurations for SQS subscriber notification.
    public struct SqsNotificationConfiguration: Swift.Equatable {

        public init() { }
    }

}

extension SecurityLakeClientTypes.SubscriberResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case createdAt
        case resourceShareArn
        case resourceShareName
        case roleArn
        case s3BucketArn
        case sources
        case subscriberArn
        case subscriberDescription
        case subscriberEndpoint
        case subscriberId
        case subscriberIdentity
        case subscriberName
        case subscriberStatus
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTypes = accessTypes {
            var accessTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessTypes)
            for accesstype0 in accessTypes {
                try accessTypesContainer.encode(accesstype0.rawValue)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = self.resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for logsourceresource0 in sources {
                try sourcesContainer.encode(logsourceresource0)
            }
        }
        if let subscriberArn = self.subscriberArn {
            try encodeContainer.encode(subscriberArn, forKey: .subscriberArn)
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberEndpoint = self.subscriberEndpoint {
            try encodeContainer.encode(subscriberEndpoint, forKey: .subscriberEndpoint)
        }
        if let subscriberId = self.subscriberId {
            try encodeContainer.encode(subscriberId, forKey: .subscriberId)
        }
        if let subscriberIdentity = self.subscriberIdentity {
            try encodeContainer.encode(subscriberIdentity, forKey: .subscriberIdentity)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
        if let subscriberStatus = self.subscriberStatus {
            try encodeContainer.encode(subscriberStatus.rawValue, forKey: .subscriberStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberId)
        subscriberId = subscriberIdDecoded
        let subscriberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberArn)
        subscriberArn = subscriberArnDecoded
        let subscriberIdentityDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsIdentity.self, forKey: .subscriberIdentity)
        subscriberIdentity = subscriberIdentityDecoded
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSourceResource]()
            for union0 in sourcesContainer {
                if let union0 = union0 {
                    sourcesDecoded0?.append(union0)
                }
            }
        }
        sources = sourcesDecoded0
        let accessTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AccessType?].self, forKey: .accessTypes)
        var accessTypesDecoded0:[SecurityLakeClientTypes.AccessType]? = nil
        if let accessTypesContainer = accessTypesContainer {
            accessTypesDecoded0 = [SecurityLakeClientTypes.AccessType]()
            for enum0 in accessTypesContainer {
                if let enum0 = enum0 {
                    accessTypesDecoded0?.append(enum0)
                }
            }
        }
        accessTypes = accessTypesDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let subscriberEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberEndpoint)
        subscriberEndpoint = subscriberEndpointDecoded
        let subscriberStatusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberStatus.self, forKey: .subscriberStatus)
        subscriberStatus = subscriberStatusDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details about the Amazon Security Lake account subscription. Subscribers are notified of new objects for a source as the data is written to your Amazon S3 bucket for Security Lake.
    public struct SubscriberResource: Swift.Equatable {
        /// You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as LAKEFORMATION.
        public var accessTypes: [SecurityLakeClientTypes.AccessType]?
        /// The date and time when the subscriber was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) which uniquely defines the AWS RAM resource share. Before accepting the RAM resource share invitation, you can view details related to the RAM resource share. This field is available only for Lake Formation subscribers created after March 8, 2023.
        public var resourceShareArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The Amazon Resource Name (ARN) specifying the role of the subscriber.
        public var roleArn: Swift.String?
        /// The ARN for the Amazon S3 bucket.
        public var s3BucketArn: Swift.String?
        /// Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/source-management.html).
        /// This member is required.
        public var sources: [SecurityLakeClientTypes.LogSourceResource]?
        /// The subscriber ARN of the Amazon Security Lake subscriber account.
        /// This member is required.
        public var subscriberArn: Swift.String?
        /// The subscriber descriptions for a subscriber account. The description for a subscriber includes subscriberName, accountID, externalID, and subscriberId.
        public var subscriberDescription: Swift.String?
        /// The subscriber endpoint to which exception messages are posted.
        public var subscriberEndpoint: Swift.String?
        /// The subscriber ID of the Amazon Security Lake subscriber account.
        /// This member is required.
        public var subscriberId: Swift.String?
        /// The AWS identity used to access your data.
        /// This member is required.
        public var subscriberIdentity: SecurityLakeClientTypes.AwsIdentity?
        /// The name of your Amazon Security Lake subscriber account.
        /// This member is required.
        public var subscriberName: Swift.String?
        /// The subscriber status of the Amazon Security Lake subscriber account.
        public var subscriberStatus: SecurityLakeClientTypes.SubscriberStatus?
        /// The date and time when the subscriber was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accessTypes: [SecurityLakeClientTypes.AccessType]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3BucketArn: Swift.String? = nil,
            sources: [SecurityLakeClientTypes.LogSourceResource]? = nil,
            subscriberArn: Swift.String? = nil,
            subscriberDescription: Swift.String? = nil,
            subscriberEndpoint: Swift.String? = nil,
            subscriberId: Swift.String? = nil,
            subscriberIdentity: SecurityLakeClientTypes.AwsIdentity? = nil,
            subscriberName: Swift.String? = nil,
            subscriberStatus: SecurityLakeClientTypes.SubscriberStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accessTypes = accessTypes
            self.createdAt = createdAt
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.roleArn = roleArn
            self.s3BucketArn = s3BucketArn
            self.sources = sources
            self.subscriberArn = subscriberArn
            self.subscriberDescription = subscriberDescription
            self.subscriberEndpoint = subscriberEndpoint
            self.subscriberId = subscriberId
            self.subscriberIdentity = subscriberIdentity
            self.subscriberName = subscriberName
            self.subscriberStatus = subscriberStatus
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityLakeClientTypes {
    public enum SubscriberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deactivated
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberStatus] {
            return [
                .active,
                .deactivated,
                .pending,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deactivated: return "DEACTIVATED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriberStatus(rawValue: rawValue) ?? SubscriberStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityLakeClientTypes {
    /// A tag is a label that you can define and associate with Amazon Web Services resources, including certain types of Amazon Security Lake resources. Tags can help you identify, categorize, and manage resources in different ways, such as by owner, environment, or other criteria. You can associate tags with the following types of Security Lake resources: subscribers, and the data lake configuration for your Amazon Web Services account in individual Amazon Web Services Regions. A resource can have up to 50 tags. Each tag consists of a required tag key and an associated tag value. A tag key is a general label that acts as a category for a more specific tag value. Each tag key must be unique and it can have only one tag value. A tag value acts as a descriptor for a tag key. Tag keys and values are case sensitive. They can contain letters, numbers, spaces, or the following symbols: _ . : / = + @ - For more information, see [Tagging Amazon Security Lake resources](https://docs.aws.amazon.com/security-lake/latest/userguide/tagging-resources.html) in the Amazon Security Lake User Guide.
    public struct Tag: Swift.Equatable {
        /// The name of the tag. This is a general label that acts as a category for a more specific tag value (value).
        /// This member is required.
        public var key: Swift.String?
        /// The value thats associated with the specified tag key (key). This value acts as a descriptor for the tag key. A tag value cannot be null, but it can be an empty string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Security Lake resource to add or update the tags for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of objects, one for each tag (key and value) to associate with the Amazon Security Lake resource. For each tag, you must specify both a tag key and a tag value. A tag value cannot be null, but it can be an empty string.
    /// This member is required.
    public var tags: [SecurityLakeClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [SecurityLakeClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [SecurityLakeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SecurityLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SecurityLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// That the rate of requests to Security Lake is exceeding the request quotas for your Amazon Web Services account.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Retry the request after the specified time.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service in Service Quotas.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Security Lake resource to remove one or more tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of one or more tag keys. For each value in the list, specify the tag key for a tag to remove from the Amazon Security Lake resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataLakeExceptionSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionTimeToLive
        case notificationEndpoint
        case subscriptionProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionTimeToLive = self.exceptionTimeToLive {
            try encodeContainer.encode(exceptionTimeToLive, forKey: .exceptionTimeToLive)
        }
        if let notificationEndpoint = self.notificationEndpoint {
            try encodeContainer.encode(notificationEndpoint, forKey: .notificationEndpoint)
        }
        if let subscriptionProtocol = self.subscriptionProtocol {
            try encodeContainer.encode(subscriptionProtocol, forKey: .subscriptionProtocol)
        }
    }
}

extension UpdateDataLakeExceptionSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct UpdateDataLakeExceptionSubscriptionInput: Swift.Equatable {
    /// The time-to-live (TTL) for the exception message to remain.
    public var exceptionTimeToLive: Swift.Int?
    /// The account that is subscribed to receive exception notifications.
    /// This member is required.
    public var notificationEndpoint: Swift.String?
    /// The subscription protocol to which exception messages are posted.
    /// This member is required.
    public var subscriptionProtocol: Swift.String?

    public init(
        exceptionTimeToLive: Swift.Int? = nil,
        notificationEndpoint: Swift.String? = nil,
        subscriptionProtocol: Swift.String? = nil
    )
    {
        self.exceptionTimeToLive = exceptionTimeToLive
        self.notificationEndpoint = notificationEndpoint
        self.subscriptionProtocol = subscriptionProtocol
    }
}

struct UpdateDataLakeExceptionSubscriptionInputBody: Swift.Equatable {
    let subscriptionProtocol: Swift.String?
    let notificationEndpoint: Swift.String?
    let exceptionTimeToLive: Swift.Int?
}

extension UpdateDataLakeExceptionSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionTimeToLive
        case notificationEndpoint
        case subscriptionProtocol
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let notificationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEndpoint)
        notificationEndpoint = notificationEndpointDecoded
        let exceptionTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exceptionTimeToLive)
        exceptionTimeToLive = exceptionTimeToLiveDecoded
    }
}

extension UpdateDataLakeExceptionSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataLakeExceptionSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataLakeExceptionSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataLakeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for datalakeconfiguration0 in configurations {
                try configurationsContainer.encode(datalakeconfiguration0)
            }
        }
    }
}

extension UpdateDataLakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct UpdateDataLakeInput: Swift.Equatable {
    /// Specify the Region or Regions that will contribute data to the rollup region.
    /// This member is required.
    public var configurations: [SecurityLakeClientTypes.DataLakeConfiguration]?

    public init(
        configurations: [SecurityLakeClientTypes.DataLakeConfiguration]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct UpdateDataLakeInputBody: Swift.Equatable {
    let configurations: [SecurityLakeClientTypes.DataLakeConfiguration]?
}

extension UpdateDataLakeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeConfiguration?].self, forKey: .configurations)
        var configurationsDecoded0:[SecurityLakeClientTypes.DataLakeConfiguration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [SecurityLakeClientTypes.DataLakeConfiguration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension UpdateDataLakeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataLakeOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataLakes = output.dataLakes
        } else {
            self.dataLakes = nil
        }
    }
}

public struct UpdateDataLakeOutput: Swift.Equatable {
    /// The created Security Lake configuration object.
    public var dataLakes: [SecurityLakeClientTypes.DataLakeResource]?

    public init(
        dataLakes: [SecurityLakeClientTypes.DataLakeResource]? = nil
    )
    {
        self.dataLakes = dataLakes
    }
}

struct UpdateDataLakeOutputBody: Swift.Equatable {
    let dataLakes: [SecurityLakeClientTypes.DataLakeResource]?
}

extension UpdateDataLakeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLakes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLakesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.DataLakeResource?].self, forKey: .dataLakes)
        var dataLakesDecoded0:[SecurityLakeClientTypes.DataLakeResource]? = nil
        if let dataLakesContainer = dataLakesContainer {
            dataLakesDecoded0 = [SecurityLakeClientTypes.DataLakeResource]()
            for structure0 in dataLakesContainer {
                if let structure0 = structure0 {
                    dataLakesDecoded0?.append(structure0)
                }
            }
        }
        dataLakes = dataLakesDecoded0
    }
}

enum UpdateDataLakeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
        case subscriberDescription
        case subscriberIdentity
        case subscriberName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for logsourceresource0 in sources {
                try sourcesContainer.encode(logsourceresource0)
            }
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberIdentity = self.subscriberIdentity {
            try encodeContainer.encode(subscriberIdentity, forKey: .subscriberIdentity)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
    }
}

extension UpdateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())"
    }
}

public struct UpdateSubscriberInput: Swift.Equatable {
    /// The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    public var sources: [SecurityLakeClientTypes.LogSourceResource]?
    /// The description of the Security Lake account subscriber.
    public var subscriberDescription: Swift.String?
    /// A value created by Security Lake that uniquely identifies your subscription.
    /// This member is required.
    public var subscriberId: Swift.String?
    /// The AWS identity used to access your data.
    public var subscriberIdentity: SecurityLakeClientTypes.AwsIdentity?
    /// The name of the Security Lake account subscriber.
    public var subscriberName: Swift.String?

    public init(
        sources: [SecurityLakeClientTypes.LogSourceResource]? = nil,
        subscriberDescription: Swift.String? = nil,
        subscriberId: Swift.String? = nil,
        subscriberIdentity: SecurityLakeClientTypes.AwsIdentity? = nil,
        subscriberName: Swift.String? = nil
    )
    {
        self.sources = sources
        self.subscriberDescription = subscriberDescription
        self.subscriberId = subscriberId
        self.subscriberIdentity = subscriberIdentity
        self.subscriberName = subscriberName
    }
}

struct UpdateSubscriberInputBody: Swift.Equatable {
    let subscriberIdentity: SecurityLakeClientTypes.AwsIdentity?
    let subscriberName: Swift.String?
    let subscriberDescription: Swift.String?
    let sources: [SecurityLakeClientTypes.LogSourceResource]?
}

extension UpdateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources
        case subscriberDescription
        case subscriberIdentity
        case subscriberName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberIdentityDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.AwsIdentity.self, forKey: .subscriberIdentity)
        subscriberIdentity = subscriberIdentityDecoded
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogSourceResource?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.LogSourceResource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.LogSourceResource]()
            for union0 in sourcesContainer {
                if let union0 = union0 {
                    sourcesDecoded0?.append(union0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension UpdateSubscriberNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
    }
}

extension UpdateSubscriberNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriberId = subscriberId else {
            return nil
        }
        return "/v1/subscribers/\(subscriberId.urlPercentEncoding())/notification"
    }
}

public struct UpdateSubscriberNotificationInput: Swift.Equatable {
    /// The configuration for subscriber notification.
    /// This member is required.
    public var configuration: SecurityLakeClientTypes.NotificationConfiguration?
    /// The subscription ID for which the subscription notification is specified.
    /// This member is required.
    public var subscriberId: Swift.String?

    public init(
        configuration: SecurityLakeClientTypes.NotificationConfiguration? = nil,
        subscriberId: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.subscriberId = subscriberId
    }
}

struct UpdateSubscriberNotificationInputBody: Swift.Equatable {
    let configuration: SecurityLakeClientTypes.NotificationConfiguration?
}

extension UpdateSubscriberNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.NotificationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateSubscriberNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriberNotificationOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriberEndpoint = output.subscriberEndpoint
        } else {
            self.subscriberEndpoint = nil
        }
    }
}

public struct UpdateSubscriberNotificationOutput: Swift.Equatable {
    /// The subscriber endpoint to which exception messages are posted.
    public var subscriberEndpoint: Swift.String?

    public init(
        subscriberEndpoint: Swift.String? = nil
    )
    {
        self.subscriberEndpoint = subscriberEndpoint
    }
}

struct UpdateSubscriberNotificationOutputBody: Swift.Equatable {
    let subscriberEndpoint: Swift.String?
}

extension UpdateSubscriberNotificationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriberEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberEndpoint)
        subscriberEndpoint = subscriberEndpointDecoded
    }
}

enum UpdateSubscriberNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSubscriberOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriber = output.subscriber
        } else {
            self.subscriber = nil
        }
    }
}

public struct UpdateSubscriberOutput: Swift.Equatable {
    /// The updated subscriber information.
    public var subscriber: SecurityLakeClientTypes.SubscriberResource?

    public init(
        subscriber: SecurityLakeClientTypes.SubscriberResource? = nil
    )
    {
        self.subscriber = subscriber
    }
}

struct UpdateSubscriberOutputBody: Swift.Equatable {
    let subscriber: SecurityLakeClientTypes.SubscriberResource?
}

extension UpdateSubscriberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberResource.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

enum UpdateSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
