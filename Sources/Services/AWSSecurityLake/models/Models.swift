// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action. Access denied errors appear when Amazon Security Lake explicitly or implicitly denies an authorization request. An explicit denial occurs when a policy contains a Deny statement for the specific Amazon Web Services action. An implicit denial occurs when there is no applicable Deny statement and also no applicable Allow statement.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityLakeClientTypes {
    public enum AccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lakeformation
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .lakeformation,
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lakeformation: return "LAKEFORMATION"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessType(rawValue: rawValue) ?? AccessType.sdkUnknown(rawValue)
        }
    }
}

extension AccountNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Security Lake cannot find an Amazon Web Services account with the accountID that you specified, or the account whose credentials you used to make this request isn't a member of an organization.
public struct AccountNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityLakeClientTypes.AccountSources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
        case eventClass
        case logsStatus
        case sourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let eventClass = self.eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let logsStatus = logsStatus {
            var logsStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logsStatus)
            for logsstatus0 in logsStatus {
                try logsStatusContainer.encode(logsstatus0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let logsStatusContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.LogsStatus?].self, forKey: .logsStatus)
        var logsStatusDecoded0:[SecurityLakeClientTypes.LogsStatus]? = nil
        if let logsStatusContainer = logsStatusContainer {
            logsStatusDecoded0 = [SecurityLakeClientTypes.LogsStatus]()
            for structure0 in logsStatusContainer {
                if let structure0 = structure0 {
                    logsStatusDecoded0?.append(structure0)
                }
            }
        }
        logsStatus = logsStatusDecoded0
        let eventClassDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.OcsfEventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Amazon Security Lake collects logs and events from supported Amazon Web Services and custom sources. For the list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    public struct AccountSources: Swift.Equatable {
        /// The ID of the Security Lake account for which logs are collected.
        /// This member is required.
        public var account: Swift.String?
        /// Initializes a new instance of the Event class.
        public var eventClass: SecurityLakeClientTypes.OcsfEventClass?
        /// The log status for the Security Lake account.
        public var logsStatus: [SecurityLakeClientTypes.LogsStatus]?
        /// The supported Amazon Web Services from which logs and events are collected. Amazon Security Lake supports log and event collection for natively supported Amazon Web Services.
        /// This member is required.
        public var sourceType: Swift.String?

        public init (
            account: Swift.String? = nil,
            eventClass: SecurityLakeClientTypes.OcsfEventClass? = nil,
            logsStatus: [SecurityLakeClientTypes.LogsStatus]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.account = account
            self.eventClass = eventClass
            self.logsStatus = logsStatus
            self.sourceType = sourceType
        }
    }

}

extension SecurityLakeClientTypes.AutoEnableNewRegionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for awslogsourcetype0 in sources {
                try sourcesContainer.encode(awslogsourcetype0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.Region.self, forKey: .region)
        region = regionDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AwsLogSourceType?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityLakeClientTypes.AwsLogSourceType]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityLakeClientTypes.AwsLogSourceType]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Automatically enable new organization accounts as member accounts from an Amazon Security Lake administrator account.
    public struct AutoEnableNewRegionConfiguration: Swift.Equatable {
        /// The Amazon Web Services Regions where Security Lake is automatically enabled.
        /// This member is required.
        public var region: SecurityLakeClientTypes.Region?
        /// The Amazon Web Services sources that are automatically enabled in Security Lake.
        /// This member is required.
        public var sources: [SecurityLakeClientTypes.AwsLogSourceType]?

        public init (
            region: SecurityLakeClientTypes.Region? = nil,
            sources: [SecurityLakeClientTypes.AwsLogSourceType]? = nil
        )
        {
            self.region = region
            self.sources = sources
        }
    }

}

extension SecurityLakeClientTypes {
    public enum AwsLogSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case route53
        case shFindings
        case vpcFlow
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsLogSourceType] {
            return [
                .cloudTrail,
                .route53,
                .shFindings,
                .vpcFlow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .route53: return "ROUTE53"
            case .shFindings: return "SH_FINDINGS"
            case .vpcFlow: return "VPC_FLOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsLogSourceType(rawValue: rawValue) ?? AwsLogSourceType.sdkUnknown(rawValue)
        }
    }
}

extension BucketNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BucketNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Security Lake generally returns 404 errors if the requested object is missing from the bucket.
public struct BucketNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BucketNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BucketNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// More than one process tried to modify a resource at the same time.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// A conflict occurred when prompting for the Resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ConflictSourceNamesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictSourceNamesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was a conflict when you attempted to modify a Security Lake source name.
public struct ConflictSourceNamesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictSourceNamesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictSourceNamesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictSubscriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictSubscriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflicting subscription exception operation is in progress.
public struct ConflictSubscriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictSubscriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictSubscriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAwsLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableAllDimensions
        case enableSingleDimension
        case enableTwoDimensions
        case inputOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableAllDimensions = enableAllDimensions {
            var enableAllDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .enableAllDimensions)
            for (dictKey0, allDimensionsMap0) in enableAllDimensions {
                var allDimensionsMap0Container = enableAllDimensionsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, twoDimensionsMap1) in allDimensionsMap0 {
                    var twoDimensionsMap1Container = allDimensionsMap0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey1))
                    for string2 in twoDimensionsMap1 {
                        try twoDimensionsMap1Container.encode(string2)
                    }
                }
            }
        }
        if let enableSingleDimension = enableSingleDimension {
            var enableSingleDimensionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enableSingleDimension)
            for safestring0 in enableSingleDimension {
                try enableSingleDimensionContainer.encode(safestring0)
            }
        }
        if let enableTwoDimensions = enableTwoDimensions {
            var enableTwoDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .enableTwoDimensions)
            for (dictKey0, twoDimensionsMap0) in enableTwoDimensions {
                var twoDimensionsMap0Container = enableTwoDimensionsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in twoDimensionsMap0 {
                    try twoDimensionsMap0Container.encode(string1)
                }
            }
        }
        if let inputOrder = inputOrder {
            var inputOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputOrder)
            for dimension0 in inputOrder {
                try inputOrderContainer.encode(dimension0.rawValue)
            }
        }
    }
}

extension CreateAwsLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/logsources/aws"
    }
}

public struct CreateAwsLogSourceInput: Swift.Equatable {
    /// Enables data collection from specific Amazon Web Services sources in all specific accounts and specific Regions.
    public var enableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    /// Enables data collection from all Amazon Web Services sources in specific accounts or Regions.
    public var enableSingleDimension: [Swift.String]?
    /// Enables data collection from specific Amazon Web Services sources in specific accounts or Regions.
    public var enableTwoDimensions: [Swift.String:[Swift.String]]?
    /// Specifies the input order to enable dimensions in Security Lake, namely Region, source type, and member account.
    /// This member is required.
    public var inputOrder: [SecurityLakeClientTypes.Dimension]?

    public init (
        enableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        enableSingleDimension: [Swift.String]? = nil,
        enableTwoDimensions: [Swift.String:[Swift.String]]? = nil,
        inputOrder: [SecurityLakeClientTypes.Dimension]? = nil
    )
    {
        self.enableAllDimensions = enableAllDimensions
        self.enableSingleDimension = enableSingleDimension
        self.enableTwoDimensions = enableTwoDimensions
        self.inputOrder = inputOrder
    }
}

struct CreateAwsLogSourceInputBody: Swift.Equatable {
    let inputOrder: [SecurityLakeClientTypes.Dimension]?
    let enableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    let enableTwoDimensions: [Swift.String:[Swift.String]]?
    let enableSingleDimension: [Swift.String]?
}

extension CreateAwsLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableAllDimensions
        case enableSingleDimension
        case enableTwoDimensions
        case inputOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputOrderContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Dimension?].self, forKey: .inputOrder)
        var inputOrderDecoded0:[SecurityLakeClientTypes.Dimension]? = nil
        if let inputOrderContainer = inputOrderContainer {
            inputOrderDecoded0 = [SecurityLakeClientTypes.Dimension]()
            for string0 in inputOrderContainer {
                if let string0 = string0 {
                    inputOrderDecoded0?.append(string0)
                }
            }
        }
        inputOrder = inputOrderDecoded0
        let enableAllDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .enableAllDimensions)
        var enableAllDimensionsDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let enableAllDimensionsContainer = enableAllDimensionsContainer {
            enableAllDimensionsDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, twodimensionsmap0) in enableAllDimensionsContainer {
                var twodimensionsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let twodimensionsmap0 = twodimensionsmap0 {
                    twodimensionsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, valueset1) in twodimensionsmap0 {
                        var valueset1Decoded1: [Swift.String]? = nil
                        if let valueset1 = valueset1 {
                            valueset1Decoded1 = [Swift.String]()
                            for string2 in valueset1 {
                                if let string2 = string2 {
                                    valueset1Decoded1?.append(string2)
                                }
                            }
                        }
                        twodimensionsmap0Decoded0?[key1] = valueset1Decoded1
                    }
                }
                enableAllDimensionsDecoded0?[key0] = twodimensionsmap0Decoded0
            }
        }
        enableAllDimensions = enableAllDimensionsDecoded0
        let enableTwoDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .enableTwoDimensions)
        var enableTwoDimensionsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let enableTwoDimensionsContainer = enableTwoDimensionsContainer {
            enableTwoDimensionsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, valueset0) in enableTwoDimensionsContainer {
                var valueset0Decoded0: [Swift.String]? = nil
                if let valueset0 = valueset0 {
                    valueset0Decoded0 = [Swift.String]()
                    for string1 in valueset0 {
                        if let string1 = string1 {
                            valueset0Decoded0?.append(string1)
                        }
                    }
                }
                enableTwoDimensionsDecoded0?[key0] = valueset0Decoded0
            }
        }
        enableTwoDimensions = enableTwoDimensionsDecoded0
        let enableSingleDimensionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enableSingleDimension)
        var enableSingleDimensionDecoded0:[Swift.String]? = nil
        if let enableSingleDimensionContainer = enableSingleDimensionContainer {
            enableSingleDimensionDecoded0 = [Swift.String]()
            for string0 in enableSingleDimensionContainer {
                if let string0 = string0 {
                    enableSingleDimensionDecoded0?.append(string0)
                }
            }
        }
        enableSingleDimension = enableSingleDimensionDecoded0
    }
}

extension CreateAwsLogSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAwsLogSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3Exception" : self = .s3Exception(try S3Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAwsLogSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case s3Exception(S3Exception)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAwsLogSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAwsLogSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
            self.processing = output.processing
        } else {
            self.failed = nil
            self.processing = nil
        }
    }
}

public struct CreateAwsLogSourceOutputResponse: Swift.Equatable {
    /// Lists all accounts in which enabling a natively supported Amazon Web Service as a Security Lake source failed. The failure occurred as these accounts are not part of an organization.
    public var failed: [Swift.String]?
    /// Lists the accounts that are in the process of enabling a natively supported Amazon Web Service as a Security Lake source.
    public var processing: [Swift.String]?

    public init (
        failed: [Swift.String]? = nil,
        processing: [Swift.String]? = nil
    )
    {
        self.failed = failed
        self.processing = processing
    }
}

struct CreateAwsLogSourceOutputResponseBody: Swift.Equatable {
    let processing: [Swift.String]?
    let failed: [Swift.String]?
}

extension CreateAwsLogSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
        case processing
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processing)
        var processingDecoded0:[Swift.String]? = nil
        if let processingContainer = processingContainer {
            processingDecoded0 = [Swift.String]()
            for string0 in processingContainer {
                if let string0 = string0 {
                    processingDecoded0?.append(string0)
                }
            }
        }
        processing = processingDecoded0
        let failedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failed)
        var failedDecoded0:[Swift.String]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [Swift.String]()
            for string0 in failedContainer {
                if let string0 = string0 {
                    failedDecoded0?.append(string0)
                }
            }
        }
        failed = failedDecoded0
    }
}

extension CreateCustomLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSourceName
        case eventClass
        case glueInvocationRoleArn
        case logProviderAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customSourceName = self.customSourceName {
            try encodeContainer.encode(customSourceName, forKey: .customSourceName)
        }
        if let eventClass = self.eventClass {
            try encodeContainer.encode(eventClass.rawValue, forKey: .eventClass)
        }
        if let glueInvocationRoleArn = self.glueInvocationRoleArn {
            try encodeContainer.encode(glueInvocationRoleArn, forKey: .glueInvocationRoleArn)
        }
        if let logProviderAccountId = self.logProviderAccountId {
            try encodeContainer.encode(logProviderAccountId, forKey: .logProviderAccountId)
        }
    }
}

extension CreateCustomLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/logsources/custom"
    }
}

public struct CreateCustomLogSourceInput: Swift.Equatable {
    /// The name for a third-party custom source. This must be a Regionally unique value.
    /// This member is required.
    public var customSourceName: Swift.String?
    /// The Open Cybersecurity Schema Framework (OCSF) event class which describes the type of data that the custom source will send to Security Lake.
    /// This member is required.
    public var eventClass: SecurityLakeClientTypes.OcsfEventClass?
    /// The Amazon Resource Name (ARN) of the Identity and Access Management (IAM) role to be used by the Glue crawler. The recommended IAM policies are:
    ///
    /// * The managed policy AWSGlueServiceRole
    ///
    /// * A custom policy granting access to your Amazon S3 Data Lake
    /// This member is required.
    public var glueInvocationRoleArn: Swift.String?
    /// The Amazon Web Services account ID of the custom source that will write logs and events into the Amazon S3 Data Lake.
    /// This member is required.
    public var logProviderAccountId: Swift.String?

    public init (
        customSourceName: Swift.String? = nil,
        eventClass: SecurityLakeClientTypes.OcsfEventClass? = nil,
        glueInvocationRoleArn: Swift.String? = nil,
        logProviderAccountId: Swift.String? = nil
    )
    {
        self.customSourceName = customSourceName
        self.eventClass = eventClass
        self.glueInvocationRoleArn = glueInvocationRoleArn
        self.logProviderAccountId = logProviderAccountId
    }
}

struct CreateCustomLogSourceInputBody: Swift.Equatable {
    let customSourceName: Swift.String?
    let eventClass: SecurityLakeClientTypes.OcsfEventClass?
    let glueInvocationRoleArn: Swift.String?
    let logProviderAccountId: Swift.String?
}

extension CreateCustomLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customSourceName
        case eventClass
        case glueInvocationRoleArn
        case logProviderAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customSourceName)
        customSourceName = customSourceNameDecoded
        let eventClassDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.OcsfEventClass.self, forKey: .eventClass)
        eventClass = eventClassDecoded
        let glueInvocationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueInvocationRoleArn)
        glueInvocationRoleArn = glueInvocationRoleArnDecoded
        let logProviderAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logProviderAccountId)
        logProviderAccountId = logProviderAccountIdDecoded
    }
}

extension CreateCustomLogSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomLogSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketNotFoundException" : self = .bucketNotFoundException(try BucketNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictSourceNamesException" : self = .conflictSourceNamesException(try ConflictSourceNamesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCustomLogSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case bucketNotFoundException(BucketNotFoundException)
    case conflictSourceNamesException(ConflictSourceNamesException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomLogSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCustomLogSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDataLocation = output.customDataLocation
            self.glueCrawlerName = output.glueCrawlerName
            self.glueDatabaseName = output.glueDatabaseName
            self.glueTableName = output.glueTableName
            self.logProviderAccessRoleArn = output.logProviderAccessRoleArn
        } else {
            self.customDataLocation = nil
            self.glueCrawlerName = nil
            self.glueDatabaseName = nil
            self.glueTableName = nil
            self.logProviderAccessRoleArn = nil
        }
    }
}

public struct CreateCustomLogSourceOutputResponse: Swift.Equatable {
    /// The location of the partition in the Amazon S3 bucket for Security Lake.
    /// This member is required.
    public var customDataLocation: Swift.String?
    /// The name of the Glue crawler.
    /// This member is required.
    public var glueCrawlerName: Swift.String?
    /// The Glue database where results are written, such as: arn:aws:daylight:us-east-1::database/sometable/*.
    /// This member is required.
    public var glueDatabaseName: Swift.String?
    /// The table name of the Glue crawler.
    /// This member is required.
    public var glueTableName: Swift.String?
    /// The ARN of the IAM role to be used by the entity putting logs into your custom source partition. Security Lake will apply the correct access policies to this role, but you must first manually create the trust policy for this role. The IAM role name must start with the text 'Security Lake'. The IAM role must trust the logProviderAccountId to assume the role.
    /// This member is required.
    public var logProviderAccessRoleArn: Swift.String?

    public init (
        customDataLocation: Swift.String? = nil,
        glueCrawlerName: Swift.String? = nil,
        glueDatabaseName: Swift.String? = nil,
        glueTableName: Swift.String? = nil,
        logProviderAccessRoleArn: Swift.String? = nil
    )
    {
        self.customDataLocation = customDataLocation
        self.glueCrawlerName = glueCrawlerName
        self.glueDatabaseName = glueDatabaseName
        self.glueTableName = glueTableName
        self.logProviderAccessRoleArn = logProviderAccessRoleArn
    }
}

struct CreateCustomLogSourceOutputResponseBody: Swift.Equatable {
    let customDataLocation: Swift.String?
    let glueCrawlerName: Swift.String?
    let glueTableName: Swift.String?
    let glueDatabaseName: Swift.String?
    let logProviderAccessRoleArn: Swift.String?
}

extension CreateCustomLogSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDataLocation
        case glueCrawlerName
        case glueDatabaseName
        case glueTableName
        case logProviderAccessRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDataLocation)
        customDataLocation = customDataLocationDecoded
        let glueCrawlerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueCrawlerName)
        glueCrawlerName = glueCrawlerNameDecoded
        let glueTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueTableName)
        glueTableName = glueTableNameDecoded
        let glueDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .glueDatabaseName)
        glueDatabaseName = glueDatabaseNameDecoded
        let logProviderAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logProviderAccessRoleArn)
        logProviderAccessRoleArn = logProviderAccessRoleArnDecoded
    }
}

extension CreateDatalakeAutoEnableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationForNewAccounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationForNewAccounts = configurationForNewAccounts {
            var configurationForNewAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationForNewAccounts)
            for autoenablenewregionconfiguration0 in configurationForNewAccounts {
                try configurationForNewAccountsContainer.encode(autoenablenewregionconfiguration0)
            }
        }
    }
}

extension CreateDatalakeAutoEnableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/autoenable"
    }
}

public struct CreateDatalakeAutoEnableInput: Swift.Equatable {
    /// Enable Security Lake with the specified configuration settings to begin collecting security data for new accounts in your organization.
    /// This member is required.
    public var configurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?

    public init (
        configurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
    )
    {
        self.configurationForNewAccounts = configurationForNewAccounts
    }
}

struct CreateDatalakeAutoEnableInputBody: Swift.Equatable {
    let configurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?
}

extension CreateDatalakeAutoEnableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationForNewAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationForNewAccountsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AutoEnableNewRegionConfiguration?].self, forKey: .configurationForNewAccounts)
        var configurationForNewAccountsDecoded0:[SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
        if let configurationForNewAccountsContainer = configurationForNewAccountsContainer {
            configurationForNewAccountsDecoded0 = [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]()
            for structure0 in configurationForNewAccountsContainer {
                if let structure0 = structure0 {
                    configurationForNewAccountsDecoded0?.append(structure0)
                }
            }
        }
        configurationForNewAccounts = configurationForNewAccountsDecoded0
    }
}

extension CreateDatalakeAutoEnableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatalakeAutoEnableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatalakeAutoEnableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatalakeAutoEnableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDatalakeAutoEnableOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateDatalakeDelegatedAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = self.account {
            try encodeContainer.encode(account, forKey: .account)
        }
    }
}

extension CreateDatalakeDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/delegate"
    }
}

public struct CreateDatalakeDelegatedAdminInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the Security Lake delegated administrator.
    /// This member is required.
    public var account: Swift.String?

    public init (
        account: Swift.String? = nil
    )
    {
        self.account = account
    }
}

struct CreateDatalakeDelegatedAdminInputBody: Swift.Equatable {
    let account: Swift.String?
}

extension CreateDatalakeDelegatedAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

extension CreateDatalakeDelegatedAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatalakeDelegatedAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatalakeDelegatedAdminOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatalakeDelegatedAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDatalakeDelegatedAdminOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateDatalakeExceptionsSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationEndpoint
        case subscriptionProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationEndpoint = self.notificationEndpoint {
            try encodeContainer.encode(notificationEndpoint, forKey: .notificationEndpoint)
        }
        if let subscriptionProtocol = self.subscriptionProtocol {
            try encodeContainer.encode(subscriptionProtocol.rawValue, forKey: .subscriptionProtocol)
        }
    }
}

extension CreateDatalakeExceptionsSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct CreateDatalakeExceptionsSubscriptionInput: Swift.Equatable {
    /// The Amazon Web Services account where you want to receive exception notifications.
    /// This member is required.
    public var notificationEndpoint: Swift.String?
    /// The subscription protocol to which exception notifications are posted.
    /// This member is required.
    public var subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType?

    public init (
        notificationEndpoint: Swift.String? = nil,
        subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType? = nil
    )
    {
        self.notificationEndpoint = notificationEndpoint
        self.subscriptionProtocol = subscriptionProtocol
    }
}

struct CreateDatalakeExceptionsSubscriptionInputBody: Swift.Equatable {
    let subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType?
    let notificationEndpoint: Swift.String?
}

extension CreateDatalakeExceptionsSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationEndpoint
        case subscriptionProtocol
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriptionProtocolType.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let notificationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEndpoint)
        notificationEndpoint = notificationEndpointDecoded
    }
}

extension CreateDatalakeExceptionsSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatalakeExceptionsSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatalakeExceptionsSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatalakeExceptionsSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDatalakeExceptionsSubscriptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateDatalakeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case enableAll
        case metaStoreManagerRoleArn
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, lakeConfigurationRequestMap0) in configurations {
                try configurationsContainer.encode(lakeConfigurationRequestMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let enableAll = self.enableAll {
            try encodeContainer.encode(enableAll, forKey: .enableAll)
        }
        if let metaStoreManagerRoleArn = self.metaStoreManagerRoleArn {
            try encodeContainer.encode(metaStoreManagerRoleArn, forKey: .metaStoreManagerRoleArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0.rawValue)
            }
        }
    }
}

extension CreateDatalakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct CreateDatalakeInput: Swift.Equatable {
    /// Specify the Region or Regions that will contribute data to the rollup region.
    public var configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]?
    /// Enable Security Lake in all Regions.
    public var enableAll: Swift.Bool?
    /// The Amazon Resource Name (ARN) used to create and update the Glue table. This table contains partitions generated by the ingestion and normalization of Amazon Web Services log sources and custom sources.
    public var metaStoreManagerRoleArn: Swift.String?
    /// Enable Security Lake in the specified Regions. To enable Security Lake in specific Amazon Web Services Regions, such as us-east-1 or ap-northeast-3, provide the Region codes. For a list of Region codes, see [Amazon Security Lake endpoints](https://docs.aws.amazon.com/general/latest/gr/securitylake.html) in the Amazon Web Services General Reference.
    public var regions: [SecurityLakeClientTypes.Region]?

    public init (
        configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]? = nil,
        enableAll: Swift.Bool? = nil,
        metaStoreManagerRoleArn: Swift.String? = nil,
        regions: [SecurityLakeClientTypes.Region]? = nil
    )
    {
        self.configurations = configurations
        self.enableAll = enableAll
        self.metaStoreManagerRoleArn = metaStoreManagerRoleArn
        self.regions = regions
    }
}

struct CreateDatalakeInputBody: Swift.Equatable {
    let regions: [SecurityLakeClientTypes.Region]?
    let configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]?
    let enableAll: Swift.Bool?
    let metaStoreManagerRoleArn: Swift.String?
}

extension CreateDatalakeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case enableAll
        case metaStoreManagerRoleArn
        case regions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Region?].self, forKey: .regions)
        var regionsDecoded0:[SecurityLakeClientTypes.Region]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [SecurityLakeClientTypes.Region]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: SecurityLakeClientTypes.LakeConfigurationRequest?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]()
            for (key0, lakeconfigurationrequest0) in configurationsContainer {
                if let lakeconfigurationrequest0 = lakeconfigurationrequest0 {
                    configurationsDecoded0?[key0] = lakeconfigurationrequest0
                }
            }
        }
        configurations = configurationsDecoded0
        let enableAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAll)
        enableAll = enableAllDecoded
        let metaStoreManagerRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metaStoreManagerRoleArn)
        metaStoreManagerRoleArn = metaStoreManagerRoleArnDecoded
    }
}

extension CreateDatalakeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatalakeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatalakeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatalakeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateDatalakeOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case accountId
        case externalId
        case sourceTypes
        case subscriberDescription
        case subscriberName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTypes = accessTypes {
            var accessTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessTypes)
            for accesstype0 in accessTypes {
                try accessTypesContainer.encode(accesstype0.rawValue)
            }
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let sourceTypes = sourceTypes {
            var sourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceTypes)
            for sourcetype0 in sourceTypes {
                try sourceTypesContainer.encode(sourcetype0)
            }
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
    }
}

extension CreateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/subscribers"
    }
}

public struct CreateSubscriberInput: Swift.Equatable {
    /// The Amazon S3 or Lake Formation access type.
    public var accessTypes: [SecurityLakeClientTypes.AccessType]?
    /// The Amazon Web Services account ID used to access your data.
    /// This member is required.
    public var accountId: Swift.String?
    /// The external ID of the subscriber. This lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.
    /// This member is required.
    public var externalId: Swift.String?
    /// The supported Amazon Web Services from which logs and events are collected. Security Lake supports log and event collection for natively supported Amazon Web Services.
    /// This member is required.
    public var sourceTypes: [SecurityLakeClientTypes.SourceType]?
    /// The description for your subscriber account in Security Lake.
    public var subscriberDescription: Swift.String?
    /// The name of your Security Lake subscriber account.
    /// This member is required.
    public var subscriberName: Swift.String?

    public init (
        accessTypes: [SecurityLakeClientTypes.AccessType]? = nil,
        accountId: Swift.String? = nil,
        externalId: Swift.String? = nil,
        sourceTypes: [SecurityLakeClientTypes.SourceType]? = nil,
        subscriberDescription: Swift.String? = nil,
        subscriberName: Swift.String? = nil
    )
    {
        self.accessTypes = accessTypes
        self.accountId = accountId
        self.externalId = externalId
        self.sourceTypes = sourceTypes
        self.subscriberDescription = subscriberDescription
        self.subscriberName = subscriberName
    }
}

struct CreateSubscriberInputBody: Swift.Equatable {
    let sourceTypes: [SecurityLakeClientTypes.SourceType]?
    let accountId: Swift.String?
    let externalId: Swift.String?
    let accessTypes: [SecurityLakeClientTypes.AccessType]?
    let subscriberName: Swift.String?
    let subscriberDescription: Swift.String?
}

extension CreateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case accountId
        case externalId
        case sourceTypes
        case subscriberDescription
        case subscriberName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.SourceType?].self, forKey: .sourceTypes)
        var sourceTypesDecoded0:[SecurityLakeClientTypes.SourceType]? = nil
        if let sourceTypesContainer = sourceTypesContainer {
            sourceTypesDecoded0 = [SecurityLakeClientTypes.SourceType]()
            for union0 in sourceTypesContainer {
                if let union0 = union0 {
                    sourceTypesDecoded0?.append(union0)
                }
            }
        }
        sourceTypes = sourceTypesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let accessTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AccessType?].self, forKey: .accessTypes)
        var accessTypesDecoded0:[SecurityLakeClientTypes.AccessType]? = nil
        if let accessTypesContainer = accessTypesContainer {
            accessTypesDecoded0 = [SecurityLakeClientTypes.AccessType]()
            for string0 in accessTypesContainer {
                if let string0 = string0 {
                    accessTypesDecoded0?.append(string0)
                }
            }
        }
        accessTypes = accessTypesDecoded0
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
    }
}

extension CreateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketNotFoundException" : self = .bucketNotFoundException(try BucketNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictSubscriptionException" : self = .conflictSubscriptionException(try ConflictSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case bucketNotFoundException(BucketNotFoundException)
    case conflictSubscriptionException(ConflictSubscriptionException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSubscriberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roleArn = output.roleArn
            self.s3BucketArn = output.s3BucketArn
            self.snsArn = output.snsArn
            self.subscriptionId = output.subscriptionId
        } else {
            self.roleArn = nil
            self.s3BucketArn = nil
            self.snsArn = nil
            self.subscriptionId = nil
        }
    }
}

public struct CreateSubscriberOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) created by you to provide to the subscriber. For more information about ARNs and how to use them in policies, see [IAM identifiers in the Identity and Access Management (IAM) User Guide](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html). .
    public var roleArn: Swift.String?
    /// The ARN for the Amazon S3 bucket.
    public var s3BucketArn: Swift.String?
    /// The ARN for the Amazon Simple Notification Service.
    public var snsArn: Swift.String?
    /// The subscriptionId created by the CreateSubscriber API call.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init (
        roleArn: Swift.String? = nil,
        s3BucketArn: Swift.String? = nil,
        snsArn: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
        self.s3BucketArn = s3BucketArn
        self.snsArn = snsArn
        self.subscriptionId = subscriptionId
    }
}

struct CreateSubscriberOutputResponseBody: Swift.Equatable {
    let subscriptionId: Swift.String?
    let roleArn: Swift.String?
    let snsArn: Swift.String?
    let s3BucketArn: Swift.String?
}

extension CreateSubscriberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3BucketArn
        case snsArn
        case subscriptionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let snsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsArn)
        snsArn = snsArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
    }
}

extension CreateSubscriptionNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSqs
        case httpsApiKeyName
        case httpsApiKeyValue
        case httpsMethod
        case roleArn
        case subscriptionEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createSqs = self.createSqs {
            try encodeContainer.encode(createSqs, forKey: .createSqs)
        }
        if let httpsApiKeyName = self.httpsApiKeyName {
            try encodeContainer.encode(httpsApiKeyName, forKey: .httpsApiKeyName)
        }
        if let httpsApiKeyValue = self.httpsApiKeyValue {
            try encodeContainer.encode(httpsApiKeyValue, forKey: .httpsApiKeyValue)
        }
        if let httpsMethod = self.httpsMethod {
            try encodeContainer.encode(httpsMethod.rawValue, forKey: .httpsMethod)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subscriptionEndpoint = self.subscriptionEndpoint {
            try encodeContainer.encode(subscriptionEndpoint, forKey: .subscriptionEndpoint)
        }
    }
}

extension CreateSubscriptionNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionId = subscriptionId else {
            return nil
        }
        return "/subscription-notifications/\(subscriptionId.urlPercentEncoding())"
    }
}

public struct CreateSubscriptionNotificationConfigurationInput: Swift.Equatable {
    /// Create an Amazon Simple Queue Service queue.
    public var createSqs: Swift.Bool?
    /// The key name for the notification subscription.
    public var httpsApiKeyName: Swift.String?
    /// The key value for the notification subscription.
    public var httpsApiKeyValue: Swift.String?
    /// The HTTPS method used for the notification subscription.
    public var httpsMethod: SecurityLakeClientTypes.HttpsMethod?
    /// The Amazon Resource Name (ARN) of the EventBridge API destinations IAM role that you created.
    public var roleArn: Swift.String?
    /// The subscription endpoint in Security Lake. If you prefer notification with an HTTPs endpoint, populate this field.
    public var subscriptionEndpoint: Swift.String?
    /// The subscription ID for the notification subscription/
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init (
        createSqs: Swift.Bool? = nil,
        httpsApiKeyName: Swift.String? = nil,
        httpsApiKeyValue: Swift.String? = nil,
        httpsMethod: SecurityLakeClientTypes.HttpsMethod? = nil,
        roleArn: Swift.String? = nil,
        subscriptionEndpoint: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.createSqs = createSqs
        self.httpsApiKeyName = httpsApiKeyName
        self.httpsApiKeyValue = httpsApiKeyValue
        self.httpsMethod = httpsMethod
        self.roleArn = roleArn
        self.subscriptionEndpoint = subscriptionEndpoint
        self.subscriptionId = subscriptionId
    }
}

struct CreateSubscriptionNotificationConfigurationInputBody: Swift.Equatable {
    let subscriptionEndpoint: Swift.String?
    let httpsApiKeyName: Swift.String?
    let httpsApiKeyValue: Swift.String?
    let httpsMethod: SecurityLakeClientTypes.HttpsMethod?
    let createSqs: Swift.Bool?
    let roleArn: Swift.String?
}

extension CreateSubscriptionNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSqs
        case httpsApiKeyName
        case httpsApiKeyValue
        case httpsMethod
        case roleArn
        case subscriptionEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndpoint)
        subscriptionEndpoint = subscriptionEndpointDecoded
        let httpsApiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpsApiKeyName)
        httpsApiKeyName = httpsApiKeyNameDecoded
        let httpsApiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpsApiKeyValue)
        httpsApiKeyValue = httpsApiKeyValueDecoded
        let httpsMethodDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.HttpsMethod.self, forKey: .httpsMethod)
        httpsMethod = httpsMethodDecoded
        let createSqsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createSqs)
        createSqs = createSqsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateSubscriptionNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubscriptionNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSubscriptionNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queueArn = output.queueArn
        } else {
            self.queueArn = nil
        }
    }
}

public struct CreateSubscriptionNotificationConfigurationOutputResponse: Swift.Equatable {
    /// Returns the Amazon Resource Name (ARN) of the queue.
    public var queueArn: Swift.String?

    public init (
        queueArn: Swift.String? = nil
    )
    {
        self.queueArn = queueArn
    }
}

struct CreateSubscriptionNotificationConfigurationOutputResponseBody: Swift.Equatable {
    let queueArn: Swift.String?
}

extension CreateSubscriptionNotificationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
    }
}

extension DeleteAwsLogSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableAllDimensions
        case disableSingleDimension
        case disableTwoDimensions
        case inputOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableAllDimensions = disableAllDimensions {
            var disableAllDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .disableAllDimensions)
            for (dictKey0, allDimensionsMap0) in disableAllDimensions {
                var allDimensionsMap0Container = disableAllDimensionsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, twoDimensionsMap1) in allDimensionsMap0 {
                    var twoDimensionsMap1Container = allDimensionsMap0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey1))
                    for string2 in twoDimensionsMap1 {
                        try twoDimensionsMap1Container.encode(string2)
                    }
                }
            }
        }
        if let disableSingleDimension = disableSingleDimension {
            var disableSingleDimensionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disableSingleDimension)
            for safestring0 in disableSingleDimension {
                try disableSingleDimensionContainer.encode(safestring0)
            }
        }
        if let disableTwoDimensions = disableTwoDimensions {
            var disableTwoDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .disableTwoDimensions)
            for (dictKey0, twoDimensionsMap0) in disableTwoDimensions {
                var twoDimensionsMap0Container = disableTwoDimensionsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in twoDimensionsMap0 {
                    try twoDimensionsMap0Container.encode(string1)
                }
            }
        }
        if let inputOrder = inputOrder {
            var inputOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputOrder)
            for dimension0 in inputOrder {
                try inputOrderContainer.encode(dimension0.rawValue)
            }
        }
    }
}

extension DeleteAwsLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/logsources/aws/delete"
    }
}

public struct DeleteAwsLogSourceInput: Swift.Equatable {
    /// Removes the specific Amazon Web Services sources from specific accounts and specific Regions.
    public var disableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    /// Removes all Amazon Web Services sources from specific accounts or Regions.
    public var disableSingleDimension: [Swift.String]?
    /// Remove a specific Amazon Web Services source from specific accounts or Regions.
    public var disableTwoDimensions: [Swift.String:[Swift.String]]?
    /// This is a mandatory input. Specify the input order to disable dimensions in Security Lake, namely Region (Amazon Web Services Region code, source type, and member (account ID of a specific Amazon Web Services account).
    /// This member is required.
    public var inputOrder: [SecurityLakeClientTypes.Dimension]?

    public init (
        disableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        disableSingleDimension: [Swift.String]? = nil,
        disableTwoDimensions: [Swift.String:[Swift.String]]? = nil,
        inputOrder: [SecurityLakeClientTypes.Dimension]? = nil
    )
    {
        self.disableAllDimensions = disableAllDimensions
        self.disableSingleDimension = disableSingleDimension
        self.disableTwoDimensions = disableTwoDimensions
        self.inputOrder = inputOrder
    }
}

struct DeleteAwsLogSourceInputBody: Swift.Equatable {
    let inputOrder: [SecurityLakeClientTypes.Dimension]?
    let disableAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    let disableTwoDimensions: [Swift.String:[Swift.String]]?
    let disableSingleDimension: [Swift.String]?
}

extension DeleteAwsLogSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableAllDimensions
        case disableSingleDimension
        case disableTwoDimensions
        case inputOrder
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputOrderContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Dimension?].self, forKey: .inputOrder)
        var inputOrderDecoded0:[SecurityLakeClientTypes.Dimension]? = nil
        if let inputOrderContainer = inputOrderContainer {
            inputOrderDecoded0 = [SecurityLakeClientTypes.Dimension]()
            for string0 in inputOrderContainer {
                if let string0 = string0 {
                    inputOrderDecoded0?.append(string0)
                }
            }
        }
        inputOrder = inputOrderDecoded0
        let disableAllDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .disableAllDimensions)
        var disableAllDimensionsDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let disableAllDimensionsContainer = disableAllDimensionsContainer {
            disableAllDimensionsDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, twodimensionsmap0) in disableAllDimensionsContainer {
                var twodimensionsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let twodimensionsmap0 = twodimensionsmap0 {
                    twodimensionsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, valueset1) in twodimensionsmap0 {
                        var valueset1Decoded1: [Swift.String]? = nil
                        if let valueset1 = valueset1 {
                            valueset1Decoded1 = [Swift.String]()
                            for string2 in valueset1 {
                                if let string2 = string2 {
                                    valueset1Decoded1?.append(string2)
                                }
                            }
                        }
                        twodimensionsmap0Decoded0?[key1] = valueset1Decoded1
                    }
                }
                disableAllDimensionsDecoded0?[key0] = twodimensionsmap0Decoded0
            }
        }
        disableAllDimensions = disableAllDimensionsDecoded0
        let disableTwoDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .disableTwoDimensions)
        var disableTwoDimensionsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let disableTwoDimensionsContainer = disableTwoDimensionsContainer {
            disableTwoDimensionsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, valueset0) in disableTwoDimensionsContainer {
                var valueset0Decoded0: [Swift.String]? = nil
                if let valueset0 = valueset0 {
                    valueset0Decoded0 = [Swift.String]()
                    for string1 in valueset0 {
                        if let string1 = string1 {
                            valueset0Decoded0?.append(string1)
                        }
                    }
                }
                disableTwoDimensionsDecoded0?[key0] = valueset0Decoded0
            }
        }
        disableTwoDimensions = disableTwoDimensionsDecoded0
        let disableSingleDimensionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .disableSingleDimension)
        var disableSingleDimensionDecoded0:[Swift.String]? = nil
        if let disableSingleDimensionContainer = disableSingleDimensionContainer {
            disableSingleDimensionDecoded0 = [Swift.String]()
            for string0 in disableSingleDimensionContainer {
                if let string0 = string0 {
                    disableSingleDimensionDecoded0?.append(string0)
                }
            }
        }
        disableSingleDimension = disableSingleDimensionDecoded0
    }
}

extension DeleteAwsLogSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAwsLogSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAwsLogSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAwsLogSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAwsLogSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failed = output.failed
            self.processing = output.processing
        } else {
            self.failed = nil
            self.processing = nil
        }
    }
}

public struct DeleteAwsLogSourceOutputResponse: Swift.Equatable {
    /// Deletion of the Amazon Web Services sources failed as the account is not a part of the organization.
    public var failed: [Swift.String]?
    /// Deletion of the Amazon Web Services sources is in progress.
    public var processing: [Swift.String]?

    public init (
        failed: [Swift.String]? = nil,
        processing: [Swift.String]? = nil
    )
    {
        self.failed = failed
        self.processing = processing
    }
}

struct DeleteAwsLogSourceOutputResponseBody: Swift.Equatable {
    let processing: [Swift.String]?
    let failed: [Swift.String]?
}

extension DeleteAwsLogSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failed
        case processing
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .processing)
        var processingDecoded0:[Swift.String]? = nil
        if let processingContainer = processingContainer {
            processingDecoded0 = [Swift.String]()
            for string0 in processingContainer {
                if let string0 = string0 {
                    processingDecoded0?.append(string0)
                }
            }
        }
        processing = processingDecoded0
        let failedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failed)
        var failedDecoded0:[Swift.String]? = nil
        if let failedContainer = failedContainer {
            failedDecoded0 = [Swift.String]()
            for string0 in failedContainer {
                if let string0 = string0 {
                    failedDecoded0?.append(string0)
                }
            }
        }
        failed = failedDecoded0
    }
}

extension DeleteCustomLogSourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let customSourceName = customSourceName else {
                let message = "Creating a URL Query Item failed. customSourceName is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let customSourceNameQueryItem = ClientRuntime.URLQueryItem(name: "customSourceName".urlPercentEncoding(), value: Swift.String(customSourceName).urlPercentEncoding())
            items.append(customSourceNameQueryItem)
            return items
        }
    }
}

extension DeleteCustomLogSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/logsources/custom"
    }
}

public struct DeleteCustomLogSourceInput: Swift.Equatable {
    /// The custom source name for the custom log source.
    /// This member is required.
    public var customSourceName: Swift.String?

    public init (
        customSourceName: Swift.String? = nil
    )
    {
        self.customSourceName = customSourceName
    }
}

struct DeleteCustomLogSourceInputBody: Swift.Equatable {
}

extension DeleteCustomLogSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomLogSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomLogSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketNotFoundException" : self = .bucketNotFoundException(try BucketNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictSourceNamesException" : self = .conflictSourceNamesException(try ConflictSourceNamesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCustomLogSourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case bucketNotFoundException(BucketNotFoundException)
    case conflictSourceNamesException(ConflictSourceNamesException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomLogSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCustomLogSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDataLocation = output.customDataLocation
        } else {
            self.customDataLocation = nil
        }
    }
}

public struct DeleteCustomLogSourceOutputResponse: Swift.Equatable {
    /// The location of the partition in the Amazon S3 bucket for Security Lake.
    /// This member is required.
    public var customDataLocation: Swift.String?

    public init (
        customDataLocation: Swift.String? = nil
    )
    {
        self.customDataLocation = customDataLocation
    }
}

struct DeleteCustomLogSourceOutputResponseBody: Swift.Equatable {
    let customDataLocation: Swift.String?
}

extension DeleteCustomLogSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDataLocation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDataLocation)
        customDataLocation = customDataLocationDecoded
    }
}

extension DeleteDatalakeAutoEnableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeFromConfigurationForNewAccounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let removeFromConfigurationForNewAccounts = removeFromConfigurationForNewAccounts {
            var removeFromConfigurationForNewAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeFromConfigurationForNewAccounts)
            for autoenablenewregionconfiguration0 in removeFromConfigurationForNewAccounts {
                try removeFromConfigurationForNewAccountsContainer.encode(autoenablenewregionconfiguration0)
            }
        }
    }
}

extension DeleteDatalakeAutoEnableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/autoenable/delete"
    }
}

public struct DeleteDatalakeAutoEnableInput: Swift.Equatable {
    /// Delete Amazon Security Lake with the specified configuration settings to stop ingesting security data for new accounts in Security Lake.
    /// This member is required.
    public var removeFromConfigurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?

    public init (
        removeFromConfigurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
    )
    {
        self.removeFromConfigurationForNewAccounts = removeFromConfigurationForNewAccounts
    }
}

struct DeleteDatalakeAutoEnableInputBody: Swift.Equatable {
    let removeFromConfigurationForNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?
}

extension DeleteDatalakeAutoEnableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case removeFromConfigurationForNewAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let removeFromConfigurationForNewAccountsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AutoEnableNewRegionConfiguration?].self, forKey: .removeFromConfigurationForNewAccounts)
        var removeFromConfigurationForNewAccountsDecoded0:[SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
        if let removeFromConfigurationForNewAccountsContainer = removeFromConfigurationForNewAccountsContainer {
            removeFromConfigurationForNewAccountsDecoded0 = [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]()
            for structure0 in removeFromConfigurationForNewAccountsContainer {
                if let structure0 = structure0 {
                    removeFromConfigurationForNewAccountsDecoded0?.append(structure0)
                }
            }
        }
        removeFromConfigurationForNewAccounts = removeFromConfigurationForNewAccountsDecoded0
    }
}

extension DeleteDatalakeAutoEnableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatalakeAutoEnableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatalakeAutoEnableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatalakeAutoEnableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatalakeAutoEnableOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatalakeDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let account = account else {
            return nil
        }
        return "/v1/datalake/delegate/\(account.urlPercentEncoding())"
    }
}

public struct DeleteDatalakeDelegatedAdminInput: Swift.Equatable {
    /// The account ID the Security Lake delegated administrator.
    /// This member is required.
    public var account: Swift.String?

    public init (
        account: Swift.String? = nil
    )
    {
        self.account = account
    }
}

struct DeleteDatalakeDelegatedAdminInputBody: Swift.Equatable {
}

extension DeleteDatalakeDelegatedAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatalakeDelegatedAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatalakeDelegatedAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatalakeDelegatedAdminOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatalakeDelegatedAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatalakeDelegatedAdminOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteDatalakeExceptionsSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct DeleteDatalakeExceptionsSubscriptionInput: Swift.Equatable {

    public init () { }
}

struct DeleteDatalakeExceptionsSubscriptionInputBody: Swift.Equatable {
}

extension DeleteDatalakeExceptionsSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatalakeExceptionsSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatalakeExceptionsSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatalakeExceptionsSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatalakeExceptionsSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDatalakeExceptionsSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteDatalakeExceptionsSubscriptionOutputResponse: Swift.Equatable {
    /// Retrieves the status of the delete Security Lake operation for an account.
    /// This member is required.
    public var status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteDatalakeExceptionsSubscriptionOutputResponseBody: Swift.Equatable {
    let status: Swift.String?
}

extension DeleteDatalakeExceptionsSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDatalakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct DeleteDatalakeInput: Swift.Equatable {

    public init () { }
}

struct DeleteDatalakeInputBody: Swift.Equatable {
}

extension DeleteDatalakeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatalakeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatalakeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatalakeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatalakeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatalakeOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSubscriberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension DeleteSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/subscribers"
    }
}

public struct DeleteSubscriberInput: Swift.Equatable {
    /// A value created by Security Lake that uniquely identifies your DeleteSubscriber API request.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSubscriberInputBody: Swift.Equatable {
}

extension DeleteSubscriberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BucketNotFoundException" : self = .bucketNotFoundException(try BucketNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case bucketNotFoundException(BucketNotFoundException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSubscriberOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSubscriptionNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionId = subscriptionId else {
            return nil
        }
        return "/subscription-notifications/\(subscriptionId.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionNotificationConfigurationInput: Swift.Equatable {
    /// The ID of the Security Lake subscriber account.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init (
        subscriptionId: Swift.String? = nil
    )
    {
        self.subscriptionId = subscriptionId
    }
}

struct DeleteSubscriptionNotificationConfigurationInputBody: Swift.Equatable {
}

extension DeleteSubscriptionNotificationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriptionNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSubscriptionNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriptionNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSubscriptionNotificationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension SecurityLakeClientTypes {
    public enum Dimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case member
        case region
        case sourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .member,
                .region,
                .sourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .member: return "MEMBER"
            case .region: return "REGION"
            case .sourceType: return "SOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Dimension(rawValue: rawValue) ?? Dimension.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes {
    public enum EndpointProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointProtocol] {
            return [
                .https,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointProtocol(rawValue: rawValue) ?? EndpointProtocol.sdkUnknown(rawValue)
        }
    }
}

extension EventBridgeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EventBridgeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Represents an error interacting with the Amazon EventBridge service.
public struct EventBridgeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventBridgeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventBridgeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityLakeClientTypes.Failures: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
        case remediation
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionMessage = self.exceptionMessage {
            try encodeContainer.encode(exceptionMessage, forKey: .exceptionMessage)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediation)
        remediation = remediationDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension SecurityLakeClientTypes {
    /// List of all failures.
    public struct Failures: Swift.Equatable {
        /// List of all exception messages.
        /// This member is required.
        public var exceptionMessage: Swift.String?
        /// List of all remediation steps for failures.
        /// This member is required.
        public var remediation: Swift.String?
        /// This error can occur if you configure the wrong timestamp format, or if the subset of entries used for validation had errors or missing values.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init (
            exceptionMessage: Swift.String? = nil,
            remediation: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.exceptionMessage = exceptionMessage
            self.remediation = remediation
            self.timestamp = timestamp
        }
    }

}

extension SecurityLakeClientTypes.FailuresResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for failures0 in failures {
                try failuresContainer.encode(failures0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let failuresContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Failures?].self, forKey: .failures)
        var failuresDecoded0:[SecurityLakeClientTypes.Failures]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [SecurityLakeClientTypes.Failures]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension SecurityLakeClientTypes {
    /// Response element for actions that make changes, namely create, update, or delete actions.
    public struct FailuresResponse: Swift.Equatable {
        /// List of all failures.
        public var failures: [SecurityLakeClientTypes.Failures]?
        /// List of Amazon Web Services Regions where the failure occurred.
        public var region: Swift.String?

        public init (
            failures: [SecurityLakeClientTypes.Failures]? = nil,
            region: Swift.String? = nil
        )
        {
            self.failures = failures
            self.region = region
        }
    }

}

extension GetDatalakeAutoEnableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/autoenable"
    }
}

public struct GetDatalakeAutoEnableInput: Swift.Equatable {

    public init () { }
}

struct GetDatalakeAutoEnableInputBody: Swift.Equatable {
}

extension GetDatalakeAutoEnableInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatalakeAutoEnableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatalakeAutoEnableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatalakeAutoEnableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatalakeAutoEnableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatalakeAutoEnableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnableNewAccounts = output.autoEnableNewAccounts
        } else {
            self.autoEnableNewAccounts = nil
        }
    }
}

public struct GetDatalakeAutoEnableOutputResponse: Swift.Equatable {
    /// The configuration for new accounts.
    /// This member is required.
    public var autoEnableNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?

    public init (
        autoEnableNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
    )
    {
        self.autoEnableNewAccounts = autoEnableNewAccounts
    }
}

struct GetDatalakeAutoEnableOutputResponseBody: Swift.Equatable {
    let autoEnableNewAccounts: [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]?
}

extension GetDatalakeAutoEnableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableNewAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableNewAccountsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AutoEnableNewRegionConfiguration?].self, forKey: .autoEnableNewAccounts)
        var autoEnableNewAccountsDecoded0:[SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]? = nil
        if let autoEnableNewAccountsContainer = autoEnableNewAccountsContainer {
            autoEnableNewAccountsDecoded0 = [SecurityLakeClientTypes.AutoEnableNewRegionConfiguration]()
            for structure0 in autoEnableNewAccountsContainer {
                if let structure0 = structure0 {
                    autoEnableNewAccountsDecoded0?.append(structure0)
                }
            }
        }
        autoEnableNewAccounts = autoEnableNewAccountsDecoded0
    }
}

extension GetDatalakeExceptionsExpiryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/expiry"
    }
}

public struct GetDatalakeExceptionsExpiryInput: Swift.Equatable {

    public init () { }
}

struct GetDatalakeExceptionsExpiryInputBody: Swift.Equatable {
}

extension GetDatalakeExceptionsExpiryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatalakeExceptionsExpiryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatalakeExceptionsExpiryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatalakeExceptionsExpiryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatalakeExceptionsExpiryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatalakeExceptionsExpiryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessageExpiry = output.exceptionMessageExpiry
        } else {
            self.exceptionMessageExpiry = nil
        }
    }
}

public struct GetDatalakeExceptionsExpiryOutputResponse: Swift.Equatable {
    /// The expiration period and time-to-live (TTL).
    /// This member is required.
    public var exceptionMessageExpiry: Swift.Int?

    public init (
        exceptionMessageExpiry: Swift.Int? = nil
    )
    {
        self.exceptionMessageExpiry = exceptionMessageExpiry
    }
}

struct GetDatalakeExceptionsExpiryOutputResponseBody: Swift.Equatable {
    let exceptionMessageExpiry: Swift.Int?
}

extension GetDatalakeExceptionsExpiryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessageExpiry
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageExpiryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exceptionMessageExpiry)
        exceptionMessageExpiry = exceptionMessageExpiryDecoded
    }
}

extension GetDatalakeExceptionsSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct GetDatalakeExceptionsSubscriptionInput: Swift.Equatable {

    public init () { }
}

struct GetDatalakeExceptionsSubscriptionInputBody: Swift.Equatable {
}

extension GetDatalakeExceptionsSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatalakeExceptionsSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatalakeExceptionsSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatalakeExceptionsSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatalakeExceptionsSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatalakeExceptionsSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protocolAndNotificationEndpoint = output.protocolAndNotificationEndpoint
        } else {
            self.protocolAndNotificationEndpoint = nil
        }
    }
}

public struct GetDatalakeExceptionsSubscriptionOutputResponse: Swift.Equatable {
    /// Retrieves the exception notification subscription information.
    /// This member is required.
    public var protocolAndNotificationEndpoint: SecurityLakeClientTypes.ProtocolAndNotificationEndpoint?

    public init (
        protocolAndNotificationEndpoint: SecurityLakeClientTypes.ProtocolAndNotificationEndpoint? = nil
    )
    {
        self.protocolAndNotificationEndpoint = protocolAndNotificationEndpoint
    }
}

struct GetDatalakeExceptionsSubscriptionOutputResponseBody: Swift.Equatable {
    let protocolAndNotificationEndpoint: SecurityLakeClientTypes.ProtocolAndNotificationEndpoint?
}

extension GetDatalakeExceptionsSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocolAndNotificationEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolAndNotificationEndpointDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.ProtocolAndNotificationEndpoint.self, forKey: .protocolAndNotificationEndpoint)
        protocolAndNotificationEndpoint = protocolAndNotificationEndpointDecoded
    }
}

extension GetDatalakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct GetDatalakeInput: Swift.Equatable {

    public init () { }
}

struct GetDatalakeInputBody: Swift.Equatable {
}

extension GetDatalakeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatalakeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatalakeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatalakeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatalakeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatalakeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
        } else {
            self.configurations = nil
        }
    }
}

public struct GetDatalakeOutputResponse: Swift.Equatable {
    /// Retrieves the Security Lake configuration object.
    /// This member is required.
    public var configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationResponse]?

    public init (
        configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationResponse]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct GetDatalakeOutputResponseBody: Swift.Equatable {
    let configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationResponse]?
}

extension GetDatalakeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: SecurityLakeClientTypes.LakeConfigurationResponse?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:SecurityLakeClientTypes.LakeConfigurationResponse]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:SecurityLakeClientTypes.LakeConfigurationResponse]()
            for (key0, lakeconfigurationresponse0) in configurationsContainer {
                if let lakeconfigurationresponse0 = lakeconfigurationresponse0 {
                    configurationsDecoded0?[key0] = lakeconfigurationresponse0
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension GetDatalakeStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSet
        case maxAccountResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountSet = accountSet {
            var accountSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountSet)
            for safestring0 in accountSet {
                try accountSetContainer.encode(safestring0)
            }
        }
        if let maxAccountResults = self.maxAccountResults {
            try encodeContainer.encode(maxAccountResults, forKey: .maxAccountResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetDatalakeStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/status"
    }
}

public struct GetDatalakeStatusInput: Swift.Equatable {
    /// The Amazon Web Services account ID for which a static snapshot of the current Amazon Web Services Region, including enabled accounts and log sources, is retrieved.
    public var accountSet: [Swift.String]?
    /// The maximum limit of accounts for which the static snapshot of the current Region, including enabled accounts and log sources, is retrieved.
    public var maxAccountResults: Swift.Int?
    /// Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        accountSet: [Swift.String]? = nil,
        maxAccountResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountSet = accountSet
        self.maxAccountResults = maxAccountResults
        self.nextToken = nextToken
    }
}

struct GetDatalakeStatusInputBody: Swift.Equatable {
    let accountSet: [Swift.String]?
    let maxAccountResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetDatalakeStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSet
        case maxAccountResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountSet)
        var accountSetDecoded0:[Swift.String]? = nil
        if let accountSetContainer = accountSetContainer {
            accountSetDecoded0 = [Swift.String]()
            for string0 in accountSetContainer {
                if let string0 = string0 {
                    accountSetDecoded0?.append(string0)
                }
            }
        }
        accountSet = accountSetDecoded0
        let maxAccountResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAccountResults)
        maxAccountResults = maxAccountResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDatalakeStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatalakeStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatalakeStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatalakeStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatalakeStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountSourcesList = output.accountSourcesList
            self.nextToken = output.nextToken
        } else {
            self.accountSourcesList = nil
            self.nextToken = nil
        }
    }
}

public struct GetDatalakeStatusOutputResponse: Swift.Equatable {
    /// The list of enabled accounts and enabled sources.
    /// This member is required.
    public var accountSourcesList: [SecurityLakeClientTypes.AccountSources]?
    /// Lists if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init (
        accountSourcesList: [SecurityLakeClientTypes.AccountSources]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountSourcesList = accountSourcesList
        self.nextToken = nextToken
    }
}

struct GetDatalakeStatusOutputResponseBody: Swift.Equatable {
    let accountSourcesList: [SecurityLakeClientTypes.AccountSources]?
    let nextToken: Swift.String?
}

extension GetDatalakeStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSourcesList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountSourcesListContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AccountSources?].self, forKey: .accountSourcesList)
        var accountSourcesListDecoded0:[SecurityLakeClientTypes.AccountSources]? = nil
        if let accountSourcesListContainer = accountSourcesListContainer {
            accountSourcesListDecoded0 = [SecurityLakeClientTypes.AccountSources]()
            for structure0 in accountSourcesListContainer {
                if let structure0 = structure0 {
                    accountSourcesListDecoded0?.append(structure0)
                }
            }
        }
        accountSourcesList = accountSourcesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/v1/subscribers/\(id.urlPercentEncoding())"
    }
}

public struct GetSubscriberInput: Swift.Equatable {
    /// A value created by Amazon Security Lake that uniquely identifies your GetSubscriber API request.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSubscriberInputBody: Swift.Equatable {
}

extension GetSubscriberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSubscriberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriber = output.subscriber
        } else {
            self.subscriber = nil
        }
    }
}

public struct GetSubscriberOutputResponse: Swift.Equatable {
    /// The subscription information for the specified subscription ID.
    public var subscriber: SecurityLakeClientTypes.SubscriberResource?

    public init (
        subscriber: SecurityLakeClientTypes.SubscriberResource? = nil
    )
    {
        self.subscriber = subscriber
    }
}

struct GetSubscriberOutputResponseBody: Swift.Equatable {
    let subscriber: SecurityLakeClientTypes.SubscriberResource?
}

extension GetSubscriberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberResource.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension SecurityLakeClientTypes {
    public enum HttpsMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpsMethod] {
            return [
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpsMethod(rawValue: rawValue) ?? HttpsMethod.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal service exceptions are sometimes caused by transient issues. Before you start troubleshooting, perform the operation again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Retry the request after the specified time.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because a value that's not valid or is out of range was supplied for an input parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityLakeClientTypes.LakeConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case replicationDestinationRegions
        case replicationRoleArn
        case retentionSettings
        case tagsMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let replicationDestinationRegions = replicationDestinationRegions {
            var replicationDestinationRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationDestinationRegions)
            for region0 in replicationDestinationRegions {
                try replicationDestinationRegionsContainer.encode(region0.rawValue)
            }
        }
        if let replicationRoleArn = self.replicationRoleArn {
            try encodeContainer.encode(replicationRoleArn, forKey: .replicationRoleArn)
        }
        if let retentionSettings = retentionSettings {
            var retentionSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retentionSettings)
            for retentionsetting0 in retentionSettings {
                try retentionSettingsContainer.encode(retentionsetting0)
            }
        }
        if let tagsMap = tagsMap {
            var tagsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagsMap)
            for (dictKey0, tagsMap0) in tagsMap {
                try tagsMapContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let retentionSettingsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.RetentionSetting?].self, forKey: .retentionSettings)
        var retentionSettingsDecoded0:[SecurityLakeClientTypes.RetentionSetting]? = nil
        if let retentionSettingsContainer = retentionSettingsContainer {
            retentionSettingsDecoded0 = [SecurityLakeClientTypes.RetentionSetting]()
            for structure0 in retentionSettingsContainer {
                if let structure0 = structure0 {
                    retentionSettingsDecoded0?.append(structure0)
                }
            }
        }
        retentionSettings = retentionSettingsDecoded0
        let tagsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagsMap)
        var tagsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsMapContainer = tagsMapContainer {
            tagsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsMapContainer {
                if let string0 = string0 {
                    tagsMapDecoded0?[key0] = string0
                }
            }
        }
        tagsMap = tagsMapDecoded0
        let replicationDestinationRegionsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Region?].self, forKey: .replicationDestinationRegions)
        var replicationDestinationRegionsDecoded0:[SecurityLakeClientTypes.Region]? = nil
        if let replicationDestinationRegionsContainer = replicationDestinationRegionsContainer {
            replicationDestinationRegionsDecoded0 = [SecurityLakeClientTypes.Region]()
            for string0 in replicationDestinationRegionsContainer {
                if let string0 = string0 {
                    replicationDestinationRegionsDecoded0?.append(string0)
                }
            }
        }
        replicationDestinationRegions = replicationDestinationRegionsDecoded0
        let replicationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationRoleArn)
        replicationRoleArn = replicationRoleArnDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details of Amazon Security Lake configuration object.
    public struct LakeConfigurationRequest: Swift.Equatable {
        /// The type of encryption key used by Amazon Security Lake to encrypt the Security Lake configuration object.
        public var encryptionKey: Swift.String?
        /// Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket. Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region.
        public var replicationDestinationRegions: [SecurityLakeClientTypes.Region]?
        /// Replication settings for the Amazon S3 buckets. This parameter uses the Identity and Access Management (IAM) role you created that is managed by Security Lake, to ensure the replication setting is correct.
        public var replicationRoleArn: Swift.String?
        /// Retention settings for the destination Amazon S3 buckets.
        public var retentionSettings: [SecurityLakeClientTypes.RetentionSetting]?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.
        public var tagsMap: [Swift.String:Swift.String]?

        public init (
            encryptionKey: Swift.String? = nil,
            replicationDestinationRegions: [SecurityLakeClientTypes.Region]? = nil,
            replicationRoleArn: Swift.String? = nil,
            retentionSettings: [SecurityLakeClientTypes.RetentionSetting]? = nil,
            tagsMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.encryptionKey = encryptionKey
            self.replicationDestinationRegions = replicationDestinationRegions
            self.replicationRoleArn = replicationRoleArn
            self.retentionSettings = retentionSettings
            self.tagsMap = tagsMap
        }
    }

}

extension SecurityLakeClientTypes.LakeConfigurationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case replicationDestinationRegions
        case replicationRoleArn
        case retentionSettings
        case s3BucketArn
        case status
        case tagsMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let replicationDestinationRegions = replicationDestinationRegions {
            var replicationDestinationRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationDestinationRegions)
            for region0 in replicationDestinationRegions {
                try replicationDestinationRegionsContainer.encode(region0.rawValue)
            }
        }
        if let replicationRoleArn = self.replicationRoleArn {
            try encodeContainer.encode(replicationRoleArn, forKey: .replicationRoleArn)
        }
        if let retentionSettings = retentionSettings {
            var retentionSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .retentionSettings)
            for retentionsetting0 in retentionSettings {
                try retentionSettingsContainer.encode(retentionsetting0)
            }
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagsMap = tagsMap {
            var tagsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tagsMap)
            for (dictKey0, tagsMap0) in tagsMap {
                try tagsMapContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let retentionSettingsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.RetentionSetting?].self, forKey: .retentionSettings)
        var retentionSettingsDecoded0:[SecurityLakeClientTypes.RetentionSetting]? = nil
        if let retentionSettingsContainer = retentionSettingsContainer {
            retentionSettingsDecoded0 = [SecurityLakeClientTypes.RetentionSetting]()
            for structure0 in retentionSettingsContainer {
                if let structure0 = structure0 {
                    retentionSettingsDecoded0?.append(structure0)
                }
            }
        }
        retentionSettings = retentionSettingsDecoded0
        let tagsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tagsMap)
        var tagsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsMapContainer = tagsMapContainer {
            tagsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsMapContainer {
                if let string0 = string0 {
                    tagsMapDecoded0?[key0] = string0
                }
            }
        }
        tagsMap = tagsMapDecoded0
        let replicationDestinationRegionsContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Region?].self, forKey: .replicationDestinationRegions)
        var replicationDestinationRegionsDecoded0:[SecurityLakeClientTypes.Region]? = nil
        if let replicationDestinationRegionsContainer = replicationDestinationRegionsContainer {
            replicationDestinationRegionsDecoded0 = [SecurityLakeClientTypes.Region]()
            for string0 in replicationDestinationRegionsContainer {
                if let string0 = string0 {
                    replicationDestinationRegionsDecoded0?.append(string0)
                }
            }
        }
        replicationDestinationRegions = replicationDestinationRegionsDecoded0
        let replicationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationRoleArn)
        replicationRoleArn = replicationRoleArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SettingsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details of Amazon Security Lake lake configuration object.
    public struct LakeConfigurationResponse: Swift.Equatable {
        /// The type of encryption key used by secure the Security Lake configuration object.
        public var encryptionKey: Swift.String?
        /// Replication enables automatic, asynchronous copying of objects across Amazon S3 buckets. Amazon S3 buckets that are configured for object replication can be owned by the same Amazon Web Services account or by different accounts. You can replicate objects to a single destination bucket or to multiple destination buckets. The destination buckets can be in different Amazon Web Services Regions or within the same Region as the source bucket. Set up one or more rollup Regions by providing the Region or Regions that should contribute to the central rollup Region.
        public var replicationDestinationRegions: [SecurityLakeClientTypes.Region]?
        /// Replication settings for the Amazon S3 buckets. This parameter uses the IAM role you created that is managed by Security Lake, to ensure the replication setting is correct.
        public var replicationRoleArn: Swift.String?
        /// Retention settings for the destination Amazon S3 buckets.
        public var retentionSettings: [SecurityLakeClientTypes.RetentionSetting]?
        /// Amazon Resource Names (ARNs) uniquely identify Amazon Web Services resources. Security Lake requires an ARN when you need to specify a resource unambiguously across all of Amazon Web Services, such as in IAM policies, Amazon Relational Database Service (Amazon RDS) tags, and API calls.
        public var s3BucketArn: Swift.String?
        /// Retrieves the status of the configuration operation for an account in Amazon Security Lake.
        public var status: SecurityLakeClientTypes.SettingsStatus?
        /// A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define.
        public var tagsMap: [Swift.String:Swift.String]?

        public init (
            encryptionKey: Swift.String? = nil,
            replicationDestinationRegions: [SecurityLakeClientTypes.Region]? = nil,
            replicationRoleArn: Swift.String? = nil,
            retentionSettings: [SecurityLakeClientTypes.RetentionSetting]? = nil,
            s3BucketArn: Swift.String? = nil,
            status: SecurityLakeClientTypes.SettingsStatus? = nil,
            tagsMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.encryptionKey = encryptionKey
            self.replicationDestinationRegions = replicationDestinationRegions
            self.replicationRoleArn = replicationRoleArn
            self.retentionSettings = retentionSettings
            self.s3BucketArn = s3BucketArn
            self.status = status
            self.tagsMap = tagsMap
        }
    }

}

extension ListDatalakeExceptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxFailures
        case nextToken
        case regionSet
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxFailures = self.maxFailures {
            try encodeContainer.encode(maxFailures, forKey: .maxFailures)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionSet = regionSet {
            var regionSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regionSet)
            for region0 in regionSet {
                try regionSetContainer.encode(region0.rawValue)
            }
        }
    }
}

extension ListDatalakeExceptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions"
    }
}

public struct ListDatalakeExceptionsInput: Swift.Equatable {
    /// List the maximum number of failures in Security Lake.
    public var maxFailures: Swift.Int?
    /// List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// List the Amazon Web Services Regions from which exceptions are retrieved.
    public var regionSet: [SecurityLakeClientTypes.Region]?

    public init (
        maxFailures: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regionSet: [SecurityLakeClientTypes.Region]? = nil
    )
    {
        self.maxFailures = maxFailures
        self.nextToken = nextToken
        self.regionSet = regionSet
    }
}

struct ListDatalakeExceptionsInputBody: Swift.Equatable {
    let regionSet: [SecurityLakeClientTypes.Region]?
    let maxFailures: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDatalakeExceptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxFailures
        case nextToken
        case regionSet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionSetContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Region?].self, forKey: .regionSet)
        var regionSetDecoded0:[SecurityLakeClientTypes.Region]? = nil
        if let regionSetContainer = regionSetContainer {
            regionSetDecoded0 = [SecurityLakeClientTypes.Region]()
            for string0 in regionSetContainer {
                if let string0 = string0 {
                    regionSetDecoded0?.append(string0)
                }
            }
        }
        regionSet = regionSetDecoded0
        let maxFailuresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFailures)
        maxFailures = maxFailuresDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDatalakeExceptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatalakeExceptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatalakeExceptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatalakeExceptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatalakeExceptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nonRetryableFailures = output.nonRetryableFailures
        } else {
            self.nextToken = nil
            self.nonRetryableFailures = nil
        }
    }
}

public struct ListDatalakeExceptionsOutputResponse: Swift.Equatable {
    /// List if there are more results available. The value of nextToken is a unique pagination token for each page. Repeat the call using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Lists the failures that cannot be retried in the current Region.
    /// This member is required.
    public var nonRetryableFailures: [SecurityLakeClientTypes.FailuresResponse]?

    public init (
        nextToken: Swift.String? = nil,
        nonRetryableFailures: [SecurityLakeClientTypes.FailuresResponse]? = nil
    )
    {
        self.nextToken = nextToken
        self.nonRetryableFailures = nonRetryableFailures
    }
}

struct ListDatalakeExceptionsOutputResponseBody: Swift.Equatable {
    let nonRetryableFailures: [SecurityLakeClientTypes.FailuresResponse]?
    let nextToken: Swift.String?
}

extension ListDatalakeExceptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nonRetryableFailures
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonRetryableFailuresContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.FailuresResponse?].self, forKey: .nonRetryableFailures)
        var nonRetryableFailuresDecoded0:[SecurityLakeClientTypes.FailuresResponse]? = nil
        if let nonRetryableFailuresContainer = nonRetryableFailuresContainer {
            nonRetryableFailuresDecoded0 = [SecurityLakeClientTypes.FailuresResponse]()
            for structure0 in nonRetryableFailuresContainer {
                if let structure0 = structure0 {
                    nonRetryableFailuresDecoded0?.append(structure0)
                }
            }
        }
        nonRetryableFailures = nonRetryableFailuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputOrder
        case listAllDimensions
        case listSingleDimension
        case listTwoDimensions
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputOrder = inputOrder {
            var inputOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputOrder)
            for dimension0 in inputOrder {
                try inputOrderContainer.encode(dimension0.rawValue)
            }
        }
        if let listAllDimensions = listAllDimensions {
            var listAllDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .listAllDimensions)
            for (dictKey0, allDimensionsMap0) in listAllDimensions {
                var allDimensionsMap0Container = listAllDimensionsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, twoDimensionsMap1) in allDimensionsMap0 {
                    var twoDimensionsMap1Container = allDimensionsMap0Container.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey1))
                    for string2 in twoDimensionsMap1 {
                        try twoDimensionsMap1Container.encode(string2)
                    }
                }
            }
        }
        if let listSingleDimension = listSingleDimension {
            var listSingleDimensionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listSingleDimension)
            for safestring0 in listSingleDimension {
                try listSingleDimensionContainer.encode(safestring0)
            }
        }
        if let listTwoDimensions = listTwoDimensions {
            var listTwoDimensionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .listTwoDimensions)
            for (dictKey0, twoDimensionsMap0) in listTwoDimensions {
                var twoDimensionsMap0Container = listTwoDimensionsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in twoDimensionsMap0 {
                    try twoDimensionsMap0Container.encode(string1)
                }
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLogSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/logsources/list"
    }
}

public struct ListLogSourcesInput: Swift.Equatable {
    /// Lists the log sources in input order, namely Region, source type, and member account.
    public var inputOrder: [SecurityLakeClientTypes.Dimension]?
    /// List the view of log sources for enabled Amazon Security Lake accounts for specific Amazon Web Services sources from specific accounts and specific Regions.
    public var listAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    /// List the view of log sources for enabled Security Lake accounts for all Amazon Web Services sources from specific accounts or specific Regions.
    public var listSingleDimension: [Swift.String]?
    /// Lists the view of log sources for enabled Security Lake accounts for specific Amazon Web Services sources from specific accounts or specific Regions.
    public var listTwoDimensions: [Swift.String:[Swift.String]]?
    /// The maximum number of accounts for which the log sources are displayed.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        inputOrder: [SecurityLakeClientTypes.Dimension]? = nil,
        listAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]? = nil,
        listSingleDimension: [Swift.String]? = nil,
        listTwoDimensions: [Swift.String:[Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inputOrder = inputOrder
        self.listAllDimensions = listAllDimensions
        self.listSingleDimension = listSingleDimension
        self.listTwoDimensions = listTwoDimensions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLogSourcesInputBody: Swift.Equatable {
    let inputOrder: [SecurityLakeClientTypes.Dimension]?
    let listAllDimensions: [Swift.String:[Swift.String:[Swift.String]]]?
    let listTwoDimensions: [Swift.String:[Swift.String]]?
    let listSingleDimension: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLogSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputOrder
        case listAllDimensions
        case listSingleDimension
        case listTwoDimensions
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputOrderContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.Dimension?].self, forKey: .inputOrder)
        var inputOrderDecoded0:[SecurityLakeClientTypes.Dimension]? = nil
        if let inputOrderContainer = inputOrderContainer {
            inputOrderDecoded0 = [SecurityLakeClientTypes.Dimension]()
            for string0 in inputOrderContainer {
                if let string0 = string0 {
                    inputOrderDecoded0?.append(string0)
                }
            }
        }
        inputOrder = inputOrderDecoded0
        let listAllDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: [Swift.String?]?]?].self, forKey: .listAllDimensions)
        var listAllDimensionsDecoded0: [Swift.String:[Swift.String:[Swift.String]]]? = nil
        if let listAllDimensionsContainer = listAllDimensionsContainer {
            listAllDimensionsDecoded0 = [Swift.String:[Swift.String:[Swift.String]]]()
            for (key0, twodimensionsmap0) in listAllDimensionsContainer {
                var twodimensionsmap0Decoded0: [Swift.String: [Swift.String]]? = nil
                if let twodimensionsmap0 = twodimensionsmap0 {
                    twodimensionsmap0Decoded0 = [Swift.String: [Swift.String]]()
                    for (key1, valueset1) in twodimensionsmap0 {
                        var valueset1Decoded1: [Swift.String]? = nil
                        if let valueset1 = valueset1 {
                            valueset1Decoded1 = [Swift.String]()
                            for string2 in valueset1 {
                                if let string2 = string2 {
                                    valueset1Decoded1?.append(string2)
                                }
                            }
                        }
                        twodimensionsmap0Decoded0?[key1] = valueset1Decoded1
                    }
                }
                listAllDimensionsDecoded0?[key0] = twodimensionsmap0Decoded0
            }
        }
        listAllDimensions = listAllDimensionsDecoded0
        let listTwoDimensionsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .listTwoDimensions)
        var listTwoDimensionsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let listTwoDimensionsContainer = listTwoDimensionsContainer {
            listTwoDimensionsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, valueset0) in listTwoDimensionsContainer {
                var valueset0Decoded0: [Swift.String]? = nil
                if let valueset0 = valueset0 {
                    valueset0Decoded0 = [Swift.String]()
                    for string1 in valueset0 {
                        if let string1 = string1 {
                            valueset0Decoded0?.append(string1)
                        }
                    }
                }
                listTwoDimensionsDecoded0?[key0] = valueset0Decoded0
            }
        }
        listTwoDimensions = listTwoDimensionsDecoded0
        let listSingleDimensionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .listSingleDimension)
        var listSingleDimensionDecoded0:[Swift.String]? = nil
        if let listSingleDimensionContainer = listSingleDimensionContainer {
            listSingleDimensionDecoded0 = [Swift.String]()
            for string0 in listSingleDimensionContainer {
                if let string0 = string0 {
                    listSingleDimensionDecoded0?.append(string0)
                }
            }
        }
        listSingleDimension = listSingleDimensionDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLogSourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLogSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.regionSourceTypesAccountsList = output.regionSourceTypesAccountsList
        } else {
            self.nextToken = nil
            self.regionSourceTypesAccountsList = nil
        }
    }
}

public struct ListLogSourcesOutputResponse: Swift.Equatable {
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Lists the log sources by Regions for enabled Security Lake accounts.
    /// This member is required.
    public var regionSourceTypesAccountsList: [[Swift.String:[Swift.String:[Swift.String]]]]?

    public init (
        nextToken: Swift.String? = nil,
        regionSourceTypesAccountsList: [[Swift.String:[Swift.String:[Swift.String]]]]? = nil
    )
    {
        self.nextToken = nextToken
        self.regionSourceTypesAccountsList = regionSourceTypesAccountsList
    }
}

struct ListLogSourcesOutputResponseBody: Swift.Equatable {
    let regionSourceTypesAccountsList: [[Swift.String:[Swift.String:[Swift.String]]]]?
    let nextToken: Swift.String?
}

extension ListLogSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case regionSourceTypesAccountsList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionSourceTypesAccountsListContainer = try containerValues.decodeIfPresent([[Swift.String: [Swift.String: [Swift.String?]?]?]?].self, forKey: .regionSourceTypesAccountsList)
        var regionSourceTypesAccountsListDecoded0:[[Swift.String:[Swift.String:[Swift.String]]]]? = nil
        if let regionSourceTypesAccountsListContainer = regionSourceTypesAccountsListContainer {
            regionSourceTypesAccountsListDecoded0 = [[Swift.String:[Swift.String:[Swift.String]]]]()
            for map0 in regionSourceTypesAccountsListContainer {
                var regionSourceTypesAccountsListContainerDecoded0: [Swift.String: [Swift.String: [Swift.String]]]? = nil
                if let map0 = map0 {
                    regionSourceTypesAccountsListContainerDecoded0 = [Swift.String: [Swift.String: [Swift.String]]]()
                    for (key1, twodimensionsmap1) in map0 {
                        var twodimensionsmap1Decoded1: [Swift.String: [Swift.String]]? = nil
                        if let twodimensionsmap1 = twodimensionsmap1 {
                            twodimensionsmap1Decoded1 = [Swift.String: [Swift.String]]()
                            for (key2, valueset2) in twodimensionsmap1 {
                                var valueset2Decoded2: [Swift.String]? = nil
                                if let valueset2 = valueset2 {
                                    valueset2Decoded2 = [Swift.String]()
                                    for string3 in valueset2 {
                                        if let string3 = string3 {
                                            valueset2Decoded2?.append(string3)
                                        }
                                    }
                                }
                                twodimensionsmap1Decoded1?[key2] = valueset2Decoded2
                            }
                        }
                        regionSourceTypesAccountsListContainerDecoded0?[key1] = twodimensionsmap1Decoded1
                    }
                }
                if let regionSourceTypesAccountsListContainerDecoded0 = regionSourceTypesAccountsListContainerDecoded0 {
                    regionSourceTypesAccountsListDecoded0?.append(regionSourceTypesAccountsListContainerDecoded0)
                }
            }
        }
        regionSourceTypesAccountsList = regionSourceTypesAccountsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubscribersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscribersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/subscribers"
    }
}

public struct ListSubscribersInput: Swift.Equatable {
    /// The maximum number of accounts for which the configuration is displayed.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubscribersInputBody: Swift.Equatable {
}

extension ListSubscribersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscribersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscribersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSubscribersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscribersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSubscribersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

public struct ListSubscribersOutputResponse: Swift.Equatable {
    /// If nextToken is returned, there are more results available. You can repeat the call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The subscribers available for the specified Security Lake account ID.
    /// This member is required.
    public var subscribers: [SecurityLakeClientTypes.SubscriberResource]?

    public init (
        nextToken: Swift.String? = nil,
        subscribers: [SecurityLakeClientTypes.SubscriberResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct ListSubscribersOutputResponseBody: Swift.Equatable {
    let subscribers: [SecurityLakeClientTypes.SubscriberResource]?
    let nextToken: Swift.String?
}

extension ListSubscribersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case subscribers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.SubscriberResource?].self, forKey: .subscribers)
        var subscribersDecoded0:[SecurityLakeClientTypes.SubscriberResource]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [SecurityLakeClientTypes.SubscriberResource]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SecurityLakeClientTypes.LogsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus
        case pathToLogs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let pathToLogs = self.pathToLogs {
            try encodeContainer.encode(pathToLogs, forKey: .pathToLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToLogsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathToLogs)
        pathToLogs = pathToLogsDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SourceStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Retrieves the Logs status for the Amazon Security Lake account.
    public struct LogsStatus: Swift.Equatable {
        /// The health status of services, including error codes and patterns.
        /// This member is required.
        public var healthStatus: SecurityLakeClientTypes.SourceStatus?
        /// Defines path the stored logs are available which has information on your systems, applications, and services.
        /// This member is required.
        public var pathToLogs: Swift.String?

        public init (
            healthStatus: SecurityLakeClientTypes.SourceStatus? = nil,
            pathToLogs: Swift.String? = nil
        )
        {
            self.healthStatus = healthStatus
            self.pathToLogs = pathToLogs
        }
    }

}

extension SecurityLakeClientTypes {
    public enum OcsfEventClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessActivity
        case accountChange
        case authentication
        case authorization
        case cloudApi
        case cloudStorage
        case configState
        case containerLifecycle
        case databaseLifecycle
        case dhcpActivity
        case dnsActivity
        case entityManagementAudit
        case fileActivity
        case ftpActivity
        case httpActivity
        case inventoryInfo
        case kernelActivity
        case kernelExtension
        case memoryActivity
        case moduleActivity
        case networkActivity
        case processActivity
        case rdpActivity
        case registryKeyActivity
        case registryValueActivity
        case resourceActivity
        case rfbActivity
        case scheduledJobActivity
        case securityFinding
        case smbActivity
        case smtpActivity
        case sshActivity
        case virtualMachineActivity
        case sdkUnknown(Swift.String)

        public static var allCases: [OcsfEventClass] {
            return [
                .accessActivity,
                .accountChange,
                .authentication,
                .authorization,
                .cloudApi,
                .cloudStorage,
                .configState,
                .containerLifecycle,
                .databaseLifecycle,
                .dhcpActivity,
                .dnsActivity,
                .entityManagementAudit,
                .fileActivity,
                .ftpActivity,
                .httpActivity,
                .inventoryInfo,
                .kernelActivity,
                .kernelExtension,
                .memoryActivity,
                .moduleActivity,
                .networkActivity,
                .processActivity,
                .rdpActivity,
                .registryKeyActivity,
                .registryValueActivity,
                .resourceActivity,
                .rfbActivity,
                .scheduledJobActivity,
                .securityFinding,
                .smbActivity,
                .smtpActivity,
                .sshActivity,
                .virtualMachineActivity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessActivity: return "ACCESS_ACTIVITY"
            case .accountChange: return "ACCOUNT_CHANGE"
            case .authentication: return "AUTHENTICATION"
            case .authorization: return "AUTHORIZATION"
            case .cloudApi: return "CLOUD_API"
            case .cloudStorage: return "CLOUD_STORAGE"
            case .configState: return "CONFIG_STATE"
            case .containerLifecycle: return "CONTAINER_LIFECYCLE"
            case .databaseLifecycle: return "DATABASE_LIFECYCLE"
            case .dhcpActivity: return "DHCP_ACTIVITY"
            case .dnsActivity: return "DNS_ACTIVITY"
            case .entityManagementAudit: return "ENTITY_MANAGEMENT_AUDIT"
            case .fileActivity: return "FILE_ACTIVITY"
            case .ftpActivity: return "FTP_ACTIVITY"
            case .httpActivity: return "HTTP_ACTIVITY"
            case .inventoryInfo: return "INVENTORY_INFO"
            case .kernelActivity: return "KERNEL_ACTIVITY"
            case .kernelExtension: return "KERNEL_EXTENSION"
            case .memoryActivity: return "MEMORY_ACTIVITY"
            case .moduleActivity: return "MODULE_ACTIVITY"
            case .networkActivity: return "NETWORK_ACTIVITY"
            case .processActivity: return "PROCESS_ACTIVITY"
            case .rdpActivity: return "RDP_ACTIVITY"
            case .registryKeyActivity: return "REGISTRY_KEY_ACTIVITY"
            case .registryValueActivity: return "REGISTRY_VALUE_ACTIVITY"
            case .resourceActivity: return "RESOURCE_ACTIVITY"
            case .rfbActivity: return "RFB_ACTIVITY"
            case .scheduledJobActivity: return "SCHEDULED_JOB_ACTIVITY"
            case .securityFinding: return "SECURITY_FINDING"
            case .smbActivity: return "SMB_ACTIVITY"
            case .smtpActivity: return "SMTP_ACTIVITY"
            case .sshActivity: return "SSH_ACTIVITY"
            case .virtualMachineActivity: return "VIRTUAL_MACHINE_ACTIVITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OcsfEventClass(rawValue: rawValue) ?? OcsfEventClass.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.ProtocolAndNotificationEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Protocol used in Amazon Security Lake that dictates how notifications are posted at the endpoint.
    public struct ProtocolAndNotificationEndpoint: Swift.Equatable {
        /// The account that is subscribed to receive exception notifications.
        public var endpoint: Swift.String?
        /// The protocol to which notification messages are posted.
        public var `protocol`: Swift.String?

        public init (
            endpoint: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityLakeClientTypes {
    public enum Region: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apSoutheast2
        case euCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [Region] {
            return [
                .apNortheast1,
                .apSoutheast2,
                .euCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Region(rawValue: rawValue) ?? Region.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource for which the type of resource could not be found.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that could not be found.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SecurityLakeClientTypes.RetentionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionPeriod
        case storageClass
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageClassDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Retention settings for the destination Amazon S3 buckets in Amazon Security Lake.
    public struct RetentionSetting: Swift.Equatable {
        /// The retention period specifies a fixed period of time during which the Security Lake object remains locked. You can specify the retention period in days for one or more sources.
        public var retentionPeriod: Swift.Int?
        /// The range of storage classes that you can choose from based on the data access, resiliency, and cost requirements of your workloads.
        public var storageClass: SecurityLakeClientTypes.StorageClass?

        public init (
            retentionPeriod: Swift.Int? = nil,
            storageClass: SecurityLakeClientTypes.StorageClass? = nil
        )
        {
            self.retentionPeriod = retentionPeriod
            self.storageClass = storageClass
        }
    }

}

extension S3Exception {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: S3ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provides an extension of the AmazonServiceException for errors reported by Amazon S3 while processing a request. In particular, this class provides access to the Amazon S3 extended request ID. If Amazon S3 is incorrectly handling a request and you need to contact Amazon, this extended request ID may provide useful debugging information.
public struct S3Exception: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct S3ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// That the rate of requests to Security Lake is exceeding the request quotas for your Amazon Web Services account.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The ID of the resource that exceeds the service quota.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource that exceeds the service quota.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The code for the service in Service Quotas.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension SecurityLakeClientTypes {
    public enum SettingsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initialized
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SettingsStatus] {
            return [
                .completed,
                .failed,
                .initialized,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SettingsStatus(rawValue: rawValue) ?? SettingsStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes {
    public enum SourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deactivated
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceStatus] {
            return [
                .active,
                .deactivated,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deactivated: return "DEACTIVATED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceStatus(rawValue: rawValue) ?? SourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.SourceType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awssourcetype = "awsSourceType"
        case customsourcetype = "customSourceType"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awssourcetype(awssourcetype):
                try container.encode(awssourcetype.rawValue, forKey: .awssourcetype)
            case let .customsourcetype(customsourcetype):
                try container.encode(customsourcetype, forKey: .customsourcetype)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let awssourcetypeDecoded = try values.decodeIfPresent(SecurityLakeClientTypes.AwsLogSourceType.self, forKey: .awssourcetype)
        if let awssourcetype = awssourcetypeDecoded {
            self = .awssourcetype(awssourcetype)
            return
        }
        let customsourcetypeDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .customsourcetype)
        if let customsourcetype = customsourcetypeDecoded {
            self = .customsourcetype(customsourcetype)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SecurityLakeClientTypes {
    /// The supported source types from which logs and events are collected in Amazon Security Lake. For the list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    public enum SourceType: Swift.Equatable {
        /// Amazon Security Lake supports log and event collection for natively supported Amazon Web Services.
        case awssourcetype(SecurityLakeClientTypes.AwsLogSourceType)
        /// Amazon Security Lake supports custom source types. For a detailed list, see the Amazon Security Lake User Guide.
        case customsourcetype(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension SecurityLakeClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deepArchive
        case expire
        case glacier
        case glacierIr
        case intelligentTiering
        case onezoneIa
        case standardIa
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .deepArchive,
                .expire,
                .glacier,
                .glacierIr,
                .intelligentTiering,
                .onezoneIa,
                .standardIa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deepArchive: return "DEEP_ARCHIVE"
            case .expire: return "EXPIRE"
            case .glacier: return "GLACIER"
            case .glacierIr: return "GLACIER_IR"
            case .intelligentTiering: return "INTELLIGENT_TIERING"
            case .onezoneIa: return "ONEZONE_IA"
            case .standardIa: return "STANDARD_IA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes.SubscriberResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTypes
        case accountId
        case createdAt
        case externalId
        case roleArn
        case s3BucketArn
        case snsArn
        case sourceTypes
        case subscriberDescription
        case subscriberName
        case subscriptionEndpoint
        case subscriptionId
        case subscriptionProtocol
        case subscriptionStatus
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessTypes = accessTypes {
            var accessTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessTypes)
            for accesstype0 in accessTypes {
                try accessTypesContainer.encode(accesstype0.rawValue)
            }
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let snsArn = self.snsArn {
            try encodeContainer.encode(snsArn, forKey: .snsArn)
        }
        if let sourceTypes = sourceTypes {
            var sourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceTypes)
            for sourcetype0 in sourceTypes {
                try sourceTypesContainer.encode(sourcetype0)
            }
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
        if let subscriptionEndpoint = self.subscriptionEndpoint {
            try encodeContainer.encode(subscriptionEndpoint, forKey: .subscriptionEndpoint)
        }
        if let subscriptionId = self.subscriptionId {
            try encodeContainer.encode(subscriptionId, forKey: .subscriptionId)
        }
        if let subscriptionProtocol = self.subscriptionProtocol {
            try encodeContainer.encode(subscriptionProtocol.rawValue, forKey: .subscriptionProtocol)
        }
        if let subscriptionStatus = self.subscriptionStatus {
            try encodeContainer.encode(subscriptionStatus.rawValue, forKey: .subscriptionStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
        let sourceTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.SourceType?].self, forKey: .sourceTypes)
        var sourceTypesDecoded0:[SecurityLakeClientTypes.SourceType]? = nil
        if let sourceTypesContainer = sourceTypesContainer {
            sourceTypesDecoded0 = [SecurityLakeClientTypes.SourceType]()
            for union0 in sourceTypesContainer {
                if let union0 = union0 {
                    sourceTypesDecoded0?.append(union0)
                }
            }
        }
        sourceTypes = sourceTypesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
        let subscriptionStatusDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriptionStatus.self, forKey: .subscriptionStatus)
        subscriptionStatus = subscriptionStatusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let snsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsArn)
        snsArn = snsArnDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
        let accessTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.AccessType?].self, forKey: .accessTypes)
        var accessTypesDecoded0:[SecurityLakeClientTypes.AccessType]? = nil
        if let accessTypesContainer = accessTypesContainer {
            accessTypesDecoded0 = [SecurityLakeClientTypes.AccessType]()
            for string0 in accessTypesContainer {
                if let string0 = string0 {
                    accessTypesDecoded0?.append(string0)
                }
            }
        }
        accessTypes = accessTypesDecoded0
        let subscriptionEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndpoint)
        subscriptionEndpoint = subscriptionEndpointDecoded
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.EndpointProtocol.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension SecurityLakeClientTypes {
    /// Provides details about the Amazon Security Lake account subscription. Subscribers are notified of new objects for a source as the data is written to your Amazon S3 bucket for Security Lake.
    public struct SubscriberResource: Swift.Equatable {
        /// You can choose to notify subscribers of new objects with an Amazon Simple Queue Service (Amazon SQS) queue or through messaging to an HTTPS endpoint provided by the subscriber. Subscribers can consume data by directly querying Lake Formation tables in your Amazon S3 bucket through services like Amazon Athena. This subscription type is defined as LAKEFORMATION.
        public var accessTypes: [SecurityLakeClientTypes.AccessType]?
        /// The Amazon Web Services account ID you are using to create your Amazon Security Lake account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The date and time when the subscription was created.
        public var createdAt: ClientRuntime.Date?
        /// The external ID of the subscriber. The external ID lets the user that is assuming the role assert the circumstances in which they are operating. It also provides a way for the account owner to permit the role to be assumed only under specific circumstances.
        public var externalId: Swift.String?
        /// The Amazon Resource Name (ARN) specifying the role of the subscriber.
        public var roleArn: Swift.String?
        /// The ARN for the Amazon S3 bucket.
        public var s3BucketArn: Swift.String?
        /// The ARN for the Amazon Simple Notification Service.
        public var snsArn: Swift.String?
        /// Amazon Security Lake supports log and event collection for natively supported Amazon Web Services. For more information, see the Amazon Security Lake User Guide.
        /// This member is required.
        public var sourceTypes: [SecurityLakeClientTypes.SourceType]?
        /// The subscriber descriptions for a subscriber account. The description for a subscriber includes subscriberName, accountID, externalID, and subscriptionId.
        public var subscriberDescription: Swift.String?
        /// The name of your Amazon Security Lake subscriber account.
        public var subscriberName: Swift.String?
        /// The subscription endpoint to which exception messages are posted.
        public var subscriptionEndpoint: Swift.String?
        /// The subscription ID of the Amazon Security Lake subscriber account.
        /// This member is required.
        public var subscriptionId: Swift.String?
        /// The subscription protocol to which exception messages are posted.
        public var subscriptionProtocol: SecurityLakeClientTypes.EndpointProtocol?
        /// The subscription status of the Amazon Security Lake subscriber account.
        public var subscriptionStatus: SecurityLakeClientTypes.SubscriptionStatus?
        /// The date and time when the subscription was created.
        public var updatedAt: ClientRuntime.Date?

        public init (
            accessTypes: [SecurityLakeClientTypes.AccessType]? = nil,
            accountId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            externalId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            s3BucketArn: Swift.String? = nil,
            snsArn: Swift.String? = nil,
            sourceTypes: [SecurityLakeClientTypes.SourceType]? = nil,
            subscriberDescription: Swift.String? = nil,
            subscriberName: Swift.String? = nil,
            subscriptionEndpoint: Swift.String? = nil,
            subscriptionId: Swift.String? = nil,
            subscriptionProtocol: SecurityLakeClientTypes.EndpointProtocol? = nil,
            subscriptionStatus: SecurityLakeClientTypes.SubscriptionStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accessTypes = accessTypes
            self.accountId = accountId
            self.createdAt = createdAt
            self.externalId = externalId
            self.roleArn = roleArn
            self.s3BucketArn = s3BucketArn
            self.snsArn = snsArn
            self.sourceTypes = sourceTypes
            self.subscriberDescription = subscriberDescription
            self.subscriberName = subscriberName
            self.subscriptionEndpoint = subscriptionEndpoint
            self.subscriptionId = subscriptionId
            self.subscriptionProtocol = subscriptionProtocol
            self.subscriptionStatus = subscriptionStatus
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityLakeClientTypes {
    public enum SubscriptionProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app
        case email
        case emailJson
        case firehose
        case http
        case https
        case lambda
        case sms
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProtocolType] {
            return [
                .app,
                .email,
                .emailJson,
                .firehose,
                .http,
                .https,
                .lambda,
                .sms,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app: return "APP"
            case .email: return "EMAIL"
            case .emailJson: return "EMAIL_JSON"
            case .firehose: return "FIREHOSE"
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .lambda: return "LAMBDA"
            case .sms: return "SMS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionProtocolType(rawValue: rawValue) ?? SubscriptionProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension SecurityLakeClientTypes {
    public enum SubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deactivated
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionStatus] {
            return [
                .active,
                .deactivated,
                .pending,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deactivated: return "DEACTIVATED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionStatus(rawValue: rawValue) ?? SubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// That the rate of requests to Security Lake is exceeding the request quotas for your Amazon Web Services account.
    public var quotaCode: Swift.String?
    /// Retry the request after the specified time.
    public var retryAfterSeconds: Swift.Int?
    /// The code for the service in Service Quotas.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UpdateDatalakeExceptionsExpiryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessageExpiry
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionMessageExpiry = self.exceptionMessageExpiry {
            try encodeContainer.encode(exceptionMessageExpiry, forKey: .exceptionMessageExpiry)
        }
    }
}

extension UpdateDatalakeExceptionsExpiryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/expiry"
    }
}

public struct UpdateDatalakeExceptionsExpiryInput: Swift.Equatable {
    /// The time-to-live (TTL) for the exception message to remain.
    /// This member is required.
    public var exceptionMessageExpiry: Swift.Int?

    public init (
        exceptionMessageExpiry: Swift.Int? = nil
    )
    {
        self.exceptionMessageExpiry = exceptionMessageExpiry
    }
}

struct UpdateDatalakeExceptionsExpiryInputBody: Swift.Equatable {
    let exceptionMessageExpiry: Swift.Int?
}

extension UpdateDatalakeExceptionsExpiryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessageExpiry
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageExpiryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exceptionMessageExpiry)
        exceptionMessageExpiry = exceptionMessageExpiryDecoded
    }
}

extension UpdateDatalakeExceptionsExpiryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatalakeExceptionsExpiryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatalakeExceptionsExpiryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatalakeExceptionsExpiryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatalakeExceptionsExpiryOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatalakeExceptionsSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationEndpoint
        case subscriptionProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationEndpoint = self.notificationEndpoint {
            try encodeContainer.encode(notificationEndpoint, forKey: .notificationEndpoint)
        }
        if let subscriptionProtocol = self.subscriptionProtocol {
            try encodeContainer.encode(subscriptionProtocol.rawValue, forKey: .subscriptionProtocol)
        }
    }
}

extension UpdateDatalakeExceptionsSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake/exceptions/subscription"
    }
}

public struct UpdateDatalakeExceptionsSubscriptionInput: Swift.Equatable {
    /// The account that is subscribed to receive exception notifications.
    /// This member is required.
    public var notificationEndpoint: Swift.String?
    /// The subscription protocol to which exception messages are posted.
    /// This member is required.
    public var subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType?

    public init (
        notificationEndpoint: Swift.String? = nil,
        subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType? = nil
    )
    {
        self.notificationEndpoint = notificationEndpoint
        self.subscriptionProtocol = subscriptionProtocol
    }
}

struct UpdateDatalakeExceptionsSubscriptionInputBody: Swift.Equatable {
    let subscriptionProtocol: SecurityLakeClientTypes.SubscriptionProtocolType?
    let notificationEndpoint: Swift.String?
}

extension UpdateDatalakeExceptionsSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationEndpoint
        case subscriptionProtocol
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionProtocolDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriptionProtocolType.self, forKey: .subscriptionProtocol)
        subscriptionProtocol = subscriptionProtocolDecoded
        let notificationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationEndpoint)
        notificationEndpoint = notificationEndpointDecoded
    }
}

extension UpdateDatalakeExceptionsSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatalakeExceptionsSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatalakeExceptionsSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatalakeExceptionsSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatalakeExceptionsSubscriptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDatalakeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, lakeConfigurationRequestMap0) in configurations {
                try configurationsContainer.encode(lakeConfigurationRequestMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateDatalakeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/datalake"
    }
}

public struct UpdateDatalakeInput: Swift.Equatable {
    /// Specify the Region or Regions that will contribute data to the rollup region.
    /// This member is required.
    public var configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]?

    public init (
        configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct UpdateDatalakeInputBody: Swift.Equatable {
    let configurations: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]?
}

extension UpdateDatalakeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: SecurityLakeClientTypes.LakeConfigurationRequest?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:SecurityLakeClientTypes.LakeConfigurationRequest]()
            for (key0, lakeconfigurationrequest0) in configurationsContainer {
                if let lakeconfigurationrequest0 = lakeconfigurationrequest0 {
                    configurationsDecoded0?[key0] = lakeconfigurationrequest0
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension UpdateDatalakeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatalakeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EventBridgeException" : self = .eventBridgeException(try EventBridgeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatalakeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case eventBridgeException(EventBridgeException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatalakeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatalakeOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId
        case sourceTypes
        case subscriberDescription
        case subscriberName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = self.externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let sourceTypes = sourceTypes {
            var sourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceTypes)
            for sourcetype0 in sourceTypes {
                try sourceTypesContainer.encode(sourcetype0)
            }
        }
        if let subscriberDescription = self.subscriberDescription {
            try encodeContainer.encode(subscriberDescription, forKey: .subscriberDescription)
        }
        if let subscriberName = self.subscriberName {
            try encodeContainer.encode(subscriberName, forKey: .subscriberName)
        }
    }
}

extension UpdateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/v1/subscribers/\(id.urlPercentEncoding())"
    }
}

public struct UpdateSubscriberInput: Swift.Equatable {
    /// The external ID of the Security Lake account.
    public var externalId: Swift.String?
    /// A value created by Security Lake that uniquely identifies your subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The supported Amazon Web Services from which logs and events are collected. For the list of supported Amazon Web Services, see the [Amazon Security Lake User Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
    /// This member is required.
    public var sourceTypes: [SecurityLakeClientTypes.SourceType]?
    /// The description of the Security Lake account subscriber.
    public var subscriberDescription: Swift.String?
    /// The name of the Security Lake account subscriber.
    public var subscriberName: Swift.String?

    public init (
        externalId: Swift.String? = nil,
        id: Swift.String? = nil,
        sourceTypes: [SecurityLakeClientTypes.SourceType]? = nil,
        subscriberDescription: Swift.String? = nil,
        subscriberName: Swift.String? = nil
    )
    {
        self.externalId = externalId
        self.id = id
        self.sourceTypes = sourceTypes
        self.subscriberDescription = subscriberDescription
        self.subscriberName = subscriberName
    }
}

struct UpdateSubscriberInputBody: Swift.Equatable {
    let sourceTypes: [SecurityLakeClientTypes.SourceType]?
    let externalId: Swift.String?
    let subscriberName: Swift.String?
    let subscriberDescription: Swift.String?
}

extension UpdateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalId
        case sourceTypes
        case subscriberDescription
        case subscriberName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypesContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.SourceType?].self, forKey: .sourceTypes)
        var sourceTypesDecoded0:[SecurityLakeClientTypes.SourceType]? = nil
        if let sourceTypesContainer = sourceTypesContainer {
            sourceTypesDecoded0 = [SecurityLakeClientTypes.SourceType]()
            for union0 in sourceTypesContainer {
                if let union0 = union0 {
                    sourceTypesDecoded0?.append(union0)
                }
            }
        }
        sourceTypes = sourceTypesDecoded0
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let subscriberNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberName)
        subscriberName = subscriberNameDecoded
        let subscriberDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriberDescription)
        subscriberDescription = subscriberDescriptionDecoded
    }
}

extension UpdateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictSubscriptionException" : self = .conflictSubscriptionException(try ConflictSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case concurrentModificationException(ConcurrentModificationException)
    case conflictSubscriptionException(ConflictSubscriptionException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSubscriberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriber = output.subscriber
        } else {
            self.subscriber = nil
        }
    }
}

public struct UpdateSubscriberOutputResponse: Swift.Equatable {
    /// The account of the subscriber.
    public var subscriber: SecurityLakeClientTypes.SubscriberResource?

    public init (
        subscriber: SecurityLakeClientTypes.SubscriberResource? = nil
    )
    {
        self.subscriber = subscriber
    }
}

struct UpdateSubscriberOutputResponseBody: Swift.Equatable {
    let subscriber: SecurityLakeClientTypes.SubscriberResource?
}

extension UpdateSubscriberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriber
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriberDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.SubscriberResource.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension UpdateSubscriptionNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSqs
        case httpsApiKeyName
        case httpsApiKeyValue
        case httpsMethod
        case roleArn
        case subscriptionEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createSqs = self.createSqs {
            try encodeContainer.encode(createSqs, forKey: .createSqs)
        }
        if let httpsApiKeyName = self.httpsApiKeyName {
            try encodeContainer.encode(httpsApiKeyName, forKey: .httpsApiKeyName)
        }
        if let httpsApiKeyValue = self.httpsApiKeyValue {
            try encodeContainer.encode(httpsApiKeyValue, forKey: .httpsApiKeyValue)
        }
        if let httpsMethod = self.httpsMethod {
            try encodeContainer.encode(httpsMethod.rawValue, forKey: .httpsMethod)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subscriptionEndpoint = self.subscriptionEndpoint {
            try encodeContainer.encode(subscriptionEndpoint, forKey: .subscriptionEndpoint)
        }
    }
}

extension UpdateSubscriptionNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionId = subscriptionId else {
            return nil
        }
        return "/subscription-notifications/\(subscriptionId.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionNotificationConfigurationInput: Swift.Equatable {
    /// Create a new subscription notification for the specified subscription ID in Amazon Security Lake.
    public var createSqs: Swift.Bool?
    /// The key name for the subscription notification.
    public var httpsApiKeyName: Swift.String?
    /// The key value for the subscription notification.
    public var httpsApiKeyValue: Swift.String?
    /// The HTTPS method used for the subscription notification.
    public var httpsMethod: SecurityLakeClientTypes.HttpsMethod?
    /// The Amazon Resource Name (ARN) specifying the role of the subscriber.
    public var roleArn: Swift.String?
    /// The subscription endpoint in Security Lake.
    public var subscriptionEndpoint: Swift.String?
    /// The subscription ID for which the subscription notification is specified.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init (
        createSqs: Swift.Bool? = nil,
        httpsApiKeyName: Swift.String? = nil,
        httpsApiKeyValue: Swift.String? = nil,
        httpsMethod: SecurityLakeClientTypes.HttpsMethod? = nil,
        roleArn: Swift.String? = nil,
        subscriptionEndpoint: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.createSqs = createSqs
        self.httpsApiKeyName = httpsApiKeyName
        self.httpsApiKeyValue = httpsApiKeyValue
        self.httpsMethod = httpsMethod
        self.roleArn = roleArn
        self.subscriptionEndpoint = subscriptionEndpoint
        self.subscriptionId = subscriptionId
    }
}

struct UpdateSubscriptionNotificationConfigurationInputBody: Swift.Equatable {
    let subscriptionEndpoint: Swift.String?
    let httpsApiKeyName: Swift.String?
    let httpsApiKeyValue: Swift.String?
    let httpsMethod: SecurityLakeClientTypes.HttpsMethod?
    let createSqs: Swift.Bool?
    let roleArn: Swift.String?
}

extension UpdateSubscriptionNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createSqs
        case httpsApiKeyName
        case httpsApiKeyValue
        case httpsMethod
        case roleArn
        case subscriptionEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndpoint)
        subscriptionEndpoint = subscriptionEndpointDecoded
        let httpsApiKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpsApiKeyName)
        httpsApiKeyName = httpsApiKeyNameDecoded
        let httpsApiKeyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpsApiKeyValue)
        httpsApiKeyValue = httpsApiKeyValueDecoded
        let httpsMethodDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.HttpsMethod.self, forKey: .httpsMethod)
        httpsMethod = httpsMethodDecoded
        let createSqsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createSqs)
        createSqs = createSqsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateSubscriptionNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountNotFoundException" : self = .accountNotFoundException(try AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubscriptionNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountNotFoundException(AccountNotFoundException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSubscriptionNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queueArn = output.queueArn
        } else {
            self.queueArn = nil
        }
    }
}

public struct UpdateSubscriptionNotificationConfigurationOutputResponse: Swift.Equatable {
    /// Returns the ARN of the queue.
    public var queueArn: Swift.String?

    public init (
        queueArn: Swift.String? = nil
    )
    {
        self.queueArn = queueArn
    }
}

struct UpdateSubscriptionNotificationConfigurationOutputResponseBody: Swift.Equatable {
    let queueArn: Swift.String?
}

extension UpdateSubscriptionNotificationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queueArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueArn)
        queueArn = queueArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your signing certificate could not be validated.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The list of parameters that failed to validate.
    public var fieldList: [SecurityLakeClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the validation exception.
    /// This member is required.
    public var reason: SecurityLakeClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [SecurityLakeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SecurityLakeClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: SecurityLakeClientTypes.ValidationExceptionReason?
    let fieldList: [SecurityLakeClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SecurityLakeClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([SecurityLakeClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[SecurityLakeClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [SecurityLakeClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension SecurityLakeClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityLakeClientTypes {
    /// The input fails to meet the constraints specified in Amazon Security Lake.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Describes the error encountered.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension SecurityLakeClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
