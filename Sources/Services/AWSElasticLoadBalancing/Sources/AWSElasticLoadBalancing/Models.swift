//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
@_spi(SmithyReadWrite) import class SmithyFormURL.Writer
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyXML.Reader
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSQueryError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension ElasticLoadBalancingClientTypes {

    /// Information about the AccessLog attribute.
    public struct AccessLog: Swift.Sendable {
        /// The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes. Default: 60 minutes
        public var emitInterval: Swift.Int?
        /// Specifies whether access logs are enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The name of the Amazon S3 bucket where the access logs are stored.
        public var s3BucketName: Swift.String?
        /// The logical hierarchy you created for your Amazon S3 bucket, for example my-bucket-prefix/prod. If the prefix is not provided, the log is placed at the root level of the bucket.
        public var s3BucketPrefix: Swift.String?

        public init(
            emitInterval: Swift.Int? = nil,
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            s3BucketPrefix: Swift.String? = nil
        )
        {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }
    }
}

/// The specified load balancer does not exist.
public struct AccessPointNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadBalancerNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about additional load balancer attributes.
    public struct AdditionalAttribute: Swift.Sendable {
        /// The name of the attribute. The following attribute is supported.
        ///
        /// * elb.http.desyncmitigationmode - Determines how the load balancer handles requests that might pose a security risk to your application. The possible values are monitor, defensive, and strictest. The default is defensive.
        public var key: Swift.String?
        /// This value of the attribute.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// A tag key was specified more than once.
public struct DuplicateTagKeysException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateTagKeys" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The quota for the number of tags that can be assigned to a load balancer has been reached.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTags" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a tag.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// Contains the parameters for AddTags.
public struct AddTagsInput: Swift.Sendable {
    /// The name of the load balancer. You can specify one load balancer only.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The tags.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

/// Contains the output of AddTags.
public struct AddTagsOutput: Swift.Sendable {

    public init() { }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy for application-controlled session stickiness.
    public struct AppCookieStickinessPolicy: Swift.Sendable {
        /// The name of the application cookie used for stickiness.
        public var cookieName: Swift.String?
        /// The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
        public var policyName: Swift.String?

        public init(
            cookieName: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieName = cookieName
            self.policyName = policyName
        }
    }
}

/// The requested configuration change is not valid.
public struct InvalidConfigurationRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfigurationRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the specified security groups do not exist.
public struct InvalidSecurityGroupException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurityGroup" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.
    /// This member is required.
    public var securityGroups: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.securityGroups = securityGroups
    }
}

/// Contains the output of ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerOutput: Swift.Sendable {
    /// The IDs of the security groups associated with the load balancer.
    public var securityGroups: [Swift.String]?

    public init(
        securityGroups: [Swift.String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

/// The specified VPC has no associated Internet gateway.
public struct InvalidSubnetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the specified subnets do not exist.
public struct SubnetNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for AttachLoaBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets to add. You can add only one subnet per Availability Zone.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

/// Contains the output of AttachLoadBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsOutput: Swift.Sendable {
    /// The IDs of the subnets attached to the load balancer.
    public var subnets: [Swift.String]?

    public init(
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about the configuration of an EC2 instance.
    public struct BackendServerDescription: Swift.Sendable {
        /// The port on which the EC2 instance is listening.
        public var instancePort: Swift.Int?
        /// The names of the policies enabled for the EC2 instance.
        public var policyNames: [Swift.String]?

        public init(
            instancePort: Swift.Int? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }
    }
}

/// The specified ARN does not refer to a valid SSL certificate in AWS Identity and Access Management (IAM) or AWS Certificate Manager (ACM). Note that if you recently uploaded the certificate to IAM, this error might indicate that the certificate is not fully available yet.
public struct CertificateNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a health check.
    public struct HealthCheck: Swift.Sendable {
        /// The number of consecutive health checks successes required before moving the instance to the Healthy state.
        /// This member is required.
        public var healthyThreshold: Swift.Int?
        /// The approximate interval, in seconds, between health checks of an individual instance.
        /// This member is required.
        public var interval: Swift.Int?
        /// The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535. TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy. SSL is also specified as SSL: port pair, for example, SSL:5000. For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy. The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.
        /// This member is required.
        public var target: Swift.String?
        /// The amount of time, in seconds, during which no response means a failed health check. This value must be less than the Interval value.
        /// This member is required.
        public var timeout: Swift.Int?
        /// The number of consecutive health check failures required before moving the instance to the Unhealthy state.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            target: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }
}

/// Contains the parameters for ConfigureHealthCheck.
public struct ConfigureHealthCheckInput: Swift.Sendable {
    /// The configuration information.
    /// This member is required.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of ConfigureHealthCheck.
public struct ConfigureHealthCheckOutput: Swift.Sendable {
    /// The updated health check.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?

    public init(
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil
    )
    {
        self.healthCheck = healthCheck
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about the ConnectionDraining attribute.
    public struct ConnectionDraining: Swift.Sendable {
        /// Specifies whether connection draining is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public var timeout: Swift.Int?

        public init(
            enabled: Swift.Bool = false,
            timeout: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.timeout = timeout
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about the ConnectionSettings attribute.
    public struct ConnectionSettings: Swift.Sendable {
        /// The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.
        /// This member is required.
        public var idleTimeout: Swift.Int?

        public init(
            idleTimeout: Swift.Int? = nil
        )
        {
            self.idleTimeout = idleTimeout
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a listener. For information about the protocols and the ports supported by Elastic Load Balancing, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    public struct Listener: Swift.Sendable {
        /// The port on which the instance is listening.
        /// This member is required.
        public var instancePort: Swift.Int?
        /// The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If the front-end protocol is TCP or SSL, the back-end protocol must be TCP or SSL. If the front-end protocol is HTTP or HTTPS, the back-end protocol must be HTTP or HTTPS. If there is another listener with the same InstancePort whose InstanceProtocol is secure, (HTTPS or SSL), the listener's InstanceProtocol must also be secure. If there is another listener with the same InstancePort whose InstanceProtocol is HTTP or TCP, the listener's InstanceProtocol must be HTTP or TCP.
        public var instanceProtocol: Swift.String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        /// This member is required.
        public var loadBalancerPort: Swift.Int
        /// The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// The Amazon Resource Name (ARN) of the server certificate.
        public var sslCertificateId: Swift.String?

        public init(
            instancePort: Swift.Int? = nil,
            instanceProtocol: Swift.String? = nil,
            loadBalancerPort: Swift.Int = 0,
            `protocol`: Swift.String? = nil,
            sslCertificateId: Swift.String? = nil
        )
        {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }
    }
}

/// A policy with the specified name already exists for this load balancer.
public struct DuplicatePolicyNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicatePolicyName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The quota for the number of policies for this load balancer has been reached.
public struct TooManyPoliciesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPolicies" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyInput: Swift.Sendable {
    /// The name of the application cookie used for stickiness.
    /// This member is required.
    public var cookieName: Swift.String?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        cookieName: Swift.String? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieName = cookieName
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

/// Contains the output for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyOutput: Swift.Sendable {

    public init() { }
}

/// Contains the parameters for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyInput: Swift.Sendable {
    /// The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.
    public var cookieExpirationPeriod: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        cookieExpirationPeriod: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

/// Contains the output for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyOutput: Swift.Sendable {

    public init() { }
}

/// The specified load balancer name already exists for this account.
public struct DuplicateAccessPointNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateLoadBalancerName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified value for the schema is not valid. You can only specify a scheme for load balancers in a VPC.
public struct InvalidSchemeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidScheme" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation is not allowed.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The quota for the number of load balancers has been reached.
public struct TooManyAccessPointsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLoadBalancers" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified protocol or signature version is not supported.
public struct UnsupportedProtocolException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedProtocol" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for CreateLoadBalancer.
public struct CreateLoadBalancerInput: Swift.Sendable {
    /// One or more Availability Zones from the same region as the load balancer. You must specify at least one Availability Zone. You can add more Availability Zones after you create the load balancer using [EnableAvailabilityZonesForLoadBalancer].
    public var availabilityZones: [Swift.String]?
    /// The listeners. For more information, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer. This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The type of a load balancer. Valid only for load balancers in a VPC. By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses. For more information about Internet-facing and Internal load balancers, see [Load Balancer Scheme](https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#load-balancer-scheme) in the Elastic Load Balancing User Guide. Specify internal to create a load balancer with a DNS name that resolves to private IP addresses.
    public var scheme: Swift.String?
    /// The IDs of the security groups to assign to the load balancer.
    public var securityGroups: [Swift.String]?
    /// The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per Availability Zone specified in AvailabilityZones.
    public var subnets: [Swift.String]?
    /// A list of tags to assign to the load balancer. For more information about tagging your load balancer, see [Tag Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/add-remove-tags.html) in the Classic Load Balancers Guide.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init(
        availabilityZones: [Swift.String]? = nil,
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil,
        scheme: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
    }
}

/// Contains the output for CreateLoadBalancer.
public struct CreateLoadBalancerOutput: Swift.Sendable {
    /// The DNS name of the load balancer.
    public var dnsName: Swift.String?

    public init(
        dnsName: Swift.String? = nil
    )
    {
        self.dnsName = dnsName
    }
}

/// A listener already exists for the specified load balancer name and port, but with a different instance port, protocol, or SSL certificate.
public struct DuplicateListenerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateListener" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for CreateLoadBalancerListeners.
public struct CreateLoadBalancerListenersInput: Swift.Sendable {
    /// The listeners.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the parameters for CreateLoadBalancerListener.
public struct CreateLoadBalancerListenersOutput: Swift.Sendable {

    public init() { }
}

/// One or more of the specified policy types do not exist.
public struct PolicyTypeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyTypeNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy attribute.
    public struct PolicyAttribute: Swift.Sendable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }
}

/// Contains the parameters for CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The policy attributes.
    public var policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]?
    /// The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the base policy type. To get the list of policy types, use [DescribeLoadBalancerPolicyTypes].
    /// This member is required.
    public var policyTypeName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]? = nil,
        policyName: Swift.String? = nil,
        policyTypeName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyAttributes = policyAttributes
        self.policyName = policyName
        self.policyTypeName = policyTypeName
    }
}

/// Contains the output of CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyOutput: Swift.Sendable {

    public init() { }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about the CrossZoneLoadBalancing attribute.
    public struct CrossZoneLoadBalancing: Swift.Sendable {
        /// Specifies whether cross-zone load balancing is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }
}

/// Contains the parameters for DeleteLoadBalancer.
public struct DeleteLoadBalancerInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of DeleteLoadBalancer.
public struct DeleteLoadBalancerOutput: Swift.Sendable {

    public init() { }
}

/// Contains the parameters for DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The client port numbers of the listeners.
    /// This member is required.
    public var loadBalancerPorts: [Swift.Int]?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPorts: [Swift.Int]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPorts = loadBalancerPorts
    }
}

/// Contains the output of DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersOutput: Swift.Sendable {

    public init() { }
}

/// Contains the parameters for DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

/// Contains the output of DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyOutput: Swift.Sendable {

    public init() { }
}

/// A request made by Elastic Load Balancing to another service exceeds the maximum request rate permitted for your account.
public struct DependencyThrottleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyThrottle" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The ID of an EC2 instance.
    public struct Instance: Swift.Sendable {
        /// The instance ID.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }
}

/// The specified endpoint is not valid.
public struct InvalidEndPointException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInstance" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerInput: Swift.Sendable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerOutput: Swift.Sendable {
    /// The remaining instances registered with the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The policies enabled for a listener.
    public struct ListenerDescription: Swift.Sendable {
        /// The listener.
        public var listener: ElasticLoadBalancingClientTypes.Listener?
        /// The policies. If there are no policies enabled, the list is empty.
        public var policyNames: [Swift.String]?

        public init(
            listener: ElasticLoadBalancingClientTypes.Listener? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.listener = listener
            self.policyNames = policyNames
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy for duration-based session stickiness.
    public struct LBCookieStickinessPolicy: Swift.Sendable {
        /// The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.
        public var cookieExpirationPeriod: Swift.Int?
        /// The name of the policy. This name must be unique within the set of policies for this load balancer.
        public var policyName: Swift.String?

        public init(
            cookieExpirationPeriod: Swift.Int? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The policies for a load balancer.
    public struct Policies: Swift.Sendable {
        /// The stickiness policies created using [CreateAppCookieStickinessPolicy].
        public var appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]?
        /// The stickiness policies created using [CreateLBCookieStickinessPolicy].
        public var lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public var otherPolicies: [Swift.String]?

        public init(
            appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]? = nil,
            lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]? = nil,
            otherPolicies: [Swift.String]? = nil
        )
        {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a source security group.
    public struct SourceSecurityGroup: Swift.Sendable {
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The owner of the security group.
        public var ownerAlias: Swift.String?

        public init(
            groupName: Swift.String? = nil,
            ownerAlias: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a load balancer.
    public struct LoadBalancerDescription: Swift.Sendable {
        /// The Availability Zones for the load balancer.
        public var availabilityZones: [Swift.String]?
        /// Information about your EC2 instances.
        public var backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]?
        /// The DNS name of the load balancer. For more information, see [Configure a Custom Domain Name](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/using-domain-names-with-elb.html) in the Classic Load Balancers Guide.
        public var canonicalHostedZoneName: Swift.String?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneNameID: Swift.String?
        /// The date and time the load balancer was created.
        public var createdTime: Foundation.Date?
        /// The DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// Information about the health checks conducted on the load balancer.
        public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
        /// The IDs of the instances for the load balancer.
        public var instances: [ElasticLoadBalancingClientTypes.Instance]?
        /// The listeners for the load balancer.
        public var listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]?
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The policies defined for the load balancer.
        public var policies: ElasticLoadBalancingClientTypes.Policies?
        /// The type of load balancer. Valid only for load balancers in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public var scheme: Swift.String?
        /// The security groups for the load balancer. Valid only for load balancers in a VPC.
        public var securityGroups: [Swift.String]?
        /// The security group for the load balancer, which you can use as part of your inbound rules for your registered instances. To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        public var sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup?
        /// The IDs of the subnets for the load balancer.
        public var subnets: [Swift.String]?
        /// The ID of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]? = nil,
            canonicalHostedZoneName: Swift.String? = nil,
            canonicalHostedZoneNameID: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dnsName: Swift.String? = nil,
            healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
            instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
            listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]? = nil,
            loadBalancerName: Swift.String? = nil,
            policies: ElasticLoadBalancingClientTypes.Policies? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }
}

public struct DescribeAccountLimitsInput: Swift.Sendable {
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call.
    public var pageSize: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about an Elastic Load Balancing resource limit for your AWS account.
    public struct Limit: Swift.Sendable {
        /// The maximum value of the limit.
        public var max: Swift.String?
        /// The name of the limit. The possible values are:
        ///
        /// * classic-listeners
        ///
        /// * classic-load-balancers
        ///
        /// * classic-registered-instances
        public var name: Swift.String?

        public init(
            max: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.name = name
        }
    }
}

public struct DescribeAccountLimitsOutput: Swift.Sendable {
    /// Information about the limits.
    public var limits: [ElasticLoadBalancingClientTypes.Limit]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init(
        limits: [ElasticLoadBalancingClientTypes.Limit]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about the state of an EC2 instance.
    public struct InstanceState: Swift.Sendable {
        /// A description of the instance state. This string can contain one or more of the following messages.
        ///
        /// * N/A
        ///
        /// * A transient error occurred. Please try again later.
        ///
        /// * Instance has failed at least the UnhealthyThreshold number of health checks consecutively.
        ///
        /// * Instance has not passed the configured HealthyThreshold number of health checks consecutively.
        ///
        /// * Instance registration is still in progress.
        ///
        /// * Instance is in the EC2 Availability Zone for which LoadBalancer is not configured to route traffic to.
        ///
        /// * Instance is not currently registered with the LoadBalancer.
        ///
        /// * Instance deregistration currently in progress.
        ///
        /// * Disable Availability Zone is currently in progress.
        ///
        /// * Instance is in pending state.
        ///
        /// * Instance is in stopped state.
        ///
        /// * Instance is in terminated state.
        public var description: Swift.String?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// Information about the cause of OutOfService instances. Specifically, whether the cause is Elastic Load Balancing or the instance. Valid values: ELB | Instance | N/A
        public var reasonCode: Swift.String?
        /// The current state of the instance. Valid values: InService | OutOfService | Unknown
        public var state: Swift.String?

        public init(
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            reasonCode: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.description = description
            self.instanceId = instanceId
            self.reasonCode = reasonCode
            self.state = state
        }
    }
}

/// Contains the parameters for DescribeInstanceHealth.
public struct DescribeInstanceHealthInput: Swift.Sendable {
    /// The IDs of the instances.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output for DescribeInstanceHealth.
public struct DescribeInstanceHealthOutput: Swift.Sendable {
    /// Information about the health of the instances.
    public var instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]?

    public init(
        instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]? = nil
    )
    {
        self.instanceStates = instanceStates
    }
}

/// The specified load balancer attribute does not exist.
public struct LoadBalancerAttributeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadBalancerAttributeNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The attributes for a load balancer.
    public struct LoadBalancerAttributes: Swift.Sendable {
        /// If enabled, the load balancer captures detailed information of all requests and delivers the information to the Amazon S3 bucket that you specify. For more information, see [Enable Access Logs](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html) in the Classic Load Balancers Guide.
        public var accessLog: ElasticLoadBalancingClientTypes.AccessLog?
        /// Any additional attributes.
        public var additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]?
        /// If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see [Configure Connection Draining](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html) in the Classic Load Balancers Guide.
        public var connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining?
        /// If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see [Configure Idle Connection Timeout](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html) in the Classic Load Balancers Guide.
        public var connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings?
        /// If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see [Configure Cross-Zone Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html) in the Classic Load Balancers Guide.
        public var crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing?

        public init(
            accessLog: ElasticLoadBalancingClientTypes.AccessLog? = nil,
            additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]? = nil,
            connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining? = nil,
            connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings? = nil,
            crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing? = nil
        )
        {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }
    }
}

/// Contains the output of DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesOutput: Swift.Sendable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
    }
}

/// One or more of the specified policies do not exist.
public struct PolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesInput: Swift.Sendable {
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?
    /// The names of the policies.
    public var policyNames: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy attribute.
    public struct PolicyAttributeDescription: Swift.Sendable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy.
    public struct PolicyDescription: Swift.Sendable {
        /// The policy attributes.
        public var policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]?
        /// The name of the policy.
        public var policyName: Swift.String?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init(
            policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]? = nil,
            policyName: Swift.String? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.policyAttributeDescriptions = policyAttributeDescriptions
            self.policyName = policyName
            self.policyTypeName = policyTypeName
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesOutput: Swift.Sendable {
    /// Information about the policies.
    public var policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]?

    public init(
        policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]? = nil
    )
    {
        self.policyDescriptions = policyDescriptions
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesInput: Swift.Sendable {
    /// The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.
    public var policyTypeNames: [Swift.String]?

    public init(
        policyTypeNames: [Swift.String]? = nil
    )
    {
        self.policyTypeNames = policyTypeNames
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy attribute type.
    public struct PolicyAttributeTypeDescription: Swift.Sendable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The type of the attribute. For example, Boolean or Integer.
        public var attributeType: Swift.String?
        /// The cardinality of the attribute. Valid values:
        ///
        /// * ONE(1) : Single value required
        ///
        /// * ZERO_OR_ONE(0..1) : Up to one value is allowed
        ///
        /// * ZERO_OR_MORE(0..*) : Optional. Multiple values are allowed
        ///
        /// * ONE_OR_MORE(1..*0) : Required. Multiple values are allowed
        public var cardinality: Swift.String?
        /// The default value of the attribute, if applicable.
        public var defaultValue: Swift.String?
        /// A description of the attribute.
        public var description: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeType: Swift.String? = nil,
            cardinality: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
            self.cardinality = cardinality
            self.defaultValue = defaultValue
            self.description = description
        }
    }
}

extension ElasticLoadBalancingClientTypes {

    /// Information about a policy type.
    public struct PolicyTypeDescription: Swift.Sendable {
        /// A description of the policy type.
        public var description: Swift.String?
        /// The description of the policy attributes associated with the policies defined by Elastic Load Balancing.
        public var policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init(
            description: Swift.String? = nil,
            policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.description = description
            self.policyAttributeTypeDescriptions = policyAttributeTypeDescriptions
            self.policyTypeName = policyTypeName
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesOutput: Swift.Sendable {
    /// Information about the policy types.
    public var policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]?

    public init(
        policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]? = nil
    )
    {
        self.policyTypeDescriptions = policyTypeDescriptions
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersInput: Swift.Sendable {
    /// The names of the load balancers.
    public var loadBalancerNames: [Swift.String]?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call (a number from 1 to 400). The default is 400.
    public var pageSize: Swift.Int?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.marker = marker
        self.pageSize = pageSize
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersOutput: Swift.Sendable {
    /// Information about the load balancers.
    public var loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init(
        loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.loadBalancerDescriptions = loadBalancerDescriptions
        self.nextMarker = nextMarker
    }
}

/// Contains the parameters for DescribeTags.
public struct DescribeTagsInput: Swift.Sendable {
    /// The names of the load balancers.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?

    public init(
        loadBalancerNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The tags associated with a load balancer.
    public struct TagDescription: Swift.Sendable {
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The tags.
        public var tags: [ElasticLoadBalancingClientTypes.Tag]?

        public init(
            loadBalancerName: Swift.String? = nil,
            tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
        )
        {
            self.loadBalancerName = loadBalancerName
            self.tags = tags
        }
    }
}

/// Contains the output for DescribeTags.
public struct DescribeTagsOutput: Swift.Sendable {
    /// Information about the tags.
    public var tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]?

    public init(
        tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

/// Contains the parameters for DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

/// Contains the output of DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsOutput: Swift.Sendable {
    /// The IDs of the remaining subnets for the load balancer.
    public var subnets: [Swift.String]?

    public init(
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

/// Contains the parameters for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerInput: Swift.Sendable {
    /// The Availability Zones.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerOutput: Swift.Sendable {
    /// The remaining Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init(
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

/// Contains the parameters for EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerInput: Swift.Sendable {
    /// The Availability Zones. These must be in the same region as the load balancer.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerOutput: Swift.Sendable {
    /// The updated list of Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init(
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

/// Contains the parameters for ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesInput: Swift.Sendable {
    /// The attributes for the load balancer.
    /// This member is required.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesOutput: Swift.Sendable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the parameters for RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerInput: Swift.Sendable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

/// Contains the output of RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerOutput: Swift.Sendable {
    /// The updated list of instances for the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

extension ElasticLoadBalancingClientTypes {

    /// The key of a tag.
    public struct TagKeyOnly: Swift.Sendable {
        /// The name of the key.
        public var key: Swift.String?

        public init(
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }
}

/// Contains the parameters for RemoveTags.
public struct RemoveTagsInput: Swift.Sendable {
    /// The name of the load balancer. You can specify a maximum of one load balancer name.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The list of tag keys to remove.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

/// Contains the output of RemoveTags.
public struct RemoveTagsOutput: Swift.Sendable {

    public init() { }
}

/// The load balancer does not have a listener configured at the specified port.
public struct ListenerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListenerNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains the parameters for SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The port that uses the specified SSL certificate.
    /// This member is required.
    public var loadBalancerPort: Swift.Int?
    /// The Amazon Resource Name (ARN) of the SSL certificate.
    /// This member is required.
    public var sslCertificateId: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int? = 0,
        sslCertificateId: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.sslCertificateId = sslCertificateId
    }
}

/// Contains the output of SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateOutput: Swift.Sendable {

    public init() { }
}

/// Contains the parameters for SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerInput: Swift.Sendable {
    /// The port number associated with the EC2 instance.
    /// This member is required.
    public var instancePort: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        instancePort: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.instancePort = instancePort
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

/// Contains the output of SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerOutput: Swift.Sendable {

    public init() { }
}

/// Contains the parameters for SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerInput: Swift.Sendable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The external port of the load balancer.
    /// This member is required.
    public var loadBalancerPort: Swift.Int?
    /// The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int? = 0,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.policyNames = policyNames
    }
}

/// Contains the output of SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerOutput: Swift.Sendable {

    public init() { }
}

extension AddTagsInput {

    static func urlPathProvider(_ value: AddTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ApplySecurityGroupsToLoadBalancerInput {

    static func urlPathProvider(_ value: ApplySecurityGroupsToLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension AttachLoadBalancerToSubnetsInput {

    static func urlPathProvider(_ value: AttachLoadBalancerToSubnetsInput) -> Swift.String? {
        return "/"
    }
}

extension ConfigureHealthCheckInput {

    static func urlPathProvider(_ value: ConfigureHealthCheckInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppCookieStickinessPolicyInput {

    static func urlPathProvider(_ value: CreateAppCookieStickinessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLBCookieStickinessPolicyInput {

    static func urlPathProvider(_ value: CreateLBCookieStickinessPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLoadBalancerInput {

    static func urlPathProvider(_ value: CreateLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLoadBalancerListenersInput {

    static func urlPathProvider(_ value: CreateLoadBalancerListenersInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLoadBalancerPolicyInput {

    static func urlPathProvider(_ value: CreateLoadBalancerPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLoadBalancerInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLoadBalancerListenersInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerListenersInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLoadBalancerPolicyInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterInstancesFromLoadBalancerInput {

    static func urlPathProvider(_ value: DeregisterInstancesFromLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountLimitsInput {

    static func urlPathProvider(_ value: DescribeAccountLimitsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceHealthInput {

    static func urlPathProvider(_ value: DescribeInstanceHealthInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoadBalancerAttributesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoadBalancerPoliciesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoadBalancerPolicyTypesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerPolicyTypesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoadBalancersInput {

    static func urlPathProvider(_ value: DescribeLoadBalancersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTagsInput {

    static func urlPathProvider(_ value: DescribeTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DetachLoadBalancerFromSubnetsInput {

    static func urlPathProvider(_ value: DetachLoadBalancerFromSubnetsInput) -> Swift.String? {
        return "/"
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput {

    static func urlPathProvider(_ value: DisableAvailabilityZonesForLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension EnableAvailabilityZonesForLoadBalancerInput {

    static func urlPathProvider(_ value: EnableAvailabilityZonesForLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyLoadBalancerAttributesInput {

    static func urlPathProvider(_ value: ModifyLoadBalancerAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterInstancesWithLoadBalancerInput {

    static func urlPathProvider(_ value: RegisterInstancesWithLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveTagsInput {

    static func urlPathProvider(_ value: RemoveTagsInput) -> Swift.String? {
        return "/"
    }
}

extension SetLoadBalancerListenerSSLCertificateInput {

    static func urlPathProvider(_ value: SetLoadBalancerListenerSSLCertificateInput) -> Swift.String? {
        return "/"
    }
}

extension SetLoadBalancerPoliciesForBackendServerInput {

    static func urlPathProvider(_ value: SetLoadBalancerPoliciesForBackendServerInput) -> Swift.String? {
        return "/"
    }
}

extension SetLoadBalancerPoliciesOfListenerInput {

    static func urlPathProvider(_ value: SetLoadBalancerPoliciesOfListenerInput) -> Swift.String? {
        return "/"
    }
}

extension AddTagsInput {

    static func write(value: AddTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerNames"].writeList(value.loadBalancerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ElasticLoadBalancingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("AddTags")
        try writer["Version"].write("2012-06-01")
    }
}

extension ApplySecurityGroupsToLoadBalancerInput {

    static func write(value: ApplySecurityGroupsToLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("ApplySecurityGroupsToLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension AttachLoadBalancerToSubnetsInput {

    static func write(value: AttachLoadBalancerToSubnetsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("AttachLoadBalancerToSubnets")
        try writer["Version"].write("2012-06-01")
    }
}

extension ConfigureHealthCheckInput {

    static func write(value: ConfigureHealthCheckInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["HealthCheck"].write(value.healthCheck, with: ElasticLoadBalancingClientTypes.HealthCheck.write(value:to:))
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("ConfigureHealthCheck")
        try writer["Version"].write("2012-06-01")
    }
}

extension CreateAppCookieStickinessPolicyInput {

    static func write(value: CreateAppCookieStickinessPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CookieName"].write(value.cookieName)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("CreateAppCookieStickinessPolicy")
        try writer["Version"].write("2012-06-01")
    }
}

extension CreateLBCookieStickinessPolicyInput {

    static func write(value: CreateLBCookieStickinessPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["CookieExpirationPeriod"].write(value.cookieExpirationPeriod)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("CreateLBCookieStickinessPolicy")
        try writer["Version"].write("2012-06-01")
    }
}

extension CreateLoadBalancerInput {

    static func write(value: CreateLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Listeners"].writeList(value.listeners, memberWritingClosure: ElasticLoadBalancingClientTypes.Listener.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Scheme"].write(value.scheme)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ElasticLoadBalancingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreateLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension CreateLoadBalancerListenersInput {

    static func write(value: CreateLoadBalancerListenersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Listeners"].writeList(value.listeners, memberWritingClosure: ElasticLoadBalancingClientTypes.Listener.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("CreateLoadBalancerListeners")
        try writer["Version"].write("2012-06-01")
    }
}

extension CreateLoadBalancerPolicyInput {

    static func write(value: CreateLoadBalancerPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyAttributes"].writeList(value.policyAttributes, memberWritingClosure: ElasticLoadBalancingClientTypes.PolicyAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyTypeName"].write(value.policyTypeName)
        try writer["Action"].write("CreateLoadBalancerPolicy")
        try writer["Version"].write("2012-06-01")
    }
}

extension DeleteLoadBalancerInput {

    static func write(value: DeleteLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("DeleteLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension DeleteLoadBalancerListenersInput {

    static func write(value: DeleteLoadBalancerListenersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["LoadBalancerPorts"].writeList(value.loadBalancerPorts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DeleteLoadBalancerListeners")
        try writer["Version"].write("2012-06-01")
    }
}

extension DeleteLoadBalancerPolicyInput {

    static func write(value: DeleteLoadBalancerPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyName"].write(value.policyName)
        try writer["Action"].write("DeleteLoadBalancerPolicy")
        try writer["Version"].write("2012-06-01")
    }
}

extension DeregisterInstancesFromLoadBalancerInput {

    static func write(value: DeregisterInstancesFromLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Instances"].writeList(value.instances, memberWritingClosure: ElasticLoadBalancingClientTypes.Instance.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("DeregisterInstancesFromLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeAccountLimitsInput {

    static func write(value: DescribeAccountLimitsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Marker"].write(value.marker)
        try writer["PageSize"].write(value.pageSize)
        try writer["Action"].write("DescribeAccountLimits")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeInstanceHealthInput {

    static func write(value: DescribeInstanceHealthInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Instances"].writeList(value.instances, memberWritingClosure: ElasticLoadBalancingClientTypes.Instance.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("DescribeInstanceHealth")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeLoadBalancerAttributesInput {

    static func write(value: DescribeLoadBalancerAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("DescribeLoadBalancerAttributes")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeLoadBalancerPoliciesInput {

    static func write(value: DescribeLoadBalancerPoliciesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyNames"].writeList(value.policyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeLoadBalancerPolicies")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeLoadBalancerPolicyTypesInput {

    static func write(value: DescribeLoadBalancerPolicyTypesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PolicyTypeNames"].writeList(value.policyTypeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeLoadBalancerPolicyTypes")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeLoadBalancersInput {

    static func write(value: DescribeLoadBalancersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerNames"].writeList(value.loadBalancerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Marker"].write(value.marker)
        try writer["PageSize"].write(value.pageSize)
        try writer["Action"].write("DescribeLoadBalancers")
        try writer["Version"].write("2012-06-01")
    }
}

extension DescribeTagsInput {

    static func write(value: DescribeTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerNames"].writeList(value.loadBalancerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DescribeTags")
        try writer["Version"].write("2012-06-01")
    }
}

extension DetachLoadBalancerFromSubnetsInput {

    static func write(value: DetachLoadBalancerFromSubnetsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("DetachLoadBalancerFromSubnets")
        try writer["Version"].write("2012-06-01")
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput {

    static func write(value: DisableAvailabilityZonesForLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("DisableAvailabilityZonesForLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension EnableAvailabilityZonesForLoadBalancerInput {

    static func write(value: EnableAvailabilityZonesForLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("EnableAvailabilityZonesForLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension ModifyLoadBalancerAttributesInput {

    static func write(value: ModifyLoadBalancerAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerAttributes"].write(value.loadBalancerAttributes, with: ElasticLoadBalancingClientTypes.LoadBalancerAttributes.write(value:to:))
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("ModifyLoadBalancerAttributes")
        try writer["Version"].write("2012-06-01")
    }
}

extension RegisterInstancesWithLoadBalancerInput {

    static func write(value: RegisterInstancesWithLoadBalancerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Instances"].writeList(value.instances, memberWritingClosure: ElasticLoadBalancingClientTypes.Instance.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Action"].write("RegisterInstancesWithLoadBalancer")
        try writer["Version"].write("2012-06-01")
    }
}

extension RemoveTagsInput {

    static func write(value: RemoveTagsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerNames"].writeList(value.loadBalancerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ElasticLoadBalancingClientTypes.TagKeyOnly.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("RemoveTags")
        try writer["Version"].write("2012-06-01")
    }
}

extension SetLoadBalancerListenerSSLCertificateInput {

    static func write(value: SetLoadBalancerListenerSSLCertificateInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["LoadBalancerPort"].write(value.loadBalancerPort)
        try writer["SSLCertificateId"].write(value.sslCertificateId)
        try writer["Action"].write("SetLoadBalancerListenerSSLCertificate")
        try writer["Version"].write("2012-06-01")
    }
}

extension SetLoadBalancerPoliciesForBackendServerInput {

    static func write(value: SetLoadBalancerPoliciesForBackendServerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstancePort"].write(value.instancePort)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["PolicyNames"].writeList(value.policyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("SetLoadBalancerPoliciesForBackendServer")
        try writer["Version"].write("2012-06-01")
    }
}

extension SetLoadBalancerPoliciesOfListenerInput {

    static func write(value: SetLoadBalancerPoliciesOfListenerInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["LoadBalancerPort"].write(value.loadBalancerPort)
        try writer["PolicyNames"].writeList(value.policyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("SetLoadBalancerPoliciesOfListener")
        try writer["Version"].write("2012-06-01")
    }
}

extension AddTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsOutput {
        return AddTagsOutput()
    }
}

extension ApplySecurityGroupsToLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApplySecurityGroupsToLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ApplySecurityGroupsToLoadBalancerResult"]
        var value = ApplySecurityGroupsToLoadBalancerOutput()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AttachLoadBalancerToSubnetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachLoadBalancerToSubnetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["AttachLoadBalancerToSubnetsResult"]
        var value = AttachLoadBalancerToSubnetsOutput()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigureHealthCheckOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfigureHealthCheckOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ConfigureHealthCheckResult"]
        var value = ConfigureHealthCheckOutput()
        value.healthCheck = try reader["HealthCheck"].readIfPresent(with: ElasticLoadBalancingClientTypes.HealthCheck.read(from:))
        return value
    }
}

extension CreateAppCookieStickinessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppCookieStickinessPolicyOutput {
        return CreateAppCookieStickinessPolicyOutput()
    }
}

extension CreateLBCookieStickinessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLBCookieStickinessPolicyOutput {
        return CreateLBCookieStickinessPolicyOutput()
    }
}

extension CreateLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateLoadBalancerResult"]
        var value = CreateLoadBalancerOutput()
        value.dnsName = try reader["DNSName"].readIfPresent()
        return value
    }
}

extension CreateLoadBalancerListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoadBalancerListenersOutput {
        return CreateLoadBalancerListenersOutput()
    }
}

extension CreateLoadBalancerPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoadBalancerPolicyOutput {
        return CreateLoadBalancerPolicyOutput()
    }
}

extension DeleteLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoadBalancerOutput {
        return DeleteLoadBalancerOutput()
    }
}

extension DeleteLoadBalancerListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoadBalancerListenersOutput {
        return DeleteLoadBalancerListenersOutput()
    }
}

extension DeleteLoadBalancerPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoadBalancerPolicyOutput {
        return DeleteLoadBalancerPolicyOutput()
    }
}

extension DeregisterInstancesFromLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterInstancesFromLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DeregisterInstancesFromLoadBalancerResult"]
        var value = DeregisterInstancesFromLoadBalancerOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeAccountLimitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountLimitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeAccountLimitsResult"]
        var value = DescribeAccountLimitsOutput()
        value.limits = try reader["Limits"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Limit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension DescribeInstanceHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeInstanceHealthResult"]
        var value = DescribeInstanceHealthOutput()
        value.instanceStates = try reader["InstanceStates"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.InstanceState.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLoadBalancerAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoadBalancerAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeLoadBalancerAttributesResult"]
        var value = DescribeLoadBalancerAttributesOutput()
        value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readIfPresent(with: ElasticLoadBalancingClientTypes.LoadBalancerAttributes.read(from:))
        return value
    }
}

extension DescribeLoadBalancerPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoadBalancerPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeLoadBalancerPoliciesResult"]
        var value = DescribeLoadBalancerPoliciesOutput()
        value.policyDescriptions = try reader["PolicyDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLoadBalancerPolicyTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoadBalancerPolicyTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeLoadBalancerPolicyTypesResult"]
        var value = DescribeLoadBalancerPolicyTypesOutput()
        value.policyTypeDescriptions = try reader["PolicyTypeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyTypeDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLoadBalancersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoadBalancersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeLoadBalancersResult"]
        var value = DescribeLoadBalancersOutput()
        value.loadBalancerDescriptions = try reader["LoadBalancerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.LoadBalancerDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextMarker = try reader["NextMarker"].readIfPresent()
        return value
    }
}

extension DescribeTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DescribeTagsResult"]
        var value = DescribeTagsOutput()
        value.tagDescriptions = try reader["TagDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.TagDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DetachLoadBalancerFromSubnetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachLoadBalancerFromSubnetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DetachLoadBalancerFromSubnetsResult"]
        var value = DetachLoadBalancerFromSubnetsOutput()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableAvailabilityZonesForLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["DisableAvailabilityZonesForLoadBalancerResult"]
        var value = DisableAvailabilityZonesForLoadBalancerOutput()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableAvailabilityZonesForLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["EnableAvailabilityZonesForLoadBalancerResult"]
        var value = EnableAvailabilityZonesForLoadBalancerOutput()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ModifyLoadBalancerAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyLoadBalancerAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ModifyLoadBalancerAttributesResult"]
        var value = ModifyLoadBalancerAttributesOutput()
        value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readIfPresent(with: ElasticLoadBalancingClientTypes.LoadBalancerAttributes.read(from:))
        value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
        return value
    }
}

extension RegisterInstancesWithLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterInstancesWithLoadBalancerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["RegisterInstancesWithLoadBalancerResult"]
        var value = RegisterInstancesWithLoadBalancerOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RemoveTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsOutput {
        return RemoveTagsOutput()
    }
}

extension SetLoadBalancerListenerSSLCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLoadBalancerListenerSSLCertificateOutput {
        return SetLoadBalancerListenerSSLCertificateOutput()
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLoadBalancerPoliciesForBackendServerOutput {
        return SetLoadBalancerPoliciesForBackendServerOutput()
    }
}

extension SetLoadBalancerPoliciesOfListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLoadBalancerPoliciesOfListenerOutput {
        return SetLoadBalancerPoliciesOfListenerOutput()
    }
}

enum AddTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "DuplicateTagKeys": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTags": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ApplySecurityGroupsToLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "InvalidSecurityGroup": return try InvalidSecurityGroupException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachLoadBalancerToSubnetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnetException.makeError(baseError: baseError)
            case "SubnetNotFound": return try SubnetNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfigureHealthCheckOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppCookieStickinessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "DuplicatePolicyName": return try DuplicatePolicyNameException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "TooManyPolicies": return try TooManyPoliciesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLBCookieStickinessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "DuplicatePolicyName": return try DuplicatePolicyNameException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "TooManyPolicies": return try TooManyPoliciesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CertificateNotFound": return try CertificateNotFoundException.makeError(baseError: baseError)
            case "DuplicateLoadBalancerName": return try DuplicateAccessPointNameException.makeError(baseError: baseError)
            case "DuplicateTagKeys": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "InvalidScheme": return try InvalidSchemeException.makeError(baseError: baseError)
            case "InvalidSecurityGroup": return try InvalidSecurityGroupException.makeError(baseError: baseError)
            case "InvalidSubnet": return try InvalidSubnetException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "SubnetNotFound": return try SubnetNotFoundException.makeError(baseError: baseError)
            case "TooManyLoadBalancers": return try TooManyAccessPointsException.makeError(baseError: baseError)
            case "TooManyTags": return try TooManyTagsException.makeError(baseError: baseError)
            case "UnsupportedProtocol": return try UnsupportedProtocolException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoadBalancerListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "CertificateNotFound": return try CertificateNotFoundException.makeError(baseError: baseError)
            case "DuplicateListener": return try DuplicateListenerException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "UnsupportedProtocol": return try UnsupportedProtocolException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoadBalancerPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "DuplicatePolicyName": return try DuplicatePolicyNameException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "PolicyTypeNotFound": return try PolicyTypeNotFoundException.makeError(baseError: baseError)
            case "TooManyPolicies": return try TooManyPoliciesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoadBalancerListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoadBalancerPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterInstancesFromLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidInstance": return try InvalidEndPointException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountLimitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidInstance": return try InvalidEndPointException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoadBalancerAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "LoadBalancerAttributeNotFound": return try LoadBalancerAttributeNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoadBalancerPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "PolicyNotFound": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoadBalancerPolicyTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "PolicyTypeNotFound": return try PolicyTypeNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoadBalancersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "DependencyThrottle": return try DependencyThrottleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachLoadBalancerFromSubnetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableAvailabilityZonesForLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableAvailabilityZonesForLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyLoadBalancerAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "LoadBalancerAttributeNotFound": return try LoadBalancerAttributeNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterInstancesWithLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidInstance": return try InvalidEndPointException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLoadBalancerListenerSSLCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "CertificateNotFound": return try CertificateNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "ListenerNotFound": return try ListenerNotFoundException.makeError(baseError: baseError)
            case "UnsupportedProtocol": return try UnsupportedProtocolException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLoadBalancerPoliciesForBackendServerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "PolicyNotFound": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLoadBalancerPoliciesOfListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LoadBalancerNotFound": return try AccessPointNotFoundException.makeError(baseError: baseError)
            case "InvalidConfigurationRequest": return try InvalidConfigurationRequestException.makeError(baseError: baseError)
            case "ListenerNotFound": return try ListenerNotFoundException.makeError(baseError: baseError)
            case "PolicyNotFound": return try PolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessPointNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> AccessPointNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AccessPointNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateTagKeysException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicateTagKeysException {
        let reader = baseError.errorBodyReader
        var value = DuplicateTagKeysException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConfigurationRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidConfigurationRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidConfigurationRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSecurityGroupException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidSecurityGroupException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecurityGroupException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubnetNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> SubnetNotFoundException {
        let reader = baseError.errorBodyReader
        var value = SubnetNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSubnetException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidSubnetException {
        let reader = baseError.errorBodyReader
        var value = InvalidSubnetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyPoliciesException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TooManyPoliciesException {
        let reader = baseError.errorBodyReader
        var value = TooManyPoliciesException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicatePolicyNameException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicatePolicyNameException {
        let reader = baseError.errorBodyReader
        var value = DuplicatePolicyNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSchemeException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidSchemeException {
        let reader = baseError.errorBodyReader
        var value = InvalidSchemeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyAccessPointsException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TooManyAccessPointsException {
        let reader = baseError.errorBodyReader
        var value = TooManyAccessPointsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> OperationNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotPermittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CertificateNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> CertificateNotFoundException {
        let reader = baseError.errorBodyReader
        var value = CertificateNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedProtocolException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> UnsupportedProtocolException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedProtocolException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateAccessPointNameException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicateAccessPointNameException {
        let reader = baseError.errorBodyReader
        var value = DuplicateAccessPointNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateListenerException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DuplicateListenerException {
        let reader = baseError.errorBodyReader
        var value = DuplicateListenerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyTypeNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PolicyTypeNotFoundException {
        let reader = baseError.errorBodyReader
        var value = PolicyTypeNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEndPointException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidEndPointException {
        let reader = baseError.errorBodyReader
        var value = InvalidEndPointException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LoadBalancerAttributeNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> LoadBalancerAttributeNotFoundException {
        let reader = baseError.errorBodyReader
        var value = LoadBalancerAttributeNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PolicyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PolicyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = PolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyThrottleException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> DependencyThrottleException {
        let reader = baseError.errorBodyReader
        var value = DependencyThrottleException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ListenerNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ListenerNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ListenerNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ElasticLoadBalancingClientTypes.HealthCheck {

    static func write(value: ElasticLoadBalancingClientTypes.HealthCheck?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["HealthyThreshold"].write(value.healthyThreshold)
        try writer["Interval"].write(value.interval)
        try writer["Target"].write(value.target)
        try writer["Timeout"].write(value.timeout)
        try writer["UnhealthyThreshold"].write(value.unhealthyThreshold)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.HealthCheck {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.HealthCheck()
        value.target = try reader["Target"].readIfPresent() ?? ""
        value.interval = try reader["Interval"].readIfPresent() ?? 0
        value.timeout = try reader["Timeout"].readIfPresent() ?? 0
        value.unhealthyThreshold = try reader["UnhealthyThreshold"].readIfPresent() ?? 0
        value.healthyThreshold = try reader["HealthyThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension ElasticLoadBalancingClientTypes.Instance {

    static func write(value: ElasticLoadBalancingClientTypes.Instance?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.Instance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.Limit {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.Limit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.Limit()
        value.name = try reader["Name"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.InstanceState {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.InstanceState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.InstanceState()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.LoadBalancerAttributes {

    static func write(value: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AccessLog"].write(value.accessLog, with: ElasticLoadBalancingClientTypes.AccessLog.write(value:to:))
        try writer["AdditionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: ElasticLoadBalancingClientTypes.AdditionalAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConnectionDraining"].write(value.connectionDraining, with: ElasticLoadBalancingClientTypes.ConnectionDraining.write(value:to:))
        try writer["ConnectionSettings"].write(value.connectionSettings, with: ElasticLoadBalancingClientTypes.ConnectionSettings.write(value:to:))
        try writer["CrossZoneLoadBalancing"].write(value.crossZoneLoadBalancing, with: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing.write(value:to:))
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.LoadBalancerAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.LoadBalancerAttributes()
        value.crossZoneLoadBalancing = try reader["CrossZoneLoadBalancing"].readIfPresent(with: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing.read(from:))
        value.accessLog = try reader["AccessLog"].readIfPresent(with: ElasticLoadBalancingClientTypes.AccessLog.read(from:))
        value.connectionDraining = try reader["ConnectionDraining"].readIfPresent(with: ElasticLoadBalancingClientTypes.ConnectionDraining.read(from:))
        value.connectionSettings = try reader["ConnectionSettings"].readIfPresent(with: ElasticLoadBalancingClientTypes.ConnectionSettings.read(from:))
        value.additionalAttributes = try reader["AdditionalAttributes"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.AdditionalAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.AdditionalAttribute {

    static func write(value: ElasticLoadBalancingClientTypes.AdditionalAttribute?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.AdditionalAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.AdditionalAttribute()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.ConnectionSettings {

    static func write(value: ElasticLoadBalancingClientTypes.ConnectionSettings?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["IdleTimeout"].write(value.idleTimeout)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.ConnectionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.ConnectionSettings()
        value.idleTimeout = try reader["IdleTimeout"].readIfPresent() ?? 0
        return value
    }
}

extension ElasticLoadBalancingClientTypes.ConnectionDraining {

    static func write(value: ElasticLoadBalancingClientTypes.ConnectionDraining?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.ConnectionDraining {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.ConnectionDraining()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.AccessLog {

    static func write(value: ElasticLoadBalancingClientTypes.AccessLog?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EmitInterval"].write(value.emitInterval)
        try writer["Enabled"].write(value.enabled)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3BucketPrefix"].write(value.s3BucketPrefix)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.AccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.AccessLog()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.emitInterval = try reader["EmitInterval"].readIfPresent()
        value.s3BucketPrefix = try reader["S3BucketPrefix"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing {

    static func write(value: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension ElasticLoadBalancingClientTypes.PolicyDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.PolicyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.PolicyDescription()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyTypeName = try reader["PolicyTypeName"].readIfPresent()
        value.policyAttributeDescriptions = try reader["PolicyAttributeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyAttributeDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.PolicyAttributeDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.PolicyAttributeDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.PolicyAttributeDescription()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.attributeValue = try reader["AttributeValue"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.PolicyTypeDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.PolicyTypeDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.PolicyTypeDescription()
        value.policyTypeName = try reader["PolicyTypeName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.policyAttributeTypeDescriptions = try reader["PolicyAttributeTypeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.attributeType = try reader["AttributeType"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.cardinality = try reader["Cardinality"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.LoadBalancerDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.LoadBalancerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.LoadBalancerDescription()
        value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
        value.dnsName = try reader["DNSName"].readIfPresent()
        value.canonicalHostedZoneName = try reader["CanonicalHostedZoneName"].readIfPresent()
        value.canonicalHostedZoneNameID = try reader["CanonicalHostedZoneNameID"].readIfPresent()
        value.listenerDescriptions = try reader["ListenerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.ListenerDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.policies = try reader["Policies"].readIfPresent(with: ElasticLoadBalancingClientTypes.Policies.read(from:))
        value.backendServerDescriptions = try reader["BackendServerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.BackendServerDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VPCId"].readIfPresent()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.healthCheck = try reader["HealthCheck"].readIfPresent(with: ElasticLoadBalancingClientTypes.HealthCheck.read(from:))
        value.sourceSecurityGroup = try reader["SourceSecurityGroup"].readIfPresent(with: ElasticLoadBalancingClientTypes.SourceSecurityGroup.read(from:))
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.scheme = try reader["Scheme"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.SourceSecurityGroup {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.SourceSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.SourceSecurityGroup()
        value.ownerAlias = try reader["OwnerAlias"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.BackendServerDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.BackendServerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.BackendServerDescription()
        value.instancePort = try reader["InstancePort"].readIfPresent()
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.Policies {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.Policies {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.Policies()
        value.appCookieStickinessPolicies = try reader["AppCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lbCookieStickinessPolicies = try reader["LBCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.otherPolicies = try reader["OtherPolicies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.cookieExpirationPeriod = try reader["CookieExpirationPeriod"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.cookieName = try reader["CookieName"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.ListenerDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.ListenerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.ListenerDescription()
        value.listener = try reader["Listener"].readIfPresent(with: ElasticLoadBalancingClientTypes.Listener.read(from:))
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.Listener {

    static func write(value: ElasticLoadBalancingClientTypes.Listener?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["InstancePort"].write(value.instancePort)
        try writer["InstanceProtocol"].write(value.instanceProtocol)
        try writer["LoadBalancerPort"].write(value.loadBalancerPort)
        try writer["Protocol"].write(value.`protocol`)
        try writer["SSLCertificateId"].write(value.sslCertificateId)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.Listener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.Listener()
        value.`protocol` = try reader["Protocol"].readIfPresent() ?? ""
        value.loadBalancerPort = try reader["LoadBalancerPort"].readIfPresent() ?? 0
        value.instanceProtocol = try reader["InstanceProtocol"].readIfPresent()
        value.instancePort = try reader["InstancePort"].readIfPresent() ?? 0
        value.sslCertificateId = try reader["SSLCertificateId"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.TagDescription {

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.TagDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.TagDescription()
        value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ElasticLoadBalancingClientTypes.Tag {

    static func write(value: ElasticLoadBalancingClientTypes.Tag?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> ElasticLoadBalancingClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ElasticLoadBalancingClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ElasticLoadBalancingClientTypes.PolicyAttribute {

    static func write(value: ElasticLoadBalancingClientTypes.PolicyAttribute?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
    }
}

extension ElasticLoadBalancingClientTypes.TagKeyOnly {

    static func write(value: ElasticLoadBalancingClientTypes.TagKeyOnly?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
    }
}

public enum ElasticLoadBalancingClientTypes {}
