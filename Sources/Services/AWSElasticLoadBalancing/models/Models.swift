// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ElasticLoadBalancingClientTypes.AccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emitInterval = "EmitInterval"
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case s3BucketPrefix = "S3BucketPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let emitInterval = emitInterval {
            try container.encode(emitInterval, forKey: ClientRuntime.Key("EmitInterval"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3BucketPrefix = s3BucketPrefix {
            try container.encode(s3BucketPrefix, forKey: ClientRuntime.Key("S3BucketPrefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let emitIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .emitInterval)
        emitInterval = emitIntervalDecoded
        let s3BucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketPrefix)
        s3BucketPrefix = s3BucketPrefixDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the AccessLog attribute.
    public struct AccessLog: Swift.Equatable {
        /// The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes. Default: 60 minutes
        public var emitInterval: Swift.Int?
        /// Specifies whether access logs are enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The name of the Amazon S3 bucket where the access logs are stored.
        public var s3BucketName: Swift.String?
        /// The logical hierarchy you created for your Amazon S3 bucket, for example my-bucket-prefix/prod. If the prefix is not provided, the log is placed at the root level of the bucket.
        public var s3BucketPrefix: Swift.String?

        public init (
            emitInterval: Swift.Int? = nil,
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            s3BucketPrefix: Swift.String? = nil
        )
        {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }
    }

}

extension AccessPointNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<AccessPointNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified load balancer does not exist.
public struct AccessPointNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessPointNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessPointNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("AddTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for AddTags.
public struct AddTagsInput: Swift.Equatable {
    /// The name of the load balancer. You can specify one load balancer only.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The tags.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init (
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let loadBalancerNames: [Swift.String]?
    let tags: [ElasticLoadBalancingClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerNamesBuffer:[Swift.String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElasticLoadBalancingClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElasticLoadBalancingClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension AddTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeys" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of AddTags.
public struct AddTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension ElasticLoadBalancingClientTypes.AdditionalAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about additional load balancer attributes.
    public struct AdditionalAttribute: Swift.Equatable {
        /// The name of the attribute. The following attribute is supported.
        ///
        /// * elb.http.desyncmitigationmode - Determines how the load balancer handles requests that might pose a security risk to your application. The possible values are monitor, defensive, and strictest. The default is defensive.
        public var key: Swift.String?
        /// This value of the attribute.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieName = "CookieName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: ClientRuntime.Key("CookieName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cookieName)
        cookieName = cookieNameDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy for application-controlled session stickiness.
    public struct AppCookieStickinessPolicy: Swift.Equatable {
        /// The name of the application cookie used for stickiness.
        public var cookieName: Swift.String?
        /// The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
        public var policyName: Swift.String?

        public init (
            cookieName: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieName = cookieName
            self.policyName = policyName
        }
    }

}

extension ApplySecurityGroupsToLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("ApplySecurityGroupsToLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ApplySecurityGroupsToLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.
    /// This member is required.
    public var securityGroups: [Swift.String]?

    public init (
        loadBalancerName: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.securityGroups = securityGroups
    }
}

struct ApplySecurityGroupsToLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let securityGroups: [Swift.String]?
}

extension ApplySecurityGroupsToLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
    }
}

extension ApplySecurityGroupsToLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplySecurityGroupsToLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroup" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ApplySecurityGroupsToLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplySecurityGroupsToLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ApplySecurityGroupsToLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityGroups = output.securityGroups
        } else {
            self.securityGroups = nil
        }
    }
}

/// Contains the output of ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerOutputResponse: Swift.Equatable {
    /// The IDs of the security groups associated with the load balancer.
    public var securityGroups: [Swift.String]?

    public init (
        securityGroups: [Swift.String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

struct ApplySecurityGroupsToLoadBalancerOutputResponseBody: Swift.Equatable {
    let securityGroups: [Swift.String]?
}

extension ApplySecurityGroupsToLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ApplySecurityGroupsToLoadBalancerResult"))
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
    }
}

extension AttachLoadBalancerToSubnetsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("AttachLoadBalancerToSubnets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachLoadBalancerToSubnetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for AttachLoaBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets to add. You can add only one subnet per Availability Zone.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init (
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

struct AttachLoadBalancerToSubnetsInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let subnets: [Swift.String]?
}

extension AttachLoadBalancerToSubnetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case subnets = "Subnets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

extension AttachLoadBalancerToSubnetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AttachLoadBalancerToSubnetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFound" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AttachLoadBalancerToSubnetsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case subnetNotFoundException(SubnetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AttachLoadBalancerToSubnetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AttachLoadBalancerToSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnets = output.subnets
        } else {
            self.subnets = nil
        }
    }
}

/// Contains the output of AttachLoadBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsOutputResponse: Swift.Equatable {
    /// The IDs of the subnets attached to the load balancer.
    public var subnets: [Swift.String]?

    public init (
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

struct AttachLoadBalancerToSubnetsOutputResponseBody: Swift.Equatable {
    let subnets: [Swift.String]?
}

extension AttachLoadBalancerToSubnetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnets = "Subnets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AttachLoadBalancerToSubnetsResult"))
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes.BackendServerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if instancePort != 0 {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the configuration of an EC2 instance.
    public struct BackendServerDescription: Swift.Equatable {
        /// The port on which the EC2 instance is listening.
        public var instancePort: Swift.Int
        /// The names of the policies enabled for the EC2 instance.
        public var policyNames: [Swift.String]?

        public init (
            instancePort: Swift.Int = 0,
            policyNames: [Swift.String]? = nil
        )
        {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }
    }

}

extension CertificateNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<CertificateNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified ARN does not refer to a valid SSL certificate in AWS Identity and Access Management (IAM) or AWS Certificate Manager (ACM). Note that if you recently uploaded the certificate to IAM, this error might indicate that the certificate is not fully available yet.
public struct CertificateNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CertificateNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigureHealthCheckInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: ClientRuntime.Key("HealthCheck"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("ConfigureHealthCheck", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ConfigureHealthCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ConfigureHealthCheck.
public struct ConfigureHealthCheckInput: Swift.Equatable {
    /// The configuration information.
    /// This member is required.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.loadBalancerName = loadBalancerName
    }
}

struct ConfigureHealthCheckInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
}

extension ConfigureHealthCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck = "HealthCheck"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension ConfigureHealthCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ConfigureHealthCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfigureHealthCheckOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureHealthCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfigureHealthCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.healthCheck = output.healthCheck
        } else {
            self.healthCheck = nil
        }
    }
}

/// Contains the output of ConfigureHealthCheck.
public struct ConfigureHealthCheckOutputResponse: Swift.Equatable {
    /// The updated health check.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?

    public init (
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil
    )
    {
        self.healthCheck = healthCheck
    }
}

struct ConfigureHealthCheckOutputResponseBody: Swift.Equatable {
    let healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
}

extension ConfigureHealthCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck = "HealthCheck"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ConfigureHealthCheckResult"))
        let healthCheckDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension ElasticLoadBalancingClientTypes.ConnectionDraining: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let timeout = timeout {
            try container.encode(timeout, forKey: ClientRuntime.Key("Timeout"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the ConnectionDraining attribute.
    public struct ConnectionDraining: Swift.Equatable {
        /// Specifies whether connection draining is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public var timeout: Swift.Int?

        public init (
            enabled: Swift.Bool = false,
            timeout: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.timeout = timeout
        }
    }

}

extension ElasticLoadBalancingClientTypes.ConnectionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idleTimeout = "IdleTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let idleTimeout = idleTimeout {
            try container.encode(idleTimeout, forKey: ClientRuntime.Key("IdleTimeout"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeout)
        idleTimeout = idleTimeoutDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the ConnectionSettings attribute.
    public struct ConnectionSettings: Swift.Equatable {
        /// The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.
        /// This member is required.
        public var idleTimeout: Swift.Int?

        public init (
            idleTimeout: Swift.Int? = nil
        )
        {
            self.idleTimeout = idleTimeout
        }
    }

}

extension CreateAppCookieStickinessPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: ClientRuntime.Key("CookieName"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("CreateAppCookieStickinessPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAppCookieStickinessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyInput: Swift.Equatable {
    /// The name of the application cookie used for stickiness.
    /// This member is required.
    public var cookieName: Swift.String?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        cookieName: Swift.String? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieName = cookieName
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

struct CreateAppCookieStickinessPolicyInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let policyName: Swift.String?
    let cookieName: Swift.String?
}

extension CreateAppCookieStickinessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieName = "CookieName"
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cookieName)
        cookieName = cookieNameDecoded
    }
}

extension CreateAppCookieStickinessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateAppCookieStickinessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyName" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPolicies" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAppCookieStickinessPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppCookieStickinessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateLBCookieStickinessPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: ClientRuntime.Key("CookieExpirationPeriod"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("CreateLBCookieStickinessPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLBCookieStickinessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyInput: Swift.Equatable {
    /// The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.
    public var cookieExpirationPeriod: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        cookieExpirationPeriod: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

struct CreateLBCookieStickinessPolicyInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let policyName: Swift.String?
    let cookieExpirationPeriod: Swift.Int?
}

extension CreateLBCookieStickinessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieExpirationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cookieExpirationPeriod)
        cookieExpirationPeriod = cookieExpirationPeriodDecoded
    }
}

extension CreateLBCookieStickinessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLBCookieStickinessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyName" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPolicies" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLBCookieStickinessPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLBCookieStickinessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let listeners = listeners {
            if !listeners.isEmpty {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                for (index0, listener0) in listeners.enumerated() {
                    try listenersContainer.encode(listener0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                try listenersContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancer.
public struct CreateLoadBalancerInput: Swift.Equatable {
    /// One or more Availability Zones from the same region as the load balancer. You must specify at least one Availability Zone. You can add more Availability Zones after you create the load balancer using [EnableAvailabilityZonesForLoadBalancer].
    public var availabilityZones: [Swift.String]?
    /// The listeners. For more information, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer. This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The type of a load balancer. Valid only for load balancers in a VPC. By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses. For more information about Internet-facing and Internal load balancers, see [Load Balancer Scheme](https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#load-balancer-scheme) in the Elastic Load Balancing User Guide. Specify internal to create a load balancer with a DNS name that resolves to private IP addresses.
    public var scheme: Swift.String?
    /// The IDs of the security groups to assign to the load balancer.
    public var securityGroups: [Swift.String]?
    /// The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per Availability Zone specified in AvailabilityZones.
    public var subnets: [Swift.String]?
    /// A list of tags to assign to the load balancer. For more information about tagging your load balancer, see [Tag Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/add-remove-tags.html) in the Classic Load Balancers Guide.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil,
        scheme: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
    }
}

struct CreateLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let listeners: [ElasticLoadBalancingClientTypes.Listener]?
    let availabilityZones: [Swift.String]?
    let subnets: [Swift.String]?
    let securityGroups: [Swift.String]?
    let scheme: Swift.String?
    let tags: [ElasticLoadBalancingClientTypes.Tag]?
}

extension CreateLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case listeners = "Listeners"
        case loadBalancerName = "LoadBalancerName"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Listener].self, forKey: .member)
                var listenersBuffer:[ElasticLoadBalancingClientTypes.Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [ElasticLoadBalancingClientTypes.Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let schemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheme)
        scheme = schemeDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElasticLoadBalancingClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElasticLoadBalancingClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension CreateLoadBalancerListenersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listeners = listeners {
            if !listeners.isEmpty {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                for (index0, listener0) in listeners.enumerated() {
                    try listenersContainer.encode(listener0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                try listenersContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("CreateLoadBalancerListeners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancerListeners.
public struct CreateLoadBalancerListenersInput: Swift.Equatable {
    /// The listeners.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
    }
}

struct CreateLoadBalancerListenersInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let listeners: [ElasticLoadBalancingClientTypes.Listener]?
}

extension CreateLoadBalancerListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Listener].self, forKey: .member)
                var listenersBuffer:[ElasticLoadBalancingClientTypes.Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [ElasticLoadBalancingClientTypes.Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

extension CreateLoadBalancerListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFound" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListener" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocol" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoadBalancerListenersOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the parameters for CreateLoadBalancerListener.
public struct CreateLoadBalancerListenersOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFound" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateLoadBalancerName" : self = .duplicateAccessPointNameException(try DuplicateAccessPointNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeys" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidScheme" : self = .invalidSchemeException(try InvalidSchemeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroup" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFound" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLoadBalancers" : self = .tooManyAccessPointsException(try TooManyAccessPointsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTags" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocol" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateAccessPointNameException(DuplicateAccessPointNameException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSchemeException(InvalidSchemeException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case invalidSubnetException(InvalidSubnetException)
    case operationNotPermittedException(OperationNotPermittedException)
    case subnetNotFoundException(SubnetNotFoundException)
    case tooManyAccessPointsException(TooManyAccessPointsException)
    case tooManyTagsException(TooManyTagsException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dnsName = output.dnsName
        } else {
            self.dnsName = nil
        }
    }
}

/// Contains the output for CreateLoadBalancer.
public struct CreateLoadBalancerOutputResponse: Swift.Equatable {
    /// The DNS name of the load balancer.
    public var dnsName: Swift.String?

    public init (
        dnsName: Swift.String? = nil
    )
    {
        self.dnsName = dnsName
    }
}

struct CreateLoadBalancerOutputResponseBody: Swift.Equatable {
    let dnsName: Swift.String?
}

extension CreateLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsName = "DNSName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateLoadBalancerResult"))
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
    }
}

extension CreateLoadBalancerPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyAttributes = policyAttributes {
            if !policyAttributes.isEmpty {
                var policyAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributes"))
                for (index0, policyattribute0) in policyAttributes.enumerated() {
                    try policyAttributesContainer.encode(policyattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributes"))
                try policyAttributesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
        try container.encode("CreateLoadBalancerPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The policy attributes.
    public var policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]?
    /// The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the base policy type. To get the list of policy types, use [DescribeLoadBalancerPolicyTypes].
    /// This member is required.
    public var policyTypeName: Swift.String?

    public init (
        loadBalancerName: Swift.String? = nil,
        policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]? = nil,
        policyName: Swift.String? = nil,
        policyTypeName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyAttributes = policyAttributes
        self.policyName = policyName
        self.policyTypeName = policyTypeName
    }
}

struct CreateLoadBalancerPolicyInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let policyName: Swift.String?
    let policyTypeName: Swift.String?
    let policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]?
}

extension CreateLoadBalancerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyAttributes = "PolicyAttributes"
        case policyName = "PolicyName"
        case policyTypeName = "PolicyTypeName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTypeName)
        policyTypeName = policyTypeNameDecoded
        if containerValues.contains(.policyAttributes) {
            struct KeyVal0{struct member{}}
            let policyAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyAttributes)
            if let policyAttributesWrappedContainer = policyAttributesWrappedContainer {
                let policyAttributesContainer = try policyAttributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.PolicyAttribute].self, forKey: .member)
                var policyAttributesBuffer:[ElasticLoadBalancingClientTypes.PolicyAttribute]? = nil
                if let policyAttributesContainer = policyAttributesContainer {
                    policyAttributesBuffer = [ElasticLoadBalancingClientTypes.PolicyAttribute]()
                    for structureContainer0 in policyAttributesContainer {
                        policyAttributesBuffer?.append(structureContainer0)
                    }
                }
                policyAttributes = policyAttributesBuffer
            } else {
                policyAttributes = []
            }
        } else {
            policyAttributes = nil
        }
    }
}

extension CreateLoadBalancerPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatePolicyName" : self = .duplicatePolicyNameException(try DuplicatePolicyNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyTypeNotFound" : self = .policyTypeNotFoundException(try PolicyTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPolicies" : self = .tooManyPoliciesException(try TooManyPoliciesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLoadBalancerPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case duplicatePolicyNameException(DuplicatePolicyNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case policyTypeNotFoundException(PolicyTypeNotFoundException)
    case tooManyPoliciesException(TooManyPoliciesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the CrossZoneLoadBalancing attribute.
    public struct CrossZoneLoadBalancing: Swift.Equatable {
        /// Specifies whether cross-zone load balancing is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension DeleteLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DeleteLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancer.
public struct DeleteLoadBalancerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

struct DeleteLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
}

extension DeleteLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
    }
}

extension DeleteLoadBalancerListenersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let loadBalancerPorts = loadBalancerPorts {
            if !loadBalancerPorts.isEmpty {
                var loadBalancerPortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerPorts"))
                for (index0, accesspointport0) in loadBalancerPorts.enumerated() {
                    try loadBalancerPortsContainer.encode(accesspointport0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerPortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerPorts"))
                try loadBalancerPortsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DeleteLoadBalancerListeners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The client port numbers of the listeners.
    /// This member is required.
    public var loadBalancerPorts: [Swift.Int]?

    public init (
        loadBalancerName: Swift.String? = nil,
        loadBalancerPorts: [Swift.Int]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPorts = loadBalancerPorts
    }
}

struct DeleteLoadBalancerListenersInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let loadBalancerPorts: [Swift.Int]?
}

extension DeleteLoadBalancerListenersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPorts = "LoadBalancerPorts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.loadBalancerPorts) {
            struct KeyVal0{struct member{}}
            let loadBalancerPortsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerPorts)
            if let loadBalancerPortsWrappedContainer = loadBalancerPortsWrappedContainer {
                let loadBalancerPortsContainer = try loadBalancerPortsWrappedContainer.decodeIfPresent([Swift.Int].self, forKey: .member)
                var loadBalancerPortsBuffer:[Swift.Int]? = nil
                if let loadBalancerPortsContainer = loadBalancerPortsContainer {
                    loadBalancerPortsBuffer = [Swift.Int]()
                    for integerContainer0 in loadBalancerPortsContainer {
                        loadBalancerPortsBuffer?.append(integerContainer0)
                    }
                }
                loadBalancerPorts = loadBalancerPortsBuffer
            } else {
                loadBalancerPorts = []
            }
        } else {
            loadBalancerPorts = nil
        }
    }
}

extension DeleteLoadBalancerListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoadBalancerListenersOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of DeleteLoadBalancer.
public struct DeleteLoadBalancerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLoadBalancerPolicyInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("DeleteLoadBalancerPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init (
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

struct DeleteLoadBalancerPolicyInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let policyName: Swift.String?
}

extension DeleteLoadBalancerPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension DeleteLoadBalancerPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLoadBalancerPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DependencyThrottleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DependencyThrottleExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A request made by Elastic Load Balancing to another service exceeds the maximum request rate permitted for your account.
public struct DependencyThrottleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyThrottleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyThrottleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeregisterInstancesFromLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DeregisterInstancesFromLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeregisterInstancesFromLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerInput: Swift.Equatable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

struct DeregisterInstancesFromLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let instances: [ElasticLoadBalancingClientTypes.Instance]?
}

extension DeregisterInstancesFromLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

extension DeregisterInstancesFromLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterInstancesFromLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstance" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterInstancesFromLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterInstancesFromLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeregisterInstancesFromLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// Contains the output of DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerOutputResponse: Swift.Equatable {
    /// The remaining instances registered with the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init (
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct DeregisterInstancesFromLoadBalancerOutputResponseBody: Swift.Equatable {
    let instances: [ElasticLoadBalancingClientTypes.Instance]?
}

extension DeregisterInstancesFromLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeregisterInstancesFromLoadBalancerResult"))
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

extension DescribeAccountLimitsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeAccountLimits", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAccountLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountLimitsInput: Swift.Equatable {
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call.
    public var pageSize: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct DescribeAccountLimitsInputBody: Swift.Equatable {
    let marker: Swift.String?
    let pageSize: Swift.Int?
}

extension DescribeAccountLimitsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pageSize = "PageSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribeAccountLimitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountLimitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccountLimitsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountLimitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccountLimitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.limits = output.limits
            self.nextMarker = output.nextMarker
        } else {
            self.limits = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeAccountLimitsOutputResponse: Swift.Equatable {
    /// Information about the limits.
    public var limits: [ElasticLoadBalancingClientTypes.Limit]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init (
        limits: [ElasticLoadBalancingClientTypes.Limit]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

struct DescribeAccountLimitsOutputResponseBody: Swift.Equatable {
    let limits: [ElasticLoadBalancingClientTypes.Limit]?
    let nextMarker: Swift.String?
}

extension DescribeAccountLimitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limits = "Limits"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAccountLimitsResult"))
        if containerValues.contains(.limits) {
            struct KeyVal0{struct member{}}
            let limitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .limits)
            if let limitsWrappedContainer = limitsWrappedContainer {
                let limitsContainer = try limitsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Limit].self, forKey: .member)
                var limitsBuffer:[ElasticLoadBalancingClientTypes.Limit]? = nil
                if let limitsContainer = limitsContainer {
                    limitsBuffer = [ElasticLoadBalancingClientTypes.Limit]()
                    for structureContainer0 in limitsContainer {
                        limitsBuffer?.append(structureContainer0)
                    }
                }
                limits = limitsBuffer
            } else {
                limits = []
            }
        } else {
            limits = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeInstanceHealthInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DescribeInstanceHealth", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeInstanceHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeInstanceHealth.
public struct DescribeInstanceHealthInput: Swift.Equatable {
    /// The IDs of the instances.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

struct DescribeInstanceHealthInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let instances: [ElasticLoadBalancingClientTypes.Instance]?
}

extension DescribeInstanceHealthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

extension DescribeInstanceHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstanceHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstance" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeInstanceHealthOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeInstanceHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceStates = output.instanceStates
        } else {
            self.instanceStates = nil
        }
    }
}

/// Contains the output for DescribeInstanceHealth.
public struct DescribeInstanceHealthOutputResponse: Swift.Equatable {
    /// Information about the health of the instances.
    public var instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]?

    public init (
        instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]? = nil
    )
    {
        self.instanceStates = instanceStates
    }
}

struct DescribeInstanceHealthOutputResponseBody: Swift.Equatable {
    let instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]?
}

extension DescribeInstanceHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceStates = "InstanceStates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeInstanceHealthResult"))
        if containerValues.contains(.instanceStates) {
            struct KeyVal0{struct member{}}
            let instanceStatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceStates)
            if let instanceStatesWrappedContainer = instanceStatesWrappedContainer {
                let instanceStatesContainer = try instanceStatesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.InstanceState].self, forKey: .member)
                var instanceStatesBuffer:[ElasticLoadBalancingClientTypes.InstanceState]? = nil
                if let instanceStatesContainer = instanceStatesContainer {
                    instanceStatesBuffer = [ElasticLoadBalancingClientTypes.InstanceState]()
                    for structureContainer0 in instanceStatesContainer {
                        instanceStatesBuffer?.append(structureContainer0)
                    }
                }
                instanceStates = instanceStatesBuffer
            } else {
                instanceStates = []
            }
        } else {
            instanceStates = nil
        }
    }
}

extension DescribeLoadBalancerAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DescribeLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

struct DescribeLoadBalancerAttributesInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
}

extension DescribeLoadBalancerAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
    }
}

extension DescribeLoadBalancerAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerAttributeNotFound" : self = .loadBalancerAttributeNotFoundException(try LoadBalancerAttributeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoadBalancerAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case loadBalancerAttributeNotFoundException(LoadBalancerAttributeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBalancerAttributes = output.loadBalancerAttributes
        } else {
            self.loadBalancerAttributes = nil
        }
    }
}

/// Contains the output of DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesOutputResponse: Swift.Equatable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?

    public init (
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
    }
}

struct DescribeLoadBalancerAttributesOutputResponseBody: Swift.Equatable {
    let loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
}

extension DescribeLoadBalancerAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancerAttributesResult"))
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.LoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
    }
}

extension DescribeLoadBalancerPoliciesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeLoadBalancerPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesInput: Swift.Equatable {
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?
    /// The names of the policies.
    public var policyNames: [Swift.String]?

    public init (
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

struct DescribeLoadBalancerPoliciesInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let policyNames: [Swift.String]?
}

extension DescribeLoadBalancerPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension DescribeLoadBalancerPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoadBalancerPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoadBalancerPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyDescriptions = output.policyDescriptions
        } else {
            self.policyDescriptions = nil
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesOutputResponse: Swift.Equatable {
    /// Information about the policies.
    public var policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]?

    public init (
        policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]? = nil
    )
    {
        self.policyDescriptions = policyDescriptions
    }
}

struct DescribeLoadBalancerPoliciesOutputResponseBody: Swift.Equatable {
    let policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]?
}

extension DescribeLoadBalancerPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDescriptions = "PolicyDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancerPoliciesResult"))
        if containerValues.contains(.policyDescriptions) {
            struct KeyVal0{struct member{}}
            let policyDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyDescriptions)
            if let policyDescriptionsWrappedContainer = policyDescriptionsWrappedContainer {
                let policyDescriptionsContainer = try policyDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.PolicyDescription].self, forKey: .member)
                var policyDescriptionsBuffer:[ElasticLoadBalancingClientTypes.PolicyDescription]? = nil
                if let policyDescriptionsContainer = policyDescriptionsContainer {
                    policyDescriptionsBuffer = [ElasticLoadBalancingClientTypes.PolicyDescription]()
                    for structureContainer0 in policyDescriptionsContainer {
                        policyDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyDescriptions = policyDescriptionsBuffer
            } else {
                policyDescriptions = []
            }
        } else {
            policyDescriptions = nil
        }
    }
}

extension DescribeLoadBalancerPolicyTypesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyTypeNames = policyTypeNames {
            if !policyTypeNames.isEmpty {
                var policyTypeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyTypeNames"))
                for (index0, policytypename0) in policyTypeNames.enumerated() {
                    try policyTypeNamesContainer.encode(policytypename0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyTypeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyTypeNames"))
                try policyTypeNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeLoadBalancerPolicyTypes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerPolicyTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesInput: Swift.Equatable {
    /// The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.
    public var policyTypeNames: [Swift.String]?

    public init (
        policyTypeNames: [Swift.String]? = nil
    )
    {
        self.policyTypeNames = policyTypeNames
    }
}

struct DescribeLoadBalancerPolicyTypesInputBody: Swift.Equatable {
    let policyTypeNames: [Swift.String]?
}

extension DescribeLoadBalancerPolicyTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTypeNames = "PolicyTypeNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyTypeNames) {
            struct KeyVal0{struct member{}}
            let policyTypeNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyTypeNames)
            if let policyTypeNamesWrappedContainer = policyTypeNamesWrappedContainer {
                let policyTypeNamesContainer = try policyTypeNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyTypeNamesBuffer:[Swift.String]? = nil
                if let policyTypeNamesContainer = policyTypeNamesContainer {
                    policyTypeNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyTypeNamesContainer {
                        policyTypeNamesBuffer?.append(stringContainer0)
                    }
                }
                policyTypeNames = policyTypeNamesBuffer
            } else {
                policyTypeNames = []
            }
        } else {
            policyTypeNames = nil
        }
    }
}

extension DescribeLoadBalancerPolicyTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerPolicyTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PolicyTypeNotFound" : self = .policyTypeNotFoundException(try PolicyTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoadBalancerPolicyTypesOutputError: Swift.Error, Swift.Equatable {
    case policyTypeNotFoundException(PolicyTypeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerPolicyTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoadBalancerPolicyTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyTypeDescriptions = output.policyTypeDescriptions
        } else {
            self.policyTypeDescriptions = nil
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesOutputResponse: Swift.Equatable {
    /// Information about the policy types.
    public var policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]?

    public init (
        policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]? = nil
    )
    {
        self.policyTypeDescriptions = policyTypeDescriptions
    }
}

struct DescribeLoadBalancerPolicyTypesOutputResponseBody: Swift.Equatable {
    let policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]?
}

extension DescribeLoadBalancerPolicyTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTypeDescriptions = "PolicyTypeDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancerPolicyTypesResult"))
        if containerValues.contains(.policyTypeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyTypeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyTypeDescriptions)
            if let policyTypeDescriptionsWrappedContainer = policyTypeDescriptionsWrappedContainer {
                let policyTypeDescriptionsContainer = try policyTypeDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.PolicyTypeDescription].self, forKey: .member)
                var policyTypeDescriptionsBuffer:[ElasticLoadBalancingClientTypes.PolicyTypeDescription]? = nil
                if let policyTypeDescriptionsContainer = policyTypeDescriptionsContainer {
                    policyTypeDescriptionsBuffer = [ElasticLoadBalancingClientTypes.PolicyTypeDescription]()
                    for structureContainer0 in policyTypeDescriptionsContainer {
                        policyTypeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyTypeDescriptions = policyTypeDescriptionsBuffer
            } else {
                policyTypeDescriptions = []
            }
        } else {
            policyTypeDescriptions = nil
        }
    }
}

extension DescribeLoadBalancersInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeLoadBalancers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersInput: Swift.Equatable {
    /// The names of the load balancers.
    public var loadBalancerNames: [Swift.String]?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call (a number from 1 to 400). The default is 400.
    public var pageSize: Swift.Int?

    public init (
        loadBalancerNames: [Swift.String]? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.marker = marker
        self.pageSize = pageSize
    }
}

struct DescribeLoadBalancersInputBody: Swift.Equatable {
    let loadBalancerNames: [Swift.String]?
    let marker: Swift.String?
    let pageSize: Swift.Int?
}

extension DescribeLoadBalancersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case marker = "Marker"
        case pageSize = "PageSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerNamesBuffer:[Swift.String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribeLoadBalancersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyThrottle" : self = .dependencyThrottleException(try DependencyThrottleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoadBalancersOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case dependencyThrottleException(DependencyThrottleException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBalancerDescriptions = output.loadBalancerDescriptions
            self.nextMarker = output.nextMarker
        } else {
            self.loadBalancerDescriptions = nil
            self.nextMarker = nil
        }
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersOutputResponse: Swift.Equatable {
    /// Information about the load balancers.
    public var loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init (
        loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.loadBalancerDescriptions = loadBalancerDescriptions
        self.nextMarker = nextMarker
    }
}

struct DescribeLoadBalancersOutputResponseBody: Swift.Equatable {
    let loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]?
    let nextMarker: Swift.String?
}

extension DescribeLoadBalancersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerDescriptions = "LoadBalancerDescriptions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancersResult"))
        if containerValues.contains(.loadBalancerDescriptions) {
            struct KeyVal0{struct member{}}
            let loadBalancerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerDescriptions)
            if let loadBalancerDescriptionsWrappedContainer = loadBalancerDescriptionsWrappedContainer {
                let loadBalancerDescriptionsContainer = try loadBalancerDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.LoadBalancerDescription].self, forKey: .member)
                var loadBalancerDescriptionsBuffer:[ElasticLoadBalancingClientTypes.LoadBalancerDescription]? = nil
                if let loadBalancerDescriptionsContainer = loadBalancerDescriptionsContainer {
                    loadBalancerDescriptionsBuffer = [ElasticLoadBalancingClientTypes.LoadBalancerDescription]()
                    for structureContainer0 in loadBalancerDescriptionsContainer {
                        loadBalancerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                loadBalancerDescriptions = loadBalancerDescriptionsBuffer
            } else {
                loadBalancerDescriptions = []
            }
        } else {
            loadBalancerDescriptions = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension DescribeTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeTags.
public struct DescribeTagsInput: Swift.Equatable {
    /// The names of the load balancers.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?

    public init (
        loadBalancerNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let loadBalancerNames: [Swift.String]?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerNamesBuffer:[Swift.String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagDescriptions = output.tagDescriptions
        } else {
            self.tagDescriptions = nil
        }
    }
}

/// Contains the output for DescribeTags.
public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]?

    public init (
        tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    let tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagDescriptions = "TagDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTagsResult"))
        if containerValues.contains(.tagDescriptions) {
            struct KeyVal0{struct member{}}
            let tagDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagDescriptions)
            if let tagDescriptionsWrappedContainer = tagDescriptionsWrappedContainer {
                let tagDescriptionsContainer = try tagDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.TagDescription].self, forKey: .member)
                var tagDescriptionsBuffer:[ElasticLoadBalancingClientTypes.TagDescription]? = nil
                if let tagDescriptionsContainer = tagDescriptionsContainer {
                    tagDescriptionsBuffer = [ElasticLoadBalancingClientTypes.TagDescription]()
                    for structureContainer0 in tagDescriptionsContainer {
                        tagDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                tagDescriptions = tagDescriptionsBuffer
            } else {
                tagDescriptions = []
            }
        } else {
            tagDescriptions = nil
        }
    }
}

extension DetachLoadBalancerFromSubnetsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DetachLoadBalancerFromSubnets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachLoadBalancerFromSubnetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init (
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

struct DetachLoadBalancerFromSubnetsInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let subnets: [Swift.String]?
}

extension DetachLoadBalancerFromSubnetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case subnets = "Subnets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

extension DetachLoadBalancerFromSubnetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DetachLoadBalancerFromSubnetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DetachLoadBalancerFromSubnetsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetachLoadBalancerFromSubnetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DetachLoadBalancerFromSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subnets = output.subnets
        } else {
            self.subnets = nil
        }
    }
}

/// Contains the output of DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsOutputResponse: Swift.Equatable {
    /// The IDs of the remaining subnets for the load balancer.
    public var subnets: [Swift.String]?

    public init (
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

struct DetachLoadBalancerFromSubnetsOutputResponseBody: Swift.Equatable {
    let subnets: [Swift.String]?
}

extension DetachLoadBalancerFromSubnetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnets = "Subnets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DetachLoadBalancerFromSubnetsResult"))
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DisableAvailabilityZonesForLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerInput: Swift.Equatable {
    /// The Availability Zones.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

struct DisableAvailabilityZonesForLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let availabilityZones: [Swift.String]?
}

extension DisableAvailabilityZonesForLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableAvailabilityZonesForLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableAvailabilityZonesForLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableAvailabilityZonesForLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZones = output.availabilityZones
        } else {
            self.availabilityZones = nil
        }
    }
}

/// Contains the output for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerOutputResponse: Swift.Equatable {
    /// The remaining Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

struct DisableAvailabilityZonesForLoadBalancerOutputResponseBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
}

extension DisableAvailabilityZonesForLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DisableAvailabilityZonesForLoadBalancerResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension DuplicateAccessPointNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateAccessPointNameExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified load balancer name already exists for this account.
public struct DuplicateAccessPointNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateAccessPointNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateAccessPointNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateListenerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateListenerExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A listener already exists for the specified load balancer name and port, but with a different instance port, protocol, or SSL certificate.
public struct DuplicateListenerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateListenerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateListenerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicatePolicyNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicatePolicyNameExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A policy with the specified name already exists for this load balancer.
public struct DuplicatePolicyNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicatePolicyNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicatePolicyNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTagKeysException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<DuplicateTagKeysExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A tag key was specified more than once.
public struct DuplicateTagKeysException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateTagKeysExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableAvailabilityZonesForLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("EnableAvailabilityZonesForLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension EnableAvailabilityZonesForLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerInput: Swift.Equatable {
    /// The Availability Zones. These must be in the same region as the load balancer.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

struct EnableAvailabilityZonesForLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let availabilityZones: [Swift.String]?
}

extension EnableAvailabilityZonesForLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableAvailabilityZonesForLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableAvailabilityZonesForLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableAvailabilityZonesForLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZones = output.availabilityZones
        } else {
            self.availabilityZones = nil
        }
    }
}

/// Contains the output of EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerOutputResponse: Swift.Equatable {
    /// The updated list of Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

struct EnableAvailabilityZonesForLoadBalancerOutputResponseBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
}

extension EnableAvailabilityZonesForLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("EnableAvailabilityZonesForLoadBalancerResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes.HealthCheck: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case target = "Target"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if healthyThreshold != 0 {
            try container.encode(healthyThreshold, forKey: ClientRuntime.Key("HealthyThreshold"))
        }
        if interval != 0 {
            try container.encode(interval, forKey: ClientRuntime.Key("Interval"))
        }
        if let target = target {
            try container.encode(target, forKey: ClientRuntime.Key("Target"))
        }
        if timeout != 0 {
            try container.encode(timeout, forKey: ClientRuntime.Key("Timeout"))
        }
        if unhealthyThreshold != 0 {
            try container.encode(unhealthyThreshold, forKey: ClientRuntime.Key("UnhealthyThreshold"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let unhealthyThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
        let healthyThresholdDecoded = try containerValues.decode(Swift.Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a health check.
    public struct HealthCheck: Swift.Equatable {
        /// The number of consecutive health checks successes required before moving the instance to the Healthy state.
        /// This member is required.
        public var healthyThreshold: Swift.Int
        /// The approximate interval, in seconds, between health checks of an individual instance.
        /// This member is required.
        public var interval: Swift.Int
        /// The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535. TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy. SSL is also specified as SSL: port pair, for example, SSL:5000. For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy. The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.
        /// This member is required.
        public var target: Swift.String?
        /// The amount of time, in seconds, during which no response means a failed health check. This value must be less than the Interval value.
        /// This member is required.
        public var timeout: Swift.Int
        /// The number of consecutive health check failures required before moving the instance to the Unhealthy state.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int

        public init (
            healthyThreshold: Swift.Int = 0,
            interval: Swift.Int = 0,
            target: Swift.String? = nil,
            timeout: Swift.Int = 0,
            unhealthyThreshold: Swift.Int = 0
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension ElasticLoadBalancingClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: ClientRuntime.Key("InstanceId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The ID of an EC2 instance.
    public struct Instance: Swift.Equatable {
        /// The instance ID.
        public var instanceId: Swift.String?

        public init (
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension ElasticLoadBalancingClientTypes.InstanceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceId = "InstanceId"
        case reasonCode = "ReasonCode"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: ClientRuntime.Key("InstanceId"))
        }
        if let reasonCode = reasonCode {
            try container.encode(reasonCode, forKey: ClientRuntime.Key("ReasonCode"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the state of an EC2 instance.
    public struct InstanceState: Swift.Equatable {
        /// A description of the instance state. This string can contain one or more of the following messages.
        ///
        /// * N/A
        ///
        /// * A transient error occurred. Please try again later.
        ///
        /// * Instance has failed at least the UnhealthyThreshold number of health checks consecutively.
        ///
        /// * Instance has not passed the configured HealthyThreshold number of health checks consecutively.
        ///
        /// * Instance registration is still in progress.
        ///
        /// * Instance is in the EC2 Availability Zone for which LoadBalancer is not configured to route traffic to.
        ///
        /// * Instance is not currently registered with the LoadBalancer.
        ///
        /// * Instance deregistration currently in progress.
        ///
        /// * Disable Availability Zone is currently in progress.
        ///
        /// * Instance is in pending state.
        ///
        /// * Instance is in stopped state.
        ///
        /// * Instance is in terminated state.
        public var description: Swift.String?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// Information about the cause of OutOfService instances. Specifically, whether the cause is Elastic Load Balancing or the instance. Valid values: ELB | Instance | N/A
        public var reasonCode: Swift.String?
        /// The current state of the instance. Valid values: InService | OutOfService | Unknown
        public var state: Swift.String?

        public init (
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            reasonCode: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.description = description
            self.instanceId = instanceId
            self.reasonCode = reasonCode
            self.state = state
        }
    }

}

extension InvalidConfigurationRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidConfigurationRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested configuration change is not valid.
public struct InvalidConfigurationRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidConfigurationRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndPointException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidEndPointExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified endpoint is not valid.
public struct InvalidEndPointException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndPointExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEndPointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSchemeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for the schema is not valid. You can only specify a scheme for load balancers in a VPC.
public struct InvalidSchemeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSchemeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSecurityGroupExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified security groups do not exist.
public struct InvalidSecurityGroupException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityGroupExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSecurityGroupExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSubnetExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified VPC has no associated Internet gateway.
public struct InvalidSubnetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSubnetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: ClientRuntime.Key("CookieExpirationPeriod"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let cookieExpirationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cookieExpirationPeriod)
        cookieExpirationPeriod = cookieExpirationPeriodDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy for duration-based session stickiness.
    public struct LBCookieStickinessPolicy: Swift.Equatable {
        /// The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.
        public var cookieExpirationPeriod: Swift.Int?
        /// The name of the policy. This name must be unique within the set of policies for this load balancer.
        public var policyName: Swift.String?

        public init (
            cookieExpirationPeriod: Swift.Int? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }
    }

}

extension ElasticLoadBalancingClientTypes.Limit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let max = max {
            try container.encode(max, forKey: ClientRuntime.Key("Max"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about an Elastic Load Balancing resource limit for your AWS account.
    public struct Limit: Swift.Equatable {
        /// The maximum value of the limit.
        public var max: Swift.String?
        /// The name of the limit. The possible values are:
        ///
        /// * classic-listeners
        ///
        /// * classic-load-balancers
        ///
        /// * classic-registered-instances
        public var name: Swift.String?

        public init (
            max: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.name = name
        }
    }

}

extension ElasticLoadBalancingClientTypes.Listener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case instanceProtocol = "InstanceProtocol"
        case loadBalancerPort = "LoadBalancerPort"
        case `protocol` = "Protocol"
        case sslCertificateId = "SSLCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if instancePort != 0 {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let instanceProtocol = instanceProtocol {
            try container.encode(instanceProtocol, forKey: ClientRuntime.Key("InstanceProtocol"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let sslCertificateId = sslCertificateId {
            try container.encode(sslCertificateId, forKey: ClientRuntime.Key("SSLCertificateId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let loadBalancerPortDecoded = try containerValues.decode(Swift.Int.self, forKey: .loadBalancerPort)
        loadBalancerPort = loadBalancerPortDecoded
        let instanceProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProtocol)
        instanceProtocol = instanceProtocolDecoded
        let instancePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        let sslCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCertificateId)
        sslCertificateId = sslCertificateIdDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a listener. For information about the protocols and the ports supported by Elastic Load Balancing, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    public struct Listener: Swift.Equatable {
        /// The port on which the instance is listening.
        /// This member is required.
        public var instancePort: Swift.Int
        /// The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If the front-end protocol is TCP or SSL, the back-end protocol must be TCP or SSL. If the front-end protocol is HTTP or HTTPS, the back-end protocol must be HTTP or HTTPS. If there is another listener with the same InstancePort whose InstanceProtocol is secure, (HTTPS or SSL), the listener's InstanceProtocol must also be secure. If there is another listener with the same InstancePort whose InstanceProtocol is HTTP or TCP, the listener's InstanceProtocol must be HTTP or TCP.
        public var instanceProtocol: Swift.String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        /// This member is required.
        public var loadBalancerPort: Swift.Int
        /// The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// The Amazon Resource Name (ARN) of the server certificate.
        public var sslCertificateId: Swift.String?

        public init (
            instancePort: Swift.Int = 0,
            instanceProtocol: Swift.String? = nil,
            loadBalancerPort: Swift.Int = 0,
            `protocol`: Swift.String? = nil,
            sslCertificateId: Swift.String? = nil
        )
        {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }
    }

}

extension ElasticLoadBalancingClientTypes.ListenerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listener = listener {
            try container.encode(listener, forKey: ClientRuntime.Key("Listener"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.Listener.self, forKey: .listener)
        listener = listenerDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The policies enabled for a listener.
    public struct ListenerDescription: Swift.Equatable {
        /// The listener.
        public var listener: ElasticLoadBalancingClientTypes.Listener?
        /// The policies. If there are no policies enabled, the list is empty.
        public var policyNames: [Swift.String]?

        public init (
            listener: ElasticLoadBalancingClientTypes.Listener? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.listener = listener
            self.policyNames = policyNames
        }
    }

}

extension ListenerNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<ListenerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The load balancer does not have a listener configured at the specified port.
public struct ListenerNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ListenerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoadBalancerAttributeNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<LoadBalancerAttributeNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified load balancer attribute does not exist.
public struct LoadBalancerAttributeNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LoadBalancerAttributeNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LoadBalancerAttributeNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingClientTypes.LoadBalancerAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLog = "AccessLog"
        case additionalAttributes = "AdditionalAttributes"
        case connectionDraining = "ConnectionDraining"
        case connectionSettings = "ConnectionSettings"
        case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessLog = accessLog {
            try container.encode(accessLog, forKey: ClientRuntime.Key("AccessLog"))
        }
        if let additionalAttributes = additionalAttributes {
            if !additionalAttributes.isEmpty {
                var additionalAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AdditionalAttributes"))
                for (index0, additionalattribute0) in additionalAttributes.enumerated() {
                    try additionalAttributesContainer.encode(additionalattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var additionalAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AdditionalAttributes"))
                try additionalAttributesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let connectionDraining = connectionDraining {
            try container.encode(connectionDraining, forKey: ClientRuntime.Key("ConnectionDraining"))
        }
        if let connectionSettings = connectionSettings {
            try container.encode(connectionSettings, forKey: ClientRuntime.Key("ConnectionSettings"))
        }
        if let crossZoneLoadBalancing = crossZoneLoadBalancing {
            try container.encode(crossZoneLoadBalancing, forKey: ClientRuntime.Key("CrossZoneLoadBalancing"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossZoneLoadBalancingDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing.self, forKey: .crossZoneLoadBalancing)
        crossZoneLoadBalancing = crossZoneLoadBalancingDecoded
        let accessLogDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.AccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
        let connectionDrainingDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.ConnectionDraining.self, forKey: .connectionDraining)
        connectionDraining = connectionDrainingDecoded
        let connectionSettingsDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.ConnectionSettings.self, forKey: .connectionSettings)
        connectionSettings = connectionSettingsDecoded
        if containerValues.contains(.additionalAttributes) {
            struct KeyVal0{struct member{}}
            let additionalAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .additionalAttributes)
            if let additionalAttributesWrappedContainer = additionalAttributesWrappedContainer {
                let additionalAttributesContainer = try additionalAttributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.AdditionalAttribute].self, forKey: .member)
                var additionalAttributesBuffer:[ElasticLoadBalancingClientTypes.AdditionalAttribute]? = nil
                if let additionalAttributesContainer = additionalAttributesContainer {
                    additionalAttributesBuffer = [ElasticLoadBalancingClientTypes.AdditionalAttribute]()
                    for structureContainer0 in additionalAttributesContainer {
                        additionalAttributesBuffer?.append(structureContainer0)
                    }
                }
                additionalAttributes = additionalAttributesBuffer
            } else {
                additionalAttributes = []
            }
        } else {
            additionalAttributes = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The attributes for a load balancer.
    public struct LoadBalancerAttributes: Swift.Equatable {
        /// If enabled, the load balancer captures detailed information of all requests and delivers the information to the Amazon S3 bucket that you specify. For more information, see [Enable Access Logs](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html) in the Classic Load Balancers Guide.
        public var accessLog: ElasticLoadBalancingClientTypes.AccessLog?
        /// Any additional attributes.
        public var additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]?
        /// If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see [Configure Connection Draining](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html) in the Classic Load Balancers Guide.
        public var connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining?
        /// If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see [Configure Idle Connection Timeout](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html) in the Classic Load Balancers Guide.
        public var connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings?
        /// If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see [Configure Cross-Zone Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html) in the Classic Load Balancers Guide.
        public var crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing?

        public init (
            accessLog: ElasticLoadBalancingClientTypes.AccessLog? = nil,
            additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]? = nil,
            connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining? = nil,
            connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings? = nil,
            crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing? = nil
        )
        {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }
    }

}

extension ElasticLoadBalancingClientTypes.LoadBalancerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dnsName = "DNSName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            if !backendServerDescriptions.isEmpty {
                var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BackendServerDescriptions"))
                for (index0, backendserverdescription0) in backendServerDescriptions.enumerated() {
                    try backendServerDescriptionsContainer.encode(backendserverdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BackendServerDescriptions"))
                try backendServerDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let canonicalHostedZoneName = canonicalHostedZoneName {
            try container.encode(canonicalHostedZoneName, forKey: ClientRuntime.Key("CanonicalHostedZoneName"))
        }
        if let canonicalHostedZoneNameID = canonicalHostedZoneNameID {
            try container.encode(canonicalHostedZoneNameID, forKey: ClientRuntime.Key("CanonicalHostedZoneNameID"))
        }
        if let createdTime = createdTime {
            try container.encodeTimestamp(createdTime, format: .dateTime, forKey: ClientRuntime.Key("createdTime"))
        }
        if let dnsName = dnsName {
            try container.encode(dnsName, forKey: ClientRuntime.Key("DNSName"))
        }
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: ClientRuntime.Key("HealthCheck"))
        }
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            if !listenerDescriptions.isEmpty {
                var listenerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ListenerDescriptions"))
                for (index0, listenerdescription0) in listenerDescriptions.enumerated() {
                    try listenerDescriptionsContainer.encode(listenerdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ListenerDescriptions"))
                try listenerDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policies = policies {
            try container.encode(policies, forKey: ClientRuntime.Key("Policies"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourceSecurityGroup = sourceSecurityGroup {
            try container.encode(sourceSecurityGroup, forKey: ClientRuntime.Key("SourceSecurityGroup"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VPCId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let canonicalHostedZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneName)
        canonicalHostedZoneName = canonicalHostedZoneNameDecoded
        let canonicalHostedZoneNameIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneNameID)
        canonicalHostedZoneNameID = canonicalHostedZoneNameIDDecoded
        if containerValues.contains(.listenerDescriptions) {
            struct KeyVal0{struct member{}}
            let listenerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listenerDescriptions)
            if let listenerDescriptionsWrappedContainer = listenerDescriptionsWrappedContainer {
                let listenerDescriptionsContainer = try listenerDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.ListenerDescription].self, forKey: .member)
                var listenerDescriptionsBuffer:[ElasticLoadBalancingClientTypes.ListenerDescription]? = nil
                if let listenerDescriptionsContainer = listenerDescriptionsContainer {
                    listenerDescriptionsBuffer = [ElasticLoadBalancingClientTypes.ListenerDescription]()
                    for structureContainer0 in listenerDescriptionsContainer {
                        listenerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                listenerDescriptions = listenerDescriptionsBuffer
            } else {
                listenerDescriptions = []
            }
        } else {
            listenerDescriptions = nil
        }
        let policiesDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.Policies.self, forKey: .policies)
        policies = policiesDecoded
        if containerValues.contains(.backendServerDescriptions) {
            struct KeyVal0{struct member{}}
            let backendServerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .backendServerDescriptions)
            if let backendServerDescriptionsWrappedContainer = backendServerDescriptionsWrappedContainer {
                let backendServerDescriptionsContainer = try backendServerDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.BackendServerDescription].self, forKey: .member)
                var backendServerDescriptionsBuffer:[ElasticLoadBalancingClientTypes.BackendServerDescription]? = nil
                if let backendServerDescriptionsContainer = backendServerDescriptionsContainer {
                    backendServerDescriptionsBuffer = [ElasticLoadBalancingClientTypes.BackendServerDescription]()
                    for structureContainer0 in backendServerDescriptionsContainer {
                        backendServerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                backendServerDescriptions = backendServerDescriptionsBuffer
            } else {
                backendServerDescriptions = []
            }
        } else {
            backendServerDescriptions = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var subnetsBuffer:[Swift.String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [Swift.String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        let healthCheckDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let sourceSecurityGroupDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.SourceSecurityGroup.self, forKey: .sourceSecurityGroup)
        sourceSecurityGroup = sourceSecurityGroupDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheme)
        scheme = schemeDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a load balancer.
    public struct LoadBalancerDescription: Swift.Equatable {
        /// The Availability Zones for the load balancer.
        public var availabilityZones: [Swift.String]?
        /// Information about your EC2 instances.
        public var backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]?
        /// The DNS name of the load balancer. For more information, see [Configure a Custom Domain Name](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/using-domain-names-with-elb.html) in the Classic Load Balancers Guide.
        public var canonicalHostedZoneName: Swift.String?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneNameID: Swift.String?
        /// The date and time the load balancer was created.
        public var createdTime: ClientRuntime.Date?
        /// The DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// Information about the health checks conducted on the load balancer.
        public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
        /// The IDs of the instances for the load balancer.
        public var instances: [ElasticLoadBalancingClientTypes.Instance]?
        /// The listeners for the load balancer.
        public var listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]?
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The policies defined for the load balancer.
        public var policies: ElasticLoadBalancingClientTypes.Policies?
        /// The type of load balancer. Valid only for load balancers in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public var scheme: Swift.String?
        /// The security groups for the load balancer. Valid only for load balancers in a VPC.
        public var securityGroups: [Swift.String]?
        /// The security group for the load balancer, which you can use as part of your inbound rules for your registered instances. To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        public var sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup?
        /// The IDs of the subnets for the load balancer.
        public var subnets: [Swift.String]?
        /// The ID of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]? = nil,
            canonicalHostedZoneName: Swift.String? = nil,
            canonicalHostedZoneNameID: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
            instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
            listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]? = nil,
            loadBalancerName: Swift.String? = nil,
            policies: ElasticLoadBalancingClientTypes.Policies? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension ModifyLoadBalancerAttributesInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerAttributes = loadBalancerAttributes {
            try container.encode(loadBalancerAttributes, forKey: ClientRuntime.Key("LoadBalancerAttributes"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("ModifyLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyLoadBalancerAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesInput: Swift.Equatable {
    /// The attributes for the load balancer.
    /// This member is required.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

struct ModifyLoadBalancerAttributesInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
}

extension ModifyLoadBalancerAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.LoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
    }
}

extension ModifyLoadBalancerAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyLoadBalancerAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerAttributeNotFound" : self = .loadBalancerAttributeNotFoundException(try LoadBalancerAttributeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ModifyLoadBalancerAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case loadBalancerAttributeNotFoundException(LoadBalancerAttributeNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLoadBalancerAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ModifyLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBalancerAttributes = output.loadBalancerAttributes
            self.loadBalancerName = output.loadBalancerName
        } else {
            self.loadBalancerAttributes = nil
            self.loadBalancerName = nil
        }
    }
}

/// Contains the output of ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesOutputResponse: Swift.Equatable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?

    public init (
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

struct ModifyLoadBalancerAttributesOutputResponseBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
}

extension ModifyLoadBalancerAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyLoadBalancerAttributesResult"))
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingClientTypes.LoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
    }
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<OperationNotPermittedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not allowed.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingClientTypes.Policies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
        case lbCookieStickinessPolicies = "LBCookieStickinessPolicies"
        case otherPolicies = "OtherPolicies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let appCookieStickinessPolicies = appCookieStickinessPolicies {
            if !appCookieStickinessPolicies.isEmpty {
                var appCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AppCookieStickinessPolicies"))
                for (index0, appcookiestickinesspolicy0) in appCookieStickinessPolicies.enumerated() {
                    try appCookieStickinessPoliciesContainer.encode(appcookiestickinesspolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var appCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AppCookieStickinessPolicies"))
                try appCookieStickinessPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let lbCookieStickinessPolicies = lbCookieStickinessPolicies {
            if !lbCookieStickinessPolicies.isEmpty {
                var lbCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LBCookieStickinessPolicies"))
                for (index0, lbcookiestickinesspolicy0) in lbCookieStickinessPolicies.enumerated() {
                    try lbCookieStickinessPoliciesContainer.encode(lbcookiestickinesspolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var lbCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LBCookieStickinessPolicies"))
                try lbCookieStickinessPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let otherPolicies = otherPolicies {
            if !otherPolicies.isEmpty {
                var otherPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OtherPolicies"))
                for (index0, policyname0) in otherPolicies.enumerated() {
                    try otherPoliciesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var otherPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OtherPolicies"))
                try otherPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.appCookieStickinessPolicies) {
            struct KeyVal0{struct member{}}
            let appCookieStickinessPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .appCookieStickinessPolicies)
            if let appCookieStickinessPoliciesWrappedContainer = appCookieStickinessPoliciesWrappedContainer {
                let appCookieStickinessPoliciesContainer = try appCookieStickinessPoliciesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy].self, forKey: .member)
                var appCookieStickinessPoliciesBuffer:[ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]? = nil
                if let appCookieStickinessPoliciesContainer = appCookieStickinessPoliciesContainer {
                    appCookieStickinessPoliciesBuffer = [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]()
                    for structureContainer0 in appCookieStickinessPoliciesContainer {
                        appCookieStickinessPoliciesBuffer?.append(structureContainer0)
                    }
                }
                appCookieStickinessPolicies = appCookieStickinessPoliciesBuffer
            } else {
                appCookieStickinessPolicies = []
            }
        } else {
            appCookieStickinessPolicies = nil
        }
        if containerValues.contains(.lbCookieStickinessPolicies) {
            struct KeyVal0{struct member{}}
            let lbCookieStickinessPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .lbCookieStickinessPolicies)
            if let lbCookieStickinessPoliciesWrappedContainer = lbCookieStickinessPoliciesWrappedContainer {
                let lbCookieStickinessPoliciesContainer = try lbCookieStickinessPoliciesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy].self, forKey: .member)
                var lbCookieStickinessPoliciesBuffer:[ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]? = nil
                if let lbCookieStickinessPoliciesContainer = lbCookieStickinessPoliciesContainer {
                    lbCookieStickinessPoliciesBuffer = [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]()
                    for structureContainer0 in lbCookieStickinessPoliciesContainer {
                        lbCookieStickinessPoliciesBuffer?.append(structureContainer0)
                    }
                }
                lbCookieStickinessPolicies = lbCookieStickinessPoliciesBuffer
            } else {
                lbCookieStickinessPolicies = []
            }
        } else {
            lbCookieStickinessPolicies = nil
        }
        if containerValues.contains(.otherPolicies) {
            struct KeyVal0{struct member{}}
            let otherPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .otherPolicies)
            if let otherPoliciesWrappedContainer = otherPoliciesWrappedContainer {
                let otherPoliciesContainer = try otherPoliciesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var otherPoliciesBuffer:[Swift.String]? = nil
                if let otherPoliciesContainer = otherPoliciesContainer {
                    otherPoliciesBuffer = [Swift.String]()
                    for stringContainer0 in otherPoliciesContainer {
                        otherPoliciesBuffer?.append(stringContainer0)
                    }
                }
                otherPolicies = otherPoliciesBuffer
            } else {
                otherPolicies = []
            }
        } else {
            otherPolicies = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The policies for a load balancer.
    public struct Policies: Swift.Equatable {
        /// The stickiness policies created using [CreateAppCookieStickinessPolicy].
        public var appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]?
        /// The stickiness policies created using [CreateLBCookieStickinessPolicy].
        public var lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public var otherPolicies: [Swift.String]?

        public init (
            appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]? = nil,
            lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]? = nil,
            otherPolicies: [Swift.String]? = nil
        )
        {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute.
    public struct PolicyAttribute: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init (
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttributeDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute.
    public struct PolicyAttributeDescription: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init (
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
        case cardinality = "Cardinality"
        case defaultValue = "DefaultValue"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeType = attributeType {
            try container.encode(attributeType, forKey: ClientRuntime.Key("AttributeType"))
        }
        if let cardinality = cardinality {
            try container.encode(cardinality, forKey: ClientRuntime.Key("Cardinality"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let cardinalityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cardinality)
        cardinality = cardinalityDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute type.
    public struct PolicyAttributeTypeDescription: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The type of the attribute. For example, Boolean or Integer.
        public var attributeType: Swift.String?
        /// The cardinality of the attribute. Valid values:
        ///
        /// * ONE(1) : Single value required
        ///
        /// * ZERO_OR_ONE(0..1) : Up to one value is allowed
        ///
        /// * ZERO_OR_MORE(0..*) : Optional. Multiple values are allowed
        ///
        /// * ONE_OR_MORE(1..*0) : Required. Multiple values are allowed
        public var cardinality: Swift.String?
        /// The default value of the attribute, if applicable.
        public var defaultValue: Swift.String?
        /// A description of the attribute.
        public var description: Swift.String?

        public init (
            attributeName: Swift.String? = nil,
            attributeType: Swift.String? = nil,
            cardinality: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
            self.cardinality = cardinality
            self.defaultValue = defaultValue
            self.description = description
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyAttributeDescriptions = "PolicyAttributeDescriptions"
        case policyName = "PolicyName"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyAttributeDescriptions = policyAttributeDescriptions {
            if !policyAttributeDescriptions.isEmpty {
                var policyAttributeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeDescriptions"))
                for (index0, policyattributedescription0) in policyAttributeDescriptions.enumerated() {
                    try policyAttributeDescriptionsContainer.encode(policyattributedescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeDescriptions"))
                try policyAttributeDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTypeName)
        policyTypeName = policyTypeNameDecoded
        if containerValues.contains(.policyAttributeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyAttributeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyAttributeDescriptions)
            if let policyAttributeDescriptionsWrappedContainer = policyAttributeDescriptionsWrappedContainer {
                let policyAttributeDescriptionsContainer = try policyAttributeDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.PolicyAttributeDescription].self, forKey: .member)
                var policyAttributeDescriptionsBuffer:[ElasticLoadBalancingClientTypes.PolicyAttributeDescription]? = nil
                if let policyAttributeDescriptionsContainer = policyAttributeDescriptionsContainer {
                    policyAttributeDescriptionsBuffer = [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]()
                    for structureContainer0 in policyAttributeDescriptionsContainer {
                        policyAttributeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyAttributeDescriptions = policyAttributeDescriptionsBuffer
            } else {
                policyAttributeDescriptions = []
            }
        } else {
            policyAttributeDescriptions = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy.
    public struct PolicyDescription: Swift.Equatable {
        /// The policy attributes.
        public var policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]?
        /// The name of the policy.
        public var policyName: Swift.String?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init (
            policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]? = nil,
            policyName: Swift.String? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.policyAttributeDescriptions = policyAttributeDescriptions
            self.policyName = policyName
            self.policyTypeName = policyTypeName
        }
    }

}

extension PolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified policies do not exist.
public struct PolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingClientTypes.PolicyTypeDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case policyAttributeTypeDescriptions = "PolicyAttributeTypeDescriptions"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let policyAttributeTypeDescriptions = policyAttributeTypeDescriptions {
            if !policyAttributeTypeDescriptions.isEmpty {
                var policyAttributeTypeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeTypeDescriptions"))
                for (index0, policyattributetypedescription0) in policyAttributeTypeDescriptions.enumerated() {
                    try policyAttributeTypeDescriptionsContainer.encode(policyattributetypedescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributeTypeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeTypeDescriptions"))
                try policyAttributeTypeDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTypeName)
        policyTypeName = policyTypeNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        if containerValues.contains(.policyAttributeTypeDescriptions) {
            struct KeyVal0{struct member{}}
            let policyAttributeTypeDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyAttributeTypeDescriptions)
            if let policyAttributeTypeDescriptionsWrappedContainer = policyAttributeTypeDescriptionsWrappedContainer {
                let policyAttributeTypeDescriptionsContainer = try policyAttributeTypeDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription].self, forKey: .member)
                var policyAttributeTypeDescriptionsBuffer:[ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]? = nil
                if let policyAttributeTypeDescriptionsContainer = policyAttributeTypeDescriptionsContainer {
                    policyAttributeTypeDescriptionsBuffer = [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]()
                    for structureContainer0 in policyAttributeTypeDescriptionsContainer {
                        policyAttributeTypeDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                policyAttributeTypeDescriptions = policyAttributeTypeDescriptionsBuffer
            } else {
                policyAttributeTypeDescriptions = []
            }
        } else {
            policyAttributeTypeDescriptions = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy type.
    public struct PolicyTypeDescription: Swift.Equatable {
        /// A description of the policy type.
        public var description: Swift.String?
        /// The description of the policy attributes associated with the policies defined by Elastic Load Balancing.
        public var policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init (
            description: Swift.String? = nil,
            policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.description = description
            self.policyAttributeTypeDescriptions = policyAttributeTypeDescriptions
            self.policyTypeName = policyTypeName
        }
    }

}

extension PolicyTypeNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<PolicyTypeNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified policy types do not exist.
public struct PolicyTypeNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyTypeNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyTypeNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegisterInstancesWithLoadBalancerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("RegisterInstancesWithLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension RegisterInstancesWithLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerInput: Swift.Equatable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init (
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

struct RegisterInstancesWithLoadBalancerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let instances: [ElasticLoadBalancingClientTypes.Instance]?
}

extension RegisterInstancesWithLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

extension RegisterInstancesWithLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterInstancesWithLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInstance" : self = .invalidEndPointException(try InvalidEndPointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterInstancesWithLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidEndPointException(InvalidEndPointException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterInstancesWithLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterInstancesWithLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// Contains the output of RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerOutputResponse: Swift.Equatable {
    /// The updated list of instances for the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init (
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct RegisterInstancesWithLoadBalancerOutputResponseBody: Swift.Equatable {
    let instances: [ElasticLoadBalancingClientTypes.Instance]?
}

extension RegisterInstancesWithLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RegisterInstancesWithLoadBalancerResult"))
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Instance].self, forKey: .member)
                var instancesBuffer:[ElasticLoadBalancingClientTypes.Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [ElasticLoadBalancingClientTypes.Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
    }
}

extension RemoveTagsInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tagkeyonly0) in tags.enumerated() {
                    try tagsContainer.encode(tagkeyonly0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("RemoveTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for RemoveTags.
public struct RemoveTagsInput: Swift.Equatable {
    /// The name of the load balancer. You can specify a maximum of one load balancer name.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The list of tag keys to remove.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]?

    public init (
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let loadBalancerNames: [Swift.String]?
    let tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerNamesBuffer:[Swift.String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.TagKeyOnly].self, forKey: .member)
                var tagsBuffer:[ElasticLoadBalancingClientTypes.TagKeyOnly]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElasticLoadBalancingClientTypes.TagKeyOnly]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension RemoveTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of RemoveTags.
public struct RemoveTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension SetLoadBalancerListenerSSLCertificateInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let sslCertificateId = sslCertificateId {
            try container.encode(sslCertificateId, forKey: ClientRuntime.Key("SSLCertificateId"))
        }
        try container.encode("SetLoadBalancerListenerSSLCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerListenerSSLCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The port that uses the specified SSL certificate.
    /// This member is required.
    public var loadBalancerPort: Swift.Int
    /// The Amazon Resource Name (ARN) of the SSL certificate.
    /// This member is required.
    public var sslCertificateId: Swift.String?

    public init (
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int = 0,
        sslCertificateId: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.sslCertificateId = sslCertificateId
    }
}

struct SetLoadBalancerListenerSSLCertificateInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let loadBalancerPort: Swift.Int
    let sslCertificateId: Swift.String?
}

extension SetLoadBalancerListenerSSLCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPort = "LoadBalancerPort"
        case sslCertificateId = "SSLCertificateId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let loadBalancerPortDecoded = try containerValues.decode(Swift.Int.self, forKey: .loadBalancerPort)
        loadBalancerPort = loadBalancerPortDecoded
        let sslCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCertificateId)
        sslCertificateId = sslCertificateIdDecoded
    }
}

extension SetLoadBalancerListenerSSLCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerListenerSSLCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFound" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFound" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocol" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetLoadBalancerListenerSSLCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case certificateNotFoundException(CertificateNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case listenerNotFoundException(ListenerNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerListenerSSLCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateOutputResponse: Swift.Equatable {

    public init () { }
}

extension SetLoadBalancerPoliciesForBackendServerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instancePort = instancePort {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetLoadBalancerPoliciesForBackendServer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerPoliciesForBackendServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerInput: Swift.Equatable {
    /// The port number associated with the EC2 instance.
    /// This member is required.
    public var instancePort: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init (
        instancePort: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.instancePort = instancePort
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

struct SetLoadBalancerPoliciesForBackendServerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let instancePort: Swift.Int?
    let policyNames: [Swift.String]?
}

extension SetLoadBalancerPoliciesForBackendServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case loadBalancerName = "LoadBalancerName"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let instancePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instancePort)
        instancePort = instancePortDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetLoadBalancerPoliciesForBackendServerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerPoliciesForBackendServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerOutputResponse: Swift.Equatable {

    public init () { }
}

extension SetLoadBalancerPoliciesOfListenerInput: Swift.Encodable {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetLoadBalancerPoliciesOfListener", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerPoliciesOfListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The external port of the load balancer.
    /// This member is required.
    public var loadBalancerPort: Swift.Int
    /// The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init (
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int = 0,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.policyNames = policyNames
    }
}

struct SetLoadBalancerPoliciesOfListenerInputBody: Swift.Equatable {
    let loadBalancerName: Swift.String?
    let loadBalancerPort: Swift.Int
    let policyNames: [Swift.String]?
}

extension SetLoadBalancerPoliciesOfListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPort = "LoadBalancerPort"
        case policyNames = "PolicyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let loadBalancerPortDecoded = try containerValues.decode(Swift.Int.self, forKey: .loadBalancerPort)
        loadBalancerPort = loadBalancerPortDecoded
        if containerValues.contains(.policyNames) {
            struct KeyVal0{struct member{}}
            let policyNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyNames)
            if let policyNamesWrappedContainer = policyNamesWrappedContainer {
                let policyNamesContainer = try policyNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyNamesBuffer:[Swift.String]? = nil
                if let policyNamesContainer = policyNamesContainer {
                    policyNamesBuffer = [Swift.String]()
                    for stringContainer0 in policyNamesContainer {
                        policyNamesBuffer?.append(stringContainer0)
                    }
                }
                policyNames = policyNamesBuffer
            } else {
                policyNames = []
            }
        } else {
            policyNames = nil
        }
    }
}

extension SetLoadBalancerPoliciesOfListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetLoadBalancerPoliciesOfListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFound" : self = .accessPointNotFoundException(try AccessPointNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequest" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFound" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyNotFound" : self = .policyNotFoundException(try PolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetLoadBalancerPoliciesOfListenerOutputError: Swift.Error, Swift.Equatable {
    case accessPointNotFoundException(AccessPointNotFoundException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case listenerNotFoundException(ListenerNotFoundException)
    case policyNotFoundException(PolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetLoadBalancerPoliciesOfListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Contains the output of SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerOutputResponse: Swift.Equatable {

    public init () { }
}

extension ElasticLoadBalancingClientTypes.SourceSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case ownerAlias = "OwnerAlias"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let ownerAlias = ownerAlias {
            try container.encode(ownerAlias, forKey: ClientRuntime.Key("OwnerAlias"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAlias)
        ownerAlias = ownerAliasDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a source security group.
    public struct SourceSecurityGroup: Swift.Equatable {
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The owner of the security group.
        public var ownerAlias: Swift.String?

        public init (
            groupName: Swift.String? = nil,
            ownerAlias: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }
    }

}

extension SubnetNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<SubnetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the specified subnets do not exist.
public struct SubnetNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SubnetNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingClientTypes.TagDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElasticLoadBalancingClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElasticLoadBalancingClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElasticLoadBalancingClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The tags associated with a load balancer.
    public struct TagDescription: Swift.Equatable {
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The tags.
        public var tags: [ElasticLoadBalancingClientTypes.Tag]?

        public init (
            loadBalancerName: Swift.String? = nil,
            tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
        )
        {
            self.loadBalancerName = loadBalancerName
            self.tags = tags
        }
    }

}

extension ElasticLoadBalancingClientTypes.TagKeyOnly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The key of a tag.
    public struct TagKeyOnly: Swift.Equatable {
        /// The name of the key.
        public var key: Swift.String?

        public init (
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }

}

extension TooManyAccessPointsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyAccessPointsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for the number of load balancers has been reached.
public struct TooManyAccessPointsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyAccessPointsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyAccessPointsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPoliciesException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyPoliciesExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for the number of policies for this load balancer has been reached.
public struct TooManyPoliciesException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPoliciesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyPoliciesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for the number of tags that can be assigned to a load balancer has been reached.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedProtocolException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData(),
            let responseDecoder = decoder {
            let output: AWSClientRuntime.ErrorResponseContainer<UnsupportedProtocolExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified protocol or signature version is not supported.
public struct UnsupportedProtocolException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedProtocolExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedProtocolExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
