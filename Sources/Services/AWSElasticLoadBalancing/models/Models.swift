// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension ElasticLoadBalancingClientTypes.AccessLog: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emitInterval = "EmitInterval"
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case s3BucketPrefix = "S3BucketPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let emitInterval = emitInterval {
            try container.encode(emitInterval, forKey: ClientRuntime.Key("EmitInterval"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3BucketPrefix = s3BucketPrefix {
            try container.encode(s3BucketPrefix, forKey: ClientRuntime.Key("S3BucketPrefix"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.AccessLog, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.AccessLog()
            value.enabled = try reader["Enabled"].readIfPresent() ?? false
            value.s3BucketName = try reader["S3BucketName"].readIfPresent()
            value.emitInterval = try reader["EmitInterval"].readIfPresent()
            value.s3BucketPrefix = try reader["S3BucketPrefix"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the AccessLog attribute.
    public struct AccessLog: Swift.Equatable {
        /// The interval for publishing the access logs. You can specify an interval of either 5 minutes or 60 minutes. Default: 60 minutes
        public var emitInterval: Swift.Int?
        /// Specifies whether access logs are enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The name of the Amazon S3 bucket where the access logs are stored.
        public var s3BucketName: Swift.String?
        /// The logical hierarchy you created for your Amazon S3 bucket, for example my-bucket-prefix/prod. If the prefix is not provided, the log is placed at the root level of the bucket.
        public var s3BucketPrefix: Swift.String?

        public init(
            emitInterval: Swift.Int? = nil,
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            s3BucketPrefix: Swift.String? = nil
        )
        {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }
    }

}

extension AccessPointNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = AccessPointNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified load balancer does not exist.
public struct AccessPointNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadBalancerNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("AddTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddTagsInput {

    static func urlPathProvider(_ value: AddTagsInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for AddTags.
public struct AddTagsInput: Swift.Equatable {
    /// The name of the load balancer. You can specify one load balancer only.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The tags.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

extension AddTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AddTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AddTagsOutput()
        }
    }
}

/// Contains the output of AddTags.
public struct AddTagsOutput: Swift.Equatable {

    public init() { }
}

enum AddTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicateTagKeys": return try await DuplicateTagKeysException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyTags": return try await TooManyTagsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.AdditionalAttribute: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.AdditionalAttribute, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.AdditionalAttribute()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about additional load balancer attributes.
    public struct AdditionalAttribute: Swift.Equatable {
        /// The name of the attribute. The following attribute is supported.
        ///
        /// * elb.http.desyncmitigationmode - Determines how the load balancer handles requests that might pose a security risk to your application. The possible values are monitor, defensive, and strictest. The default is defensive.
        public var key: Swift.String?
        /// This value of the attribute.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieName = "CookieName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: ClientRuntime.Key("CookieName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.cookieName = try reader["CookieName"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy for application-controlled session stickiness.
    public struct AppCookieStickinessPolicy: Swift.Equatable {
        /// The name of the application cookie used for stickiness.
        public var cookieName: Swift.String?
        /// The mnemonic name for the policy being created. The name must be unique within a set of policies for this load balancer.
        public var policyName: Swift.String?

        public init(
            cookieName: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieName = cookieName
            self.policyName = policyName
        }
    }

}

extension ApplySecurityGroupsToLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case securityGroups = "SecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("ApplySecurityGroupsToLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ApplySecurityGroupsToLoadBalancerInput {

    static func urlPathProvider(_ value: ApplySecurityGroupsToLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the security groups to associate with the load balancer. Note that you cannot specify the name of the security group.
    /// This member is required.
    public var securityGroups: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.securityGroups = securityGroups
    }
}

extension ApplySecurityGroupsToLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ApplySecurityGroupsToLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ApplySecurityGroupsToLoadBalancerResult"]
            var value = ApplySecurityGroupsToLoadBalancerOutput()
            value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of ApplySecurityGroupsToLoadBalancer.
public struct ApplySecurityGroupsToLoadBalancerOutput: Swift.Equatable {
    /// The IDs of the security groups associated with the load balancer.
    public var securityGroups: [Swift.String]?

    public init(
        securityGroups: [Swift.String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

enum ApplySecurityGroupsToLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurityGroup": return try await InvalidSecurityGroupException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AttachLoadBalancerToSubnetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("AttachLoadBalancerToSubnets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension AttachLoadBalancerToSubnetsInput {

    static func urlPathProvider(_ value: AttachLoadBalancerToSubnetsInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for AttachLoaBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets to add. You can add only one subnet per Availability Zone.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

extension AttachLoadBalancerToSubnetsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AttachLoadBalancerToSubnetsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["AttachLoadBalancerToSubnetsResult"]
            var value = AttachLoadBalancerToSubnetsOutput()
            value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of AttachLoadBalancerToSubnets.
public struct AttachLoadBalancerToSubnetsOutput: Swift.Equatable {
    /// The IDs of the subnets attached to the load balancer.
    public var subnets: [Swift.String]?

    public init(
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

enum AttachLoadBalancerToSubnetsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSubnet": return try await InvalidSubnetException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "SubnetNotFound": return try await SubnetNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.BackendServerDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instancePort = instancePort {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.BackendServerDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.BackendServerDescription()
            value.instancePort = try reader["InstancePort"].readIfPresent()
            value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the configuration of an EC2 instance.
    public struct BackendServerDescription: Swift.Equatable {
        /// The port on which the EC2 instance is listening.
        public var instancePort: Swift.Int?
        /// The names of the policies enabled for the EC2 instance.
        public var policyNames: [Swift.String]?

        public init(
            instancePort: Swift.Int? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }
    }

}

extension CertificateNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = CertificateNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified ARN does not refer to a valid SSL certificate in AWS Identity and Access Management (IAM) or AWS Certificate Manager (ACM). Note that if you recently uploaded the certificate to IAM, this error might indicate that the certificate is not fully available yet.
public struct CertificateNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CertificateNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigureHealthCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck = "HealthCheck"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: ClientRuntime.Key("HealthCheck"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("ConfigureHealthCheck", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ConfigureHealthCheckInput {

    static func urlPathProvider(_ value: ConfigureHealthCheckInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ConfigureHealthCheck.
public struct ConfigureHealthCheckInput: Swift.Equatable {
    /// The configuration information.
    /// This member is required.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.loadBalancerName = loadBalancerName
    }
}

extension ConfigureHealthCheckOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ConfigureHealthCheckOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ConfigureHealthCheckResult"]
            var value = ConfigureHealthCheckOutput()
            value.healthCheck = try reader["HealthCheck"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.HealthCheck.readingClosure)
            return value
        }
    }
}

/// Contains the output of ConfigureHealthCheck.
public struct ConfigureHealthCheckOutput: Swift.Equatable {
    /// The updated health check.
    public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?

    public init(
        healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil
    )
    {
        self.healthCheck = healthCheck
    }
}

enum ConfigureHealthCheckOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.ConnectionDraining: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let timeout = timeout {
            try container.encode(timeout, forKey: ClientRuntime.Key("Timeout"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.ConnectionDraining, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.ConnectionDraining()
            value.enabled = try reader["Enabled"].readIfPresent() ?? false
            value.timeout = try reader["Timeout"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the ConnectionDraining attribute.
    public struct ConnectionDraining: Swift.Equatable {
        /// Specifies whether connection draining is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public var timeout: Swift.Int?

        public init(
            enabled: Swift.Bool = false,
            timeout: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.timeout = timeout
        }
    }

}

extension ElasticLoadBalancingClientTypes.ConnectionSettings: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idleTimeout = "IdleTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let idleTimeout = idleTimeout {
            try container.encode(idleTimeout, forKey: ClientRuntime.Key("IdleTimeout"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.ConnectionSettings, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.ConnectionSettings()
            value.idleTimeout = try reader["IdleTimeout"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the ConnectionSettings attribute.
    public struct ConnectionSettings: Swift.Equatable {
        /// The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer.
        /// This member is required.
        public var idleTimeout: Swift.Int?

        public init(
            idleTimeout: Swift.Int? = nil
        )
        {
            self.idleTimeout = idleTimeout
        }
    }

}

extension CreateAppCookieStickinessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieName = "CookieName"
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieName = cookieName {
            try container.encode(cookieName, forKey: ClientRuntime.Key("CookieName"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("CreateAppCookieStickinessPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateAppCookieStickinessPolicyInput {

    static func urlPathProvider(_ value: CreateAppCookieStickinessPolicyInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyInput: Swift.Equatable {
    /// The name of the application cookie used for stickiness.
    /// This member is required.
    public var cookieName: Swift.String?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        cookieName: Swift.String? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieName = cookieName
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension CreateAppCookieStickinessPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateAppCookieStickinessPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateAppCookieStickinessPolicyOutput()
        }
    }
}

/// Contains the output for CreateAppCookieStickinessPolicy.
public struct CreateAppCookieStickinessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum CreateAppCookieStickinessPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicatePolicyName": return try await DuplicatePolicyNameException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyPolicies": return try await TooManyPoliciesException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateLBCookieStickinessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: ClientRuntime.Key("CookieExpirationPeriod"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("CreateLBCookieStickinessPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLBCookieStickinessPolicyInput {

    static func urlPathProvider(_ value: CreateLBCookieStickinessPolicyInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyInput: Swift.Equatable {
    /// The time period, in seconds, after which the cookie should be considered stale. If you do not specify this parameter, the default value is 0, which indicates that the sticky session should last for the duration of the browser session.
    public var cookieExpirationPeriod: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy being created. Policy names must consist of alphanumeric characters and dashes (-). This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        cookieExpirationPeriod: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.cookieExpirationPeriod = cookieExpirationPeriod
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension CreateLBCookieStickinessPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateLBCookieStickinessPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateLBCookieStickinessPolicyOutput()
        }
    }
}

/// Contains the output for CreateLBCookieStickinessPolicy.
public struct CreateLBCookieStickinessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum CreateLBCookieStickinessPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicatePolicyName": return try await DuplicatePolicyNameException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyPolicies": return try await TooManyPoliciesException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case listeners = "Listeners"
        case loadBalancerName = "LoadBalancerName"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let listeners = listeners {
            if !listeners.isEmpty {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                for (index0, listener0) in listeners.enumerated() {
                    try listenersContainer.encode(listener0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                try listenersContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerInput {

    static func urlPathProvider(_ value: CreateLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancer.
public struct CreateLoadBalancerInput: Swift.Equatable {
    /// One or more Availability Zones from the same region as the load balancer. You must specify at least one Availability Zone. You can add more Availability Zones after you create the load balancer using [EnableAvailabilityZonesForLoadBalancer].
    public var availabilityZones: [Swift.String]?
    /// The listeners. For more information, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer. This name must be unique within your set of load balancers for the region, must have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and cannot begin or end with a hyphen.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The type of a load balancer. Valid only for load balancers in a VPC. By default, Elastic Load Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP addresses. For more information about Internet-facing and Internal load balancers, see [Load Balancer Scheme](https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#load-balancer-scheme) in the Elastic Load Balancing User Guide. Specify internal to create a load balancer with a DNS name that resolves to private IP addresses.
    public var scheme: Swift.String?
    /// The IDs of the security groups to assign to the load balancer.
    public var securityGroups: [Swift.String]?
    /// The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per Availability Zone specified in AvailabilityZones.
    public var subnets: [Swift.String]?
    /// A list of tags to assign to the load balancer. For more information about tagging your load balancer, see [Tag Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/add-remove-tags.html) in the Classic Load Balancers Guide.
    public var tags: [ElasticLoadBalancingClientTypes.Tag]?

    public init(
        availabilityZones: [Swift.String]? = nil,
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil,
        scheme: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
    }
}

extension CreateLoadBalancerListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listeners = listeners {
            if !listeners.isEmpty {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                for (index0, listener0) in listeners.enumerated() {
                    try listenersContainer.encode(listener0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Listeners"))
                try listenersContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("CreateLoadBalancerListeners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerListenersInput {

    static func urlPathProvider(_ value: CreateLoadBalancerListenersInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancerListeners.
public struct CreateLoadBalancerListenersInput: Swift.Equatable {
    /// The listeners.
    /// This member is required.
    public var listeners: [ElasticLoadBalancingClientTypes.Listener]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        listeners: [ElasticLoadBalancingClientTypes.Listener]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.loadBalancerName = loadBalancerName
    }
}

extension CreateLoadBalancerListenersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateLoadBalancerListenersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateLoadBalancerListenersOutput()
        }
    }
}

/// Contains the parameters for CreateLoadBalancerListener.
public struct CreateLoadBalancerListenersOutput: Swift.Equatable {

    public init() { }
}

enum CreateLoadBalancerListenersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "CertificateNotFound": return try await CertificateNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicateListener": return try await DuplicateListenerException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnsupportedProtocol": return try await UnsupportedProtocolException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateLoadBalancerResult"]
            var value = CreateLoadBalancerOutput()
            value.dnsName = try reader["DNSName"].readIfPresent()
            return value
        }
    }
}

/// Contains the output for CreateLoadBalancer.
public struct CreateLoadBalancerOutput: Swift.Equatable {
    /// The DNS name of the load balancer.
    public var dnsName: Swift.String?

    public init(
        dnsName: Swift.String? = nil
    )
    {
        self.dnsName = dnsName
    }
}

enum CreateLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "CertificateNotFound": return try await CertificateNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicateLoadBalancerName": return try await DuplicateAccessPointNameException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicateTagKeys": return try await DuplicateTagKeysException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidScheme": return try await InvalidSchemeException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurityGroup": return try await InvalidSecurityGroupException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSubnet": return try await InvalidSubnetException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "OperationNotPermitted": return try await OperationNotPermittedException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "SubnetNotFound": return try await SubnetNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyLoadBalancers": return try await TooManyAccessPointsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyTags": return try await TooManyTagsException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnsupportedProtocol": return try await UnsupportedProtocolException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateLoadBalancerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyAttributes = "PolicyAttributes"
        case policyName = "PolicyName"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyAttributes = policyAttributes {
            if !policyAttributes.isEmpty {
                var policyAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributes"))
                for (index0, policyattribute0) in policyAttributes.enumerated() {
                    try policyAttributesContainer.encode(policyattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributes"))
                try policyAttributesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
        try container.encode("CreateLoadBalancerPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateLoadBalancerPolicyInput {

    static func urlPathProvider(_ value: CreateLoadBalancerPolicyInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The policy attributes.
    public var policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]?
    /// The name of the load balancer policy to be created. This name must be unique within the set of policies for this load balancer.
    /// This member is required.
    public var policyName: Swift.String?
    /// The name of the base policy type. To get the list of policy types, use [DescribeLoadBalancerPolicyTypes].
    /// This member is required.
    public var policyTypeName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyAttributes: [ElasticLoadBalancingClientTypes.PolicyAttribute]? = nil,
        policyName: Swift.String? = nil,
        policyTypeName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyAttributes = policyAttributes
        self.policyName = policyName
        self.policyTypeName = policyTypeName
    }
}

extension CreateLoadBalancerPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateLoadBalancerPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateLoadBalancerPolicyOutput()
        }
    }
}

/// Contains the output of CreateLoadBalancerPolicy.
public struct CreateLoadBalancerPolicyOutput: Swift.Equatable {

    public init() { }
}

enum CreateLoadBalancerPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DuplicatePolicyName": return try await DuplicatePolicyNameException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyTypeNotFound": return try await PolicyTypeNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyPolicies": return try await TooManyPoliciesException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing()
            value.enabled = try reader["Enabled"].readIfPresent() ?? false
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the CrossZoneLoadBalancing attribute.
    public struct CrossZoneLoadBalancing: Swift.Equatable {
        /// Specifies whether cross-zone load balancing is enabled for the load balancer.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension DeleteLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DeleteLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancer.
public struct DeleteLoadBalancerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

extension DeleteLoadBalancerListenersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPorts = "LoadBalancerPorts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let loadBalancerPorts = loadBalancerPorts {
            if !loadBalancerPorts.isEmpty {
                var loadBalancerPortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerPorts"))
                for (index0, accesspointport0) in loadBalancerPorts.enumerated() {
                    try loadBalancerPortsContainer.encode(accesspointport0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerPortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerPorts"))
                try loadBalancerPortsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DeleteLoadBalancerListeners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerListenersInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerListenersInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The client port numbers of the listeners.
    /// This member is required.
    public var loadBalancerPorts: [Swift.Int]?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPorts: [Swift.Int]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPorts = loadBalancerPorts
    }
}

extension DeleteLoadBalancerListenersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteLoadBalancerListenersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteLoadBalancerListenersOutput()
        }
    }
}

/// Contains the output of DeleteLoadBalancerListeners.
public struct DeleteLoadBalancerListenersOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoadBalancerListenersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteLoadBalancerOutput()
        }
    }
}

/// Contains the output of DeleteLoadBalancer.
public struct DeleteLoadBalancerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteLoadBalancerPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        try container.encode("DeleteLoadBalancerPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteLoadBalancerPolicyInput {

    static func urlPathProvider(_ value: DeleteLoadBalancerPolicyInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var policyName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyName = policyName
    }
}

extension DeleteLoadBalancerPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteLoadBalancerPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteLoadBalancerPolicyOutput()
        }
    }
}

/// Contains the output of DeleteLoadBalancerPolicy.
public struct DeleteLoadBalancerPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoadBalancerPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DependencyThrottleException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DependencyThrottleException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A request made by Elastic Load Balancing to another service exceeds the maximum request rate permitted for your account.
public struct DependencyThrottleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyThrottle" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeregisterInstancesFromLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DeregisterInstancesFromLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeregisterInstancesFromLoadBalancerInput {

    static func urlPathProvider(_ value: DeregisterInstancesFromLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerInput: Swift.Equatable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension DeregisterInstancesFromLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeregisterInstancesFromLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DeregisterInstancesFromLoadBalancerResult"]
            var value = DeregisterInstancesFromLoadBalancerOutput()
            value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of DeregisterInstancesFromLoadBalancer.
public struct DeregisterInstancesFromLoadBalancerOutput: Swift.Equatable {
    /// The remaining instances registered with the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

enum DeregisterInstancesFromLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInstance": return try await InvalidEndPointException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeAccountLimitsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pageSize = "PageSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeAccountLimits", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeAccountLimitsInput {

    static func urlPathProvider(_ value: DescribeAccountLimitsInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAccountLimitsInput: Swift.Equatable {
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call.
    public var pageSize: Swift.Int?

    public init(
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeAccountLimitsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeAccountLimitsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeAccountLimitsResult"]
            var value = DescribeAccountLimitsOutput()
            value.limits = try reader["Limits"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Limit.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            return value
        }
    }
}

public struct DescribeAccountLimitsOutput: Swift.Equatable {
    /// Information about the limits.
    public var limits: [ElasticLoadBalancingClientTypes.Limit]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init(
        limits: [ElasticLoadBalancingClientTypes.Limit]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

enum DescribeAccountLimitsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeInstanceHealthInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DescribeInstanceHealth", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeInstanceHealthInput {

    static func urlPathProvider(_ value: DescribeInstanceHealthInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeInstanceHealth.
public struct DescribeInstanceHealthInput: Swift.Equatable {
    /// The IDs of the instances.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension DescribeInstanceHealthOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeInstanceHealthOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeInstanceHealthResult"]
            var value = DescribeInstanceHealthOutput()
            value.instanceStates = try reader["InstanceStates"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.InstanceState.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output for DescribeInstanceHealth.
public struct DescribeInstanceHealthOutput: Swift.Equatable {
    /// Information about the health of the instances.
    public var instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]?

    public init(
        instanceStates: [ElasticLoadBalancingClientTypes.InstanceState]? = nil
    )
    {
        self.instanceStates = instanceStates
    }
}

enum DescribeInstanceHealthOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInstance": return try await InvalidEndPointException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeLoadBalancerAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DescribeLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerAttributesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
    }
}

extension DescribeLoadBalancerAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeLoadBalancerAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeLoadBalancerAttributesResult"]
            var value = DescribeLoadBalancerAttributesOutput()
            value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.LoadBalancerAttributes.readingClosure)
            return value
        }
    }
}

/// Contains the output of DescribeLoadBalancerAttributes.
public struct DescribeLoadBalancerAttributesOutput: Swift.Equatable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
    }
}

enum DescribeLoadBalancerAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LoadBalancerAttributeNotFound": return try await LoadBalancerAttributeNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeLoadBalancerPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeLoadBalancerPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerPoliciesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerPoliciesInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesInput: Swift.Equatable {
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?
    /// The names of the policies.
    public var policyNames: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

extension DescribeLoadBalancerPoliciesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeLoadBalancerPoliciesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeLoadBalancerPoliciesResult"]
            var value = DescribeLoadBalancerPoliciesOutput()
            value.policyDescriptions = try reader["PolicyDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicies.
public struct DescribeLoadBalancerPoliciesOutput: Swift.Equatable {
    /// Information about the policies.
    public var policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]?

    public init(
        policyDescriptions: [ElasticLoadBalancingClientTypes.PolicyDescription]? = nil
    )
    {
        self.policyDescriptions = policyDescriptions
    }
}

enum DescribeLoadBalancerPoliciesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotFound": return try await PolicyNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeLoadBalancerPolicyTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyTypeNames = "PolicyTypeNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyTypeNames = policyTypeNames {
            if !policyTypeNames.isEmpty {
                var policyTypeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyTypeNames"))
                for (index0, policytypename0) in policyTypeNames.enumerated() {
                    try policyTypeNamesContainer.encode(policytypename0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyTypeNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyTypeNames"))
                try policyTypeNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeLoadBalancerPolicyTypes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancerPolicyTypesInput {

    static func urlPathProvider(_ value: DescribeLoadBalancerPolicyTypesInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesInput: Swift.Equatable {
    /// The names of the policy types. If no names are specified, describes all policy types defined by Elastic Load Balancing.
    public var policyTypeNames: [Swift.String]?

    public init(
        policyTypeNames: [Swift.String]? = nil
    )
    {
        self.policyTypeNames = policyTypeNames
    }
}

extension DescribeLoadBalancerPolicyTypesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeLoadBalancerPolicyTypesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeLoadBalancerPolicyTypesResult"]
            var value = DescribeLoadBalancerPolicyTypesOutput()
            value.policyTypeDescriptions = try reader["PolicyTypeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyTypeDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of DescribeLoadBalancerPolicyTypes.
public struct DescribeLoadBalancerPolicyTypesOutput: Swift.Equatable {
    /// Information about the policy types.
    public var policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]?

    public init(
        policyTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyTypeDescription]? = nil
    )
    {
        self.policyTypeDescriptions = policyTypeDescriptions
    }
}

enum DescribeLoadBalancerPolicyTypesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "PolicyTypeNotFound": return try await PolicyTypeNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeLoadBalancersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case marker = "Marker"
        case pageSize = "PageSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeLoadBalancers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeLoadBalancersInput {

    static func urlPathProvider(_ value: DescribeLoadBalancersInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersInput: Swift.Equatable {
    /// The names of the load balancers.
    public var loadBalancerNames: [Swift.String]?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The maximum number of results to return with this call (a number from 1 to 400). The default is 400.
    public var pageSize: Swift.Int?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeLoadBalancersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeLoadBalancersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeLoadBalancersResult"]
            var value = DescribeLoadBalancersOutput()
            value.loadBalancerDescriptions = try reader["LoadBalancerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.LoadBalancerDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.nextMarker = try reader["NextMarker"].readIfPresent()
            return value
        }
    }
}

/// Contains the parameters for DescribeLoadBalancers.
public struct DescribeLoadBalancersOutput: Swift.Equatable {
    /// Information about the load balancers.
    public var loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var nextMarker: Swift.String?

    public init(
        loadBalancerDescriptions: [ElasticLoadBalancingClientTypes.LoadBalancerDescription]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.loadBalancerDescriptions = loadBalancerDescriptions
        self.nextMarker = nextMarker
    }
}

enum DescribeLoadBalancersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "DependencyThrottle": return try await DependencyThrottleException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DescribeTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DescribeTagsInput {

    static func urlPathProvider(_ value: DescribeTagsInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DescribeTags.
public struct DescribeTagsInput: Swift.Equatable {
    /// The names of the load balancers.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?

    public init(
        loadBalancerNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
    }
}

extension DescribeTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DescribeTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DescribeTagsResult"]
            var value = DescribeTagsOutput()
            value.tagDescriptions = try reader["TagDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.TagDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output for DescribeTags.
public struct DescribeTagsOutput: Swift.Equatable {
    /// Information about the tags.
    public var tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]?

    public init(
        tagDescriptions: [ElasticLoadBalancingClientTypes.TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

enum DescribeTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DetachLoadBalancerFromSubnetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("DetachLoadBalancerFromSubnets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DetachLoadBalancerFromSubnetsInput {

    static func urlPathProvider(_ value: DetachLoadBalancerFromSubnetsInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The IDs of the subnets.
    /// This member is required.
    public var subnets: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.subnets = subnets
    }
}

extension DetachLoadBalancerFromSubnetsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DetachLoadBalancerFromSubnetsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DetachLoadBalancerFromSubnetsResult"]
            var value = DetachLoadBalancerFromSubnetsOutput()
            value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of DetachLoadBalancerFromSubnets.
public struct DetachLoadBalancerFromSubnetsOutput: Swift.Equatable {
    /// The IDs of the remaining subnets for the load balancer.
    public var subnets: [Swift.String]?

    public init(
        subnets: [Swift.String]? = nil
    )
    {
        self.subnets = subnets
    }
}

enum DetachLoadBalancerFromSubnetsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("DisableAvailabilityZonesForLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension DisableAvailabilityZonesForLoadBalancerInput {

    static func urlPathProvider(_ value: DisableAvailabilityZonesForLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerInput: Swift.Equatable {
    /// The Availability Zones.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

extension DisableAvailabilityZonesForLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DisableAvailabilityZonesForLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["DisableAvailabilityZonesForLoadBalancerResult"]
            var value = DisableAvailabilityZonesForLoadBalancerOutput()
            value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output for DisableAvailabilityZonesForLoadBalancer.
public struct DisableAvailabilityZonesForLoadBalancerOutput: Swift.Equatable {
    /// The remaining Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init(
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

enum DisableAvailabilityZonesForLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DuplicateAccessPointNameException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicateAccessPointNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified load balancer name already exists for this account.
public struct DuplicateAccessPointNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateLoadBalancerName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DuplicateListenerException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicateListenerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A listener already exists for the specified load balancer name and port, but with a different instance port, protocol, or SSL certificate.
public struct DuplicateListenerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateListener" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DuplicatePolicyNameException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicatePolicyNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A policy with the specified name already exists for this load balancer.
public struct DuplicatePolicyNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicatePolicyName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DuplicateTagKeysException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = DuplicateTagKeysException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A tag key was specified more than once.
public struct DuplicateTagKeysException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateTagKeys" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum ElasticLoadBalancingClientTypes {}

extension EnableAvailabilityZonesForLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("EnableAvailabilityZonesForLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension EnableAvailabilityZonesForLoadBalancerInput {

    static func urlPathProvider(_ value: EnableAvailabilityZonesForLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerInput: Swift.Equatable {
    /// The Availability Zones. These must be in the same region as the load balancer.
    /// This member is required.
    public var availabilityZones: [Swift.String]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        availabilityZones: [Swift.String]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.loadBalancerName = loadBalancerName
    }
}

extension EnableAvailabilityZonesForLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<EnableAvailabilityZonesForLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["EnableAvailabilityZonesForLoadBalancerResult"]
            var value = EnableAvailabilityZonesForLoadBalancerOutput()
            value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of EnableAvailabilityZonesForLoadBalancer.
public struct EnableAvailabilityZonesForLoadBalancerOutput: Swift.Equatable {
    /// The updated list of Availability Zones for the load balancer.
    public var availabilityZones: [Swift.String]?

    public init(
        availabilityZones: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
    }
}

enum EnableAvailabilityZonesForLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.HealthCheck: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case target = "Target"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthyThreshold = healthyThreshold {
            try container.encode(healthyThreshold, forKey: ClientRuntime.Key("HealthyThreshold"))
        }
        if let interval = interval {
            try container.encode(interval, forKey: ClientRuntime.Key("Interval"))
        }
        if let target = target {
            try container.encode(target, forKey: ClientRuntime.Key("Target"))
        }
        if let timeout = timeout {
            try container.encode(timeout, forKey: ClientRuntime.Key("Timeout"))
        }
        if let unhealthyThreshold = unhealthyThreshold {
            try container.encode(unhealthyThreshold, forKey: ClientRuntime.Key("UnhealthyThreshold"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.HealthCheck, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.HealthCheck()
            value.target = try reader["Target"].readIfPresent()
            value.interval = try reader["Interval"].readIfPresent()
            value.timeout = try reader["Timeout"].readIfPresent()
            value.unhealthyThreshold = try reader["UnhealthyThreshold"].readIfPresent()
            value.healthyThreshold = try reader["HealthyThreshold"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a health check.
    public struct HealthCheck: Swift.Equatable {
        /// The number of consecutive health checks successes required before moving the instance to the Healthy state.
        /// This member is required.
        public var healthyThreshold: Swift.Int?
        /// The approximate interval, in seconds, between health checks of an individual instance.
        /// This member is required.
        public var interval: Swift.Int?
        /// The instance being checked. The protocol is either TCP, HTTP, HTTPS, or SSL. The range of valid ports is one (1) through 65535. TCP is the default, specified as a TCP: port pair, for example "TCP:5000". In this case, a health check simply attempts to open a TCP connection to the instance on the specified port. Failure to connect within the configured timeout is considered unhealthy. SSL is also specified as SSL: port pair, for example, SSL:5000. For HTTP/HTTPS, you must include a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing; grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP GET request is issued to the instance on the given port and path. Any answer other than "200 OK" within the timeout period is considered unhealthy. The total length of the HTTP ping target must be 1024 16-bit Unicode characters or less.
        /// This member is required.
        public var target: Swift.String?
        /// The amount of time, in seconds, during which no response means a failed health check. This value must be less than the Interval value.
        /// This member is required.
        public var timeout: Swift.Int?
        /// The number of consecutive health check failures required before moving the instance to the Unhealthy state.
        /// This member is required.
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            target: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension ElasticLoadBalancingClientTypes.Instance: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: ClientRuntime.Key("InstanceId"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.Instance, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.Instance()
            value.instanceId = try reader["InstanceId"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The ID of an EC2 instance.
    public struct Instance: Swift.Equatable {
        /// The instance ID.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension ElasticLoadBalancingClientTypes.InstanceState: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceId = "InstanceId"
        case reasonCode = "ReasonCode"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: ClientRuntime.Key("InstanceId"))
        }
        if let reasonCode = reasonCode {
            try container.encode(reasonCode, forKey: ClientRuntime.Key("ReasonCode"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.InstanceState, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.InstanceState()
            value.instanceId = try reader["InstanceId"].readIfPresent()
            value.state = try reader["State"].readIfPresent()
            value.reasonCode = try reader["ReasonCode"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about the state of an EC2 instance.
    public struct InstanceState: Swift.Equatable {
        /// A description of the instance state. This string can contain one or more of the following messages.
        ///
        /// * N/A
        ///
        /// * A transient error occurred. Please try again later.
        ///
        /// * Instance has failed at least the UnhealthyThreshold number of health checks consecutively.
        ///
        /// * Instance has not passed the configured HealthyThreshold number of health checks consecutively.
        ///
        /// * Instance registration is still in progress.
        ///
        /// * Instance is in the EC2 Availability Zone for which LoadBalancer is not configured to route traffic to.
        ///
        /// * Instance is not currently registered with the LoadBalancer.
        ///
        /// * Instance deregistration currently in progress.
        ///
        /// * Disable Availability Zone is currently in progress.
        ///
        /// * Instance is in pending state.
        ///
        /// * Instance is in stopped state.
        ///
        /// * Instance is in terminated state.
        public var description: Swift.String?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// Information about the cause of OutOfService instances. Specifically, whether the cause is Elastic Load Balancing or the instance. Valid values: ELB | Instance | N/A
        public var reasonCode: Swift.String?
        /// The current state of the instance. Valid values: InService | OutOfService | Unknown
        public var state: Swift.String?

        public init(
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            reasonCode: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.description = description
            self.instanceId = instanceId
            self.reasonCode = reasonCode
            self.state = state
        }
    }

}

extension InvalidConfigurationRequestException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidConfigurationRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The requested configuration change is not valid.
public struct InvalidConfigurationRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfigurationRequest" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidEndPointException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidEndPointException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified endpoint is not valid.
public struct InvalidEndPointException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInstance" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSchemeException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidSchemeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified value for the schema is not valid. You can only specify a scheme for load balancers in a VPC.
public struct InvalidSchemeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidScheme" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSecurityGroupException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidSecurityGroupException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// One or more of the specified security groups do not exist.
public struct InvalidSecurityGroupException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurityGroup" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSubnetException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidSubnetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified VPC has no associated Internet gateway.
public struct InvalidSubnetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSubnet" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cookieExpirationPeriod = cookieExpirationPeriod {
            try container.encode(cookieExpirationPeriod, forKey: ClientRuntime.Key("CookieExpirationPeriod"))
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.cookieExpirationPeriod = try reader["CookieExpirationPeriod"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy for duration-based session stickiness.
    public struct LBCookieStickinessPolicy: Swift.Equatable {
        /// The time period, in seconds, after which the cookie should be considered stale. If this parameter is not specified, the stickiness session lasts for the duration of the browser session.
        public var cookieExpirationPeriod: Swift.Int?
        /// The name of the policy. This name must be unique within the set of policies for this load balancer.
        public var policyName: Swift.String?

        public init(
            cookieExpirationPeriod: Swift.Int? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }
    }

}

extension ElasticLoadBalancingClientTypes.Limit: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let max = max {
            try container.encode(max, forKey: ClientRuntime.Key("Max"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.Limit, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.Limit()
            value.name = try reader["Name"].readIfPresent()
            value.max = try reader["Max"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about an Elastic Load Balancing resource limit for your AWS account.
    public struct Limit: Swift.Equatable {
        /// The maximum value of the limit.
        public var max: Swift.String?
        /// The name of the limit. The possible values are:
        ///
        /// * classic-listeners
        ///
        /// * classic-load-balancers
        ///
        /// * classic-registered-instances
        public var name: Swift.String?

        public init(
            max: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.name = name
        }
    }

}

extension ElasticLoadBalancingClientTypes.Listener: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case instanceProtocol = "InstanceProtocol"
        case loadBalancerPort = "LoadBalancerPort"
        case `protocol` = "Protocol"
        case sslCertificateId = "SSLCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instancePort = instancePort {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let instanceProtocol = instanceProtocol {
            try container.encode(instanceProtocol, forKey: ClientRuntime.Key("InstanceProtocol"))
        }
        if loadBalancerPort != 0 {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let sslCertificateId = sslCertificateId {
            try container.encode(sslCertificateId, forKey: ClientRuntime.Key("SSLCertificateId"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.Listener, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.Listener()
            value.`protocol` = try reader["Protocol"].readIfPresent()
            value.loadBalancerPort = try reader["LoadBalancerPort"].readIfPresent() ?? 0
            value.instanceProtocol = try reader["InstanceProtocol"].readIfPresent()
            value.instancePort = try reader["InstancePort"].readIfPresent()
            value.sslCertificateId = try reader["SSLCertificateId"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a listener. For information about the protocols and the ports supported by Elastic Load Balancing, see [Listeners for Your Classic Load Balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html) in the Classic Load Balancers Guide.
    public struct Listener: Swift.Equatable {
        /// The port on which the instance is listening.
        /// This member is required.
        public var instancePort: Swift.Int?
        /// The protocol to use for routing traffic to instances: HTTP, HTTPS, TCP, or SSL. If the front-end protocol is TCP or SSL, the back-end protocol must be TCP or SSL. If the front-end protocol is HTTP or HTTPS, the back-end protocol must be HTTP or HTTPS. If there is another listener with the same InstancePort whose InstanceProtocol is secure, (HTTPS or SSL), the listener's InstanceProtocol must also be secure. If there is another listener with the same InstancePort whose InstanceProtocol is HTTP or TCP, the listener's InstanceProtocol must be HTTP or TCP.
        public var instanceProtocol: Swift.String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        /// This member is required.
        public var loadBalancerPort: Swift.Int
        /// The load balancer transport protocol to use for routing: HTTP, HTTPS, TCP, or SSL.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// The Amazon Resource Name (ARN) of the server certificate.
        public var sslCertificateId: Swift.String?

        public init(
            instancePort: Swift.Int? = nil,
            instanceProtocol: Swift.String? = nil,
            loadBalancerPort: Swift.Int = 0,
            `protocol`: Swift.String? = nil,
            sslCertificateId: Swift.String? = nil
        )
        {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }
    }

}

extension ElasticLoadBalancingClientTypes.ListenerDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listener = listener {
            try container.encode(listener, forKey: ClientRuntime.Key("Listener"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.ListenerDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.ListenerDescription()
            value.listener = try reader["Listener"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.Listener.readingClosure)
            value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The policies enabled for a listener.
    public struct ListenerDescription: Swift.Equatable {
        /// The listener.
        public var listener: ElasticLoadBalancingClientTypes.Listener?
        /// The policies. If there are no policies enabled, the list is empty.
        public var policyNames: [Swift.String]?

        public init(
            listener: ElasticLoadBalancingClientTypes.Listener? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.listener = listener
            self.policyNames = policyNames
        }
    }

}

extension ListenerNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ListenerNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The load balancer does not have a listener configured at the specified port.
public struct ListenerNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ListenerNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LoadBalancerAttributeNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = LoadBalancerAttributeNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified load balancer attribute does not exist.
public struct LoadBalancerAttributeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoadBalancerAttributeNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes.LoadBalancerAttributes: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLog = "AccessLog"
        case additionalAttributes = "AdditionalAttributes"
        case connectionDraining = "ConnectionDraining"
        case connectionSettings = "ConnectionSettings"
        case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessLog = accessLog {
            try container.encode(accessLog, forKey: ClientRuntime.Key("AccessLog"))
        }
        if let additionalAttributes = additionalAttributes {
            if !additionalAttributes.isEmpty {
                var additionalAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AdditionalAttributes"))
                for (index0, additionalattribute0) in additionalAttributes.enumerated() {
                    try additionalAttributesContainer.encode(additionalattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var additionalAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AdditionalAttributes"))
                try additionalAttributesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let connectionDraining = connectionDraining {
            try container.encode(connectionDraining, forKey: ClientRuntime.Key("ConnectionDraining"))
        }
        if let connectionSettings = connectionSettings {
            try container.encode(connectionSettings, forKey: ClientRuntime.Key("ConnectionSettings"))
        }
        if let crossZoneLoadBalancing = crossZoneLoadBalancing {
            try container.encode(crossZoneLoadBalancing, forKey: ClientRuntime.Key("CrossZoneLoadBalancing"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.LoadBalancerAttributes, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.LoadBalancerAttributes()
            value.crossZoneLoadBalancing = try reader["CrossZoneLoadBalancing"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing.readingClosure)
            value.accessLog = try reader["AccessLog"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.AccessLog.readingClosure)
            value.connectionDraining = try reader["ConnectionDraining"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.ConnectionDraining.readingClosure)
            value.connectionSettings = try reader["ConnectionSettings"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.ConnectionSettings.readingClosure)
            value.additionalAttributes = try reader["AdditionalAttributes"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.AdditionalAttribute.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The attributes for a load balancer.
    public struct LoadBalancerAttributes: Swift.Equatable {
        /// If enabled, the load balancer captures detailed information of all requests and delivers the information to the Amazon S3 bucket that you specify. For more information, see [Enable Access Logs](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-access-logs.html) in the Classic Load Balancers Guide.
        public var accessLog: ElasticLoadBalancingClientTypes.AccessLog?
        /// Any additional attributes.
        public var additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]?
        /// If enabled, the load balancer allows existing requests to complete before the load balancer shifts traffic away from a deregistered or unhealthy instance. For more information, see [Configure Connection Draining](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-conn-drain.html) in the Classic Load Balancers Guide.
        public var connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining?
        /// If enabled, the load balancer allows the connections to remain idle (no data is sent over the connection) for the specified duration. By default, Elastic Load Balancing maintains a 60-second idle connection timeout for both front-end and back-end connections of your load balancer. For more information, see [Configure Idle Connection Timeout](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/config-idle-timeout.html) in the Classic Load Balancers Guide.
        public var connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings?
        /// If enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones. For more information, see [Configure Cross-Zone Load Balancing](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-disable-crosszone-lb.html) in the Classic Load Balancers Guide.
        public var crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing?

        public init(
            accessLog: ElasticLoadBalancingClientTypes.AccessLog? = nil,
            additionalAttributes: [ElasticLoadBalancingClientTypes.AdditionalAttribute]? = nil,
            connectionDraining: ElasticLoadBalancingClientTypes.ConnectionDraining? = nil,
            connectionSettings: ElasticLoadBalancingClientTypes.ConnectionSettings? = nil,
            crossZoneLoadBalancing: ElasticLoadBalancingClientTypes.CrossZoneLoadBalancing? = nil
        )
        {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }
    }

}

extension ElasticLoadBalancingClientTypes.LoadBalancerDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dnsName = "DNSName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                for (index0, availabilityzone0) in availabilityZones.enumerated() {
                    try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            if !backendServerDescriptions.isEmpty {
                var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BackendServerDescriptions"))
                for (index0, backendserverdescription0) in backendServerDescriptions.enumerated() {
                    try backendServerDescriptionsContainer.encode(backendserverdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BackendServerDescriptions"))
                try backendServerDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let canonicalHostedZoneName = canonicalHostedZoneName {
            try container.encode(canonicalHostedZoneName, forKey: ClientRuntime.Key("CanonicalHostedZoneName"))
        }
        if let canonicalHostedZoneNameID = canonicalHostedZoneNameID {
            try container.encode(canonicalHostedZoneNameID, forKey: ClientRuntime.Key("CanonicalHostedZoneNameID"))
        }
        if let createdTime = createdTime {
            try container.encodeTimestamp(createdTime, format: .dateTime, forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let dnsName = dnsName {
            try container.encode(dnsName, forKey: ClientRuntime.Key("DNSName"))
        }
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: ClientRuntime.Key("HealthCheck"))
        }
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            if !listenerDescriptions.isEmpty {
                var listenerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ListenerDescriptions"))
                for (index0, listenerdescription0) in listenerDescriptions.enumerated() {
                    try listenerDescriptionsContainer.encode(listenerdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var listenerDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ListenerDescriptions"))
                try listenerDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policies = policies {
            try container.encode(policies, forKey: ClientRuntime.Key("Policies"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                for (index0, securitygroupid0) in securityGroups.enumerated() {
                    try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourceSecurityGroup = sourceSecurityGroup {
            try container.encode(sourceSecurityGroup, forKey: ClientRuntime.Key("SourceSecurityGroup"))
        }
        if let subnets = subnets {
            if !subnets.isEmpty {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                for (index0, subnetid0) in subnets.enumerated() {
                    try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
                try subnetsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VPCId"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.LoadBalancerDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.LoadBalancerDescription()
            value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
            value.dnsName = try reader["DNSName"].readIfPresent()
            value.canonicalHostedZoneName = try reader["CanonicalHostedZoneName"].readIfPresent()
            value.canonicalHostedZoneNameID = try reader["CanonicalHostedZoneNameID"].readIfPresent()
            value.listenerDescriptions = try reader["ListenerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.ListenerDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.policies = try reader["Policies"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.Policies.readingClosure)
            value.backendServerDescriptions = try reader["BackendServerDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.BackendServerDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.vpcId = try reader["VPCId"].readIfPresent()
            value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.healthCheck = try reader["HealthCheck"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.HealthCheck.readingClosure)
            value.sourceSecurityGroup = try reader["SourceSecurityGroup"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.SourceSecurityGroup.readingClosure)
            value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: .dateTime)
            value.scheme = try reader["Scheme"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a load balancer.
    public struct LoadBalancerDescription: Swift.Equatable {
        /// The Availability Zones for the load balancer.
        public var availabilityZones: [Swift.String]?
        /// Information about your EC2 instances.
        public var backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]?
        /// The DNS name of the load balancer. For more information, see [Configure a Custom Domain Name](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/using-domain-names-with-elb.html) in the Classic Load Balancers Guide.
        public var canonicalHostedZoneName: Swift.String?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneNameID: Swift.String?
        /// The date and time the load balancer was created.
        public var createdTime: ClientRuntime.Date?
        /// The DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// Information about the health checks conducted on the load balancer.
        public var healthCheck: ElasticLoadBalancingClientTypes.HealthCheck?
        /// The IDs of the instances for the load balancer.
        public var instances: [ElasticLoadBalancingClientTypes.Instance]?
        /// The listeners for the load balancer.
        public var listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]?
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The policies defined for the load balancer.
        public var policies: ElasticLoadBalancingClientTypes.Policies?
        /// The type of load balancer. Valid only for load balancers in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public var scheme: Swift.String?
        /// The security groups for the load balancer. Valid only for load balancers in a VPC.
        public var securityGroups: [Swift.String]?
        /// The security group for the load balancer, which you can use as part of your inbound rules for your registered instances. To only allow traffic from load balancers, add a security group rule that specifies this source security group as the inbound source.
        public var sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup?
        /// The IDs of the subnets for the load balancer.
        public var subnets: [Swift.String]?
        /// The ID of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            backendServerDescriptions: [ElasticLoadBalancingClientTypes.BackendServerDescription]? = nil,
            canonicalHostedZoneName: Swift.String? = nil,
            canonicalHostedZoneNameID: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            dnsName: Swift.String? = nil,
            healthCheck: ElasticLoadBalancingClientTypes.HealthCheck? = nil,
            instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
            listenerDescriptions: [ElasticLoadBalancingClientTypes.ListenerDescription]? = nil,
            loadBalancerName: Swift.String? = nil,
            policies: ElasticLoadBalancingClientTypes.Policies? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            sourceSecurityGroup: ElasticLoadBalancingClientTypes.SourceSecurityGroup? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension ModifyLoadBalancerAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerAttributes = loadBalancerAttributes {
            try container.encode(loadBalancerAttributes, forKey: ClientRuntime.Key("LoadBalancerAttributes"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("ModifyLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension ModifyLoadBalancerAttributesInput {

    static func urlPathProvider(_ value: ModifyLoadBalancerAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesInput: Swift.Equatable {
    /// The attributes for the load balancer.
    /// This member is required.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

extension ModifyLoadBalancerAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ModifyLoadBalancerAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ModifyLoadBalancerAttributesResult"]
            var value = ModifyLoadBalancerAttributesOutput()
            value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readIfPresent(readingClosure: ElasticLoadBalancingClientTypes.LoadBalancerAttributes.readingClosure)
            value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
            return value
        }
    }
}

/// Contains the output of ModifyLoadBalancerAttributes.
public struct ModifyLoadBalancerAttributesOutput: Swift.Equatable {
    /// Information about the load balancer attributes.
    public var loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes?
    /// The name of the load balancer.
    public var loadBalancerName: Swift.String?

    public init(
        loadBalancerAttributes: ElasticLoadBalancingClientTypes.LoadBalancerAttributes? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.loadBalancerAttributes = loadBalancerAttributes
        self.loadBalancerName = loadBalancerName
    }
}

enum ModifyLoadBalancerAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "LoadBalancerAttributeNotFound": return try await LoadBalancerAttributeNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension OperationNotPermittedException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OperationNotPermittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// This operation is not allowed.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes.Policies: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
        case lbCookieStickinessPolicies = "LBCookieStickinessPolicies"
        case otherPolicies = "OtherPolicies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let appCookieStickinessPolicies = appCookieStickinessPolicies {
            if !appCookieStickinessPolicies.isEmpty {
                var appCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AppCookieStickinessPolicies"))
                for (index0, appcookiestickinesspolicy0) in appCookieStickinessPolicies.enumerated() {
                    try appCookieStickinessPoliciesContainer.encode(appcookiestickinesspolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var appCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AppCookieStickinessPolicies"))
                try appCookieStickinessPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let lbCookieStickinessPolicies = lbCookieStickinessPolicies {
            if !lbCookieStickinessPolicies.isEmpty {
                var lbCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LBCookieStickinessPolicies"))
                for (index0, lbcookiestickinesspolicy0) in lbCookieStickinessPolicies.enumerated() {
                    try lbCookieStickinessPoliciesContainer.encode(lbcookiestickinesspolicy0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var lbCookieStickinessPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LBCookieStickinessPolicies"))
                try lbCookieStickinessPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let otherPolicies = otherPolicies {
            if !otherPolicies.isEmpty {
                var otherPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OtherPolicies"))
                for (index0, policyname0) in otherPolicies.enumerated() {
                    try otherPoliciesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var otherPoliciesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OtherPolicies"))
                try otherPoliciesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.Policies, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.Policies()
            value.appCookieStickinessPolicies = try reader["AppCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.lbCookieStickinessPolicies = try reader["LBCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.otherPolicies = try reader["OtherPolicies"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The policies for a load balancer.
    public struct Policies: Swift.Equatable {
        /// The stickiness policies created using [CreateAppCookieStickinessPolicy].
        public var appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]?
        /// The stickiness policies created using [CreateLBCookieStickinessPolicy].
        public var lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public var otherPolicies: [Swift.String]?

        public init(
            appCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.AppCookieStickinessPolicy]? = nil,
            lbCookieStickinessPolicies: [ElasticLoadBalancingClientTypes.LBCookieStickinessPolicy]? = nil,
            otherPolicies: [Swift.String]? = nil
        )
        {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttribute: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.PolicyAttribute, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.PolicyAttribute()
            value.attributeName = try reader["AttributeName"].readIfPresent()
            value.attributeValue = try reader["AttributeValue"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute.
    public struct PolicyAttribute: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttributeDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.PolicyAttributeDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.PolicyAttributeDescription()
            value.attributeName = try reader["AttributeName"].readIfPresent()
            value.attributeValue = try reader["AttributeValue"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute.
    public struct PolicyAttributeDescription: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The value of the attribute.
        public var attributeValue: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
        case cardinality = "Cardinality"
        case defaultValue = "DefaultValue"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeType = attributeType {
            try container.encode(attributeType, forKey: ClientRuntime.Key("AttributeType"))
        }
        if let cardinality = cardinality {
            try container.encode(cardinality, forKey: ClientRuntime.Key("Cardinality"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription()
            value.attributeName = try reader["AttributeName"].readIfPresent()
            value.attributeType = try reader["AttributeType"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.defaultValue = try reader["DefaultValue"].readIfPresent()
            value.cardinality = try reader["Cardinality"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy attribute type.
    public struct PolicyAttributeTypeDescription: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The type of the attribute. For example, Boolean or Integer.
        public var attributeType: Swift.String?
        /// The cardinality of the attribute. Valid values:
        ///
        /// * ONE(1) : Single value required
        ///
        /// * ZERO_OR_ONE(0..1) : Up to one value is allowed
        ///
        /// * ZERO_OR_MORE(0..*) : Optional. Multiple values are allowed
        ///
        /// * ONE_OR_MORE(1..*0) : Required. Multiple values are allowed
        public var cardinality: Swift.String?
        /// The default value of the attribute, if applicable.
        public var defaultValue: Swift.String?
        /// A description of the attribute.
        public var description: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeType: Swift.String? = nil,
            cardinality: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
            self.cardinality = cardinality
            self.defaultValue = defaultValue
            self.description = description
        }
    }

}

extension ElasticLoadBalancingClientTypes.PolicyDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyAttributeDescriptions = "PolicyAttributeDescriptions"
        case policyName = "PolicyName"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let policyAttributeDescriptions = policyAttributeDescriptions {
            if !policyAttributeDescriptions.isEmpty {
                var policyAttributeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeDescriptions"))
                for (index0, policyattributedescription0) in policyAttributeDescriptions.enumerated() {
                    try policyAttributeDescriptionsContainer.encode(policyattributedescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeDescriptions"))
                try policyAttributeDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyName = policyName {
            try container.encode(policyName, forKey: ClientRuntime.Key("PolicyName"))
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.PolicyDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.PolicyDescription()
            value.policyName = try reader["PolicyName"].readIfPresent()
            value.policyTypeName = try reader["PolicyTypeName"].readIfPresent()
            value.policyAttributeDescriptions = try reader["PolicyAttributeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyAttributeDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy.
    public struct PolicyDescription: Swift.Equatable {
        /// The policy attributes.
        public var policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]?
        /// The name of the policy.
        public var policyName: Swift.String?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init(
            policyAttributeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeDescription]? = nil,
            policyName: Swift.String? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.policyAttributeDescriptions = policyAttributeDescriptions
            self.policyName = policyName
            self.policyTypeName = policyTypeName
        }
    }

}

extension PolicyNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// One or more of the specified policies do not exist.
public struct PolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes.PolicyTypeDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case policyAttributeTypeDescriptions = "PolicyAttributeTypeDescriptions"
        case policyTypeName = "PolicyTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let policyAttributeTypeDescriptions = policyAttributeTypeDescriptions {
            if !policyAttributeTypeDescriptions.isEmpty {
                var policyAttributeTypeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeTypeDescriptions"))
                for (index0, policyattributetypedescription0) in policyAttributeTypeDescriptions.enumerated() {
                    try policyAttributeTypeDescriptionsContainer.encode(policyattributetypedescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyAttributeTypeDescriptionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyAttributeTypeDescriptions"))
                try policyAttributeTypeDescriptionsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let policyTypeName = policyTypeName {
            try container.encode(policyTypeName, forKey: ClientRuntime.Key("PolicyTypeName"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.PolicyTypeDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.PolicyTypeDescription()
            value.policyTypeName = try reader["PolicyTypeName"].readIfPresent()
            value.description = try reader["Description"].readIfPresent()
            value.policyAttributeTypeDescriptions = try reader["PolicyAttributeTypeDescriptions"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a policy type.
    public struct PolicyTypeDescription: Swift.Equatable {
        /// A description of the policy type.
        public var description: Swift.String?
        /// The description of the policy attributes associated with the policies defined by Elastic Load Balancing.
        public var policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]?
        /// The name of the policy type.
        public var policyTypeName: Swift.String?

        public init(
            description: Swift.String? = nil,
            policyAttributeTypeDescriptions: [ElasticLoadBalancingClientTypes.PolicyAttributeTypeDescription]? = nil,
            policyTypeName: Swift.String? = nil
        )
        {
            self.description = description
            self.policyAttributeTypeDescriptions = policyAttributeTypeDescriptions
            self.policyTypeName = policyTypeName
        }
    }

}

extension PolicyTypeNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PolicyTypeNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// One or more of the specified policy types do not exist.
public struct PolicyTypeNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyTypeNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RegisterInstancesWithLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case loadBalancerName = "LoadBalancerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instances = instances {
            if !instances.isEmpty {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                for (index0, instance0) in instances.enumerated() {
                    try instancesContainer.encode(instance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var instancesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Instances"))
                try instancesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        try container.encode("RegisterInstancesWithLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension RegisterInstancesWithLoadBalancerInput {

    static func urlPathProvider(_ value: RegisterInstancesWithLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerInput: Swift.Equatable {
    /// The IDs of the instances.
    /// This member is required.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil,
        loadBalancerName: Swift.String? = nil
    )
    {
        self.instances = instances
        self.loadBalancerName = loadBalancerName
    }
}

extension RegisterInstancesWithLoadBalancerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RegisterInstancesWithLoadBalancerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["RegisterInstancesWithLoadBalancerResult"]
            var value = RegisterInstancesWithLoadBalancerOutput()
            value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Instance.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Contains the output of RegisterInstancesWithLoadBalancer.
public struct RegisterInstancesWithLoadBalancerOutput: Swift.Equatable {
    /// The updated list of instances for the load balancer.
    public var instances: [ElasticLoadBalancingClientTypes.Instance]?

    public init(
        instances: [ElasticLoadBalancingClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

enum RegisterInstancesWithLoadBalancerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidInstance": return try await InvalidEndPointException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerNames = "LoadBalancerNames"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerNames = loadBalancerNames {
            if !loadBalancerNames.isEmpty {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                for (index0, accesspointname0) in loadBalancerNames.enumerated() {
                    try loadBalancerNamesContainer.encode(accesspointname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var loadBalancerNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerNames"))
                try loadBalancerNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tagkeyonly0) in tags.enumerated() {
                    try tagsContainer.encode(tagkeyonly0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("RemoveTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemoveTagsInput {

    static func urlPathProvider(_ value: RemoveTagsInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for RemoveTags.
public struct RemoveTagsInput: Swift.Equatable {
    /// The name of the load balancer. You can specify a maximum of one load balancer name.
    /// This member is required.
    public var loadBalancerNames: [Swift.String]?
    /// The list of tag keys to remove.
    /// This member is required.
    public var tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]?

    public init(
        loadBalancerNames: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingClientTypes.TagKeyOnly]? = nil
    )
    {
        self.loadBalancerNames = loadBalancerNames
        self.tags = tags
    }
}

extension RemoveTagsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RemoveTagsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return RemoveTagsOutput()
        }
    }
}

/// Contains the output of RemoveTags.
public struct RemoveTagsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveTagsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetLoadBalancerListenerSSLCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPort = "LoadBalancerPort"
        case sslCertificateId = "SSLCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let loadBalancerPort = loadBalancerPort {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let sslCertificateId = sslCertificateId {
            try container.encode(sslCertificateId, forKey: ClientRuntime.Key("SSLCertificateId"))
        }
        try container.encode("SetLoadBalancerListenerSSLCertificate", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerListenerSSLCertificateInput {

    static func urlPathProvider(_ value: SetLoadBalancerListenerSSLCertificateInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The port that uses the specified SSL certificate.
    /// This member is required.
    public var loadBalancerPort: Swift.Int?
    /// The Amazon Resource Name (ARN) of the SSL certificate.
    /// This member is required.
    public var sslCertificateId: Swift.String?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int? = nil,
        sslCertificateId: Swift.String? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.sslCertificateId = sslCertificateId
    }
}

extension SetLoadBalancerListenerSSLCertificateOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetLoadBalancerListenerSSLCertificateOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetLoadBalancerListenerSSLCertificateOutput()
        }
    }
}

/// Contains the output of SetLoadBalancerListenerSSLCertificate.
public struct SetLoadBalancerListenerSSLCertificateOutput: Swift.Equatable {

    public init() { }
}

enum SetLoadBalancerListenerSSLCertificateOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "CertificateNotFound": return try await CertificateNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ListenerNotFound": return try await ListenerNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UnsupportedProtocol": return try await UnsupportedProtocolException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetLoadBalancerPoliciesForBackendServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case loadBalancerName = "LoadBalancerName"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let instancePort = instancePort {
            try container.encode(instancePort, forKey: ClientRuntime.Key("InstancePort"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetLoadBalancerPoliciesForBackendServer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerPoliciesForBackendServerInput {

    static func urlPathProvider(_ value: SetLoadBalancerPoliciesForBackendServerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerInput: Swift.Equatable {
    /// The port number associated with the EC2 instance.
    /// This member is required.
    public var instancePort: Swift.Int?
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The names of the policies. If the list is empty, then all current polices are removed from the EC2 instance.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        instancePort: Swift.Int? = nil,
        loadBalancerName: Swift.String? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.instancePort = instancePort
        self.loadBalancerName = loadBalancerName
        self.policyNames = policyNames
    }
}

extension SetLoadBalancerPoliciesForBackendServerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetLoadBalancerPoliciesForBackendServerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetLoadBalancerPoliciesForBackendServerOutput()
        }
    }
}

/// Contains the output of SetLoadBalancerPoliciesForBackendServer.
public struct SetLoadBalancerPoliciesForBackendServerOutput: Swift.Equatable {

    public init() { }
}

enum SetLoadBalancerPoliciesForBackendServerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotFound": return try await PolicyNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetLoadBalancerPoliciesOfListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case loadBalancerPort = "LoadBalancerPort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let loadBalancerPort = loadBalancerPort {
            try container.encode(loadBalancerPort, forKey: ClientRuntime.Key("LoadBalancerPort"))
        }
        if let policyNames = policyNames {
            if !policyNames.isEmpty {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                for (index0, policyname0) in policyNames.enumerated() {
                    try policyNamesContainer.encode(policyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var policyNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyNames"))
                try policyNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetLoadBalancerPoliciesOfListener", forKey:ClientRuntime.Key("Action"))
        try container.encode("2012-06-01", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetLoadBalancerPoliciesOfListenerInput {

    static func urlPathProvider(_ value: SetLoadBalancerPoliciesOfListenerInput) -> Swift.String? {
        return "/"
    }
}

/// Contains the parameters for SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerInput: Swift.Equatable {
    /// The name of the load balancer.
    /// This member is required.
    public var loadBalancerName: Swift.String?
    /// The external port of the load balancer.
    /// This member is required.
    public var loadBalancerPort: Swift.Int?
    /// The names of the policies. This list must include all policies to be enabled. If you omit a policy that is currently enabled, it is disabled. If the list is empty, all current policies are disabled.
    /// This member is required.
    public var policyNames: [Swift.String]?

    public init(
        loadBalancerName: Swift.String? = nil,
        loadBalancerPort: Swift.Int? = nil,
        policyNames: [Swift.String]? = nil
    )
    {
        self.loadBalancerName = loadBalancerName
        self.loadBalancerPort = loadBalancerPort
        self.policyNames = policyNames
    }
}

extension SetLoadBalancerPoliciesOfListenerOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetLoadBalancerPoliciesOfListenerOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetLoadBalancerPoliciesOfListenerOutput()
        }
    }
}

/// Contains the output of SetLoadBalancePoliciesOfListener.
public struct SetLoadBalancerPoliciesOfListenerOutput: Swift.Equatable {

    public init() { }
}

enum SetLoadBalancerPoliciesOfListenerOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "LoadBalancerNotFound": return try await AccessPointNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidConfigurationRequest": return try await InvalidConfigurationRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ListenerNotFound": return try await ListenerNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PolicyNotFound": return try await PolicyNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ElasticLoadBalancingClientTypes.SourceSecurityGroup: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case ownerAlias = "OwnerAlias"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let groupName = groupName {
            try container.encode(groupName, forKey: ClientRuntime.Key("GroupName"))
        }
        if let ownerAlias = ownerAlias {
            try container.encode(ownerAlias, forKey: ClientRuntime.Key("OwnerAlias"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.SourceSecurityGroup, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.SourceSecurityGroup()
            value.ownerAlias = try reader["OwnerAlias"].readIfPresent()
            value.groupName = try reader["GroupName"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a source security group.
    public struct SourceSecurityGroup: Swift.Equatable {
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The owner of the security group.
        public var ownerAlias: Swift.String?

        public init(
            groupName: Swift.String? = nil,
            ownerAlias: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }
    }

}

extension SubnetNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = SubnetNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// One or more of the specified subnets do not exist.
public struct SubnetNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ElasticLoadBalancingClientTypes.Tag: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// Information about a tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingClientTypes.TagDescription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerName = "LoadBalancerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.TagDescription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.TagDescription()
            value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ElasticLoadBalancingClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The tags associated with a load balancer.
    public struct TagDescription: Swift.Equatable {
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The tags.
        public var tags: [ElasticLoadBalancingClientTypes.Tag]?

        public init(
            loadBalancerName: Swift.String? = nil,
            tags: [ElasticLoadBalancingClientTypes.Tag]? = nil
        )
        {
            self.loadBalancerName = loadBalancerName
            self.tags = tags
        }
    }

}

extension ElasticLoadBalancingClientTypes.TagKeyOnly: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<ElasticLoadBalancingClientTypes.TagKeyOnly, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = ElasticLoadBalancingClientTypes.TagKeyOnly()
            value.key = try reader["Key"].readIfPresent()
            return value
        }
    }
}

extension ElasticLoadBalancingClientTypes {
    /// The key of a tag.
    public struct TagKeyOnly: Swift.Equatable {
        /// The name of the key.
        public var key: Swift.String?

        public init(
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }

}

extension TooManyAccessPointsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyAccessPointsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The quota for the number of load balancers has been reached.
public struct TooManyAccessPointsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLoadBalancers" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyPoliciesException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyPoliciesException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The quota for the number of policies for this load balancer has been reached.
public struct TooManyPoliciesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyPolicies" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyTagsException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The quota for the number of tags that can be assigned to a load balancer has been reached.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTags" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnsupportedProtocolException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = UnsupportedProtocolException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The specified protocol or signature version is not supported.
public struct UnsupportedProtocolException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedProtocol" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
