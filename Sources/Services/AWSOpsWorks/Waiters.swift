// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension OpsWorksClientProtocol {

    static func appExistsWaiterConfig() throws -> WaiterConfiguration<DescribeAppsInput, DescribeAppsOutput> {
        let acceptors: [WaiterConfiguration<DescribeAppsInput, DescribeAppsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeAppsInput, result: Result<DescribeAppsOutput, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
            .init(state: .failure, matcher: { (input: DescribeAppsInput, result: Result<DescribeAppsOutput, Error>) -> Bool in
                switch result {
                    case .success: return false
                    case .failure: return true
                }
            }),
        ]
        return try WaiterConfiguration<DescribeAppsInput, DescribeAppsOutput>(acceptors: acceptors, minDelay: 1.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the AppExists event on the describeApps operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeAppsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilAppExists(options: WaiterOptions, input: DescribeAppsInput) async throws -> WaiterOutcome<DescribeAppsOutput> {
        let waiter = Waiter(config: try Self.appExistsWaiterConfig(), operation: self.describeApps(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func deploymentSuccessfulWaiterConfig() throws -> WaiterConfiguration<DescribeDeploymentsInput, DescribeDeploymentsOutput> {
        let acceptors: [WaiterConfiguration<DescribeDeploymentsInput, DescribeDeploymentsOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeDeploymentsInput, result: Result<DescribeDeploymentsOutput, Error>) -> Bool in
                // JMESPath expression: "Deployments[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "successful"
                guard case .success(let output) = result else { return false }
                let deployments = output.deployments
                let projection: [Swift.String]? = deployments?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "successful") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeDeploymentsInput, result: Result<DescribeDeploymentsOutput, Error>) -> Bool in
                // JMESPath expression: "Deployments[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "failed"
                guard case .success(let output) = result else { return false }
                let deployments = output.deployments
                let projection: [Swift.String]? = deployments?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeDeploymentsInput, DescribeDeploymentsOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the DeploymentSuccessful event on the describeDeployments operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeDeploymentsInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilDeploymentSuccessful(options: WaiterOptions, input: DescribeDeploymentsInput) async throws -> WaiterOutcome<DescribeDeploymentsOutput> {
        let waiter = Waiter(config: try Self.deploymentSuccessfulWaiterConfig(), operation: self.describeDeployments(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceOnlineWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "online"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "online") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "setup_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "setup_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "shutting_down"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "shutting_down") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "start_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "start_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopped"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stopped") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminating"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "terminating") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stop_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stop_failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceOnline event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceOnline(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceOnlineWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceRegisteredWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "registered"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "registered") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "setup_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "setup_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "shutting_down"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "shutting_down") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopped"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stopped") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stopping"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stopping") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminating"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "terminating") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "terminated") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stop_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stop_failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceRegistered event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceRegistered(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceRegisteredWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "stopped"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "stopped") } ?? false)
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "booting"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "booting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "rebooting"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "rebooting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "requested"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "requested") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "running_setup"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "running_setup") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "setup_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "setup_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "start_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "start_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "stop_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "stop_failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceStopped event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceStopped(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceStoppedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func instanceTerminatedWaiterConfig() throws -> WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput> {
        let acceptors: [WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "allStringEquals"
                // JMESPath expected value: "terminated"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return (projection?.count ?? 0) > 1 && (projection?.allSatisfy { JMESUtils.compare($0, ==, "terminated") } ?? false)
            }),
            .init(state: .success, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? ServiceError)?.typeName == "ResourceNotFoundException"
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "booting"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "booting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "online"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "online") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "pending"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "pending") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "rebooting"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "rebooting") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "requested"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "requested") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "running_setup"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "running_setup") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "setup_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "setup_failed") }) ?? false
            }),
            .init(state: .failure, matcher: { (input: DescribeInstancesInput, result: Result<DescribeInstancesOutput, Error>) -> Bool in
                // JMESPath expression: "Instances[].Status"
                // JMESPath comparator: "anyStringEquals"
                // JMESPath expected value: "start_failed"
                guard case .success(let output) = result else { return false }
                let instances = output.instances
                let projection: [Swift.String]? = instances?.compactMap { original in
                    let status = original.status
                    return status
                }
                return projection?.contains(where: { JMESUtils.compare($0, ==, "start_failed") }) ?? false
            }),
        ]
        return try WaiterConfiguration<DescribeInstancesInput, DescribeInstancesOutput>(acceptors: acceptors, minDelay: 15.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InstanceTerminated event on the describeInstances operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeInstancesInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInstanceTerminated(options: WaiterOptions, input: DescribeInstancesInput) async throws -> WaiterOutcome<DescribeInstancesOutput> {
        let waiter = Waiter(config: try Self.instanceTerminatedWaiterConfig(), operation: self.describeInstances(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
