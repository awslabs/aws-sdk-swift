//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError


public struct AssignInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct AssignVolumeOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateElasticIpOutput: Swift.Sendable {

    public init() { }
}

public struct AttachElasticLoadBalancerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLayerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStackOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteUserProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterEcsClusterOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterElasticIpOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterRdsDbInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterVolumeOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeMyUserProfileInput: Swift.Sendable {

    public init() { }
}

public struct DescribeOperatingSystemsInput: Swift.Sendable {

    public init() { }
}

public struct DetachElasticLoadBalancerOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateElasticIpOutput: Swift.Sendable {

    public init() { }
}

public struct RebootInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct RegisterRdsDbInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct SetLoadBasedAutoScalingOutput: Swift.Sendable {

    public init() { }
}

public struct SetPermissionOutput: Swift.Sendable {

    public init() { }
}

public struct SetTimeBasedAutoScalingOutput: Swift.Sendable {

    public init() { }
}

public struct StartInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct StartStackOutput: Swift.Sendable {

    public init() { }
}

public struct StopInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct StopStackOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UnassignInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct UnassignVolumeOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAppOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateElasticIpOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLayerOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMyUserProfileOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRdsDbInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateStackOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateUserProfileOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateVolumeOutput: Swift.Sendable {

    public init() { }
}

extension OpsWorksClientTypes {

    /// Describes the configuration manager.
    public struct StackConfigurationManager: Swift.Sendable {
        /// The name. This parameter must be set to Chef.
        public var name: Swift.String?
        /// The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 12.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an agent version.
    public struct AgentVersion: Swift.Sendable {
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The agent version.
        public var version: Swift.String?

        public init(
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            version: Swift.String? = nil
        )
        {
            self.configurationManager = configurationManager
            self.version = version
        }
    }
}

extension OpsWorksClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archive
        case git
        case s3
        case svn
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .archive,
                .git,
                .s3,
                .svn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archive: return "archive"
            case .git: return "git"
            case .s3: return "s3"
            case .svn: return "svn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Creating Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Custom Recipes and Cookbooks](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public struct Source: Swift.Sendable {
        /// When included in a request, the parameter depends on the repository type.
        ///
        /// * For Amazon S3 bundles, set Password to the appropriate IAM secret access key.
        ///
        /// * For HTTP bundles and Subversion repositories, set Password to the password.
        ///
        ///
        /// For more information on how to safely handle IAM credentials, see [https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html). In responses, OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var password: Swift.String?
        /// The application's version. OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.
        public var revision: Swift.String?
        /// In requests, the repository's SSH key. In responses, OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var sshKey: Swift.String?
        /// The repository type.
        public var type: OpsWorksClientTypes.SourceType?
        /// The source URL. The following is an example of an Amazon S3 source URL: https://s3.amazonaws.com/opsworks-demo-bucket/opsworks_cookbook_demo.tar.gz.
        public var url: Swift.String?
        /// This parameter depends on the repository type.
        ///
        /// * For Amazon S3 bundles, set Username to the appropriate IAM access key ID.
        ///
        /// * For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            revision: Swift.String? = nil,
            sshKey: Swift.String? = nil,
            type: OpsWorksClientTypes.SourceType? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.revision = revision
            self.sshKey = sshKey
            self.type = type
            self.url = url
            self.username = username
        }
    }
}

extension OpsWorksClientTypes {

    public enum AppAttributesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autobundleondeploy
        case awsflowrubysettings
        case documentroot
        case railsenv
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAttributesKeys] {
            return [
                .autobundleondeploy,
                .awsflowrubysettings,
                .documentroot,
                .railsenv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autobundleondeploy: return "AutoBundleOnDeploy"
            case .awsflowrubysettings: return "AwsFlowRubySettings"
            case .documentroot: return "DocumentRoot"
            case .railsenv: return "RailsEnv"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an app's data source.
    public struct DataSource: Swift.Sendable {
        /// The data source's ARN.
        public var arn: Swift.String?
        /// The database name.
        public var databaseName: Swift.String?
        /// The data source's type, AutoSelectOpsworksMysqlInstance, OpsworksMysqlInstance, RdsDbInstance, or None.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.databaseName = databaseName
            self.type = type
        }
    }
}

extension OpsWorksClientTypes {

    /// Represents an app's environment variable.
    public struct EnvironmentVariable: Swift.Sendable {
        /// (Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.
        /// This member is required.
        public var key: Swift.String?
        /// (Optional) Whether the variable's value is returned by the [DescribeApps] action. To hide an environment variable's value, set Secure to true. DescribeApps returns *****FILTERED***** instead of the actual value. The default value for Secure is false.
        public var secure: Swift.Bool?
        /// (Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            secure: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.secure = secure
            self.value = value
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an app's SSL configuration.
    public struct SslConfiguration: Swift.Sendable {
        /// The contents of the certificate's domain.crt file.
        /// This member is required.
        public var certificate: Swift.String?
        /// Optional. Can be used to specify an intermediate certificate authority key or client authentication.
        public var chain: Swift.String?
        /// The private key; the contents of the certificate's domain.kex file.
        /// This member is required.
        public var privateKey: Swift.String?

        public init(
            certificate: Swift.String? = nil,
            chain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificate = certificate
            self.chain = chain
            self.privateKey = privateKey
        }
    }
}

extension OpsWorksClientTypes {

    public enum AppType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsFlowRuby
        case java
        case nodejs
        case other
        case php
        case rails
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .awsFlowRuby,
                .java,
                .nodejs,
                .other,
                .php,
                .rails,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .java: return "java"
            case .nodejs: return "nodejs"
            case .other: return "other"
            case .php: return "php"
            case .rails: return "rails"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// A description of the app.
    public struct App: Swift.Sendable {
        /// The app ID.
        public var appId: Swift.String?
        /// A Source object that describes the app repository.
        public var appSource: OpsWorksClientTypes.Source?
        /// The stack attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// When the app was created.
        public var createdAt: Swift.String?
        /// The app's data sources.
        public var dataSources: [OpsWorksClientTypes.DataSource]?
        /// A description of the app.
        public var description: Swift.String?
        /// The app vhost settings with multiple domains separated by commas. For example: 'www.example.com, example.com'
        public var domains: [Swift.String]?
        /// Whether to enable SSL for the app.
        public var enableSsl: Swift.Bool?
        /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances. For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variable names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases, but if you do exceed it, you will cause an exception (API) with an "Environment: is too large (maximum is 20 KB)" message.
        public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
        /// The app name.
        public var name: Swift.String?
        /// The app's short name.
        public var shortname: Swift.String?
        /// An SslConfiguration object with the SSL configuration.
        public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
        /// The app stack ID.
        public var stackId: Swift.String?
        /// The app type.
        public var type: OpsWorksClientTypes.AppType?

        public init(
            appId: Swift.String? = nil,
            appSource: OpsWorksClientTypes.Source? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            createdAt: Swift.String? = nil,
            dataSources: [OpsWorksClientTypes.DataSource]? = nil,
            description: Swift.String? = nil,
            domains: [Swift.String]? = nil,
            enableSsl: Swift.Bool? = nil,
            environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
            name: Swift.String? = nil,
            shortname: Swift.String? = nil,
            sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.AppType? = nil
        )
        {
            self.appId = appId
            self.appSource = appSource
            self.attributes = attributes
            self.createdAt = createdAt
            self.dataSources = dataSources
            self.description = description
            self.domains = domains
            self.enableSsl = enableSsl
            self.environment = environment
            self.name = name
            self.shortname = shortname
            self.sslConfiguration = sslConfiguration
            self.stackId = stackId
            self.type = type
        }
    }
}

extension OpsWorksClientTypes {

    public enum Architecture: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case i386
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .i386,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .i386: return "i386"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Indicates that a resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a request was not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssignInstanceInput: Swift.Sendable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The layer ID, which must correspond to a custom layer. You cannot assign a registered instance to a built-in layer.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        layerIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.layerIds = layerIds
    }
}

public struct AssignVolumeInput: Swift.Sendable {
    /// The instance ID.
    public var instanceId: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.volumeId = volumeId
    }
}

public struct AssociateElasticIpInput: Swift.Sendable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The instance ID.
    public var instanceId: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.instanceId = instanceId
    }
}

public struct AttachElasticLoadBalancerInput: Swift.Sendable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer to which the Elastic Load Balancing instance is to be attached.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

extension OpsWorksClientTypes {

    /// Describes a load-based auto scaling upscaling or downscaling threshold configuration, which specifies when OpsWorks Stacks starts or stops load-based instances.
    public struct AutoScalingThresholds: Swift.Sendable {
        /// Custom CloudWatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack. To use custom alarms, you must update your service role to allow cloudwatch:DescribeAlarms. You can either have OpsWorks Stacks update the role for you when you first use this feature or you can edit the role manually. For more information, see [Allowing OpsWorks Stacks to Act on Your Behalf](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-servicerole.html).
        public var alarms: [Swift.String]?
        /// The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        public var cpuThreshold: Swift.Double?
        /// The amount of time (in minutes) after a scaling event occurs that OpsWorks Stacks should ignore metrics and suppress additional scaling events. For example, OpsWorks Stacks adds new instances following an upscaling event but the instances won't start reducing the load until they have been booted and configured. There is no point in raising additional scaling events during that operation, which typically takes several minutes. IgnoreMetricsTime allows you to direct OpsWorks Stacks to suppress scaling events long enough to get the new instances online.
        public var ignoreMetricsTime: Swift.Int?
        /// The number of instances to add or remove when the load exceeds a threshold.
        public var instanceCount: Swift.Int?
        /// The load threshold. A value of -1 disables the threshold. For more information about how load is computed, see [Load (computing)](http://en.wikipedia.org/wiki/Load_%28computing%29).
        public var loadThreshold: Swift.Double?
        /// The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        public var memoryThreshold: Swift.Double?
        /// The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        public var thresholdsWaitTime: Swift.Int?

        public init(
            alarms: [Swift.String]? = nil,
            cpuThreshold: Swift.Double? = nil,
            ignoreMetricsTime: Swift.Int? = nil,
            instanceCount: Swift.Int? = nil,
            loadThreshold: Swift.Double? = nil,
            memoryThreshold: Swift.Double? = nil,
            thresholdsWaitTime: Swift.Int? = nil
        )
        {
            self.alarms = alarms
            self.cpuThreshold = cpuThreshold
            self.ignoreMetricsTime = ignoreMetricsTime
            self.instanceCount = instanceCount
            self.loadThreshold = loadThreshold
            self.memoryThreshold = memoryThreshold
            self.thresholdsWaitTime = thresholdsWaitTime
        }
    }
}

extension OpsWorksClientTypes {

    public enum AutoScalingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case load
        case timer
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingType] {
            return [
                .load,
                .timer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .load: return "load"
            case .timer: return "timer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    public enum VolumeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case io1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .io1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .io1: return "io1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an Amazon EBS volume. This data type maps directly to the Amazon EC2 [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html) data type.
    public struct EbsBlockDevice: Swift.Sendable {
        /// Whether the volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// The number of I/O operations per second (IOPS) that the volume supports. For more information, see [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html).
        public var iops: Swift.Int?
        /// The snapshot ID.
        public var snapshotId: Swift.String?
        /// The volume size, in GiB. For more information, see [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html).
        public var volumeSize: Swift.Int?
        /// The volume type. gp2 for General Purpose (SSD) volumes, io1 for Provisioned IOPS (SSD) volumes, st1 for Throughput Optimized hard disk drives (HDD), sc1 for Cold HDD,and standard for Magnetic volumes. If you specify the io1 volume type, you must also specify a value for the Iops attribute. The maximum ratio of provisioned IOPS to requested volume size (in GiB) is 50:1. Amazon Web Services uses the default volume size (in GiB) specified in the AMI attributes to set IOPS to 50 x (volume size).
        public var volumeType: OpsWorksClientTypes.VolumeType?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            snapshotId: Swift.String? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: OpsWorksClientTypes.VolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes a block device mapping. This data type maps directly to the Amazon EC2 [BlockDeviceMapping](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html) data type.
    public struct BlockDeviceMapping: Swift.Sendable {
        /// The device name that is exposed to the instance, such as /dev/sdh. For the root device, you can use the explicit device name or you can set this parameter to ROOT_DEVICE and OpsWorks Stacks will provide the correct device name.
        public var deviceName: Swift.String?
        /// An EBSBlockDevice that defines how to configure an Amazon EBS volume when the instance is launched.
        public var ebs: OpsWorksClientTypes.EbsBlockDevice?
        /// Suppresses the specified device included in the AMI's block device mapping.
        public var noDevice: Swift.String?
        /// The virtual device name. For more information, see [BlockDeviceMapping](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html).
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: OpsWorksClientTypes.EbsBlockDevice? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes the Chef configuration.
    public struct ChefConfiguration: Swift.Sendable {
        /// The Berkshelf version.
        public var berkshelfVersion: Swift.String?
        /// Whether to enable Berkshelf.
        public var manageBerkshelf: Swift.Bool?

        public init(
            berkshelfVersion: Swift.String? = nil,
            manageBerkshelf: Swift.Bool? = nil
        )
        {
            self.berkshelfVersion = berkshelfVersion
            self.manageBerkshelf = manageBerkshelf
        }
    }
}

extension OpsWorksClientTypes {

    public enum StackAttributesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case color
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttributesKeys] {
            return [
                .color
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .color: return "Color"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    public enum RootDeviceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ebs
        case instanceStore
        case sdkUnknown(Swift.String)

        public static var allCases: [RootDeviceType] {
            return [
                .ebs,
                .instanceStore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "ebs"
            case .instanceStore: return "instance-store"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CloneStackInput: Swift.Sendable {
    /// The default OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. OpsWorks Stacks automatically installs that version on the stack's instances.
    ///
    ///
    /// The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// A list of stack attributes and values as key/value pairs to be added to the cloned stack.
    public var attributes: [Swift.String: Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// A list of source stack app IDs to be included in the cloned stack.
    public var cloneAppIds: [Swift.String]?
    /// Whether to clone the source stack's permissions.
    public var clonePermissions: Swift.Bool?
    /// The configuration manager. When you clone a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html)
    public var customJson: Swift.String?
    /// The cloned stack's default Availability Zone, which must be in the specified region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description.
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2, Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 18.04 LTS, Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the parent stack's operating system. Not all operating systems are supported with all versions of Chef. For more information about supported operating systems, see [OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). You can specify a different Linux operating system for the cloned stack, but you cannot change from Linux to Windows or Windows to Linux.
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the cloned stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces are replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The cloned stack name. Stack names can be a maximum of 64 characters.
    public var name: Swift.String?
    /// The cloned stack Amazon Web Services Region, such as ap-northeast-2. For more information about Amazon Web Services Regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
    public var region: Swift.String?
    /// The stack Identity and Access Management (IAM) role, which allows OpsWorks Stacks to work with Amazon Web Services resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. If you create a stack by using the OpsWorkss Stacks console, it creates the role for you. You can obtain an existing stack's IAM ARN programmatically by calling [DescribePermissions]. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html). You must set this parameter to a valid service role ARN or the action will fail; there is no default value. You can specify the source stack's service role ARN, if you prefer, but you must do so explicitly.
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// The source stack ID.
    /// This member is required.
    public var sourceStackId: Swift.String?
    /// Whether to use custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the OpsWorks Stacks built-in security groups with the stack's layers. OpsWorks Stacks provides a standard set of security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it but you cannot delete the built-in security group.
    ///
    /// * False - OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate Amazon EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the cloned stack is to be launched into. It must be in the specified region. All instances are launched into this VPC, and you cannot change the ID later.
    ///
    /// * If your account supports EC2 Classic, the default value is no VPC.
    ///
    /// * If your account does not support EC2 Classic, the default value is the default VPC for the specified region.
    ///
    ///
    /// If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, OpsWorks Stacks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively. If you specify a nondefault VPC ID, note the following:
    ///
    /// * It must belong to a VPC in your account that is in the specified region.
    ///
    /// * You must specify a value for DefaultSubnetId.
    ///
    ///
    /// For more information about how to use OpsWorks Stacks with a VPC, see [Running a Stack in a VPC](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html). For more information about default VPC and EC2 Classic, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var vpcId: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        cloneAppIds: [Swift.String]? = nil,
        clonePermissions: Swift.Bool? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        sourceStackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.cloneAppIds = cloneAppIds
        self.clonePermissions = clonePermissions
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.sourceStackId = sourceStackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

/// Contains the response to a CloneStack request.
public struct CloneStackOutput: Swift.Sendable {
    /// The cloned stack ID.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
    public enum CloudWatchLogsEncoding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascii
        case big5
        case big5hkscs
        case cp037
        case cp1006
        case cp1026
        case cp1140
        case cp1250
        case cp1251
        case cp1252
        case cp1253
        case cp1254
        case cp1255
        case cp1256
        case cp1257
        case cp1258
        case cp424
        case cp437
        case cp500
        case cp720
        case cp737
        case cp775
        case cp850
        case cp852
        case cp855
        case cp856
        case cp857
        case cp858
        case cp860
        case cp861
        case cp862
        case cp863
        case cp864
        case cp865
        case cp866
        case cp869
        case cp874
        case cp875
        case cp932
        case cp949
        case cp950
        case eucJis2004
        case eucJisx0213
        case eucJp
        case eucKr
        case gb18030
        case gb2312
        case gbk
        case hz
        case iso2022Jp
        case iso2022Jp1
        case iso2022Jp2
        case iso2022Jp2004
        case iso2022Jp3
        case iso2022JpExt
        case iso2022Kr
        case iso885910
        case iso885913
        case iso885914
        case iso885915
        case iso885916
        case iso88592
        case iso88593
        case iso88594
        case iso88595
        case iso88596
        case iso88597
        case iso88598
        case iso88599
        case johab
        case koi8R
        case koi8U
        case latin1
        case macCyrillic
        case macGreek
        case macIceland
        case macLatin2
        case macRoman
        case macTurkish
        case ptcp154
        case shiftJis
        case shiftJis2004
        case shiftJisx0213
        case utf16
        case utf16Be
        case utf16Le
        case utf32
        case utf32Be
        case utf32Le
        case utf7
        case utf8
        case utf8Sig
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsEncoding] {
            return [
                .ascii,
                .big5,
                .big5hkscs,
                .cp037,
                .cp1006,
                .cp1026,
                .cp1140,
                .cp1250,
                .cp1251,
                .cp1252,
                .cp1253,
                .cp1254,
                .cp1255,
                .cp1256,
                .cp1257,
                .cp1258,
                .cp424,
                .cp437,
                .cp500,
                .cp720,
                .cp737,
                .cp775,
                .cp850,
                .cp852,
                .cp855,
                .cp856,
                .cp857,
                .cp858,
                .cp860,
                .cp861,
                .cp862,
                .cp863,
                .cp864,
                .cp865,
                .cp866,
                .cp869,
                .cp874,
                .cp875,
                .cp932,
                .cp949,
                .cp950,
                .eucJis2004,
                .eucJisx0213,
                .eucJp,
                .eucKr,
                .gb18030,
                .gb2312,
                .gbk,
                .hz,
                .iso2022Jp,
                .iso2022Jp1,
                .iso2022Jp2,
                .iso2022Jp2004,
                .iso2022Jp3,
                .iso2022JpExt,
                .iso2022Kr,
                .iso885910,
                .iso885913,
                .iso885914,
                .iso885915,
                .iso885916,
                .iso88592,
                .iso88593,
                .iso88594,
                .iso88595,
                .iso88596,
                .iso88597,
                .iso88598,
                .iso88599,
                .johab,
                .koi8R,
                .koi8U,
                .latin1,
                .macCyrillic,
                .macGreek,
                .macIceland,
                .macLatin2,
                .macRoman,
                .macTurkish,
                .ptcp154,
                .shiftJis,
                .shiftJis2004,
                .shiftJisx0213,
                .utf16,
                .utf16Be,
                .utf16Le,
                .utf32,
                .utf32Be,
                .utf32Le,
                .utf7,
                .utf8,
                .utf8Sig
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascii: return "ascii"
            case .big5: return "big5"
            case .big5hkscs: return "big5hkscs"
            case .cp037: return "cp037"
            case .cp1006: return "cp1006"
            case .cp1026: return "cp1026"
            case .cp1140: return "cp1140"
            case .cp1250: return "cp1250"
            case .cp1251: return "cp1251"
            case .cp1252: return "cp1252"
            case .cp1253: return "cp1253"
            case .cp1254: return "cp1254"
            case .cp1255: return "cp1255"
            case .cp1256: return "cp1256"
            case .cp1257: return "cp1257"
            case .cp1258: return "cp1258"
            case .cp424: return "cp424"
            case .cp437: return "cp437"
            case .cp500: return "cp500"
            case .cp720: return "cp720"
            case .cp737: return "cp737"
            case .cp775: return "cp775"
            case .cp850: return "cp850"
            case .cp852: return "cp852"
            case .cp855: return "cp855"
            case .cp856: return "cp856"
            case .cp857: return "cp857"
            case .cp858: return "cp858"
            case .cp860: return "cp860"
            case .cp861: return "cp861"
            case .cp862: return "cp862"
            case .cp863: return "cp863"
            case .cp864: return "cp864"
            case .cp865: return "cp865"
            case .cp866: return "cp866"
            case .cp869: return "cp869"
            case .cp874: return "cp874"
            case .cp875: return "cp875"
            case .cp932: return "cp932"
            case .cp949: return "cp949"
            case .cp950: return "cp950"
            case .eucJis2004: return "euc_jis_2004"
            case .eucJisx0213: return "euc_jisx0213"
            case .eucJp: return "euc_jp"
            case .eucKr: return "euc_kr"
            case .gb18030: return "gb18030"
            case .gb2312: return "gb2312"
            case .gbk: return "gbk"
            case .hz: return "hz"
            case .iso2022Jp: return "iso2022_jp"
            case .iso2022Jp1: return "iso2022_jp_1"
            case .iso2022Jp2: return "iso2022_jp_2"
            case .iso2022Jp2004: return "iso2022_jp_2004"
            case .iso2022Jp3: return "iso2022_jp_3"
            case .iso2022JpExt: return "iso2022_jp_ext"
            case .iso2022Kr: return "iso2022_kr"
            case .iso885910: return "iso8859_10"
            case .iso885913: return "iso8859_13"
            case .iso885914: return "iso8859_14"
            case .iso885915: return "iso8859_15"
            case .iso885916: return "iso8859_16"
            case .iso88592: return "iso8859_2"
            case .iso88593: return "iso8859_3"
            case .iso88594: return "iso8859_4"
            case .iso88595: return "iso8859_5"
            case .iso88596: return "iso8859_6"
            case .iso88597: return "iso8859_7"
            case .iso88598: return "iso8859_8"
            case .iso88599: return "iso8859_9"
            case .johab: return "johab"
            case .koi8R: return "koi8_r"
            case .koi8U: return "koi8_u"
            case .latin1: return "latin_1"
            case .macCyrillic: return "mac_cyrillic"
            case .macGreek: return "mac_greek"
            case .macIceland: return "mac_iceland"
            case .macLatin2: return "mac_latin2"
            case .macRoman: return "mac_roman"
            case .macTurkish: return "mac_turkish"
            case .ptcp154: return "ptcp154"
            case .shiftJis: return "shift_jis"
            case .shiftJis2004: return "shift_jis_2004"
            case .shiftJisx0213: return "shift_jisx0213"
            case .utf16: return "utf_16"
            case .utf16Be: return "utf_16_be"
            case .utf16Le: return "utf_16_le"
            case .utf32: return "utf_32"
            case .utf32Be: return "utf_32_be"
            case .utf32Le: return "utf_32_le"
            case .utf7: return "utf_7"
            case .utf8: return "utf_8"
            case .utf8Sig: return "utf_8_sig"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. It's only used if there is no state persisted for that log stream.
    public enum CloudWatchLogsInitialPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endOfFile
        case startOfFile
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsInitialPosition] {
            return [
                .endOfFile,
                .startOfFile
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endOfFile: return "end_of_file"
            case .startOfFile: return "start_of_file"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// The preferred time zone for logs streamed to CloudWatch Logs. Valid values are LOCAL and UTC, for Coordinated Universal Time.
    public enum CloudWatchLogsTimeZone: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case local
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsTimeZone] {
            return [
                .local,
                .utc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes the CloudWatch Logs configuration for a layer. For detailed information about members of this data type, see the [CloudWatch Logs Agent Reference](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
    public struct CloudWatchLogsLogStream: Swift.Sendable {
        /// Specifies the max number of log events in a batch, up to 10000. The default value is 1000.
        public var batchCount: Swift.Int?
        /// Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes. The default value is 32768 bytes. This size is calculated as the sum of all event messages in UTF-8, plus 26 bytes for each log event.
        public var batchSize: Swift.Int?
        /// Specifies the time duration for the batching of log events. The minimum value is 5000ms and default value is 5000ms.
        public var bufferDuration: Swift.Int?
        /// Specifies how the time stamp is extracted from logs. For more information, see the [CloudWatch Logs Agent Reference](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
        public var datetimeFormat: Swift.String?
        /// Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
        public var encoding: OpsWorksClientTypes.CloudWatchLogsEncoding?
        /// Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*). Only the latest file is pushed to CloudWatch Logs, based on file modification time. We recommend that you use wild card characters to specify a series of files of the same type, such as access_log.2014-06-01-01, access_log.2014-06-01-02, and so on by using a pattern like access_log.*. Don't use a wildcard to match multiple file types, such as access_log_80 and access_log_443. To specify multiple, different file types, add another log stream entry to the configuration file, so that each log file type is stored in a different log group. Zipped files are not supported.
        public var file: Swift.String?
        /// Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as '1', '2-5'. The default value is '1', meaning the first line is used to calculate the fingerprint. Fingerprint lines are not sent to CloudWatch Logs unless all specified lines are available.
        public var fileFingerprintLines: Swift.String?
        /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. This setting is only used if there is no state persisted for that log stream.
        public var initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition?
        /// Specifies the destination log group. A log group is created automatically if it doesn't already exist. Log group names can be between 1 and 512 characters long. Allowed characters include a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), and '.' (period).
        public var logGroupName: Swift.String?
        /// Specifies the pattern for identifying the start of a log message.
        public var multiLineStartPattern: Swift.String?
        /// Specifies the time zone of log event time stamps.
        public var timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone?

        public init(
            batchCount: Swift.Int? = nil,
            batchSize: Swift.Int? = nil,
            bufferDuration: Swift.Int? = nil,
            datetimeFormat: Swift.String? = nil,
            encoding: OpsWorksClientTypes.CloudWatchLogsEncoding? = nil,
            file: Swift.String? = nil,
            fileFingerprintLines: Swift.String? = nil,
            initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition? = nil,
            logGroupName: Swift.String? = nil,
            multiLineStartPattern: Swift.String? = nil,
            timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone? = nil
        )
        {
            self.batchCount = batchCount
            self.batchSize = batchSize
            self.bufferDuration = bufferDuration
            self.datetimeFormat = datetimeFormat
            self.encoding = encoding
            self.file = file
            self.fileFingerprintLines = fileFingerprintLines
            self.initialPosition = initialPosition
            self.logGroupName = logGroupName
            self.multiLineStartPattern = multiLineStartPattern
            self.timeZone = timeZone
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes the Amazon CloudWatch Logs configuration for a layer.
    public struct CloudWatchLogsConfiguration: Swift.Sendable {
        /// Whether CloudWatch Logs is enabled for a layer.
        public var enabled: Swift.Bool?
        /// A list of configuration options for CloudWatch Logs.
        public var logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]?

        public init(
            enabled: Swift.Bool? = nil,
            logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]? = nil
        )
        {
            self.enabled = enabled
            self.logStreams = logStreams
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes a command.
    public struct Command: Swift.Sendable {
        /// Date and time when the command was acknowledged.
        public var acknowledgedAt: Swift.String?
        /// The command ID.
        public var commandId: Swift.String?
        /// Date when the command completed.
        public var completedAt: Swift.String?
        /// Date and time when the command was run.
        public var createdAt: Swift.String?
        /// The command deployment ID.
        public var deploymentId: Swift.String?
        /// The command exit code.
        public var exitCode: Swift.Int?
        /// The ID of the instance where the command was executed.
        public var instanceId: Swift.String?
        /// The URL of the command log.
        public var logUrl: Swift.String?
        /// The command status:
        ///
        /// * failed
        ///
        /// * successful
        ///
        /// * skipped
        ///
        /// * pending
        public var status: Swift.String?
        /// The command type:
        ///
        /// * configure
        ///
        /// * deploy
        ///
        /// * execute_recipes
        ///
        /// * install_dependencies
        ///
        /// * restart
        ///
        /// * rollback
        ///
        /// * setup
        ///
        /// * start
        ///
        /// * stop
        ///
        /// * undeploy
        ///
        /// * update_custom_cookbooks
        ///
        /// * update_dependencies
        public var type: Swift.String?

        public init(
            acknowledgedAt: Swift.String? = nil,
            commandId: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            exitCode: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.acknowledgedAt = acknowledgedAt
            self.commandId = commandId
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.deploymentId = deploymentId
            self.exitCode = exitCode
            self.instanceId = instanceId
            self.logUrl = logUrl
            self.status = status
            self.type = type
        }
    }
}

public struct CreateAppInput: Swift.Sendable {
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// The app's data source.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com'
    public var domains: [Swift.String]?
    /// Whether to enable SSL for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instance. For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20KB)." If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    /// This member is required.
    public var name: Swift.String?
    /// The app's short name.
    public var shortname: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The app type. Each supported type is associated with a particular layer. For example, PHP applications are associated with a PHP layer. OpsWorks Stacks deploys an application to those instances that are members of the corresponding layer. If your app isn't one of the standard types, or you prefer to implement your own Deploy recipes, specify other.
    /// This member is required.
    public var type: OpsWorksClientTypes.AppType?

    public init(
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        shortname: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.shortname = shortname
        self.sslConfiguration = sslConfiguration
        self.stackId = stackId
        self.type = type
    }
}

/// Contains the response to a CreateApp request.
public struct CreateAppOutput: Swift.Sendable {
    /// The app ID.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

extension OpsWorksClientTypes {

    public enum DeploymentCommandName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configure
        case deploy
        case executeRecipes
        case installDependencies
        case restart
        case rollback
        case setup
        case start
        case stop
        case undeploy
        case updateCustomCookbooks
        case updateDependencies
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentCommandName] {
            return [
                .configure,
                .deploy,
                .executeRecipes,
                .installDependencies,
                .restart,
                .rollback,
                .setup,
                .start,
                .stop,
                .undeploy,
                .updateCustomCookbooks,
                .updateDependencies
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configure: return "configure"
            case .deploy: return "deploy"
            case .executeRecipes: return "execute_recipes"
            case .installDependencies: return "install_dependencies"
            case .restart: return "restart"
            case .rollback: return "rollback"
            case .setup: return "setup"
            case .start: return "start"
            case .stop: return "stop"
            case .undeploy: return "undeploy"
            case .updateCustomCookbooks: return "update_custom_cookbooks"
            case .updateDependencies: return "update_dependencies"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Used to specify a stack or deployment command.
    public struct DeploymentCommand: Swift.Sendable {
        /// The arguments of those commands that take arguments. It should be set to a JSON object with the following format: {"arg_name1" : ["value1", "value2", ...], "arg_name2" : ["value1", "value2", ...], ...} The update_dependencies command takes two arguments:
        ///
        /// * upgrade_os_to - Specifies the Amazon Linux version that you want instances to run, such as Amazon Linux 2. You must also set the allow_reboot argument to true.
        ///
        /// * allow_reboot - Specifies whether to allow OpsWorks Stacks to reboot the instances if necessary, after installing the updates. This argument can be set to either true or false. The default value is false.
        ///
        ///
        /// For example, to upgrade an instance to Amazon Linux 2018.03, set Args to the following.  { "upgrade_os_to":["Amazon Linux 2018.03"], "allow_reboot":["true"] }
        public var args: [Swift.String: [Swift.String]]?
        /// Specifies the operation. You can specify only one command. For stacks, the following commands are available:
        ///
        /// * execute_recipes: Execute one or more recipes. To specify the recipes, set an Args parameter named recipes to the list of recipes to be executed. For example, to execute phpapp::appsetup, set Args to {"recipes":["phpapp::appsetup"]}.
        ///
        /// * install_dependencies: Install the stack's dependencies.
        ///
        /// * update_custom_cookbooks: Update the stack's custom cookbooks.
        ///
        /// * update_dependencies: Update the stack's dependencies.
        ///
        ///
        /// The update_dependencies and install_dependencies commands are supported only for Linux instances. You can run the commands successfully on Windows instances, but they do nothing. For apps, the following commands are available:
        ///
        /// * deploy: Deploy an app. Ruby on Rails apps have an optional Args parameter named migrate. Set Args to {"migrate":["true"]} to migrate the database. The default setting is {"migrate":["false"]}.
        ///
        /// * rollback Roll the app back to the previous version. When you update an app, OpsWorks Stacks stores the previous version, up to a maximum of five versions. You can use this command to roll an app back as many as four versions.
        ///
        /// * start: Start the app's web or application server.
        ///
        /// * stop: Stop the app's web or application server.
        ///
        /// * restart: Restart the app's web or application server.
        ///
        /// * undeploy: Undeploy the app.
        /// This member is required.
        public var name: OpsWorksClientTypes.DeploymentCommandName?

        public init(
            args: [Swift.String: [Swift.String]]? = nil,
            name: OpsWorksClientTypes.DeploymentCommandName? = nil
        )
        {
            self.args = args
            self.name = name
        }
    }
}

public struct CreateDeploymentInput: Swift.Sendable {
    /// The app ID. This parameter is required for app deployments, but not for other deployment commands.
    public var appId: Swift.String?
    /// A DeploymentCommand object that specifies the deployment command and any associated arguments.
    /// This member is required.
    public var command: OpsWorksClientTypes.DeploymentCommand?
    /// A user-defined comment.
    public var comment: Swift.String?
    /// A string that contains user-defined, custom JSON. You can use this parameter to override some corresponding default stack configuration JSON values. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html) and [Overriding Attributes With Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html).
    public var customJson: Swift.String?
    /// The instance IDs for the deployment targets.
    public var instanceIds: [Swift.String]?
    /// The layer IDs for the deployment targets.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        command: OpsWorksClientTypes.DeploymentCommand? = nil,
        comment: Swift.String? = nil,
        customJson: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.command = command
        self.comment = comment
        self.customJson = customJson
        self.instanceIds = instanceIds
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

/// Contains the response to a CreateDeployment request.
public struct CreateDeploymentOutput: Swift.Sendable {
    /// The deployment ID, which can be used with other requests to identify the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

public struct CreateInstanceInput: Swift.Sendable {
    /// The default OpsWorks Stacks agent version. You have the following options:
    ///
    /// * INHERIT - Use the stack's default agent version setting.
    ///
    /// * version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, edit the instance configuration and specify a new version. OpsWorks Stacks installs that version on the instance.
    ///
    ///
    /// The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// A custom AMI ID to be used to create the instance. The AMI should be based on one of the supported operating systems. For more information, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html). If you specify a custom AMI, you must set Os to Custom.
    public var amiId: Swift.String?
    /// The instance architecture. The default option is x86_64. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// The instance Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
    public var availabilityZone: Swift.String?
    /// An array of BlockDeviceMapping objects that specify the instance's block devices. For more information, see [Block Device Mapping](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html). Note that block device mappings are not supported for custom AMIs.
    public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
    /// Whether to create an Amazon EBS-optimized instance.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name. The following are character limits for instance host names.
    ///
    /// * Linux-based instances: 63 characters
    ///
    /// * Windows-based instances: 15 characters
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html). The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
    /// This member is required.
    public var instanceType: Swift.String?
    /// An array that contains the instance's layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2, Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 18.04 LTS, Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom.
    ///
    ///
    /// Not all operating systems are supported with all versions of Chef. For more information about the supported operating systems, see [OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the [CreateInstance] action's AmiId parameter to specify the custom AMI that you want to use. Block device mappings are not supported if the value is Custom. For more information about how to use custom AMIs with OpsWorks Stacks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    public var os: Swift.String?
    /// The instance root device type. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// The instance's Amazon EC2 key-pair name.
    public var sshKeyName: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The ID of the instance's subnet. If the stack is running in a VPC, you can use this parameter to override the stack's default subnet ID value and direct OpsWorks Stacks to launch the instance in a different subnet.
    public var subnetId: Swift.String?
    /// The instance's tenancy option. The default option is no tenancy, or if the instance is running in a VPC, inherit tenancy settings from the VPC. The following are valid values for this parameter: dedicated, default, or host. Because there are costs associated with changes in tenancy options, we recommend that you research tenancy options before choosing them for your instances. For more information about dedicated hosts, see [Dedicated Hosts Overview](http://aws.amazon.com/ec2/dedicated-hosts/) and [Amazon EC2 Dedicated Hosts](http://aws.amazon.com/ec2/dedicated-hosts/). For more information about dedicated instances, see [Dedicated Instances](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html) and [Amazon EC2 Dedicated Instances](http://aws.amazon.com/ec2/purchasing-options/dedicated-instances/).
    public var tenancy: Swift.String?
    /// The instance's virtualization type, paravirtual or hvm.
    public var virtualizationType: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        availabilityZone: Swift.String? = nil,
        blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        sshKeyName: Swift.String? = nil,
        stackId: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tenancy: Swift.String? = nil,
        virtualizationType: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.availabilityZone = availabilityZone
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.rootDeviceType = rootDeviceType
        self.sshKeyName = sshKeyName
        self.stackId = stackId
        self.subnetId = subnetId
        self.tenancy = tenancy
        self.virtualizationType = virtualizationType
    }
}

/// Contains the response to a CreateInstance request.
public struct CreateInstanceOutput: Swift.Sendable {
    /// The instance ID.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

extension OpsWorksClientTypes {

    public enum LayerAttributesKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bundlerversion
        case ecsclusterarn
        case enablehaproxystats
        case gangliapassword
        case gangliaurl
        case gangliauser
        case haproxyhealthcheckmethod
        case haproxyhealthcheckurl
        case haproxystatspassword
        case haproxystatsurl
        case haproxystatsuser
        case javaappserver
        case javaappserverversion
        case jvm
        case jvmoptions
        case jvmversion
        case managebundler
        case memcachedmemory
        case mysqlrootpassword
        case mysqlrootpasswordubiquitous
        case nodejsversion
        case passengerversion
        case railsstack
        case rubyversion
        case rubygemsversion
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAttributesKeys] {
            return [
                .bundlerversion,
                .ecsclusterarn,
                .enablehaproxystats,
                .gangliapassword,
                .gangliaurl,
                .gangliauser,
                .haproxyhealthcheckmethod,
                .haproxyhealthcheckurl,
                .haproxystatspassword,
                .haproxystatsurl,
                .haproxystatsuser,
                .javaappserver,
                .javaappserverversion,
                .jvm,
                .jvmoptions,
                .jvmversion,
                .managebundler,
                .memcachedmemory,
                .mysqlrootpassword,
                .mysqlrootpasswordubiquitous,
                .nodejsversion,
                .passengerversion,
                .railsstack,
                .rubyversion,
                .rubygemsversion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bundlerversion: return "BundlerVersion"
            case .ecsclusterarn: return "EcsClusterArn"
            case .enablehaproxystats: return "EnableHaproxyStats"
            case .gangliapassword: return "GangliaPassword"
            case .gangliaurl: return "GangliaUrl"
            case .gangliauser: return "GangliaUser"
            case .haproxyhealthcheckmethod: return "HaproxyHealthCheckMethod"
            case .haproxyhealthcheckurl: return "HaproxyHealthCheckUrl"
            case .haproxystatspassword: return "HaproxyStatsPassword"
            case .haproxystatsurl: return "HaproxyStatsUrl"
            case .haproxystatsuser: return "HaproxyStatsUser"
            case .javaappserver: return "JavaAppServer"
            case .javaappserverversion: return "JavaAppServerVersion"
            case .jvm: return "Jvm"
            case .jvmoptions: return "JvmOptions"
            case .jvmversion: return "JvmVersion"
            case .managebundler: return "ManageBundler"
            case .memcachedmemory: return "MemcachedMemory"
            case .mysqlrootpassword: return "MysqlRootPassword"
            case .mysqlrootpasswordubiquitous: return "MysqlRootPasswordUbiquitous"
            case .nodejsversion: return "NodejsVersion"
            case .passengerversion: return "PassengerVersion"
            case .railsstack: return "RailsStack"
            case .rubyversion: return "RubyVersion"
            case .rubygemsversion: return "RubygemsVersion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// OpsWorks Stacks supports five lifecycle events: setup, configuration, deploy, undeploy, and shutdown. For each layer, OpsWorks Stacks runs a set of standard recipes for each event. In addition, you can provide custom recipes for any or all layers and events. OpsWorks Stacks runs custom event recipes after the standard recipes. LayerCustomRecipes specifies the custom recipes for a particular layer to be run in response to each of the five events. To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.
    public struct Recipes: Swift.Sendable {
        /// An array of custom recipe names to be run following a configure event.
        public var configure: [Swift.String]?
        /// An array of custom recipe names to be run following a deploy event.
        public var deploy: [Swift.String]?
        /// An array of custom recipe names to be run following a setup event.
        public var setup: [Swift.String]?
        /// An array of custom recipe names to be run following a shutdown event.
        public var shutdown: [Swift.String]?
        /// An array of custom recipe names to be run following a undeploy event.
        public var undeploy: [Swift.String]?

        public init(
            configure: [Swift.String]? = nil,
            deploy: [Swift.String]? = nil,
            setup: [Swift.String]? = nil,
            shutdown: [Swift.String]? = nil,
            undeploy: [Swift.String]? = nil
        )
        {
            self.configure = configure
            self.deploy = deploy
            self.setup = setup
            self.shutdown = shutdown
            self.undeploy = undeploy
        }
    }
}

extension OpsWorksClientTypes {

    /// The Shutdown event configuration.
    public struct ShutdownEventConfiguration: Swift.Sendable {
        /// Whether to enable Elastic Load Balancing connection draining. For more information, see [Connection Draining](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#conn-drain)
        public var delayUntilElbConnectionsDrained: Swift.Bool?
        /// The time, in seconds, that OpsWorks Stacks waits after triggering a Shutdown event before shutting down an instance.
        public var executionTimeout: Swift.Int?

        public init(
            delayUntilElbConnectionsDrained: Swift.Bool? = nil,
            executionTimeout: Swift.Int? = nil
        )
        {
            self.delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained
            self.executionTimeout = executionTimeout
        }
    }
}

extension OpsWorksClientTypes {

    /// Specifies the lifecycle event configuration
    public struct LifecycleEventConfiguration: Swift.Sendable {
        /// A ShutdownEventConfiguration object that specifies the Shutdown event configuration.
        public var shutdown: OpsWorksClientTypes.ShutdownEventConfiguration?

        public init(
            shutdown: OpsWorksClientTypes.ShutdownEventConfiguration? = nil
        )
        {
            self.shutdown = shutdown
        }
    }
}

extension OpsWorksClientTypes {

    public enum LayerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsFlowRuby
        case custom
        case dbMaster
        case ecsCluster
        case javaApp
        case lb
        case memcached
        case monitoringMaster
        case nodejsApp
        case phpApp
        case railsApp
        case web
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerType] {
            return [
                .awsFlowRuby,
                .custom,
                .dbMaster,
                .ecsCluster,
                .javaApp,
                .lb,
                .memcached,
                .monitoringMaster,
                .nodejsApp,
                .phpApp,
                .railsApp,
                .web
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .custom: return "custom"
            case .dbMaster: return "db-master"
            case .ecsCluster: return "ecs-cluster"
            case .javaApp: return "java-app"
            case .lb: return "lb"
            case .memcached: return "memcached"
            case .monitoringMaster: return "monitoring-master"
            case .nodejsApp: return "nodejs-app"
            case .phpApp: return "php-app"
            case .railsApp: return "rails-app"
            case .web: return "web"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an Amazon EBS volume configuration.
    public struct VolumeConfiguration: Swift.Sendable {
        /// Specifies whether an Amazon EBS volume is encrypted. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html).
        public var encrypted: Swift.Bool?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example "/dev/sdh".
        /// This member is required.
        public var mountPoint: Swift.String?
        /// The number of disks in the volume.
        /// This member is required.
        public var numberOfDisks: Swift.Int?
        /// The volume [RAID level](http://en.wikipedia.org/wiki/Standard_RAID_levels).
        public var raidLevel: Swift.Int?
        /// The volume size.
        /// This member is required.
        public var size: Swift.Int?
        /// The volume type. For more information, see [ Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
        ///
        /// * standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        /// * io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        /// * gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        /// * st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 125 GiB and a maximum size of 16384 GiB.
        ///
        /// * sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 125 GiB and a maximum size of 16384 GiB.
        public var volumeType: Swift.String?

        public init(
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.encrypted = encrypted
            self.iops = iops
            self.mountPoint = mountPoint
            self.numberOfDisks = numberOfDisks
            self.raidLevel = raidLevel
            self.size = size
            self.volumeType = volumeType
        }
    }
}

public struct CreateLayerInput: Swift.Sendable {
    /// One or more user-defined key-value pairs to be added to the stack attributes. To create a cluster layer, set the EcsClusterArn attribute to the cluster's ARN.
    public var attributes: [Swift.String: Swift.String]?
    /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see [CloudWatchLogsLogStream].
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see [ Using Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html). This feature is supported as of version 1.7.42 of the CLI.
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. To ensure that your instances have the latest security updates, we strongly recommend using the default value of true.
    public var installUpdatesOnBoot: Swift.Bool?
    /// A LifeCycleEventConfiguration object that you can use to configure the Shutdown event to specify an execution timeout and enable or disable Elastic Load Balancer connection draining.
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console. Layer names can be a maximum of 32 characters.
    /// This member is required.
    public var name: Swift.String?
    /// An array of Package objects that describes the layer packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by OpsWorks Stacks and by Chef recipes. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 32 characters, which are limited to the alphanumeric characters, '-', '_', and '.'. Built-in layer short names are defined by OpsWorks Stacks. For more information, see the [Layer Reference](https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html).
    /// This member is required.
    public var shortname: Swift.String?
    /// The layer stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The layer type. A stack cannot have more than one built-in layer of the same type. It can have any number of custom layers. Built-in layers are not available in Chef 12 stacks.
    /// This member is required.
    public var type: OpsWorksClientTypes.LayerType?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.LayerType? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.stackId = stackId
        self.type = type
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

/// Contains the response to a CreateLayer request.
public struct CreateLayerOutput: Swift.Sendable {
    /// The layer ID.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

public struct CreateStackInput: Swift.Sendable {
    /// The default OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. OpsWorks Stacks installs that version on the stack's instances.
    ///
    ///
    /// The default setting is the most recent release of the agent. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you create a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the specified region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description.
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    /// This member is required.
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's default operating system, which is installed on every instance unless you specify a different operating system when you create the instance. You can specify one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2, Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 18.04 LTS, Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information, see [ Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the current Amazon Linux version. Not all operating systems are supported with all versions of Chef. For more information about supported operating systems, see [OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html).
    public var defaultOs: Swift.String?
    /// The default root device type. This value is the default for all instances in the stack, but you can override it when you create an instance. The default option is instance-store. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack name. Stack names can be a maximum of 64 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The stack's Amazon Web Services Region, such as ap-south-1. For more information about Amazon Web Services Regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). In the CLI, this API maps to the --stack-region parameter. If the --stack-region parameter and the CLI common parameter --region are set to the same value, the stack uses a regional endpoint. If the --stack-region parameter is not set, but the CLI --region parameter is, this also results in a stack with a regional endpoint. However, if the --region parameter is set to us-east-1, and the --stack-region parameter is set to one of the following, then the stack uses a legacy or classic region: us-west-1, us-west-2, sa-east-1, eu-central-1, eu-west-1, ap-northeast-1, ap-southeast-1, ap-southeast-2. In this case, the actual API endpoint of the stack is in us-east-1. Only the preceding regions are supported as classic regions in the us-east-1 API endpoint. Because it is a best practice to choose the regional endpoint that is closest to where you manage Amazon Web Services, we recommend that you use regional endpoints for new stacks. The CLI common --region parameter always specifies a regional API endpoint; it cannot be used to specify a classic OpsWorks Stacks region.
    /// This member is required.
    public var region: Swift.String?
    /// The stack's IAM role, which allows OpsWorks Stacks to work with Amazon Web Services resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the OpsWorks Stacks built-in security groups with the stack's layers. OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    /// * False - OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the stack is to be launched into. The VPC must be in the stack's region. All instances are launched into this VPC. You cannot change the ID later.
    ///
    /// * If your account supports EC2-Classic, the default value is no VPC.
    ///
    /// * If your account does not support EC2-Classic, the default value is the default VPC for the specified region.
    ///
    ///
    /// If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, OpsWorks Stacks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively. If you specify a nondefault VPC ID, note the following:
    ///
    /// * It must belong to a VPC in your account that is in the specified region.
    ///
    /// * You must specify a value for DefaultSubnetId.
    ///
    ///
    /// For more information about how to use OpsWorks Stacks with a VPC, see [Running a Stack in a VPC](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html). For more information about default VPC and EC2-Classic, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var vpcId: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

/// Contains the response to a CreateStack request.
public struct CreateStackOutput: Swift.Sendable {
    /// The stack ID, which is an opaque string that you use to identify the stack when performing actions such as DescribeStacks.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

public struct CreateUserProfileInput: Swift.Sendable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Setting an IAM User's Public SSH Key](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
    public var allowSelfManagement: Swift.Bool?
    /// The user's IAM ARN; this can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's public SSH key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, OpsWorks Stacks removes them. For example, my.name is changed to myname. If you do not specify an SSH user name, OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init(
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

/// Contains the response to a CreateUserProfile request.
public struct CreateUserProfileOutput: Swift.Sendable {
    /// The user's IAM ARN.
    public var iamUserArn: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

public struct DeleteAppInput: Swift.Sendable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct DeleteInstanceInput: Swift.Sendable {
    /// Whether to delete the instance Elastic IP address.
    public var deleteElasticIp: Swift.Bool?
    /// Whether to delete the instance's Amazon EBS volumes.
    public var deleteVolumes: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        deleteElasticIp: Swift.Bool? = nil,
        deleteVolumes: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.deleteElasticIp = deleteElasticIp
        self.deleteVolumes = deleteVolumes
        self.instanceId = instanceId
    }
}

public struct DeleteLayerInput: Swift.Sendable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

public struct DeleteStackInput: Swift.Sendable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

public struct DeleteUserProfileInput: Swift.Sendable {
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

extension OpsWorksClientTypes {

    /// Describes a deployment of a stack or app.
    public struct Deployment: Swift.Sendable {
        /// The app ID.
        public var appId: Swift.String?
        /// Used to specify a stack or deployment command.
        public var command: OpsWorksClientTypes.DeploymentCommand?
        /// A user-defined comment.
        public var comment: Swift.String?
        /// Date when the deployment completed.
        public var completedAt: Swift.String?
        /// Date when the deployment was created.
        public var createdAt: Swift.String?
        /// A string that contains user-defined custom JSON. It can be used to override the corresponding default stack configuration attribute values for stack or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information on custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
        public var customJson: Swift.String?
        /// The deployment ID.
        public var deploymentId: Swift.String?
        /// The deployment duration.
        public var duration: Swift.Int?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The IDs of the target instances.
        public var instanceIds: [Swift.String]?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The deployment status:
        ///
        /// * running
        ///
        /// * successful
        ///
        /// * failed
        public var status: Swift.String?

        public init(
            appId: Swift.String? = nil,
            command: OpsWorksClientTypes.DeploymentCommand? = nil,
            comment: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            customJson: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            duration: Swift.Int? = nil,
            iamUserArn: Swift.String? = nil,
            instanceIds: [Swift.String]? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.appId = appId
            self.command = command
            self.comment = comment
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.customJson = customJson
            self.deploymentId = deploymentId
            self.duration = duration
            self.iamUserArn = iamUserArn
            self.instanceIds = instanceIds
            self.stackId = stackId
            self.status = status
        }
    }
}

public struct DeregisterEcsClusterInput: Swift.Sendable {
    /// The cluster's Amazon Resource Number (ARN).
    /// This member is required.
    public var ecsClusterArn: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

public struct DeregisterElasticIpInput: Swift.Sendable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

public struct DeregisterInstanceInput: Swift.Sendable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct DeregisterRdsDbInstanceInput: Swift.Sendable {
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init(
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

public struct DeregisterVolumeInput: Swift.Sendable {
    /// The OpsWorks Stacks volume ID, which is the GUID that OpsWorks Stacks assigned to the instance when you registered the volume with the stack, not the Amazon EC2 volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

public struct DescribeAgentVersionsInput: Swift.Sendable {
    /// The configuration manager.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.configurationManager = configurationManager
        self.stackId = stackId
    }
}

/// Contains the response to a DescribeAgentVersions request.
public struct DescribeAgentVersionsOutput: Swift.Sendable {
    /// The agent versions for the specified stack or configuration manager. Note that this value is the complete version number, not the abbreviated number used by the console.
    public var agentVersions: [OpsWorksClientTypes.AgentVersion]?

    public init(
        agentVersions: [OpsWorksClientTypes.AgentVersion]? = nil
    )
    {
        self.agentVersions = agentVersions
    }
}

public struct DescribeAppsInput: Swift.Sendable {
    /// An array of app IDs for the apps to be described. If you use this parameter, DescribeApps returns a description of the specified apps. Otherwise, it returns a description of every app.
    public var appIds: [Swift.String]?
    /// The app stack ID. If you use this parameter, DescribeApps returns a description of the apps in the specified stack.
    public var stackId: Swift.String?

    public init(
        appIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appIds = appIds
        self.stackId = stackId
    }
}

/// Contains the response to a DescribeApps request.
public struct DescribeAppsOutput: Swift.Sendable {
    /// An array of App objects that describe the specified apps.
    public var apps: [OpsWorksClientTypes.App]?

    public init(
        apps: [OpsWorksClientTypes.App]? = nil
    )
    {
        self.apps = apps
    }
}

public struct DescribeCommandsInput: Swift.Sendable {
    /// An array of command IDs. If you include this parameter, DescribeCommands returns a description of the specified commands. Otherwise, it returns a description of every command.
    public var commandIds: [Swift.String]?
    /// The deployment ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified deployment.
    public var deploymentId: Swift.String?
    /// The instance ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified instance.
    public var instanceId: Swift.String?

    public init(
        commandIds: [Swift.String]? = nil,
        deploymentId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.commandIds = commandIds
        self.deploymentId = deploymentId
        self.instanceId = instanceId
    }
}

/// Contains the response to a DescribeCommands request.
public struct DescribeCommandsOutput: Swift.Sendable {
    /// An array of Command objects that describe each of the specified commands.
    public var commands: [OpsWorksClientTypes.Command]?

    public init(
        commands: [OpsWorksClientTypes.Command]? = nil
    )
    {
        self.commands = commands
    }
}

public struct DescribeDeploymentsInput: Swift.Sendable {
    /// The app ID. If you include this parameter, the command returns a description of the commands associated with the specified app.
    public var appId: Swift.String?
    /// An array of deployment IDs to be described. If you include this parameter, the command returns a description of the specified deployments. Otherwise, it returns a description of every deployment.
    public var deploymentIds: [Swift.String]?
    /// The stack ID. If you include this parameter, the command returns a description of the commands associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        deploymentIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.deploymentIds = deploymentIds
        self.stackId = stackId
    }
}

/// Contains the response to a DescribeDeployments request.
public struct DescribeDeploymentsOutput: Swift.Sendable {
    /// An array of Deployment objects that describe the deployments.
    public var deployments: [OpsWorksClientTypes.Deployment]?

    public init(
        deployments: [OpsWorksClientTypes.Deployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

public struct DescribeEcsClustersInput: Swift.Sendable {
    /// A list of ARNs, one for each cluster to be described.
    public var ecsClusterArns: [Swift.String]?
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object'sNextToken parameter value is set to a token. To retrieve the next set of results, call DescribeEcsClusters again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A stack ID. DescribeEcsClusters returns a description of the cluster that is registered with the stack.
    public var stackId: Swift.String?

    public init(
        ecsClusterArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArns = ecsClusterArns
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes a registered Amazon ECS cluster.
    public struct EcsCluster: Swift.Sendable {
        /// The cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// The cluster name.
        public var ecsClusterName: Swift.String?
        /// The time and date that the cluster was registered with the stack.
        public var registeredAt: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init(
            ecsClusterArn: Swift.String? = nil,
            ecsClusterName: Swift.String? = nil,
            registeredAt: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.ecsClusterArn = ecsClusterArn
            self.ecsClusterName = ecsClusterName
            self.registeredAt = registeredAt
            self.stackId = stackId
        }
    }
}

/// Contains the response to a DescribeEcsClusters request.
public struct DescribeEcsClustersOutput: Swift.Sendable {
    /// A list of EcsCluster objects containing the cluster descriptions.
    public var ecsClusters: [OpsWorksClientTypes.EcsCluster]?
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that you can assign to the request object's NextToken parameter to retrieve the next set of results. If the previous paginated request returned all of the remaining results, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        ecsClusters: [OpsWorksClientTypes.EcsCluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ecsClusters = ecsClusters
        self.nextToken = nextToken
    }
}

public struct DescribeElasticIpsInput: Swift.Sendable {
    /// The instance ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of Elastic IP addresses to be described. If you include this parameter, DescribeElasticIps returns a description of the specified Elastic IP addresses. Otherwise, it returns a description of every Elastic IP address.
    public var ips: [Swift.String]?
    /// A stack ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses that are registered with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ips: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ips = ips
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes an Elastic IP address.
    public struct ElasticIp: Swift.Sendable {
        /// The domain.
        public var domain: Swift.String?
        /// The ID of the instance that the address is attached to.
        public var instanceId: Swift.String?
        /// The IP address.
        public var ip: Swift.String?
        /// The name, which can be a maximum of 32 characters.
        public var name: Swift.String?
        /// The Amazon Web Services Region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?

        public init(
            domain: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            ip: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.domain = domain
            self.instanceId = instanceId
            self.ip = ip
            self.name = name
            self.region = region
        }
    }
}

/// Contains the response to a DescribeElasticIps request.
public struct DescribeElasticIpsOutput: Swift.Sendable {
    /// An ElasticIps object that describes the specified Elastic IP addresses.
    public var elasticIps: [OpsWorksClientTypes.ElasticIp]?

    public init(
        elasticIps: [OpsWorksClientTypes.ElasticIp]? = nil
    )
    {
        self.elasticIps = elasticIps
    }
}

public struct DescribeElasticLoadBalancersInput: Swift.Sendable {
    /// A list of layer IDs. The action describes the Elastic Load Balancing instances for the specified layers.
    public var layerIds: [Swift.String]?
    /// A stack ID. The action describes the stack's Elastic Load Balancing instances.
    public var stackId: Swift.String?

    public init(
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes an Elastic Load Balancing instance.
    public struct ElasticLoadBalancer: Swift.Sendable {
        /// A list of Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// The instance's public DNS name.
        public var dnsName: Swift.String?
        /// A list of the EC2 instances for which the Elastic Load Balancing instance is managing traffic.
        public var ec2InstanceIds: [Swift.String]?
        /// The Elastic Load Balancing instance name.
        public var elasticLoadBalancerName: Swift.String?
        /// The ID of the layer to which the instance is attached.
        public var layerId: Swift.String?
        /// The instance's Amazon Web Services Region.
        public var region: Swift.String?
        /// The ID of the stack with which the instance is associated.
        public var stackId: Swift.String?
        /// A list of subnet IDs, if the stack is running in a VPC.
        public var subnetIds: [Swift.String]?
        /// The VPC ID.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            dnsName: Swift.String? = nil,
            ec2InstanceIds: [Swift.String]? = nil,
            elasticLoadBalancerName: Swift.String? = nil,
            layerId: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.dnsName = dnsName
            self.ec2InstanceIds = ec2InstanceIds
            self.elasticLoadBalancerName = elasticLoadBalancerName
            self.layerId = layerId
            self.region = region
            self.stackId = stackId
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

/// Contains the response to a DescribeElasticLoadBalancers request.
public struct DescribeElasticLoadBalancersOutput: Swift.Sendable {
    /// A list of ElasticLoadBalancer objects that describe the specified Elastic Load Balancing instances.
    public var elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]?

    public init(
        elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]? = nil
    )
    {
        self.elasticLoadBalancers = elasticLoadBalancers
    }
}

public struct DescribeInstancesInput: Swift.Sendable {
    /// An array of instance IDs to be described. If you use this parameter, DescribeInstances returns a description of the specified instances. Otherwise, it returns a description of every instance.
    public var instanceIds: [Swift.String]?
    /// A layer ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified layer.
    public var layerId: Swift.String?
    /// A stack ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceIds: [Swift.String]? = nil,
        layerId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.layerId = layerId
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// A registered instance's reported operating system.
    public struct ReportedOs: Swift.Sendable {
        /// The operating system family.
        public var family: Swift.String?
        /// The operating system name.
        public var name: Swift.String?
        /// The operating system version.
        public var version: Swift.String?

        public init(
            family: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.family = family
            self.name = name
            self.version = version
        }
    }
}

extension OpsWorksClientTypes {

    public enum VirtualizationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hvm
        case paravirtual
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualizationType] {
            return [
                .hvm,
                .paravirtual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hvm: return "hvm"
            case .paravirtual: return "paravirtual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an instance.
    public struct Instance: Swift.Sendable {
        /// The agent version. This parameter is set to INHERIT if the instance inherits the default stack setting or to a a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// A custom AMI ID to be used to create the instance. For more information, see [Instances](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html)
        public var amiId: Swift.String?
        /// The instance architecture: "i386" or "x86_64".
        public var architecture: OpsWorksClientTypes.Architecture?
        /// The instance's Amazon Resource Number (ARN).
        public var arn: Swift.String?
        /// For load-based or time-based instances, the type.
        public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
        /// The instance Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// An array of BlockDeviceMapping objects that specify the instance's block device mappings.
        public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
        /// The time that the instance was created.
        public var createdAt: Swift.String?
        /// Whether this is an Amazon EBS-optimized instance.
        public var ebsOptimized: Swift.Bool?
        /// The ID of the associated Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// For container instances, the Amazon ECS cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// For container instances, the instance's ARN.
        public var ecsContainerInstanceArn: Swift.String?
        /// The instance [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html).
        public var elasticIp: Swift.String?
        /// The instance host name. The following are character limits for instance host names.
        ///
        /// * Linux-based instances: 63 characters
        ///
        /// * Windows-based instances: 15 characters
        public var hostname: Swift.String?
        /// For registered instances, the infrastructure class: ec2 or on-premises.
        public var infrastructureClass: Swift.String?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must update instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true to ensure that your instances have the latest security updates.
        public var installUpdatesOnBoot: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// The ARN of the instance's IAM profile. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var instanceProfileArn: Swift.String?
        /// The instance type, such as t2.micro.
        public var instanceType: Swift.String?
        /// The ID of the last service error. For more information, call [DescribeServiceErrors].
        public var lastServiceErrorId: Swift.String?
        /// An array containing the instance layer IDs.
        public var layerIds: [Swift.String]?
        /// The instance's operating system.
        public var os: Swift.String?
        /// The instance's platform.
        public var platform: Swift.String?
        /// The instance's private DNS name.
        public var privateDns: Swift.String?
        /// The instance's private IP address.
        public var privateIp: Swift.String?
        /// The instance public DNS name.
        public var publicDns: Swift.String?
        /// The instance public IP address.
        public var publicIp: Swift.String?
        /// For registered instances, who performed the registration.
        public var registeredBy: Swift.String?
        /// The instance's reported OpsWorks Stacks agent version.
        public var reportedAgentVersion: Swift.String?
        /// For registered instances, the reported operating system.
        public var reportedOs: OpsWorksClientTypes.ReportedOs?
        /// The instance's root device type. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
        public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// The root device volume ID.
        public var rootDeviceVolumeId: Swift.String?
        /// An array containing the instance security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// The SSH key's Deep Security Agent (DSA) fingerprint.
        public var sshHostDsaKeyFingerprint: Swift.String?
        /// The SSH key's RSA fingerprint.
        public var sshHostRsaKeyFingerprint: Swift.String?
        /// The instance's Amazon EC2 key-pair name.
        public var sshKeyName: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The instance status:
        ///
        /// * booting
        ///
        /// * connection_lost
        ///
        /// * online
        ///
        /// * pending
        ///
        /// * rebooting
        ///
        /// * requested
        ///
        /// * running_setup
        ///
        /// * setup_failed
        ///
        /// * shutting_down
        ///
        /// * start_failed
        ///
        /// * stop_failed
        ///
        /// * stopped
        ///
        /// * stopping
        ///
        /// * terminated
        ///
        /// * terminating
        public var status: Swift.String?
        /// The instance's subnet ID; applicable only if the stack is running in a VPC.
        public var subnetId: Swift.String?
        /// The instance's tenancy option, such as dedicated or host.
        public var tenancy: Swift.String?
        /// The instance's virtualization type: paravirtual or hvm.
        public var virtualizationType: OpsWorksClientTypes.VirtualizationType?

        public init(
            agentVersion: Swift.String? = nil,
            amiId: Swift.String? = nil,
            architecture: OpsWorksClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
            availabilityZone: Swift.String? = nil,
            blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
            createdAt: Swift.String? = nil,
            ebsOptimized: Swift.Bool? = nil,
            ec2InstanceId: Swift.String? = nil,
            ecsClusterArn: Swift.String? = nil,
            ecsContainerInstanceArn: Swift.String? = nil,
            elasticIp: Swift.String? = nil,
            hostname: Swift.String? = nil,
            infrastructureClass: Swift.String? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastServiceErrorId: Swift.String? = nil,
            layerIds: [Swift.String]? = nil,
            os: Swift.String? = nil,
            platform: Swift.String? = nil,
            privateDns: Swift.String? = nil,
            privateIp: Swift.String? = nil,
            publicDns: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            registeredBy: Swift.String? = nil,
            reportedAgentVersion: Swift.String? = nil,
            reportedOs: OpsWorksClientTypes.ReportedOs? = nil,
            rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            rootDeviceVolumeId: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            sshHostDsaKeyFingerprint: Swift.String? = nil,
            sshHostRsaKeyFingerprint: Swift.String? = nil,
            sshKeyName: Swift.String? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tenancy: Swift.String? = nil,
            virtualizationType: OpsWorksClientTypes.VirtualizationType? = nil
        )
        {
            self.agentVersion = agentVersion
            self.amiId = amiId
            self.architecture = architecture
            self.arn = arn
            self.autoScalingType = autoScalingType
            self.availabilityZone = availabilityZone
            self.blockDeviceMappings = blockDeviceMappings
            self.createdAt = createdAt
            self.ebsOptimized = ebsOptimized
            self.ec2InstanceId = ec2InstanceId
            self.ecsClusterArn = ecsClusterArn
            self.ecsContainerInstanceArn = ecsContainerInstanceArn
            self.elasticIp = elasticIp
            self.hostname = hostname
            self.infrastructureClass = infrastructureClass
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.instanceId = instanceId
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.lastServiceErrorId = lastServiceErrorId
            self.layerIds = layerIds
            self.os = os
            self.platform = platform
            self.privateDns = privateDns
            self.privateIp = privateIp
            self.publicDns = publicDns
            self.publicIp = publicIp
            self.registeredBy = registeredBy
            self.reportedAgentVersion = reportedAgentVersion
            self.reportedOs = reportedOs
            self.rootDeviceType = rootDeviceType
            self.rootDeviceVolumeId = rootDeviceVolumeId
            self.securityGroupIds = securityGroupIds
            self.sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint
            self.sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint
            self.sshKeyName = sshKeyName
            self.stackId = stackId
            self.status = status
            self.subnetId = subnetId
            self.tenancy = tenancy
            self.virtualizationType = virtualizationType
        }
    }
}

/// Contains the response to a DescribeInstances request.
public struct DescribeInstancesOutput: Swift.Sendable {
    /// An array of Instance objects that describe the instances.
    public var instances: [OpsWorksClientTypes.Instance]?

    public init(
        instances: [OpsWorksClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

public struct DescribeLayersInput: Swift.Sendable {
    /// An array of layer IDs that specify the layers to be described. If you omit this parameter, DescribeLayers returns a description of every layer in the specified stack.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes a layer.
    public struct Layer: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of a layer.
        public var arn: Swift.String?
        /// The layer attributes. For the HaproxyStatsPassword, MysqlRootPassword, and GangliaPassword attributes, OpsWorks Stacks returns *****FILTERED***** instead of the actual value For an ECS Cluster layer, OpsWorks Stacks the EcsClusterArn attribute is set to the cluster's ARN.
        public var attributes: [Swift.String: Swift.String]?
        /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
        public var autoAssignElasticIps: Swift.Bool?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
        public var autoAssignPublicIps: Swift.Bool?
        /// The Amazon CloudWatch Logs configuration settings for the layer.
        public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
        /// Date when the layer was created.
        public var createdAt: Swift.String?
        /// The ARN of the default IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var customInstanceProfileArn: Swift.String?
        /// A JSON formatted string containing the layer's custom stack configuration and deployment attributes.
        public var customJson: Swift.String?
        /// A LayerCustomRecipes object that specifies the layer's custom recipes.
        public var customRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's custom security group IDs.
        public var customSecurityGroupIds: [Swift.String]?
        /// OpsWorks Stacks supports five lifecycle events: setup, configuration, deploy, undeploy, and shutdown. For each layer, OpsWorks Stacks runs a set of standard recipes for each event. You can also provide custom recipes for any or all layers and events. OpsWorks Stacks runs custom event recipes after the standard recipes. LayerCustomRecipes specifies the custom recipes for a particular layer to be run in response to each of the five events. To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.
        public var defaultRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's security group names.
        public var defaultSecurityGroupNames: [Swift.String]?
        /// Whether auto healing is disabled for the layer.
        public var enableAutoHealing: Swift.Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
        public var installUpdatesOnBoot: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// A LifeCycleEventConfiguration object that specifies the Shutdown event configuration.
        public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
        /// The layer name. Layer names can be a maximum of 32 characters.
        public var name: Swift.String?
        /// An array of Package objects that describe the layer's packages.
        public var packages: [Swift.String]?
        /// The layer short name.
        public var shortname: Swift.String?
        /// The layer stack ID.
        public var stackId: Swift.String?
        /// The layer type.
        public var type: OpsWorksClientTypes.LayerType?
        /// Whether the layer uses Amazon EBS-optimized instances.
        public var useEbsOptimizedInstances: Swift.Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            autoAssignElasticIps: Swift.Bool? = nil,
            autoAssignPublicIps: Swift.Bool? = nil,
            cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
            createdAt: Swift.String? = nil,
            customInstanceProfileArn: Swift.String? = nil,
            customJson: Swift.String? = nil,
            customRecipes: OpsWorksClientTypes.Recipes? = nil,
            customSecurityGroupIds: [Swift.String]? = nil,
            defaultRecipes: OpsWorksClientTypes.Recipes? = nil,
            defaultSecurityGroupNames: [Swift.String]? = nil,
            enableAutoHealing: Swift.Bool? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
            name: Swift.String? = nil,
            packages: [Swift.String]? = nil,
            shortname: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.LayerType? = nil,
            useEbsOptimizedInstances: Swift.Bool? = nil,
            volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.autoAssignPublicIps = autoAssignPublicIps
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.createdAt = createdAt
            self.customInstanceProfileArn = customInstanceProfileArn
            self.customJson = customJson
            self.customRecipes = customRecipes
            self.customSecurityGroupIds = customSecurityGroupIds
            self.defaultRecipes = defaultRecipes
            self.defaultSecurityGroupNames = defaultSecurityGroupNames
            self.enableAutoHealing = enableAutoHealing
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.layerId = layerId
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.name = name
            self.packages = packages
            self.shortname = shortname
            self.stackId = stackId
            self.type = type
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.volumeConfigurations = volumeConfigurations
        }
    }
}

/// Contains the response to a DescribeLayers request.
public struct DescribeLayersOutput: Swift.Sendable {
    /// An array of Layer objects that describe the layers.
    public var layers: [OpsWorksClientTypes.Layer]?

    public init(
        layers: [OpsWorksClientTypes.Layer]? = nil
    )
    {
        self.layers = layers
    }
}

public struct DescribeLoadBasedAutoScalingInput: Swift.Sendable {
    /// An array of layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init(
        layerIds: [Swift.String]? = nil
    )
    {
        self.layerIds = layerIds
    }
}

extension OpsWorksClientTypes {

    /// Describes a layer's load-based auto scaling configuration.
    public struct LoadBasedAutoScalingConfiguration: Swift.Sendable {
        /// An AutoScalingThresholds object that describes the downscaling configuration, which defines how and when OpsWorks Stacks reduces the number of instances.
        public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
        /// Whether load-based auto scaling is enabled for the layer.
        public var enable: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// An AutoScalingThresholds object that describes the upscaling configuration, which defines how and when OpsWorks Stacks increases the number of instances.
        public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

        public init(
            downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
            enable: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
        )
        {
            self.downScaling = downScaling
            self.enable = enable
            self.layerId = layerId
            self.upScaling = upScaling
        }
    }
}

/// Contains the response to a DescribeLoadBasedAutoScaling request.
public struct DescribeLoadBasedAutoScalingOutput: Swift.Sendable {
    /// An array of LoadBasedAutoScalingConfiguration objects that describe each layer's configuration.
    public var loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]?

    public init(
        loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]? = nil
    )
    {
        self.loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurations
    }
}

extension OpsWorksClientTypes {

    /// Describes a user's SSH information.
    public struct SelfUserProfile: Swift.Sendable {
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init(
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }
}

/// Contains the response to a DescribeMyUserProfile request.
public struct DescribeMyUserProfileOutput: Swift.Sendable {
    /// A UserProfile object that describes the user's SSH information.
    public var userProfile: OpsWorksClientTypes.SelfUserProfile?

    public init(
        userProfile: OpsWorksClientTypes.SelfUserProfile? = nil
    )
    {
        self.userProfile = userProfile
    }
}

extension OpsWorksClientTypes {

    /// A block that contains information about the configuration manager (Chef) and the versions of the configuration manager that are supported for an operating system.
    public struct OperatingSystemConfigurationManager: Swift.Sendable {
        /// The name of the configuration manager, which is Chef.
        public var name: Swift.String?
        /// The versions of the configuration manager that are supported by an operating system.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes supported operating systems in OpsWorks Stacks.
    public struct OperatingSystem: Swift.Sendable {
        /// Supported configuration manager name and versions for an OpsWorks Stacks operating system.
        public var configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]?
        /// The ID of a supported operating system, such as Amazon Linux 2.
        public var id: Swift.String?
        /// The name of the operating system, such as Amazon Linux 2.
        public var name: Swift.String?
        /// A short name for the operating system manufacturer.
        public var reportedName: Swift.String?
        /// The version of the operating system, including the release and edition, if applicable.
        public var reportedVersion: Swift.String?
        /// Indicates that an operating system is not supported for new instances.
        public var supported: Swift.Bool?
        /// The type of a supported operating system, either Linux or Windows.
        public var type: Swift.String?

        public init(
            configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reportedName: Swift.String? = nil,
            reportedVersion: Swift.String? = nil,
            supported: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.configurationManagers = configurationManagers
            self.id = id
            self.name = name
            self.reportedName = reportedName
            self.reportedVersion = reportedVersion
            self.supported = supported
            self.type = type
        }
    }
}

/// The response to a DescribeOperatingSystems request.
public struct DescribeOperatingSystemsOutput: Swift.Sendable {
    /// Contains information in response to a DescribeOperatingSystems request.
    public var operatingSystems: [OpsWorksClientTypes.OperatingSystem]?

    public init(
        operatingSystems: [OpsWorksClientTypes.OperatingSystem]? = nil
    )
    {
        self.operatingSystems = operatingSystems
    }
}

public struct DescribePermissionsInput: Swift.Sendable {
    /// The user's IAM ARN. This can also be a federated user's ARN. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var iamUserArn: Swift.String?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes stack or user permissions.
    public struct Permission: Swift.Sendable {
        /// Whether the user can use SSH.
        public var allowSsh: Swift.Bool?
        /// Whether the user can use sudo.
        public var allowSudo: Swift.Bool?
        /// The Amazon Resource Name (ARN) for an Identity and Access Management (IAM) role. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var iamUserArn: Swift.String?
        /// The user's permission level, which must be the following:
        ///
        /// * deny
        ///
        /// * show
        ///
        /// * deploy
        ///
        /// * manage
        ///
        /// * iam_only
        ///
        ///
        /// For more information on the permissions associated with these levels, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html)
        public var level: Swift.String?
        /// A stack ID.
        public var stackId: Swift.String?

        public init(
            allowSsh: Swift.Bool? = nil,
            allowSudo: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            level: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.allowSsh = allowSsh
            self.allowSudo = allowSudo
            self.iamUserArn = iamUserArn
            self.level = level
            self.stackId = stackId
        }
    }
}

/// Contains the response to a DescribePermissions request.
public struct DescribePermissionsOutput: Swift.Sendable {
    /// An array of Permission objects that describe the stack permissions.
    ///
    /// * If the request object contains only a stack ID, the array contains a Permission object with permissions for each of the stack IAM ARNs.
    ///
    /// * If the request object contains only an IAM ARN, the array contains a Permission object with permissions for each of the user's stack IDs.
    ///
    /// * If the request contains a stack ID and an IAM ARN, the array contains a single Permission object with permissions for the specified stack and IAM ARN.
    public var permissions: [OpsWorksClientTypes.Permission]?

    public init(
        permissions: [OpsWorksClientTypes.Permission]? = nil
    )
    {
        self.permissions = permissions
    }
}

public struct DescribeRaidArraysInput: Swift.Sendable {
    /// The instance ID. If you use this parameter, DescribeRaidArrays returns descriptions of the RAID arrays associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of RAID array IDs. If you use this parameter, DescribeRaidArrays returns descriptions of the specified arrays. Otherwise, it returns a description of every array.
    public var raidArrayIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        raidArrayIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayIds = raidArrayIds
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes an instance's RAID array.
    public struct RaidArray: Swift.Sendable {
        /// The array's Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// When the RAID array was created.
        public var createdAt: Swift.String?
        /// The array's Linux device. For example /dev/mdadm0.
        public var device: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The array's mount point.
        public var mountPoint: Swift.String?
        /// The array name.
        public var name: Swift.String?
        /// The number of disks in the array.
        public var numberOfDisks: Swift.Int?
        /// The array ID.
        public var raidArrayId: Swift.String?
        /// The [RAID level](http://en.wikipedia.org/wiki/Standard_RAID_levels).
        public var raidLevel: Swift.Int?
        /// The array's size.
        public var size: Swift.Int?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The volume type, standard or PIOPS.
        public var volumeType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            device: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidArrayId: Swift.String? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            stackId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.createdAt = createdAt
            self.device = device
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.numberOfDisks = numberOfDisks
            self.raidArrayId = raidArrayId
            self.raidLevel = raidLevel
            self.size = size
            self.stackId = stackId
            self.volumeType = volumeType
        }
    }
}

/// Contains the response to a DescribeRaidArrays request.
public struct DescribeRaidArraysOutput: Swift.Sendable {
    /// A RaidArrays object that describes the specified RAID arrays.
    public var raidArrays: [OpsWorksClientTypes.RaidArray]?

    public init(
        raidArrays: [OpsWorksClientTypes.RaidArray]? = nil
    )
    {
        self.raidArrays = raidArrays
    }
}

public struct DescribeRdsDbInstancesInput: Swift.Sendable {
    /// An array containing the ARNs of the instances to be described.
    public var rdsDbInstanceArns: [Swift.String]?
    /// The ID of the stack with which the instances are registered. The operation returns descriptions of all registered Amazon RDS instances.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        rdsDbInstanceArns: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArns = rdsDbInstanceArns
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes an Amazon RDS instance.
    public struct RdsDbInstance: Swift.Sendable {
        /// The instance's address.
        public var address: Swift.String?
        /// The database instance identifier.
        public var dbInstanceIdentifier: Swift.String?
        /// OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var dbPassword: Swift.String?
        /// The master user name.
        public var dbUser: Swift.String?
        /// The instance's database engine.
        public var engine: Swift.String?
        /// Set to true if OpsWorks Stacks is unable to discover the Amazon RDS instance. OpsWorks Stacks attempts to discover the instance only once. If this value is set to true, you must deregister the instance, and then register it again.
        public var missingOnRds: Swift.Bool?
        /// The instance's ARN.
        public var rdsDbInstanceArn: Swift.String?
        /// The instance's Amazon Web Services Region.
        public var region: Swift.String?
        /// The ID of the stack with which the instance is registered.
        public var stackId: Swift.String?

        public init(
            address: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbPassword: Swift.String? = nil,
            dbUser: Swift.String? = nil,
            engine: Swift.String? = nil,
            missingOnRds: Swift.Bool? = nil,
            rdsDbInstanceArn: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.address = address
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbPassword = dbPassword
            self.dbUser = dbUser
            self.engine = engine
            self.missingOnRds = missingOnRds
            self.rdsDbInstanceArn = rdsDbInstanceArn
            self.region = region
            self.stackId = stackId
        }
    }
}

/// Contains the response to a DescribeRdsDbInstances request.
public struct DescribeRdsDbInstancesOutput: Swift.Sendable {
    /// An a array of RdsDbInstance objects that describe the instances.
    public var rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]?

    public init(
        rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]? = nil
    )
    {
        self.rdsDbInstances = rdsDbInstances
    }
}

public struct DescribeServiceErrorsInput: Swift.Sendable {
    /// The instance ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of service error IDs. If you use this parameter, DescribeServiceErrors returns descriptions of the specified errors. Otherwise, it returns a description of every error.
    public var serviceErrorIds: [Swift.String]?
    /// The stack ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        serviceErrorIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceErrorIds = serviceErrorIds
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes an OpsWorks Stacks service error.
    public struct ServiceError: Swift.Sendable {
        /// When the error occurred.
        public var createdAt: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// A message that describes the error.
        public var message: Swift.String?
        /// The error ID.
        public var serviceErrorId: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The error type.
        public var type: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            message: Swift.String? = nil,
            serviceErrorId: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.instanceId = instanceId
            self.message = message
            self.serviceErrorId = serviceErrorId
            self.stackId = stackId
            self.type = type
        }
    }
}

/// Contains the response to a DescribeServiceErrors request.
public struct DescribeServiceErrorsOutput: Swift.Sendable {
    /// An array of ServiceError objects that describe the specified service errors.
    public var serviceErrors: [OpsWorksClientTypes.ServiceError]?

    public init(
        serviceErrors: [OpsWorksClientTypes.ServiceError]? = nil
    )
    {
        self.serviceErrors = serviceErrors
    }
}

public struct DescribeStackProvisioningParametersInput: Swift.Sendable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

/// Contains the response to a DescribeStackProvisioningParameters request.
public struct DescribeStackProvisioningParametersOutput: Swift.Sendable {
    /// The OpsWorks Stacks agent installer's URL.
    public var agentInstallerUrl: Swift.String?
    /// An embedded object that contains the provisioning parameters.
    public var parameters: [Swift.String: Swift.String]?

    public init(
        agentInstallerUrl: Swift.String? = nil,
        parameters: [Swift.String: Swift.String]? = nil
    )
    {
        self.agentInstallerUrl = agentInstallerUrl
        self.parameters = parameters
    }
}

public struct DescribeStacksInput: Swift.Sendable {
    /// An array of stack IDs that specify the stacks to be described. If you omit this parameter, and have permissions to get information about all stacks, DescribeStacks returns a description of every stack. If the IAM policy that is attached to an IAM user limits the DescribeStacks action to specific stack ARNs, this parameter is required, and the user must specify a stack ARN that is allowed by the policy. Otherwise, DescribeStacks returns an AccessDenied error.
    public var stackIds: [Swift.String]?

    public init(
        stackIds: [Swift.String]? = nil
    )
    {
        self.stackIds = stackIds
    }
}

extension OpsWorksClientTypes {

    /// Describes a stack.
    public struct Stack: Swift.Sendable {
        /// The agent version. This parameter is set to LATEST for auto-update. or a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// The stack's attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
        public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The date when the stack was created.
        public var createdAt: Swift.String?
        /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
        public var customCookbooksSource: OpsWorksClientTypes.Source?
        /// A JSON object that contains user-defined attributes to be added to the stack configuration and deployment attributes. You can use custom JSON to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information on custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
        public var customJson: Swift.String?
        /// The stack's default Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var defaultAvailabilityZone: Swift.String?
        /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var defaultInstanceProfileArn: Swift.String?
        /// The stack's default operating system.
        public var defaultOs: Swift.String?
        /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
        public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// A default Amazon EC2 key pair for the stack's instances. You can override this value when you create or update an instance.
        public var defaultSshKeyName: Swift.String?
        /// The default subnet ID; applicable only if the stack is running in a VPC.
        public var defaultSubnetId: Swift.String?
        /// The stack host name theme, with spaces replaced by underscores.
        public var hostnameTheme: Swift.String?
        /// The stack name. Stack names can be a maximum of 64 characters.
        public var name: Swift.String?
        /// The stack Amazon Web Services Region, such as ap-northeast-2. For more information about Amazon Web Services Regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?
        /// The stack Identity and Access Management (IAM) role.
        public var serviceRoleArn: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// Whether the stack uses custom cookbooks.
        public var useCustomCookbooks: Swift.Bool?
        /// Whether the stack automatically associates the OpsWorks Stacks built-in security groups with the stack's layers.
        public var useOpsworksSecurityGroups: Swift.Bool?
        /// The VPC ID; applicable only if the stack is running in a VPC.
        public var vpcId: Swift.String?

        public init(
            agentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            createdAt: Swift.String? = nil,
            customCookbooksSource: OpsWorksClientTypes.Source? = nil,
            customJson: Swift.String? = nil,
            defaultAvailabilityZone: Swift.String? = nil,
            defaultInstanceProfileArn: Swift.String? = nil,
            defaultOs: Swift.String? = nil,
            defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            defaultSshKeyName: Swift.String? = nil,
            defaultSubnetId: Swift.String? = nil,
            hostnameTheme: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            stackId: Swift.String? = nil,
            useCustomCookbooks: Swift.Bool? = nil,
            useOpsworksSecurityGroups: Swift.Bool? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.arn = arn
            self.attributes = attributes
            self.chefConfiguration = chefConfiguration
            self.configurationManager = configurationManager
            self.createdAt = createdAt
            self.customCookbooksSource = customCookbooksSource
            self.customJson = customJson
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.defaultOs = defaultOs
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultSshKeyName = defaultSshKeyName
            self.defaultSubnetId = defaultSubnetId
            self.hostnameTheme = hostnameTheme
            self.name = name
            self.region = region
            self.serviceRoleArn = serviceRoleArn
            self.stackId = stackId
            self.useCustomCookbooks = useCustomCookbooks
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
            self.vpcId = vpcId
        }
    }
}

/// Contains the response to a DescribeStacks request.
public struct DescribeStacksOutput: Swift.Sendable {
    /// An array of Stack objects that describe the stacks.
    public var stacks: [OpsWorksClientTypes.Stack]?

    public init(
        stacks: [OpsWorksClientTypes.Stack]? = nil
    )
    {
        self.stacks = stacks
    }
}

public struct DescribeStackSummaryInput: Swift.Sendable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

extension OpsWorksClientTypes {

    /// Describes how many instances a stack has for each status.
    public struct InstancesCount: Swift.Sendable {
        /// The number of instances in the Assigning state.
        public var assigning: Swift.Int?
        /// The number of instances with booting status.
        public var booting: Swift.Int?
        /// The number of instances with connection_lost status.
        public var connectionLost: Swift.Int?
        /// The number of instances in the Deregistering state.
        public var deregistering: Swift.Int?
        /// The number of instances with online status.
        public var online: Swift.Int?
        /// The number of instances with pending status.
        public var pending: Swift.Int?
        /// The number of instances with rebooting status.
        public var rebooting: Swift.Int?
        /// The number of instances in the Registered state.
        public var registered: Swift.Int?
        /// The number of instances in the Registering state.
        public var registering: Swift.Int?
        /// The number of instances with requested status.
        public var requested: Swift.Int?
        /// The number of instances with running_setup status.
        public var runningSetup: Swift.Int?
        /// The number of instances with setup_failed status.
        public var setupFailed: Swift.Int?
        /// The number of instances with shutting_down status.
        public var shuttingDown: Swift.Int?
        /// The number of instances with start_failed status.
        public var startFailed: Swift.Int?
        /// The number of instances with stop_failed status.
        public var stopFailed: Swift.Int?
        /// The number of instances with stopped status.
        public var stopped: Swift.Int?
        /// The number of instances with stopping status.
        public var stopping: Swift.Int?
        /// The number of instances with terminated status.
        public var terminated: Swift.Int?
        /// The number of instances with terminating status.
        public var terminating: Swift.Int?
        /// The number of instances in the Unassigning state.
        public var unassigning: Swift.Int?

        public init(
            assigning: Swift.Int? = nil,
            booting: Swift.Int? = nil,
            connectionLost: Swift.Int? = nil,
            deregistering: Swift.Int? = nil,
            online: Swift.Int? = nil,
            pending: Swift.Int? = nil,
            rebooting: Swift.Int? = nil,
            registered: Swift.Int? = nil,
            registering: Swift.Int? = nil,
            requested: Swift.Int? = nil,
            runningSetup: Swift.Int? = nil,
            setupFailed: Swift.Int? = nil,
            shuttingDown: Swift.Int? = nil,
            startFailed: Swift.Int? = nil,
            stopFailed: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            stopping: Swift.Int? = nil,
            terminated: Swift.Int? = nil,
            terminating: Swift.Int? = nil,
            unassigning: Swift.Int? = nil
        )
        {
            self.assigning = assigning
            self.booting = booting
            self.connectionLost = connectionLost
            self.deregistering = deregistering
            self.online = online
            self.pending = pending
            self.rebooting = rebooting
            self.registered = registered
            self.registering = registering
            self.requested = requested
            self.runningSetup = runningSetup
            self.setupFailed = setupFailed
            self.shuttingDown = shuttingDown
            self.startFailed = startFailed
            self.stopFailed = stopFailed
            self.stopped = stopped
            self.stopping = stopping
            self.terminated = terminated
            self.terminating = terminating
            self.unassigning = unassigning
        }
    }
}

extension OpsWorksClientTypes {

    /// Summarizes the number of layers, instances, and apps in a stack.
    public struct StackSummary: Swift.Sendable {
        /// The number of apps.
        public var appsCount: Swift.Int?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// An InstancesCount object with the number of instances in each status.
        public var instancesCount: OpsWorksClientTypes.InstancesCount?
        /// The number of layers.
        public var layersCount: Swift.Int?
        /// The stack name.
        public var name: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init(
            appsCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            instancesCount: OpsWorksClientTypes.InstancesCount? = nil,
            layersCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.appsCount = appsCount
            self.arn = arn
            self.instancesCount = instancesCount
            self.layersCount = layersCount
            self.name = name
            self.stackId = stackId
        }
    }
}

/// Contains the response to a DescribeStackSummary request.
public struct DescribeStackSummaryOutput: Swift.Sendable {
    /// A StackSummary object that contains the results.
    public var stackSummary: OpsWorksClientTypes.StackSummary?

    public init(
        stackSummary: OpsWorksClientTypes.StackSummary? = nil
    )
    {
        self.stackSummary = stackSummary
    }
}

public struct DescribeTimeBasedAutoScalingInput: Swift.Sendable {
    /// An array of instance IDs.
    /// This member is required.
    public var instanceIds: [Swift.String]?

    public init(
        instanceIds: [Swift.String]? = nil
    )
    {
        self.instanceIds = instanceIds
    }
}

extension OpsWorksClientTypes {

    /// Describes a time-based instance's auto scaling schedule. The schedule consists of a set of key-value pairs.
    ///
    /// * The key is the time period (a UTC hour) and must be an integer from 0 - 23.
    ///
    /// * The value indicates whether the instance should be online or offline for the specified period, and must be set to "on" or "off"
    ///
    ///
    /// The default setting for all time periods is off, so you use the following parameters primarily to specify the online periods. You don't have to explicitly specify offline periods unless you want to change an online period to an offline period. The following example specifies that the instance should be online for four hours, from UTC 1200 - 1600. It will be off for the remainder of the day.  { "12":"on", "13":"on", "14":"on", "15":"on" }
    public struct WeeklyAutoScalingSchedule: Swift.Sendable {
        /// The schedule for Friday.
        public var friday: [Swift.String: Swift.String]?
        /// The schedule for Monday.
        public var monday: [Swift.String: Swift.String]?
        /// The schedule for Saturday.
        public var saturday: [Swift.String: Swift.String]?
        /// The schedule for Sunday.
        public var sunday: [Swift.String: Swift.String]?
        /// The schedule for Thursday.
        public var thursday: [Swift.String: Swift.String]?
        /// The schedule for Tuesday.
        public var tuesday: [Swift.String: Swift.String]?
        /// The schedule for Wednesday.
        public var wednesday: [Swift.String: Swift.String]?

        public init(
            friday: [Swift.String: Swift.String]? = nil,
            monday: [Swift.String: Swift.String]? = nil,
            saturday: [Swift.String: Swift.String]? = nil,
            sunday: [Swift.String: Swift.String]? = nil,
            thursday: [Swift.String: Swift.String]? = nil,
            tuesday: [Swift.String: Swift.String]? = nil,
            wednesday: [Swift.String: Swift.String]? = nil
        )
        {
            self.friday = friday
            self.monday = monday
            self.saturday = saturday
            self.sunday = sunday
            self.thursday = thursday
            self.tuesday = tuesday
            self.wednesday = wednesday
        }
    }
}

extension OpsWorksClientTypes {

    /// Describes an instance's time-based auto scaling configuration.
    public struct TimeBasedAutoScalingConfiguration: Swift.Sendable {
        /// A WeeklyAutoScalingSchedule object with the instance schedule.
        public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
        /// The instance ID.
        public var instanceId: Swift.String?

        public init(
            autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.autoScalingSchedule = autoScalingSchedule
            self.instanceId = instanceId
        }
    }
}

/// Contains the response to a DescribeTimeBasedAutoScaling request.
public struct DescribeTimeBasedAutoScalingOutput: Swift.Sendable {
    /// An array of TimeBasedAutoScalingConfiguration objects that describe the configuration for the specified instances.
    public var timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]?

    public init(
        timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]? = nil
    )
    {
        self.timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurations
    }
}

public struct DescribeUserProfilesInput: Swift.Sendable {
    /// An array of IAM or federated user ARNs that identify the users to be described.
    public var iamUserArns: [Swift.String]?

    public init(
        iamUserArns: [Swift.String]? = nil
    )
    {
        self.iamUserArns = iamUserArns
    }
}

extension OpsWorksClientTypes {

    /// Describes a user's SSH information.
    public struct UserProfile: Swift.Sendable {
        /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
        public var allowSelfManagement: Swift.Bool?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init(
            allowSelfManagement: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.allowSelfManagement = allowSelfManagement
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }
}

/// Contains the response to a DescribeUserProfiles request.
public struct DescribeUserProfilesOutput: Swift.Sendable {
    /// A Users object that describes the specified users.
    public var userProfiles: [OpsWorksClientTypes.UserProfile]?

    public init(
        userProfiles: [OpsWorksClientTypes.UserProfile]? = nil
    )
    {
        self.userProfiles = userProfiles
    }
}

public struct DescribeVolumesInput: Swift.Sendable {
    /// The instance ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified instance.
    public var instanceId: Swift.String?
    /// The RAID array ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified RAID array.
    public var raidArrayId: Swift.String?
    /// A stack ID. The action describes the stack's registered Amazon EBS volumes.
    public var stackId: Swift.String?
    /// Am array of volume IDs. If you use this parameter, DescribeVolumes returns descriptions of the specified volumes. Otherwise, it returns a description of every volume.
    public var volumeIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        raidArrayId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        volumeIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayId = raidArrayId
        self.stackId = stackId
        self.volumeIds = volumeIds
    }
}

extension OpsWorksClientTypes {

    /// Describes an instance's Amazon EBS volume.
    public struct Volume: Swift.Sendable {
        /// The volume Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// The device name.
        public var device: Swift.String?
        /// The Amazon EC2 volume ID.
        public var ec2VolumeId: Swift.String?
        /// Specifies whether an Amazon EBS volume is encrypted. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html).
        public var encrypted: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example, "/mnt/disk1".
        public var mountPoint: Swift.String?
        /// The volume name. Volume names are a maximum of 128 characters.
        public var name: Swift.String?
        /// The RAID array ID.
        public var raidArrayId: Swift.String?
        /// The Amazon Web Services Region. For more information about Amazon Web Services Regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?
        /// The volume size.
        public var size: Swift.Int?
        /// The value returned by [DescribeVolumes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html).
        public var status: Swift.String?
        /// The volume ID.
        public var volumeId: Swift.String?
        /// The volume type. For more information, see [ Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
        ///
        /// * standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        /// * io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        /// * gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        /// * st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 125 GiB and a maximum size of 16384 GiB.
        ///
        /// * sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 125 GiB and a maximum size of 16384 GiB.
        public var volumeType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            device: Swift.String? = nil,
            ec2VolumeId: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            raidArrayId: Swift.String? = nil,
            region: Swift.String? = nil,
            size: Swift.Int? = nil,
            status: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.device = device
            self.ec2VolumeId = ec2VolumeId
            self.encrypted = encrypted
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.raidArrayId = raidArrayId
            self.region = region
            self.size = size
            self.status = status
            self.volumeId = volumeId
            self.volumeType = volumeType
        }
    }
}

/// Contains the response to a DescribeVolumes request.
public struct DescribeVolumesOutput: Swift.Sendable {
    /// An array of volume IDs.
    public var volumes: [OpsWorksClientTypes.Volume]?

    public init(
        volumes: [OpsWorksClientTypes.Volume]? = nil
    )
    {
        self.volumes = volumes
    }
}

public struct DetachElasticLoadBalancerInput: Swift.Sendable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer that the Elastic Load Balancing instance is attached to.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

public struct DisassociateElasticIpInput: Swift.Sendable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

public struct GetHostnameSuggestionInput: Swift.Sendable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

/// Contains the response to a GetHostnameSuggestion request.
public struct GetHostnameSuggestionOutput: Swift.Sendable {
    /// The generated host name.
    public var hostname: Swift.String?
    /// The layer ID.
    public var layerId: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.layerId = layerId
    }
}

public struct GrantAccessInput: Swift.Sendable {
    /// The instance's OpsWorks Stacks ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The length of time (in minutes) that the grant is valid. When the grant expires at the end of this period, the user will no longer be able to use the credentials to log in. If the user is logged in at the time, they are logged out.
    public var validForInMinutes: Swift.Int?

    public init(
        instanceId: Swift.String? = nil,
        validForInMinutes: Swift.Int? = nil
    )
    {
        self.instanceId = instanceId
        self.validForInMinutes = validForInMinutes
    }
}

extension OpsWorksClientTypes {

    /// Contains the data needed by RDP clients such as the Microsoft Remote Desktop Connection to log in to the instance.
    public struct TemporaryCredential: Swift.Sendable {
        /// The instance's OpsWorks Stacks ID.
        public var instanceId: Swift.String?
        /// The password.
        public var password: Swift.String?
        /// The user name.
        public var username: Swift.String?
        /// The length of time (in minutes) that the grant is valid. When the grant expires, at the end of this period, the user will no longer be able to use the credentials to log in. If they are logged in at the time, they are automatically logged out.
        public var validForInMinutes: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil,
            validForInMinutes: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.password = password
            self.username = username
            self.validForInMinutes = validForInMinutes
        }
    }
}

/// Contains the response to a GrantAccess request.
public struct GrantAccessOutput: Swift.Sendable {
    /// A TemporaryCredential object that contains the data needed to log in to the instance by RDP clients, such as the Microsoft Remote Desktop Connection.
    public var temporaryCredential: OpsWorksClientTypes.TemporaryCredential?

    public init(
        temporaryCredential: OpsWorksClientTypes.TemporaryCredential? = nil
    )
    {
        self.temporaryCredential = temporaryCredential
    }
}

extension OpsWorksClientTypes {

    /// Contains a description of an Amazon EC2 instance from the Amazon EC2 metadata service. For more information, see [Instance Metadata and User Data](https://docs.aws.amazon.com/sdkfornet/latest/apidocs/Index.html).
    public struct InstanceIdentity: Swift.Sendable {
        /// A JSON document that contains the metadata.
        public var document: Swift.String?
        /// A signature that can be used to verify the document's accuracy and authenticity.
        public var signature: Swift.String?

        public init(
            document: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.document = document
            self.signature = signature
        }
    }
}

public struct ListTagsInput: Swift.Sendable {
    /// Do not use. A validation exception occurs if you add a MaxResults parameter to a ListTagsRequest call.
    public var maxResults: Swift.Int?
    /// Do not use. A validation exception occurs if you add a NextToken parameter to a ListTagsRequest call.
    public var nextToken: Swift.String?
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

/// Contains the response to a ListTags request.
public struct ListTagsOutput: Swift.Sendable {
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that you can assign to the request object's NextToken parameter to get the next set of results. If the previous paginated request returned all of the remaining results, this parameter is set to null.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that contain tag keys and tag values that are attached to a stack or layer.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct RebootInstanceInput: Swift.Sendable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct RegisterEcsClusterInput: Swift.Sendable {
    /// The cluster's ARN.
    /// This member is required.
    public var ecsClusterArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
        self.stackId = stackId
    }
}

/// Contains the response to a RegisterEcsCluster request.
public struct RegisterEcsClusterOutput: Swift.Sendable {
    /// The cluster's ARN.
    public var ecsClusterArn: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

public struct RegisterElasticIpInput: Swift.Sendable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.stackId = stackId
    }
}

/// Contains the response to a RegisterElasticIp request.
public struct RegisterElasticIpOutput: Swift.Sendable {
    /// The Elastic IP address.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

public struct RegisterInstanceInput: Swift.Sendable {
    /// The instance's host name. The following are character limits for instance host names.
    ///
    /// * Linux-based instances: 63 characters
    ///
    /// * Windows-based instances: 15 characters
    public var hostname: Swift.String?
    /// An InstanceIdentity object that contains the instance's identity.
    public var instanceIdentity: OpsWorksClientTypes.InstanceIdentity?
    /// The instance's private IP address.
    public var privateIp: Swift.String?
    /// The instance's public IP address.
    public var publicIp: Swift.String?
    /// The instances public RSA key. This key is used to encrypt communication between the instance and the service.
    public var rsaPublicKey: Swift.String?
    /// The instances public RSA key fingerprint.
    public var rsaPublicKeyFingerprint: Swift.String?
    /// The ID of the stack that the instance is to be registered with.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        instanceIdentity: OpsWorksClientTypes.InstanceIdentity? = nil,
        privateIp: Swift.String? = nil,
        publicIp: Swift.String? = nil,
        rsaPublicKey: Swift.String? = nil,
        rsaPublicKeyFingerprint: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.privateIp = privateIp
        self.publicIp = publicIp
        self.rsaPublicKey = rsaPublicKey
        self.rsaPublicKeyFingerprint = rsaPublicKeyFingerprint
        self.stackId = stackId
    }
}

/// Contains the response to a RegisterInstanceResult request.
public struct RegisterInstanceOutput: Swift.Sendable {
    /// The registered instance's OpsWorks Stacks ID.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct RegisterRdsDbInstanceInput: Swift.Sendable {
    /// The database password.
    /// This member is required.
    public var dbPassword: Swift.String?
    /// The database's master user name.
    /// This member is required.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
        self.stackId = stackId
    }
}

public struct RegisterVolumeInput: Swift.Sendable {
    /// The Amazon EBS volume ID.
    public var ec2VolumeId: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        ec2VolumeId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ec2VolumeId = ec2VolumeId
        self.stackId = stackId
    }
}

/// Contains the response to a RegisterVolume request.
public struct RegisterVolumeOutput: Swift.Sendable {
    /// The volume ID.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

public struct SetLoadBasedAutoScalingInput: Swift.Sendable {
    /// An AutoScalingThresholds object with the downscaling threshold configuration. If the load falls below these thresholds for a specified amount of time, OpsWorks Stacks stops a specified number of instances.
    public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
    /// Enables load-based auto scaling for the layer.
    public var enable: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    /// An AutoScalingThresholds object with the upscaling threshold configuration. If the load exceeds these thresholds for a specified amount of time, OpsWorks Stacks starts a specified number of instances.
    public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

    public init(
        downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
        enable: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
    )
    {
        self.downScaling = downScaling
        self.enable = enable
        self.layerId = layerId
        self.upScaling = upScaling
    }
}

public struct SetPermissionInput: Swift.Sendable {
    /// The user is allowed to use SSH to communicate with the instance.
    public var allowSsh: Swift.Bool?
    /// The user is allowed to use sudo to elevate privileges.
    public var allowSudo: Swift.Bool?
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's permission level, which must be set to one of the following strings. You cannot set your own permissions level.
    ///
    /// * deny
    ///
    /// * show
    ///
    /// * deploy
    ///
    /// * manage
    ///
    /// * iam_only
    ///
    ///
    /// For more information about the permissions associated with these levels, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html).
    public var level: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        allowSsh: Swift.Bool? = nil,
        allowSudo: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        level: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.allowSsh = allowSsh
        self.allowSudo = allowSudo
        self.iamUserArn = iamUserArn
        self.level = level
        self.stackId = stackId
    }
}

public struct SetTimeBasedAutoScalingInput: Swift.Sendable {
    /// An AutoScalingSchedule with the instance schedule.
    public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.autoScalingSchedule = autoScalingSchedule
        self.instanceId = instanceId
    }
}

public struct StartInstanceInput: Swift.Sendable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct StartStackInput: Swift.Sendable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

public struct StopInstanceInput: Swift.Sendable {
    /// Specifies whether to force an instance to stop. If the instance's root device type is ebs, or EBS-backed, adding the Force parameter to the StopInstances API call disassociates the OpsWorks Stacks instance from EC2, and forces deletion of only the OpsWorks Stacks instance. You must also delete the formerly-associated instance in EC2 after troubleshooting and replacing the OpsWorks Stacks instance with a new one.
    public var force: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.force = force
        self.instanceId = instanceId
    }
}

public struct StopStackInput: Swift.Sendable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a stack or layer.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 40 tags is allowed for any resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UnassignInstanceInput: Swift.Sendable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct UnassignVolumeInput: Swift.Sendable {
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of tags to be removed from a stack or layer.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateAppInput: Swift.Sendable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// The app's data sources.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app's virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com'
    public var domains: [Swift.String]?
    /// Whether SSL is enabled for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances.For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20 KB)." If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    public var name: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The app type.
    public var type: OpsWorksClientTypes.AppType?

    public init(
        appId: Swift.String? = nil,
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appId = appId
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.sslConfiguration = sslConfiguration
        self.type = type
    }
}

public struct UpdateElasticIpInput: Swift.Sendable {
    /// The IP address for which you want to update the name.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The new name, which can be a maximum of 32 characters.
    public var name: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.name = name
    }
}

public struct UpdateInstanceInput: Swift.Sendable {
    /// The default OpsWorks Stacks agent version. You have the following options:
    ///
    /// * INHERIT - Use the stack's default agent version setting.
    ///
    /// * version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, you must edit the instance configuration and specify a new version. OpsWorks Stacks installs that version on the instance.
    ///
    ///
    /// The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using. You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs.
    public var amiId: Swift.String?
    /// The instance architecture. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// This property cannot be updated.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name. The following are character limits for instance host names.
    ///
    /// * Linux-based instances: 63 characters
    ///
    /// * Windows-based instances: 15 characters
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html). The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
    public var instanceType: Swift.String?
    /// The instance's layer IDs.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2, Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 18.04 LTS, Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    /// Not all operating systems are supported with all versions of Chef. For more information about supported operating systems, see [OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the AmiId parameter to specify the custom AMI that you want to use. For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html). You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux.
    public var os: Swift.String?
    /// The instance's Amazon EC2 key name.
    public var sshKeyName: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        sshKeyName: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.sshKeyName = sshKeyName
    }
}

public struct UpdateLayerInput: Swift.Sendable {
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see [CloudWatchLogsLogStream].
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see [ Using Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html).
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer's custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer's custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    ///
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console. Layer names can be a maximum of 32 characters.
    public var name: Swift.String?
    /// An array of Package objects that describe the layer's packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by OpsWorks Stacks and by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 32 characters and must be in the following format: /\A[a-z0-9\-\_\.]+\Z/. Built-in layer short names are defined by OpsWorks Stacks. For more information, see the [Layer reference](https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html) in the OpsWorks User Guide.
    public var shortname: Swift.String?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.layerId = layerId
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

public struct UpdateMyUserProfileInput: Swift.Sendable {
    /// The user's SSH public key.
    public var sshPublicKey: Swift.String?

    public init(
        sshPublicKey: Swift.String? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

public struct UpdateRdsDbInstanceInput: Swift.Sendable {
    /// The database password.
    public var dbPassword: Swift.String?
    /// The master user name.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

public struct UpdateStackInput: Swift.Sendable {
    /// The default OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. OpsWorks Stacks installs that version on the stack's instances.
    ///
    ///
    /// The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String: Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the stack's region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see [CreateStack].
    public var defaultAvailabilityZone: Swift.String?
    /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following:
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2, Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 18.04 LTS, Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the stack's current operating system. Not all operating systems are supported with all versions of Chef. For more information about supported operating systems, see [OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html).
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key-pair name. The default value is none. If you specify a key-pair name, OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's new host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack's new name. Stack names can be a maximum of 64 characters.
    public var name: Swift.String?
    /// Do not use this parameter. You cannot update a stack's service role.
    public var serviceRoleArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the OpsWorks Stacks built-in security groups with the stack's layers. OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. UseOpsworksSecurityGroups allows you to provide your own custom security groups instead of using the built-in groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    /// * False - OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        stackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.serviceRoleArn = serviceRoleArn
        self.stackId = stackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
    }
}

public struct UpdateUserProfileInput: Swift.Sendable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
    public var allowSelfManagement: Swift.Bool?
    /// The user IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's new SSH public key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, OpsWorks Stacks removes them. For example, my.name will be changed to myname. If you do not specify an SSH user name, OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init(
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

public struct UpdateVolumeInput: Swift.Sendable {
    /// The new mount point.
    public var mountPoint: Swift.String?
    /// The new name. Volume names can be a maximum of 128 characters.
    public var name: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        mountPoint: Swift.String? = nil,
        name: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.mountPoint = mountPoint
        self.name = name
        self.volumeId = volumeId
    }
}

extension AssignInstanceInput {

    static func urlPathProvider(_ value: AssignInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension AssignVolumeInput {

    static func urlPathProvider(_ value: AssignVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateElasticIpInput {

    static func urlPathProvider(_ value: AssociateElasticIpInput) -> Swift.String? {
        return "/"
    }
}

extension AttachElasticLoadBalancerInput {

    static func urlPathProvider(_ value: AttachElasticLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension CloneStackInput {

    static func urlPathProvider(_ value: CloneStackInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppInput {

    static func urlPathProvider(_ value: CreateAppInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceInput {

    static func urlPathProvider(_ value: CreateInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLayerInput {

    static func urlPathProvider(_ value: CreateLayerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStackInput {

    static func urlPathProvider(_ value: CreateStackInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserProfileInput {

    static func urlPathProvider(_ value: CreateUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppInput {

    static func urlPathProvider(_ value: DeleteAppInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceInput {

    static func urlPathProvider(_ value: DeleteInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLayerInput {

    static func urlPathProvider(_ value: DeleteLayerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStackInput {

    static func urlPathProvider(_ value: DeleteStackInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserProfileInput {

    static func urlPathProvider(_ value: DeleteUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterEcsClusterInput {

    static func urlPathProvider(_ value: DeregisterEcsClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterElasticIpInput {

    static func urlPathProvider(_ value: DeregisterElasticIpInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterInstanceInput {

    static func urlPathProvider(_ value: DeregisterInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterRdsDbInstanceInput {

    static func urlPathProvider(_ value: DeregisterRdsDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterVolumeInput {

    static func urlPathProvider(_ value: DeregisterVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAgentVersionsInput {

    static func urlPathProvider(_ value: DescribeAgentVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAppsInput {

    static func urlPathProvider(_ value: DescribeAppsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCommandsInput {

    static func urlPathProvider(_ value: DescribeCommandsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDeploymentsInput {

    static func urlPathProvider(_ value: DescribeDeploymentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEcsClustersInput {

    static func urlPathProvider(_ value: DescribeEcsClustersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeElasticIpsInput {

    static func urlPathProvider(_ value: DescribeElasticIpsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeElasticLoadBalancersInput {

    static func urlPathProvider(_ value: DescribeElasticLoadBalancersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstancesInput {

    static func urlPathProvider(_ value: DescribeInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLayersInput {

    static func urlPathProvider(_ value: DescribeLayersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoadBasedAutoScalingInput {

    static func urlPathProvider(_ value: DescribeLoadBasedAutoScalingInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMyUserProfileInput {

    static func urlPathProvider(_ value: DescribeMyUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOperatingSystemsInput {

    static func urlPathProvider(_ value: DescribeOperatingSystemsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePermissionsInput {

    static func urlPathProvider(_ value: DescribePermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRaidArraysInput {

    static func urlPathProvider(_ value: DescribeRaidArraysInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRdsDbInstancesInput {

    static func urlPathProvider(_ value: DescribeRdsDbInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceErrorsInput {

    static func urlPathProvider(_ value: DescribeServiceErrorsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStackProvisioningParametersInput {

    static func urlPathProvider(_ value: DescribeStackProvisioningParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStacksInput {

    static func urlPathProvider(_ value: DescribeStacksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStackSummaryInput {

    static func urlPathProvider(_ value: DescribeStackSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTimeBasedAutoScalingInput {

    static func urlPathProvider(_ value: DescribeTimeBasedAutoScalingInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUserProfilesInput {

    static func urlPathProvider(_ value: DescribeUserProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVolumesInput {

    static func urlPathProvider(_ value: DescribeVolumesInput) -> Swift.String? {
        return "/"
    }
}

extension DetachElasticLoadBalancerInput {

    static func urlPathProvider(_ value: DetachElasticLoadBalancerInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateElasticIpInput {

    static func urlPathProvider(_ value: DisassociateElasticIpInput) -> Swift.String? {
        return "/"
    }
}

extension GetHostnameSuggestionInput {

    static func urlPathProvider(_ value: GetHostnameSuggestionInput) -> Swift.String? {
        return "/"
    }
}

extension GrantAccessInput {

    static func urlPathProvider(_ value: GrantAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/"
    }
}

extension RebootInstanceInput {

    static func urlPathProvider(_ value: RebootInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterEcsClusterInput {

    static func urlPathProvider(_ value: RegisterEcsClusterInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterElasticIpInput {

    static func urlPathProvider(_ value: RegisterElasticIpInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterInstanceInput {

    static func urlPathProvider(_ value: RegisterInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterRdsDbInstanceInput {

    static func urlPathProvider(_ value: RegisterRdsDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterVolumeInput {

    static func urlPathProvider(_ value: RegisterVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension SetLoadBasedAutoScalingInput {

    static func urlPathProvider(_ value: SetLoadBasedAutoScalingInput) -> Swift.String? {
        return "/"
    }
}

extension SetPermissionInput {

    static func urlPathProvider(_ value: SetPermissionInput) -> Swift.String? {
        return "/"
    }
}

extension SetTimeBasedAutoScalingInput {

    static func urlPathProvider(_ value: SetTimeBasedAutoScalingInput) -> Swift.String? {
        return "/"
    }
}

extension StartInstanceInput {

    static func urlPathProvider(_ value: StartInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension StartStackInput {

    static func urlPathProvider(_ value: StartStackInput) -> Swift.String? {
        return "/"
    }
}

extension StopInstanceInput {

    static func urlPathProvider(_ value: StopInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension StopStackInput {

    static func urlPathProvider(_ value: StopStackInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UnassignInstanceInput {

    static func urlPathProvider(_ value: UnassignInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UnassignVolumeInput {

    static func urlPathProvider(_ value: UnassignVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAppInput {

    static func urlPathProvider(_ value: UpdateAppInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateElasticIpInput {

    static func urlPathProvider(_ value: UpdateElasticIpInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInstanceInput {

    static func urlPathProvider(_ value: UpdateInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLayerInput {

    static func urlPathProvider(_ value: UpdateLayerInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMyUserProfileInput {

    static func urlPathProvider(_ value: UpdateMyUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRdsDbInstanceInput {

    static func urlPathProvider(_ value: UpdateRdsDbInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateStackInput {

    static func urlPathProvider(_ value: UpdateStackInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserProfileInput {

    static func urlPathProvider(_ value: UpdateUserProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVolumeInput {

    static func urlPathProvider(_ value: UpdateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension AssignInstanceInput {

    static func write(value: AssignInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssignVolumeInput {

    static func write(value: AssignVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension AssociateElasticIpInput {

    static func write(value: AssociateElasticIpInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension AttachElasticLoadBalancerInput {

    static func write(value: AttachElasticLoadBalancerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticLoadBalancerName"].write(value.elasticLoadBalancerName)
        try writer["LayerId"].write(value.layerId)
    }
}

extension CloneStackInput {

    static func write(value: CloneStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChefConfiguration"].write(value.chefConfiguration, with: OpsWorksClientTypes.ChefConfiguration.write(value:to:))
        try writer["CloneAppIds"].writeList(value.cloneAppIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClonePermissions"].write(value.clonePermissions)
        try writer["ConfigurationManager"].write(value.configurationManager, with: OpsWorksClientTypes.StackConfigurationManager.write(value:to:))
        try writer["CustomCookbooksSource"].write(value.customCookbooksSource, with: OpsWorksClientTypes.Source.write(value:to:))
        try writer["CustomJson"].write(value.customJson)
        try writer["DefaultAvailabilityZone"].write(value.defaultAvailabilityZone)
        try writer["DefaultInstanceProfileArn"].write(value.defaultInstanceProfileArn)
        try writer["DefaultOs"].write(value.defaultOs)
        try writer["DefaultRootDeviceType"].write(value.defaultRootDeviceType)
        try writer["DefaultSshKeyName"].write(value.defaultSshKeyName)
        try writer["DefaultSubnetId"].write(value.defaultSubnetId)
        try writer["HostnameTheme"].write(value.hostnameTheme)
        try writer["Name"].write(value.name)
        try writer["Region"].write(value.region)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["SourceStackId"].write(value.sourceStackId)
        try writer["UseCustomCookbooks"].write(value.useCustomCookbooks)
        try writer["UseOpsworksSecurityGroups"].write(value.useOpsworksSecurityGroups)
        try writer["VpcId"].write(value.vpcId)
    }
}

extension CreateAppInput {

    static func write(value: CreateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppSource"].write(value.appSource, with: OpsWorksClientTypes.Source.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: OpsWorksClientTypes.DataSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Domains"].writeList(value.domains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableSsl"].write(value.enableSsl)
        try writer["Environment"].writeList(value.environment, memberWritingClosure: OpsWorksClientTypes.EnvironmentVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Shortname"].write(value.shortname)
        try writer["SslConfiguration"].write(value.sslConfiguration, with: OpsWorksClientTypes.SslConfiguration.write(value:to:))
        try writer["StackId"].write(value.stackId)
        try writer["Type"].write(value.type)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppId"].write(value.appId)
        try writer["Command"].write(value.command, with: OpsWorksClientTypes.DeploymentCommand.write(value:to:))
        try writer["Comment"].write(value.comment)
        try writer["CustomJson"].write(value.customJson)
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension CreateInstanceInput {

    static func write(value: CreateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["AmiId"].write(value.amiId)
        try writer["Architecture"].write(value.architecture)
        try writer["AutoScalingType"].write(value.autoScalingType)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["BlockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: OpsWorksClientTypes.BlockDeviceMapping.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["Hostname"].write(value.hostname)
        try writer["InstallUpdatesOnBoot"].write(value.installUpdatesOnBoot)
        try writer["InstanceType"].write(value.instanceType)
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Os"].write(value.os)
        try writer["RootDeviceType"].write(value.rootDeviceType)
        try writer["SshKeyName"].write(value.sshKeyName)
        try writer["StackId"].write(value.stackId)
        try writer["SubnetId"].write(value.subnetId)
        try writer["Tenancy"].write(value.tenancy)
        try writer["VirtualizationType"].write(value.virtualizationType)
    }
}

extension CreateLayerInput {

    static func write(value: CreateLayerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AutoAssignElasticIps"].write(value.autoAssignElasticIps)
        try writer["AutoAssignPublicIps"].write(value.autoAssignPublicIps)
        try writer["CloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: OpsWorksClientTypes.CloudWatchLogsConfiguration.write(value:to:))
        try writer["CustomInstanceProfileArn"].write(value.customInstanceProfileArn)
        try writer["CustomJson"].write(value.customJson)
        try writer["CustomRecipes"].write(value.customRecipes, with: OpsWorksClientTypes.Recipes.write(value:to:))
        try writer["CustomSecurityGroupIds"].writeList(value.customSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableAutoHealing"].write(value.enableAutoHealing)
        try writer["InstallUpdatesOnBoot"].write(value.installUpdatesOnBoot)
        try writer["LifecycleEventConfiguration"].write(value.lifecycleEventConfiguration, with: OpsWorksClientTypes.LifecycleEventConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Packages"].writeList(value.packages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Shortname"].write(value.shortname)
        try writer["StackId"].write(value.stackId)
        try writer["Type"].write(value.type)
        try writer["UseEbsOptimizedInstances"].write(value.useEbsOptimizedInstances)
        try writer["VolumeConfigurations"].writeList(value.volumeConfigurations, memberWritingClosure: OpsWorksClientTypes.VolumeConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStackInput {

    static func write(value: CreateStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChefConfiguration"].write(value.chefConfiguration, with: OpsWorksClientTypes.ChefConfiguration.write(value:to:))
        try writer["ConfigurationManager"].write(value.configurationManager, with: OpsWorksClientTypes.StackConfigurationManager.write(value:to:))
        try writer["CustomCookbooksSource"].write(value.customCookbooksSource, with: OpsWorksClientTypes.Source.write(value:to:))
        try writer["CustomJson"].write(value.customJson)
        try writer["DefaultAvailabilityZone"].write(value.defaultAvailabilityZone)
        try writer["DefaultInstanceProfileArn"].write(value.defaultInstanceProfileArn)
        try writer["DefaultOs"].write(value.defaultOs)
        try writer["DefaultRootDeviceType"].write(value.defaultRootDeviceType)
        try writer["DefaultSshKeyName"].write(value.defaultSshKeyName)
        try writer["DefaultSubnetId"].write(value.defaultSubnetId)
        try writer["HostnameTheme"].write(value.hostnameTheme)
        try writer["Name"].write(value.name)
        try writer["Region"].write(value.region)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["UseCustomCookbooks"].write(value.useCustomCookbooks)
        try writer["UseOpsworksSecurityGroups"].write(value.useOpsworksSecurityGroups)
        try writer["VpcId"].write(value.vpcId)
    }
}

extension CreateUserProfileInput {

    static func write(value: CreateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowSelfManagement"].write(value.allowSelfManagement)
        try writer["IamUserArn"].write(value.iamUserArn)
        try writer["SshPublicKey"].write(value.sshPublicKey)
        try writer["SshUsername"].write(value.sshUsername)
    }
}

extension DeleteAppInput {

    static func write(value: DeleteAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppId"].write(value.appId)
    }
}

extension DeleteInstanceInput {

    static func write(value: DeleteInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteElasticIp"].write(value.deleteElasticIp)
        try writer["DeleteVolumes"].write(value.deleteVolumes)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension DeleteLayerInput {

    static func write(value: DeleteLayerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LayerId"].write(value.layerId)
    }
}

extension DeleteStackInput {

    static func write(value: DeleteStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackId"].write(value.stackId)
    }
}

extension DeleteUserProfileInput {

    static func write(value: DeleteUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamUserArn"].write(value.iamUserArn)
    }
}

extension DeregisterEcsClusterInput {

    static func write(value: DeregisterEcsClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EcsClusterArn"].write(value.ecsClusterArn)
    }
}

extension DeregisterElasticIpInput {

    static func write(value: DeregisterElasticIpInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
    }
}

extension DeregisterInstanceInput {

    static func write(value: DeregisterInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension DeregisterRdsDbInstanceInput {

    static func write(value: DeregisterRdsDbInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RdsDbInstanceArn"].write(value.rdsDbInstanceArn)
    }
}

extension DeregisterVolumeInput {

    static func write(value: DeregisterVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension DescribeAgentVersionsInput {

    static func write(value: DescribeAgentVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationManager"].write(value.configurationManager, with: OpsWorksClientTypes.StackConfigurationManager.write(value:to:))
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeAppsInput {

    static func write(value: DescribeAppsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppIds"].writeList(value.appIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeCommandsInput {

    static func write(value: DescribeCommandsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommandIds"].writeList(value.commandIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension DescribeDeploymentsInput {

    static func write(value: DescribeDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppId"].write(value.appId)
        try writer["DeploymentIds"].writeList(value.deploymentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeEcsClustersInput {

    static func write(value: DescribeEcsClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EcsClusterArns"].writeList(value.ecsClusterArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeElasticIpsInput {

    static func write(value: DescribeElasticIpsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["Ips"].writeList(value.ips, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeElasticLoadBalancersInput {

    static func write(value: DescribeElasticLoadBalancersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeInstancesInput {

    static func write(value: DescribeInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LayerId"].write(value.layerId)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeLayersInput {

    static func write(value: DescribeLayersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeLoadBasedAutoScalingInput {

    static func write(value: DescribeLoadBasedAutoScalingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeMyUserProfileInput {

    static func write(value: DescribeMyUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeOperatingSystemsInput {

    static func write(value: DescribeOperatingSystemsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribePermissionsInput {

    static func write(value: DescribePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamUserArn"].write(value.iamUserArn)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeRaidArraysInput {

    static func write(value: DescribeRaidArraysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["RaidArrayIds"].writeList(value.raidArrayIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeRdsDbInstancesInput {

    static func write(value: DescribeRdsDbInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RdsDbInstanceArns"].writeList(value.rdsDbInstanceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeServiceErrorsInput {

    static func write(value: DescribeServiceErrorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["ServiceErrorIds"].writeList(value.serviceErrorIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeStackProvisioningParametersInput {

    static func write(value: DescribeStackProvisioningParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeStacksInput {

    static func write(value: DescribeStacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackIds"].writeList(value.stackIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeStackSummaryInput {

    static func write(value: DescribeStackSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackId"].write(value.stackId)
    }
}

extension DescribeTimeBasedAutoScalingInput {

    static func write(value: DescribeTimeBasedAutoScalingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeUserProfilesInput {

    static func write(value: DescribeUserProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamUserArns"].writeList(value.iamUserArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeVolumesInput {

    static func write(value: DescribeVolumesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["RaidArrayId"].write(value.raidArrayId)
        try writer["StackId"].write(value.stackId)
        try writer["VolumeIds"].writeList(value.volumeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DetachElasticLoadBalancerInput {

    static func write(value: DetachElasticLoadBalancerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticLoadBalancerName"].write(value.elasticLoadBalancerName)
        try writer["LayerId"].write(value.layerId)
    }
}

extension DisassociateElasticIpInput {

    static func write(value: DisassociateElasticIpInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
    }
}

extension GetHostnameSuggestionInput {

    static func write(value: GetHostnameSuggestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LayerId"].write(value.layerId)
    }
}

extension GrantAccessInput {

    static func write(value: GrantAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["ValidForInMinutes"].write(value.validForInMinutes)
    }
}

extension ListTagsInput {

    static func write(value: ListTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension RebootInstanceInput {

    static func write(value: RebootInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension RegisterEcsClusterInput {

    static func write(value: RegisterEcsClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EcsClusterArn"].write(value.ecsClusterArn)
        try writer["StackId"].write(value.stackId)
    }
}

extension RegisterElasticIpInput {

    static func write(value: RegisterElasticIpInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
        try writer["StackId"].write(value.stackId)
    }
}

extension RegisterInstanceInput {

    static func write(value: RegisterInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hostname"].write(value.hostname)
        try writer["InstanceIdentity"].write(value.instanceIdentity, with: OpsWorksClientTypes.InstanceIdentity.write(value:to:))
        try writer["PrivateIp"].write(value.privateIp)
        try writer["PublicIp"].write(value.publicIp)
        try writer["RsaPublicKey"].write(value.rsaPublicKey)
        try writer["RsaPublicKeyFingerprint"].write(value.rsaPublicKeyFingerprint)
        try writer["StackId"].write(value.stackId)
    }
}

extension RegisterRdsDbInstanceInput {

    static func write(value: RegisterRdsDbInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbPassword"].write(value.dbPassword)
        try writer["DbUser"].write(value.dbUser)
        try writer["RdsDbInstanceArn"].write(value.rdsDbInstanceArn)
        try writer["StackId"].write(value.stackId)
    }
}

extension RegisterVolumeInput {

    static func write(value: RegisterVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ec2VolumeId"].write(value.ec2VolumeId)
        try writer["StackId"].write(value.stackId)
    }
}

extension SetLoadBasedAutoScalingInput {

    static func write(value: SetLoadBasedAutoScalingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DownScaling"].write(value.downScaling, with: OpsWorksClientTypes.AutoScalingThresholds.write(value:to:))
        try writer["Enable"].write(value.enable)
        try writer["LayerId"].write(value.layerId)
        try writer["UpScaling"].write(value.upScaling, with: OpsWorksClientTypes.AutoScalingThresholds.write(value:to:))
    }
}

extension SetPermissionInput {

    static func write(value: SetPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowSsh"].write(value.allowSsh)
        try writer["AllowSudo"].write(value.allowSudo)
        try writer["IamUserArn"].write(value.iamUserArn)
        try writer["Level"].write(value.level)
        try writer["StackId"].write(value.stackId)
    }
}

extension SetTimeBasedAutoScalingInput {

    static func write(value: SetTimeBasedAutoScalingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingSchedule"].write(value.autoScalingSchedule, with: OpsWorksClientTypes.WeeklyAutoScalingSchedule.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StartInstanceInput {

    static func write(value: StartInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StartStackInput {

    static func write(value: StartStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackId"].write(value.stackId)
    }
}

extension StopInstanceInput {

    static func write(value: StopInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Force"].write(value.force)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension StopStackInput {

    static func write(value: StopStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackId"].write(value.stackId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UnassignInstanceInput {

    static func write(value: UnassignInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension UnassignVolumeInput {

    static func write(value: UnassignVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAppInput {

    static func write(value: UpdateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppId"].write(value.appId)
        try writer["AppSource"].write(value.appSource, with: OpsWorksClientTypes.Source.write(value:to:))
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: OpsWorksClientTypes.DataSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Domains"].writeList(value.domains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableSsl"].write(value.enableSsl)
        try writer["Environment"].writeList(value.environment, memberWritingClosure: OpsWorksClientTypes.EnvironmentVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["SslConfiguration"].write(value.sslConfiguration, with: OpsWorksClientTypes.SslConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension UpdateElasticIpInput {

    static func write(value: UpdateElasticIpInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
        try writer["Name"].write(value.name)
    }
}

extension UpdateInstanceInput {

    static func write(value: UpdateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["AmiId"].write(value.amiId)
        try writer["Architecture"].write(value.architecture)
        try writer["AutoScalingType"].write(value.autoScalingType)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["Hostname"].write(value.hostname)
        try writer["InstallUpdatesOnBoot"].write(value.installUpdatesOnBoot)
        try writer["InstanceId"].write(value.instanceId)
        try writer["InstanceType"].write(value.instanceType)
        try writer["LayerIds"].writeList(value.layerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Os"].write(value.os)
        try writer["SshKeyName"].write(value.sshKeyName)
    }
}

extension UpdateLayerInput {

    static func write(value: UpdateLayerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AutoAssignElasticIps"].write(value.autoAssignElasticIps)
        try writer["AutoAssignPublicIps"].write(value.autoAssignPublicIps)
        try writer["CloudWatchLogsConfiguration"].write(value.cloudWatchLogsConfiguration, with: OpsWorksClientTypes.CloudWatchLogsConfiguration.write(value:to:))
        try writer["CustomInstanceProfileArn"].write(value.customInstanceProfileArn)
        try writer["CustomJson"].write(value.customJson)
        try writer["CustomRecipes"].write(value.customRecipes, with: OpsWorksClientTypes.Recipes.write(value:to:))
        try writer["CustomSecurityGroupIds"].writeList(value.customSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableAutoHealing"].write(value.enableAutoHealing)
        try writer["InstallUpdatesOnBoot"].write(value.installUpdatesOnBoot)
        try writer["LayerId"].write(value.layerId)
        try writer["LifecycleEventConfiguration"].write(value.lifecycleEventConfiguration, with: OpsWorksClientTypes.LifecycleEventConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Packages"].writeList(value.packages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Shortname"].write(value.shortname)
        try writer["UseEbsOptimizedInstances"].write(value.useEbsOptimizedInstances)
        try writer["VolumeConfigurations"].writeList(value.volumeConfigurations, memberWritingClosure: OpsWorksClientTypes.VolumeConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMyUserProfileInput {

    static func write(value: UpdateMyUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SshPublicKey"].write(value.sshPublicKey)
    }
}

extension UpdateRdsDbInstanceInput {

    static func write(value: UpdateRdsDbInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbPassword"].write(value.dbPassword)
        try writer["DbUser"].write(value.dbUser)
        try writer["RdsDbInstanceArn"].write(value.rdsDbInstanceArn)
    }
}

extension UpdateStackInput {

    static func write(value: UpdateStackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ChefConfiguration"].write(value.chefConfiguration, with: OpsWorksClientTypes.ChefConfiguration.write(value:to:))
        try writer["ConfigurationManager"].write(value.configurationManager, with: OpsWorksClientTypes.StackConfigurationManager.write(value:to:))
        try writer["CustomCookbooksSource"].write(value.customCookbooksSource, with: OpsWorksClientTypes.Source.write(value:to:))
        try writer["CustomJson"].write(value.customJson)
        try writer["DefaultAvailabilityZone"].write(value.defaultAvailabilityZone)
        try writer["DefaultInstanceProfileArn"].write(value.defaultInstanceProfileArn)
        try writer["DefaultOs"].write(value.defaultOs)
        try writer["DefaultRootDeviceType"].write(value.defaultRootDeviceType)
        try writer["DefaultSshKeyName"].write(value.defaultSshKeyName)
        try writer["DefaultSubnetId"].write(value.defaultSubnetId)
        try writer["HostnameTheme"].write(value.hostnameTheme)
        try writer["Name"].write(value.name)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["StackId"].write(value.stackId)
        try writer["UseCustomCookbooks"].write(value.useCustomCookbooks)
        try writer["UseOpsworksSecurityGroups"].write(value.useOpsworksSecurityGroups)
    }
}

extension UpdateUserProfileInput {

    static func write(value: UpdateUserProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowSelfManagement"].write(value.allowSelfManagement)
        try writer["IamUserArn"].write(value.iamUserArn)
        try writer["SshPublicKey"].write(value.sshPublicKey)
        try writer["SshUsername"].write(value.sshUsername)
    }
}

extension UpdateVolumeInput {

    static func write(value: UpdateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MountPoint"].write(value.mountPoint)
        try writer["Name"].write(value.name)
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension AssignInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssignInstanceOutput {
        return AssignInstanceOutput()
    }
}

extension AssignVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssignVolumeOutput {
        return AssignVolumeOutput()
    }
}

extension AssociateElasticIpOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateElasticIpOutput {
        return AssociateElasticIpOutput()
    }
}

extension AttachElasticLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachElasticLoadBalancerOutput {
        return AttachElasticLoadBalancerOutput()
    }
}

extension CloneStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CloneStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CloneStackOutput()
        value.stackId = try reader["StackId"].readIfPresent()
        return value
    }
}

extension CreateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppOutput()
        value.appId = try reader["AppId"].readIfPresent()
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        return value
    }
}

extension CreateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceOutput()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension CreateLayerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLayerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLayerOutput()
        value.layerId = try reader["LayerId"].readIfPresent()
        return value
    }
}

extension CreateStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStackOutput()
        value.stackId = try reader["StackId"].readIfPresent()
        return value
    }
}

extension CreateUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserProfileOutput()
        value.iamUserArn = try reader["IamUserArn"].readIfPresent()
        return value
    }
}

extension DeleteAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppOutput {
        return DeleteAppOutput()
    }
}

extension DeleteInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceOutput {
        return DeleteInstanceOutput()
    }
}

extension DeleteLayerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLayerOutput {
        return DeleteLayerOutput()
    }
}

extension DeleteStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStackOutput {
        return DeleteStackOutput()
    }
}

extension DeleteUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserProfileOutput {
        return DeleteUserProfileOutput()
    }
}

extension DeregisterEcsClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterEcsClusterOutput {
        return DeregisterEcsClusterOutput()
    }
}

extension DeregisterElasticIpOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterElasticIpOutput {
        return DeregisterElasticIpOutput()
    }
}

extension DeregisterInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterInstanceOutput {
        return DeregisterInstanceOutput()
    }
}

extension DeregisterRdsDbInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterRdsDbInstanceOutput {
        return DeregisterRdsDbInstanceOutput()
    }
}

extension DeregisterVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterVolumeOutput {
        return DeregisterVolumeOutput()
    }
}

extension DescribeAgentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAgentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAgentVersionsOutput()
        value.agentVersions = try reader["AgentVersions"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.AgentVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAppsOutput()
        value.apps = try reader["Apps"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.App.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeCommandsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCommandsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCommandsOutput()
        value.commands = try reader["Commands"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Command.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeploymentsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEcsClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEcsClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEcsClustersOutput()
        value.ecsClusters = try reader["EcsClusters"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.EcsCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeElasticIpsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeElasticIpsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeElasticIpsOutput()
        value.elasticIps = try reader["ElasticIps"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.ElasticIp.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeElasticLoadBalancersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeElasticLoadBalancersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeElasticLoadBalancersOutput()
        value.elasticLoadBalancers = try reader["ElasticLoadBalancers"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.ElasticLoadBalancer.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLayersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLayersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLayersOutput()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Layer.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLoadBasedAutoScalingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoadBasedAutoScalingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLoadBasedAutoScalingOutput()
        value.loadBasedAutoScalingConfigurations = try reader["LoadBasedAutoScalingConfigurations"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.LoadBasedAutoScalingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMyUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMyUserProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMyUserProfileOutput()
        value.userProfile = try reader["UserProfile"].readIfPresent(with: OpsWorksClientTypes.SelfUserProfile.read(from:))
        return value
    }
}

extension DescribeOperatingSystemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOperatingSystemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOperatingSystemsOutput()
        value.operatingSystems = try reader["OperatingSystems"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.OperatingSystem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Permission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRaidArraysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRaidArraysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRaidArraysOutput()
        value.raidArrays = try reader["RaidArrays"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.RaidArray.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRdsDbInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRdsDbInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRdsDbInstancesOutput()
        value.rdsDbInstances = try reader["RdsDbInstances"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.RdsDbInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeServiceErrorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceErrorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceErrorsOutput()
        value.serviceErrors = try reader["ServiceErrors"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.ServiceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeStackProvisioningParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStackProvisioningParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStackProvisioningParametersOutput()
        value.agentInstallerUrl = try reader["AgentInstallerUrl"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeStacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStacksOutput()
        value.stacks = try reader["Stacks"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Stack.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeStackSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStackSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStackSummaryOutput()
        value.stackSummary = try reader["StackSummary"].readIfPresent(with: OpsWorksClientTypes.StackSummary.read(from:))
        return value
    }
}

extension DescribeTimeBasedAutoScalingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTimeBasedAutoScalingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTimeBasedAutoScalingOutput()
        value.timeBasedAutoScalingConfigurations = try reader["TimeBasedAutoScalingConfigurations"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.TimeBasedAutoScalingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeUserProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserProfilesOutput()
        value.userProfiles = try reader["UserProfiles"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.UserProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeVolumesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVolumesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVolumesOutput()
        value.volumes = try reader["Volumes"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.Volume.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DetachElasticLoadBalancerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachElasticLoadBalancerOutput {
        return DetachElasticLoadBalancerOutput()
    }
}

extension DisassociateElasticIpOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateElasticIpOutput {
        return DisassociateElasticIpOutput()
    }
}

extension GetHostnameSuggestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHostnameSuggestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHostnameSuggestionOutput()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.layerId = try reader["LayerId"].readIfPresent()
        return value
    }
}

extension GrantAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GrantAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GrantAccessOutput()
        value.temporaryCredential = try reader["TemporaryCredential"].readIfPresent(with: OpsWorksClientTypes.TemporaryCredential.read(from:))
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RebootInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RebootInstanceOutput {
        return RebootInstanceOutput()
    }
}

extension RegisterEcsClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterEcsClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterEcsClusterOutput()
        value.ecsClusterArn = try reader["EcsClusterArn"].readIfPresent()
        return value
    }
}

extension RegisterElasticIpOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterElasticIpOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterElasticIpOutput()
        value.elasticIp = try reader["ElasticIp"].readIfPresent()
        return value
    }
}

extension RegisterInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterInstanceOutput()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension RegisterRdsDbInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterRdsDbInstanceOutput {
        return RegisterRdsDbInstanceOutput()
    }
}

extension RegisterVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterVolumeOutput()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        return value
    }
}

extension SetLoadBasedAutoScalingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetLoadBasedAutoScalingOutput {
        return SetLoadBasedAutoScalingOutput()
    }
}

extension SetPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetPermissionOutput {
        return SetPermissionOutput()
    }
}

extension SetTimeBasedAutoScalingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetTimeBasedAutoScalingOutput {
        return SetTimeBasedAutoScalingOutput()
    }
}

extension StartInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartInstanceOutput {
        return StartInstanceOutput()
    }
}

extension StartStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartStackOutput {
        return StartStackOutput()
    }
}

extension StopInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopInstanceOutput {
        return StopInstanceOutput()
    }
}

extension StopStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopStackOutput {
        return StopStackOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UnassignInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnassignInstanceOutput {
        return UnassignInstanceOutput()
    }
}

extension UnassignVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnassignVolumeOutput {
        return UnassignVolumeOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppOutput {
        return UpdateAppOutput()
    }
}

extension UpdateElasticIpOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateElasticIpOutput {
        return UpdateElasticIpOutput()
    }
}

extension UpdateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceOutput {
        return UpdateInstanceOutput()
    }
}

extension UpdateLayerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLayerOutput {
        return UpdateLayerOutput()
    }
}

extension UpdateMyUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMyUserProfileOutput {
        return UpdateMyUserProfileOutput()
    }
}

extension UpdateRdsDbInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRdsDbInstanceOutput {
        return UpdateRdsDbInstanceOutput()
    }
}

extension UpdateStackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStackOutput {
        return UpdateStackOutput()
    }
}

extension UpdateUserProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserProfileOutput {
        return UpdateUserProfileOutput()
    }
}

extension UpdateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVolumeOutput {
        return UpdateVolumeOutput()
    }
}

enum AssignInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssignVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateElasticIpOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachElasticLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CloneStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLayerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLayerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterEcsClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterElasticIpOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterRdsDbInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAgentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCommandsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEcsClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeElasticIpsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeElasticLoadBalancersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLayersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoadBasedAutoScalingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMyUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOperatingSystemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRaidArraysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRdsDbInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceErrorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStackProvisioningParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStackSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTimeBasedAutoScalingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVolumesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachElasticLoadBalancerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateElasticIpOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHostnameSuggestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GrantAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RebootInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterEcsClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterElasticIpOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterRdsDbInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetLoadBasedAutoScalingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetTimeBasedAutoScalingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnassignInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnassignVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateElasticIpOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLayerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMyUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRdsDbInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsWorksClientTypes.AgentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.AgentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.AgentVersion()
        value.version = try reader["Version"].readIfPresent()
        value.configurationManager = try reader["ConfigurationManager"].readIfPresent(with: OpsWorksClientTypes.StackConfigurationManager.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.StackConfigurationManager {

    static func write(value: OpsWorksClientTypes.StackConfigurationManager?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.StackConfigurationManager {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.StackConfigurationManager()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.App {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.App {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.App()
        value.appId = try reader["AppId"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.shortname = try reader["Shortname"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.appSource = try reader["AppSource"].readIfPresent(with: OpsWorksClientTypes.Source.read(from:))
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableSsl = try reader["EnableSsl"].readIfPresent()
        value.sslConfiguration = try reader["SslConfiguration"].readIfPresent(with: OpsWorksClientTypes.SslConfiguration.read(from:))
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.environment = try reader["Environment"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.EnvironmentVariable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.EnvironmentVariable {

    static func write(value: OpsWorksClientTypes.EnvironmentVariable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Secure"].write(value.secure)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.EnvironmentVariable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.EnvironmentVariable()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.secure = try reader["Secure"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.SslConfiguration {

    static func write(value: OpsWorksClientTypes.SslConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Certificate"].write(value.certificate)
        try writer["Chain"].write(value.chain)
        try writer["PrivateKey"].write(value.privateKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.SslConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.SslConfiguration()
        value.certificate = try reader["Certificate"].readIfPresent() ?? ""
        value.privateKey = try reader["PrivateKey"].readIfPresent() ?? ""
        value.chain = try reader["Chain"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Source {

    static func write(value: OpsWorksClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Password"].write(value.password)
        try writer["Revision"].write(value.revision)
        try writer["SshKey"].write(value.sshKey)
        try writer["Type"].write(value.type)
        try writer["Url"].write(value.url)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Source()
        value.type = try reader["Type"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.sshKey = try reader["SshKey"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.DataSource {

    static func write(value: OpsWorksClientTypes.DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.DataSource()
        value.type = try reader["Type"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Command {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Command {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Command()
        value.commandId = try reader["CommandId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.acknowledgedAt = try reader["AcknowledgedAt"].readIfPresent()
        value.completedAt = try reader["CompletedAt"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.exitCode = try reader["ExitCode"].readIfPresent()
        value.logUrl = try reader["LogUrl"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Deployment()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.appId = try reader["AppId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.completedAt = try reader["CompletedAt"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.iamUserArn = try reader["IamUserArn"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        value.command = try reader["Command"].readIfPresent(with: OpsWorksClientTypes.DeploymentCommand.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.customJson = try reader["CustomJson"].readIfPresent()
        value.instanceIds = try reader["InstanceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.DeploymentCommand {

    static func write(value: OpsWorksClientTypes.DeploymentCommand?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Args"].writeMap(value.args, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.DeploymentCommand {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.DeploymentCommand()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.args = try reader["Args"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.EcsCluster {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.EcsCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.EcsCluster()
        value.ecsClusterArn = try reader["EcsClusterArn"].readIfPresent()
        value.ecsClusterName = try reader["EcsClusterName"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.registeredAt = try reader["RegisteredAt"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.ElasticIp {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ElasticIp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ElasticIp()
        value.ip = try reader["Ip"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.ElasticLoadBalancer {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ElasticLoadBalancer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ElasticLoadBalancer()
        value.elasticLoadBalancerName = try reader["ElasticLoadBalancerName"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.dnsName = try reader["DnsName"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.layerId = try reader["LayerId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2InstanceIds = try reader["Ec2InstanceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Instance()
        value.agentVersion = try reader["AgentVersion"].readIfPresent()
        value.amiId = try reader["AmiId"].readIfPresent()
        value.architecture = try reader["Architecture"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.autoScalingType = try reader["AutoScalingType"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.blockDeviceMappings = try reader["BlockDeviceMappings"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.BlockDeviceMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.ebsOptimized = try reader["EbsOptimized"].readIfPresent()
        value.ec2InstanceId = try reader["Ec2InstanceId"].readIfPresent()
        value.ecsClusterArn = try reader["EcsClusterArn"].readIfPresent()
        value.ecsContainerInstanceArn = try reader["EcsContainerInstanceArn"].readIfPresent()
        value.elasticIp = try reader["ElasticIp"].readIfPresent()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.infrastructureClass = try reader["InfrastructureClass"].readIfPresent()
        value.installUpdatesOnBoot = try reader["InstallUpdatesOnBoot"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceProfileArn = try reader["InstanceProfileArn"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.lastServiceErrorId = try reader["LastServiceErrorId"].readIfPresent()
        value.layerIds = try reader["LayerIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.os = try reader["Os"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.privateDns = try reader["PrivateDns"].readIfPresent()
        value.privateIp = try reader["PrivateIp"].readIfPresent()
        value.publicDns = try reader["PublicDns"].readIfPresent()
        value.publicIp = try reader["PublicIp"].readIfPresent()
        value.registeredBy = try reader["RegisteredBy"].readIfPresent()
        value.reportedAgentVersion = try reader["ReportedAgentVersion"].readIfPresent()
        value.reportedOs = try reader["ReportedOs"].readIfPresent(with: OpsWorksClientTypes.ReportedOs.read(from:))
        value.rootDeviceType = try reader["RootDeviceType"].readIfPresent()
        value.rootDeviceVolumeId = try reader["RootDeviceVolumeId"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sshHostDsaKeyFingerprint = try reader["SshHostDsaKeyFingerprint"].readIfPresent()
        value.sshHostRsaKeyFingerprint = try reader["SshHostRsaKeyFingerprint"].readIfPresent()
        value.sshKeyName = try reader["SshKeyName"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.tenancy = try reader["Tenancy"].readIfPresent()
        value.virtualizationType = try reader["VirtualizationType"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.ReportedOs {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ReportedOs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ReportedOs()
        value.family = try reader["Family"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.BlockDeviceMapping {

    static func write(value: OpsWorksClientTypes.BlockDeviceMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["Ebs"].write(value.ebs, with: OpsWorksClientTypes.EbsBlockDevice.write(value:to:))
        try writer["NoDevice"].write(value.noDevice)
        try writer["VirtualName"].write(value.virtualName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.BlockDeviceMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.BlockDeviceMapping()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.noDevice = try reader["NoDevice"].readIfPresent()
        value.virtualName = try reader["VirtualName"].readIfPresent()
        value.ebs = try reader["Ebs"].readIfPresent(with: OpsWorksClientTypes.EbsBlockDevice.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.EbsBlockDevice {

    static func write(value: OpsWorksClientTypes.EbsBlockDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["Iops"].write(value.iops)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.EbsBlockDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.EbsBlockDevice()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.volumeSize = try reader["VolumeSize"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Layer {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Layer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Layer()
        value.arn = try reader["Arn"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.layerId = try reader["LayerId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.shortname = try reader["Shortname"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.cloudWatchLogsConfiguration = try reader["CloudWatchLogsConfiguration"].readIfPresent(with: OpsWorksClientTypes.CloudWatchLogsConfiguration.read(from:))
        value.customInstanceProfileArn = try reader["CustomInstanceProfileArn"].readIfPresent()
        value.customJson = try reader["CustomJson"].readIfPresent()
        value.customSecurityGroupIds = try reader["CustomSecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultSecurityGroupNames = try reader["DefaultSecurityGroupNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.packages = try reader["Packages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.volumeConfigurations = try reader["VolumeConfigurations"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.VolumeConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enableAutoHealing = try reader["EnableAutoHealing"].readIfPresent()
        value.autoAssignElasticIps = try reader["AutoAssignElasticIps"].readIfPresent()
        value.autoAssignPublicIps = try reader["AutoAssignPublicIps"].readIfPresent()
        value.defaultRecipes = try reader["DefaultRecipes"].readIfPresent(with: OpsWorksClientTypes.Recipes.read(from:))
        value.customRecipes = try reader["CustomRecipes"].readIfPresent(with: OpsWorksClientTypes.Recipes.read(from:))
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.installUpdatesOnBoot = try reader["InstallUpdatesOnBoot"].readIfPresent()
        value.useEbsOptimizedInstances = try reader["UseEbsOptimizedInstances"].readIfPresent()
        value.lifecycleEventConfiguration = try reader["LifecycleEventConfiguration"].readIfPresent(with: OpsWorksClientTypes.LifecycleEventConfiguration.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.LifecycleEventConfiguration {

    static func write(value: OpsWorksClientTypes.LifecycleEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Shutdown"].write(value.shutdown, with: OpsWorksClientTypes.ShutdownEventConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.LifecycleEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.LifecycleEventConfiguration()
        value.shutdown = try reader["Shutdown"].readIfPresent(with: OpsWorksClientTypes.ShutdownEventConfiguration.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.ShutdownEventConfiguration {

    static func write(value: OpsWorksClientTypes.ShutdownEventConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DelayUntilElbConnectionsDrained"].write(value.delayUntilElbConnectionsDrained)
        try writer["ExecutionTimeout"].write(value.executionTimeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ShutdownEventConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ShutdownEventConfiguration()
        value.executionTimeout = try reader["ExecutionTimeout"].readIfPresent()
        value.delayUntilElbConnectionsDrained = try reader["DelayUntilElbConnectionsDrained"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Recipes {

    static func write(value: OpsWorksClientTypes.Recipes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configure"].writeList(value.configure, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Deploy"].writeList(value.deploy, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Setup"].writeList(value.setup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Shutdown"].writeList(value.shutdown, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Undeploy"].writeList(value.undeploy, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Recipes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Recipes()
        value.setup = try reader["Setup"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.configure = try reader["Configure"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deploy = try reader["Deploy"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.undeploy = try reader["Undeploy"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.shutdown = try reader["Shutdown"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.VolumeConfiguration {

    static func write(value: OpsWorksClientTypes.VolumeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["MountPoint"].write(value.mountPoint)
        try writer["NumberOfDisks"].write(value.numberOfDisks)
        try writer["RaidLevel"].write(value.raidLevel)
        try writer["Size"].write(value.size)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.VolumeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.VolumeConfiguration()
        value.mountPoint = try reader["MountPoint"].readIfPresent() ?? ""
        value.raidLevel = try reader["RaidLevel"].readIfPresent()
        value.numberOfDisks = try reader["NumberOfDisks"].readIfPresent() ?? 0
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.CloudWatchLogsConfiguration {

    static func write(value: OpsWorksClientTypes.CloudWatchLogsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["LogStreams"].writeList(value.logStreams, memberWritingClosure: OpsWorksClientTypes.CloudWatchLogsLogStream.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.CloudWatchLogsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.CloudWatchLogsConfiguration()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.logStreams = try reader["LogStreams"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.CloudWatchLogsLogStream.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.CloudWatchLogsLogStream {

    static func write(value: OpsWorksClientTypes.CloudWatchLogsLogStream?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchCount"].write(value.batchCount)
        try writer["BatchSize"].write(value.batchSize)
        try writer["BufferDuration"].write(value.bufferDuration)
        try writer["DatetimeFormat"].write(value.datetimeFormat)
        try writer["Encoding"].write(value.encoding)
        try writer["File"].write(value.file)
        try writer["FileFingerprintLines"].write(value.fileFingerprintLines)
        try writer["InitialPosition"].write(value.initialPosition)
        try writer["LogGroupName"].write(value.logGroupName)
        try writer["MultiLineStartPattern"].write(value.multiLineStartPattern)
        try writer["TimeZone"].write(value.timeZone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.CloudWatchLogsLogStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.CloudWatchLogsLogStream()
        value.logGroupName = try reader["LogGroupName"].readIfPresent()
        value.datetimeFormat = try reader["DatetimeFormat"].readIfPresent()
        value.timeZone = try reader["TimeZone"].readIfPresent()
        value.file = try reader["File"].readIfPresent()
        value.fileFingerprintLines = try reader["FileFingerprintLines"].readIfPresent()
        value.multiLineStartPattern = try reader["MultiLineStartPattern"].readIfPresent()
        value.initialPosition = try reader["InitialPosition"].readIfPresent()
        value.encoding = try reader["Encoding"].readIfPresent()
        value.bufferDuration = try reader["BufferDuration"].readIfPresent()
        value.batchCount = try reader["BatchCount"].readIfPresent()
        value.batchSize = try reader["BatchSize"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.LoadBasedAutoScalingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.LoadBasedAutoScalingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.LoadBasedAutoScalingConfiguration()
        value.layerId = try reader["LayerId"].readIfPresent()
        value.enable = try reader["Enable"].readIfPresent()
        value.upScaling = try reader["UpScaling"].readIfPresent(with: OpsWorksClientTypes.AutoScalingThresholds.read(from:))
        value.downScaling = try reader["DownScaling"].readIfPresent(with: OpsWorksClientTypes.AutoScalingThresholds.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.AutoScalingThresholds {

    static func write(value: OpsWorksClientTypes.AutoScalingThresholds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alarms"].writeList(value.alarms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CpuThreshold"].write(value.cpuThreshold)
        try writer["IgnoreMetricsTime"].write(value.ignoreMetricsTime)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["LoadThreshold"].write(value.loadThreshold)
        try writer["MemoryThreshold"].write(value.memoryThreshold)
        try writer["ThresholdsWaitTime"].write(value.thresholdsWaitTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.AutoScalingThresholds {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.AutoScalingThresholds()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.thresholdsWaitTime = try reader["ThresholdsWaitTime"].readIfPresent()
        value.ignoreMetricsTime = try reader["IgnoreMetricsTime"].readIfPresent()
        value.cpuThreshold = try reader["CpuThreshold"].readIfPresent()
        value.memoryThreshold = try reader["MemoryThreshold"].readIfPresent()
        value.loadThreshold = try reader["LoadThreshold"].readIfPresent()
        value.alarms = try reader["Alarms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.SelfUserProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.SelfUserProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.SelfUserProfile()
        value.iamUserArn = try reader["IamUserArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.sshUsername = try reader["SshUsername"].readIfPresent()
        value.sshPublicKey = try reader["SshPublicKey"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.OperatingSystem {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.OperatingSystem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.OperatingSystem()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.configurationManagers = try reader["ConfigurationManagers"].readListIfPresent(memberReadingClosure: OpsWorksClientTypes.OperatingSystemConfigurationManager.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reportedName = try reader["ReportedName"].readIfPresent()
        value.reportedVersion = try reader["ReportedVersion"].readIfPresent()
        value.supported = try reader["Supported"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.OperatingSystemConfigurationManager {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.OperatingSystemConfigurationManager {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.OperatingSystemConfigurationManager()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Permission {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Permission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Permission()
        value.stackId = try reader["StackId"].readIfPresent()
        value.iamUserArn = try reader["IamUserArn"].readIfPresent()
        value.allowSsh = try reader["AllowSsh"].readIfPresent()
        value.allowSudo = try reader["AllowSudo"].readIfPresent()
        value.level = try reader["Level"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.RaidArray {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.RaidArray {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.RaidArray()
        value.raidArrayId = try reader["RaidArrayId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.raidLevel = try reader["RaidLevel"].readIfPresent()
        value.numberOfDisks = try reader["NumberOfDisks"].readIfPresent()
        value.size = try reader["Size"].readIfPresent()
        value.device = try reader["Device"].readIfPresent()
        value.mountPoint = try reader["MountPoint"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.RdsDbInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.RdsDbInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.RdsDbInstance()
        value.rdsDbInstanceArn = try reader["RdsDbInstanceArn"].readIfPresent()
        value.dbInstanceIdentifier = try reader["DbInstanceIdentifier"].readIfPresent()
        value.dbUser = try reader["DbUser"].readIfPresent()
        value.dbPassword = try reader["DbPassword"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.address = try reader["Address"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.missingOnRds = try reader["MissingOnRds"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.ServiceError {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ServiceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ServiceError()
        value.serviceErrorId = try reader["ServiceErrorId"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Stack {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Stack {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Stack()
        value.stackId = try reader["StackId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.defaultInstanceProfileArn = try reader["DefaultInstanceProfileArn"].readIfPresent()
        value.defaultOs = try reader["DefaultOs"].readIfPresent()
        value.hostnameTheme = try reader["HostnameTheme"].readIfPresent()
        value.defaultAvailabilityZone = try reader["DefaultAvailabilityZone"].readIfPresent()
        value.defaultSubnetId = try reader["DefaultSubnetId"].readIfPresent()
        value.customJson = try reader["CustomJson"].readIfPresent()
        value.configurationManager = try reader["ConfigurationManager"].readIfPresent(with: OpsWorksClientTypes.StackConfigurationManager.read(from:))
        value.chefConfiguration = try reader["ChefConfiguration"].readIfPresent(with: OpsWorksClientTypes.ChefConfiguration.read(from:))
        value.useCustomCookbooks = try reader["UseCustomCookbooks"].readIfPresent()
        value.useOpsworksSecurityGroups = try reader["UseOpsworksSecurityGroups"].readIfPresent()
        value.customCookbooksSource = try reader["CustomCookbooksSource"].readIfPresent(with: OpsWorksClientTypes.Source.read(from:))
        value.defaultSshKeyName = try reader["DefaultSshKeyName"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.defaultRootDeviceType = try reader["DefaultRootDeviceType"].readIfPresent()
        value.agentVersion = try reader["AgentVersion"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.ChefConfiguration {

    static func write(value: OpsWorksClientTypes.ChefConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BerkshelfVersion"].write(value.berkshelfVersion)
        try writer["ManageBerkshelf"].write(value.manageBerkshelf)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.ChefConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.ChefConfiguration()
        value.manageBerkshelf = try reader["ManageBerkshelf"].readIfPresent()
        value.berkshelfVersion = try reader["BerkshelfVersion"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.StackSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.StackSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.StackSummary()
        value.stackId = try reader["StackId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.layersCount = try reader["LayersCount"].readIfPresent()
        value.appsCount = try reader["AppsCount"].readIfPresent()
        value.instancesCount = try reader["InstancesCount"].readIfPresent(with: OpsWorksClientTypes.InstancesCount.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.InstancesCount {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.InstancesCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.InstancesCount()
        value.assigning = try reader["Assigning"].readIfPresent()
        value.booting = try reader["Booting"].readIfPresent()
        value.connectionLost = try reader["ConnectionLost"].readIfPresent()
        value.deregistering = try reader["Deregistering"].readIfPresent()
        value.online = try reader["Online"].readIfPresent()
        value.pending = try reader["Pending"].readIfPresent()
        value.rebooting = try reader["Rebooting"].readIfPresent()
        value.registered = try reader["Registered"].readIfPresent()
        value.registering = try reader["Registering"].readIfPresent()
        value.requested = try reader["Requested"].readIfPresent()
        value.runningSetup = try reader["RunningSetup"].readIfPresent()
        value.setupFailed = try reader["SetupFailed"].readIfPresent()
        value.shuttingDown = try reader["ShuttingDown"].readIfPresent()
        value.startFailed = try reader["StartFailed"].readIfPresent()
        value.stopFailed = try reader["StopFailed"].readIfPresent()
        value.stopped = try reader["Stopped"].readIfPresent()
        value.stopping = try reader["Stopping"].readIfPresent()
        value.terminated = try reader["Terminated"].readIfPresent()
        value.terminating = try reader["Terminating"].readIfPresent()
        value.unassigning = try reader["Unassigning"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.TimeBasedAutoScalingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.TimeBasedAutoScalingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.TimeBasedAutoScalingConfiguration()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.autoScalingSchedule = try reader["AutoScalingSchedule"].readIfPresent(with: OpsWorksClientTypes.WeeklyAutoScalingSchedule.read(from:))
        return value
    }
}

extension OpsWorksClientTypes.WeeklyAutoScalingSchedule {

    static func write(value: OpsWorksClientTypes.WeeklyAutoScalingSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Friday"].writeMap(value.friday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Monday"].writeMap(value.monday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Saturday"].writeMap(value.saturday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Sunday"].writeMap(value.sunday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Thursday"].writeMap(value.thursday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Tuesday"].writeMap(value.tuesday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Wednesday"].writeMap(value.wednesday, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.WeeklyAutoScalingSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.WeeklyAutoScalingSchedule()
        value.monday = try reader["Monday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tuesday = try reader["Tuesday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.wednesday = try reader["Wednesday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.thursday = try reader["Thursday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.friday = try reader["Friday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.saturday = try reader["Saturday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sunday = try reader["Sunday"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension OpsWorksClientTypes.UserProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.UserProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.UserProfile()
        value.iamUserArn = try reader["IamUserArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.sshUsername = try reader["SshUsername"].readIfPresent()
        value.sshPublicKey = try reader["SshPublicKey"].readIfPresent()
        value.allowSelfManagement = try reader["AllowSelfManagement"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.Volume {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.Volume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.Volume()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        value.ec2VolumeId = try reader["Ec2VolumeId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.raidArrayId = try reader["RaidArrayId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.size = try reader["Size"].readIfPresent()
        value.device = try reader["Device"].readIfPresent()
        value.mountPoint = try reader["MountPoint"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.TemporaryCredential {

    static func read(from reader: SmithyJSON.Reader) throws -> OpsWorksClientTypes.TemporaryCredential {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpsWorksClientTypes.TemporaryCredential()
        value.username = try reader["Username"].readIfPresent()
        value.password = try reader["Password"].readIfPresent()
        value.validForInMinutes = try reader["ValidForInMinutes"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension OpsWorksClientTypes.InstanceIdentity {

    static func write(value: OpsWorksClientTypes.InstanceIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Document"].write(value.document)
        try writer["Signature"].write(value.signature)
    }
}

public enum OpsWorksClientTypes {}
