// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpsWorksClientTypes.AgentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an agent version.
    public struct AgentVersion: Swift.Equatable {
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The agent version.
        public var version: Swift.String?

        public init(
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            version: Swift.String? = nil
        )
        {
            self.configurationManager = configurationManager
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case createdAt = "CreatedAt"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = self.appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appAttributes0) in attributes {
                try attributesContainer.encode(appAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for string0 in domains {
                try domainsContainer.encode(string0)
            }
        }
        if let enableSsl = self.enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariable0 in environment {
                try environmentContainer.encode(environmentvariable0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = self.shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = self.sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension OpsWorksClientTypes {
    /// A description of the app.
    public struct App: Swift.Equatable {
        /// The app ID.
        public var appId: Swift.String?
        /// A Source object that describes the app repository.
        public var appSource: OpsWorksClientTypes.Source?
        /// The stack attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// When the app was created.
        public var createdAt: Swift.String?
        /// The app's data sources.
        public var dataSources: [OpsWorksClientTypes.DataSource]?
        /// A description of the app.
        public var description: Swift.String?
        /// The app vhost settings with multiple domains separated by commas. For example: 'www.example.com, example.com'
        public var domains: [Swift.String]?
        /// Whether to enable SSL for the app.
        public var enableSsl: Swift.Bool?
        /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances. For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variable names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases, but if you do exceed it, you will cause an exception (API) with an "Environment: is too large (maximum is 20 KB)" message.
        public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
        /// The app name.
        public var name: Swift.String?
        /// The app's short name.
        public var shortname: Swift.String?
        /// An SslConfiguration object with the SSL configuration.
        public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
        /// The app stack ID.
        public var stackId: Swift.String?
        /// The app type.
        public var type: OpsWorksClientTypes.AppType?

        public init(
            appId: Swift.String? = nil,
            appSource: OpsWorksClientTypes.Source? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            createdAt: Swift.String? = nil,
            dataSources: [OpsWorksClientTypes.DataSource]? = nil,
            description: Swift.String? = nil,
            domains: [Swift.String]? = nil,
            enableSsl: Swift.Bool? = nil,
            environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
            name: Swift.String? = nil,
            shortname: Swift.String? = nil,
            sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.AppType? = nil
        )
        {
            self.appId = appId
            self.appSource = appSource
            self.attributes = attributes
            self.createdAt = createdAt
            self.dataSources = dataSources
            self.description = description
            self.domains = domains
            self.enableSsl = enableSsl
            self.environment = environment
            self.name = name
            self.shortname = shortname
            self.sslConfiguration = sslConfiguration
            self.stackId = stackId
            self.type = type
        }
    }

}

extension OpsWorksClientTypes {
    public enum AppAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autobundleondeploy
        case awsflowrubysettings
        case documentroot
        case railsenv
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAttributesKeys] {
            return [
                .autobundleondeploy,
                .awsflowrubysettings,
                .documentroot,
                .railsenv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autobundleondeploy: return "AutoBundleOnDeploy"
            case .awsflowrubysettings: return "AwsFlowRubySettings"
            case .documentroot: return "DocumentRoot"
            case .railsenv: return "RailsEnv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppAttributesKeys(rawValue: rawValue) ?? AppAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum AppType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsFlowRuby
        case java
        case nodejs
        case other
        case php
        case rails
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .awsFlowRuby,
                .java,
                .nodejs,
                .other,
                .php,
                .rails,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .java: return "java"
            case .nodejs: return "nodejs"
            case .other: return "other"
            case .php: return "php"
            case .rails: return "rails"
            case .static: return "static"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppType(rawValue: rawValue) ?? AppType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum Architecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case i386
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [Architecture] {
            return [
                .i386,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .i386: return "i386"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Architecture(rawValue: rawValue) ?? Architecture.sdkUnknown(rawValue)
        }
    }
}

extension AssignInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
    }
}

extension AssignInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssignInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The layer ID, which must correspond to a custom layer. You cannot assign a registered instance to a built-in layer.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        layerIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.layerIds = layerIds
    }
}

struct AssignInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let layerIds: [Swift.String]?
}

extension AssignInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case layerIds = "LayerIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension AssignInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssignInstanceOutput: Swift.Equatable {

    public init() { }
}

enum AssignInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssignVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

extension AssignVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssignVolumeInput: Swift.Equatable {
    /// The instance ID.
    public var instanceId: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.volumeId = volumeId
    }
}

struct AssignVolumeInputBody: Swift.Equatable {
    let volumeId: Swift.String?
    let instanceId: Swift.String?
}

extension AssignVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case volumeId = "VolumeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssignVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssignVolumeOutput: Swift.Equatable {

    public init() { }
}

enum AssignVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateElasticIpInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension AssociateElasticIpInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The instance ID.
    public var instanceId: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.instanceId = instanceId
    }
}

struct AssociateElasticIpInputBody: Swift.Equatable {
    let elasticIp: Swift.String?
    let instanceId: Swift.String?
}

extension AssociateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension AssociateElasticIpOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateElasticIpOutput: Swift.Equatable {

    public init() { }
}

enum AssociateElasticIpOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachElasticLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = self.elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

extension AttachElasticLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachElasticLoadBalancerInput: Swift.Equatable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer to which the Elastic Load Balancing instance is to be attached.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct AttachElasticLoadBalancerInputBody: Swift.Equatable {
    let elasticLoadBalancerName: Swift.String?
    let layerId: Swift.String?
}

extension AttachElasticLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension AttachElasticLoadBalancerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachElasticLoadBalancerOutput: Swift.Equatable {

    public init() { }
}

enum AttachElasticLoadBalancerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.AutoScalingThresholds: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms = "Alarms"
        case cpuThreshold = "CpuThreshold"
        case ignoreMetricsTime = "IgnoreMetricsTime"
        case instanceCount = "InstanceCount"
        case loadThreshold = "LoadThreshold"
        case memoryThreshold = "MemoryThreshold"
        case thresholdsWaitTime = "ThresholdsWaitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            var alarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarms)
            for string0 in alarms {
                try alarmsContainer.encode(string0)
            }
        }
        if let cpuThreshold = self.cpuThreshold {
            try encodeContainer.encode(cpuThreshold, forKey: .cpuThreshold)
        }
        if let ignoreMetricsTime = self.ignoreMetricsTime {
            try encodeContainer.encode(ignoreMetricsTime, forKey: .ignoreMetricsTime)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let loadThreshold = self.loadThreshold {
            try encodeContainer.encode(loadThreshold, forKey: .loadThreshold)
        }
        if let memoryThreshold = self.memoryThreshold {
            try encodeContainer.encode(memoryThreshold, forKey: .memoryThreshold)
        }
        if let thresholdsWaitTime = self.thresholdsWaitTime {
            try encodeContainer.encode(thresholdsWaitTime, forKey: .thresholdsWaitTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let thresholdsWaitTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .thresholdsWaitTime)
        thresholdsWaitTime = thresholdsWaitTimeDecoded
        let ignoreMetricsTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ignoreMetricsTime)
        ignoreMetricsTime = ignoreMetricsTimeDecoded
        let cpuThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .cpuThreshold)
        cpuThreshold = cpuThresholdDecoded
        let memoryThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .memoryThreshold)
        memoryThreshold = memoryThresholdDecoded
        let loadThresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .loadThreshold)
        loadThreshold = loadThresholdDecoded
        let alarmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alarms)
        var alarmsDecoded0:[Swift.String]? = nil
        if let alarmsContainer = alarmsContainer {
            alarmsDecoded0 = [Swift.String]()
            for string0 in alarmsContainer {
                if let string0 = string0 {
                    alarmsDecoded0?.append(string0)
                }
            }
        }
        alarms = alarmsDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Describes a load-based auto scaling upscaling or downscaling threshold configuration, which specifies when AWS OpsWorks Stacks starts or stops load-based instances.
    public struct AutoScalingThresholds: Swift.Equatable {
        /// Custom Cloudwatch auto scaling alarms, to be used as thresholds. This parameter takes a list of up to five alarm names, which are case sensitive and must be in the same region as the stack. To use custom alarms, you must update your service role to allow cloudwatch:DescribeAlarms. You can either have AWS OpsWorks Stacks update the role for you when you first use this feature or you can edit the role manually. For more information, see [Allowing AWS OpsWorks Stacks to Act on Your Behalf](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-servicerole.html).
        public var alarms: [Swift.String]?
        /// The CPU utilization threshold, as a percent of the available CPU. A value of -1 disables the threshold.
        public var cpuThreshold: Swift.Double?
        /// The amount of time (in minutes) after a scaling event occurs that AWS OpsWorks Stacks should ignore metrics and suppress additional scaling events. For example, AWS OpsWorks Stacks adds new instances following an upscaling event but the instances won't start reducing the load until they have been booted and configured. There is no point in raising additional scaling events during that operation, which typically takes several minutes. IgnoreMetricsTime allows you to direct AWS OpsWorks Stacks to suppress scaling events long enough to get the new instances online.
        public var ignoreMetricsTime: Swift.Int?
        /// The number of instances to add or remove when the load exceeds a threshold.
        public var instanceCount: Swift.Int?
        /// The load threshold. A value of -1 disables the threshold. For more information about how load is computed, see [Load (computing)](http://en.wikipedia.org/wiki/Load_%28computing%29).
        public var loadThreshold: Swift.Double?
        /// The memory utilization threshold, as a percent of the available memory. A value of -1 disables the threshold.
        public var memoryThreshold: Swift.Double?
        /// The amount of time, in minutes, that the load must exceed a threshold before more instances are added or removed.
        public var thresholdsWaitTime: Swift.Int?

        public init(
            alarms: [Swift.String]? = nil,
            cpuThreshold: Swift.Double? = nil,
            ignoreMetricsTime: Swift.Int? = nil,
            instanceCount: Swift.Int? = nil,
            loadThreshold: Swift.Double? = nil,
            memoryThreshold: Swift.Double? = nil,
            thresholdsWaitTime: Swift.Int? = nil
        )
        {
            self.alarms = alarms
            self.cpuThreshold = cpuThreshold
            self.ignoreMetricsTime = ignoreMetricsTime
            self.instanceCount = instanceCount
            self.loadThreshold = loadThreshold
            self.memoryThreshold = memoryThreshold
            self.thresholdsWaitTime = thresholdsWaitTime
        }
    }

}

extension OpsWorksClientTypes {
    public enum AutoScalingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case load
        case timer
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingType] {
            return [
                .load,
                .timer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .load: return "load"
            case .timer: return "timer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingType(rawValue: rawValue) ?? AutoScalingType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.BlockDeviceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = self.noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = self.virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.EbsBlockDevice.self, forKey: .ebs)
        ebs = ebsDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a block device mapping. This data type maps directly to the Amazon EC2 [BlockDeviceMapping](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html) data type.
    public struct BlockDeviceMapping: Swift.Equatable {
        /// The device name that is exposed to the instance, such as /dev/sdh. For the root device, you can use the explicit device name or you can set this parameter to ROOT_DEVICE and AWS OpsWorks Stacks will provide the correct device name.
        public var deviceName: Swift.String?
        /// An EBSBlockDevice that defines how to configure an Amazon EBS volume when the instance is launched.
        public var ebs: OpsWorksClientTypes.EbsBlockDevice?
        /// Suppresses the specified device included in the AMI's block device mapping.
        public var noDevice: Swift.String?
        /// The virtual device name. For more information, see [BlockDeviceMapping](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_BlockDeviceMapping.html).
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: OpsWorksClientTypes.EbsBlockDevice? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension OpsWorksClientTypes.ChefConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case berkshelfVersion = "BerkshelfVersion"
        case manageBerkshelf = "ManageBerkshelf"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let berkshelfVersion = self.berkshelfVersion {
            try encodeContainer.encode(berkshelfVersion, forKey: .berkshelfVersion)
        }
        if let manageBerkshelf = self.manageBerkshelf {
            try encodeContainer.encode(manageBerkshelf, forKey: .manageBerkshelf)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manageBerkshelfDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageBerkshelf)
        manageBerkshelf = manageBerkshelfDecoded
        let berkshelfVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .berkshelfVersion)
        berkshelfVersion = berkshelfVersionDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes the Chef configuration.
    public struct ChefConfiguration: Swift.Equatable {
        /// The Berkshelf version.
        public var berkshelfVersion: Swift.String?
        /// Whether to enable Berkshelf.
        public var manageBerkshelf: Swift.Bool?

        public init(
            berkshelfVersion: Swift.String? = nil,
            manageBerkshelf: Swift.Bool? = nil
        )
        {
            self.berkshelfVersion = berkshelfVersion
            self.manageBerkshelf = manageBerkshelf
        }
    }

}

extension CloneStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackAttributes0) in attributes {
                try attributesContainer.encode(stackAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = self.chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let cloneAppIds = cloneAppIds {
            var cloneAppIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cloneAppIds)
            for string0 in cloneAppIds {
                try cloneAppIdsContainer.encode(string0)
            }
        }
        if let clonePermissions = self.clonePermissions {
            try encodeContainer.encode(clonePermissions, forKey: .clonePermissions)
        }
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = self.customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = self.defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = self.defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = self.defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = self.defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = self.defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = self.defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = self.hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let sourceStackId = self.sourceStackId {
            try encodeContainer.encode(sourceStackId, forKey: .sourceStackId)
        }
        if let useCustomCookbooks = self.useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = self.useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CloneStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CloneStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    /// The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// A list of stack attributes and values as key/value pairs to be added to the cloned stack.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// A list of source stack app IDs to be included in the cloned stack.
    public var cloneAppIds: [Swift.String]?
    /// Whether to clone the source stack's permissions.
    public var clonePermissions: Swift.Bool?
    /// The configuration manager. When you clone a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It is used to override the corresponding default stack configuration JSON values. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html)
    public var customJson: Swift.String?
    /// The cloned stack's default Availability Zone, which must be in the specified region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description.
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the parent stack's operating system. For more information about supported operating systems, see [AWS OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). You can specify a different Linux operating system for the cloned stack, but you cannot change from Linux to Windows or Windows to Linux.
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the cloned stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces are replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The cloned stack name.
    public var name: Swift.String?
    /// The cloned stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
    public var region: Swift.String?
    /// The stack AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. If you create a stack by using the AWS OpsWorks Stacks console, it creates the role for you. You can obtain an existing stack's IAM ARN programmatically by calling [DescribePermissions]. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html). You must set this parameter to a valid service role ARN or the action will fail; there is no default value. You can specify the source stack's service role ARN, if you prefer, but you must do so explicitly.
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// The source stack ID.
    /// This member is required.
    public var sourceStackId: Swift.String?
    /// Whether to use custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers. AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it but you cannot delete the built-in security group.
    ///
    /// * False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate Amazon Elastic Compute Cloud (Amazon EC2) security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the cloned stack is to be launched into. It must be in the specified region. All instances are launched into this VPC, and you cannot change the ID later.
    ///
    /// * If your account supports EC2 Classic, the default value is no VPC.
    ///
    /// * If your account does not support EC2 Classic, the default value is the default VPC for the specified region.
    ///
    ///
    /// If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, AWS OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively. If you specify a nondefault VPC ID, note the following:
    ///
    /// * It must belong to a VPC in your account that is in the specified region.
    ///
    /// * You must specify a value for DefaultSubnetId.
    ///
    ///
    /// For more information about how to use AWS OpsWorks Stacks with a VPC, see [Running a Stack in a VPC](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html). For more information about default VPC and EC2 Classic, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var vpcId: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        cloneAppIds: [Swift.String]? = nil,
        clonePermissions: Swift.Bool? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        sourceStackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.cloneAppIds = cloneAppIds
        self.clonePermissions = clonePermissions
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.sourceStackId = sourceStackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CloneStackInputBody: Swift.Equatable {
    let sourceStackId: Swift.String?
    let name: Swift.String?
    let region: Swift.String?
    let vpcId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let serviceRoleArn: Swift.String?
    let defaultInstanceProfileArn: Swift.String?
    let defaultOs: Swift.String?
    let hostnameTheme: Swift.String?
    let defaultAvailabilityZone: Swift.String?
    let defaultSubnetId: Swift.String?
    let customJson: Swift.String?
    let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    let useCustomCookbooks: Swift.Bool?
    let useOpsworksSecurityGroups: Swift.Bool?
    let customCookbooksSource: OpsWorksClientTypes.Source?
    let defaultSshKeyName: Swift.String?
    let clonePermissions: Swift.Bool?
    let cloneAppIds: [Swift.String]?
    let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    let agentVersion: Swift.String?
}

extension CloneStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case cloneAppIds = "CloneAppIds"
        case clonePermissions = "ClonePermissions"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceStackId = "SourceStackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceStackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceStackId)
        sourceStackId = sourceStackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let clonePermissionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clonePermissions)
        clonePermissions = clonePermissionsDecoded
        let cloneAppIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cloneAppIds)
        var cloneAppIdsDecoded0:[Swift.String]? = nil
        if let cloneAppIdsContainer = cloneAppIdsContainer {
            cloneAppIdsDecoded0 = [Swift.String]()
            for string0 in cloneAppIdsContainer {
                if let string0 = string0 {
                    cloneAppIdsDecoded0?.append(string0)
                }
            }
        }
        cloneAppIds = cloneAppIdsDecoded0
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CloneStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloneStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// Contains the response to a CloneStack request.
public struct CloneStackOutput: Swift.Equatable {
    /// The cloned stack ID.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CloneStackOutputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension CloneStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

enum CloneStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.CloudWatchLogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case logStreams = "LogStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logStreams = logStreams {
            var logStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logStreams)
            for cloudwatchlogslogstream0 in logStreams {
                try logStreamsContainer.encode(cloudwatchlogslogstream0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logStreamsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.CloudWatchLogsLogStream?].self, forKey: .logStreams)
        var logStreamsDecoded0:[OpsWorksClientTypes.CloudWatchLogsLogStream]? = nil
        if let logStreamsContainer = logStreamsContainer {
            logStreamsDecoded0 = [OpsWorksClientTypes.CloudWatchLogsLogStream]()
            for structure0 in logStreamsContainer {
                if let structure0 = structure0 {
                    logStreamsDecoded0?.append(structure0)
                }
            }
        }
        logStreams = logStreamsDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Describes the Amazon CloudWatch logs configuration for a layer.
    public struct CloudWatchLogsConfiguration: Swift.Equatable {
        /// Whether CloudWatch Logs is enabled for a layer.
        public var enabled: Swift.Bool?
        /// A list of configuration options for CloudWatch Logs.
        public var logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]?

        public init(
            enabled: Swift.Bool? = nil,
            logStreams: [OpsWorksClientTypes.CloudWatchLogsLogStream]? = nil
        )
        {
            self.enabled = enabled
            self.logStreams = logStreams
        }
    }

}

extension OpsWorksClientTypes {
    /// Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
    public enum CloudWatchLogsEncoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascii
        case big5
        case big5hkscs
        case cp037
        case cp1006
        case cp1026
        case cp1140
        case cp1250
        case cp1251
        case cp1252
        case cp1253
        case cp1254
        case cp1255
        case cp1256
        case cp1257
        case cp1258
        case cp424
        case cp437
        case cp500
        case cp720
        case cp737
        case cp775
        case cp850
        case cp852
        case cp855
        case cp856
        case cp857
        case cp858
        case cp860
        case cp861
        case cp862
        case cp863
        case cp864
        case cp865
        case cp866
        case cp869
        case cp874
        case cp875
        case cp932
        case cp949
        case cp950
        case eucJis2004
        case eucJisx0213
        case eucJp
        case eucKr
        case gb18030
        case gb2312
        case gbk
        case hz
        case iso2022Jp
        case iso2022Jp1
        case iso2022Jp2
        case iso2022Jp2004
        case iso2022Jp3
        case iso2022JpExt
        case iso2022Kr
        case iso885910
        case iso885913
        case iso885914
        case iso885915
        case iso885916
        case iso88592
        case iso88593
        case iso88594
        case iso88595
        case iso88596
        case iso88597
        case iso88598
        case iso88599
        case johab
        case koi8R
        case koi8U
        case latin1
        case macCyrillic
        case macGreek
        case macIceland
        case macLatin2
        case macRoman
        case macTurkish
        case ptcp154
        case shiftJis
        case shiftJis2004
        case shiftJisx0213
        case utf16
        case utf16Be
        case utf16Le
        case utf32
        case utf32Be
        case utf32Le
        case utf7
        case utf8
        case utf8Sig
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsEncoding] {
            return [
                .ascii,
                .big5,
                .big5hkscs,
                .cp037,
                .cp1006,
                .cp1026,
                .cp1140,
                .cp1250,
                .cp1251,
                .cp1252,
                .cp1253,
                .cp1254,
                .cp1255,
                .cp1256,
                .cp1257,
                .cp1258,
                .cp424,
                .cp437,
                .cp500,
                .cp720,
                .cp737,
                .cp775,
                .cp850,
                .cp852,
                .cp855,
                .cp856,
                .cp857,
                .cp858,
                .cp860,
                .cp861,
                .cp862,
                .cp863,
                .cp864,
                .cp865,
                .cp866,
                .cp869,
                .cp874,
                .cp875,
                .cp932,
                .cp949,
                .cp950,
                .eucJis2004,
                .eucJisx0213,
                .eucJp,
                .eucKr,
                .gb18030,
                .gb2312,
                .gbk,
                .hz,
                .iso2022Jp,
                .iso2022Jp1,
                .iso2022Jp2,
                .iso2022Jp2004,
                .iso2022Jp3,
                .iso2022JpExt,
                .iso2022Kr,
                .iso885910,
                .iso885913,
                .iso885914,
                .iso885915,
                .iso885916,
                .iso88592,
                .iso88593,
                .iso88594,
                .iso88595,
                .iso88596,
                .iso88597,
                .iso88598,
                .iso88599,
                .johab,
                .koi8R,
                .koi8U,
                .latin1,
                .macCyrillic,
                .macGreek,
                .macIceland,
                .macLatin2,
                .macRoman,
                .macTurkish,
                .ptcp154,
                .shiftJis,
                .shiftJis2004,
                .shiftJisx0213,
                .utf16,
                .utf16Be,
                .utf16Le,
                .utf32,
                .utf32Be,
                .utf32Le,
                .utf7,
                .utf8,
                .utf8Sig,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascii: return "ascii"
            case .big5: return "big5"
            case .big5hkscs: return "big5hkscs"
            case .cp037: return "cp037"
            case .cp1006: return "cp1006"
            case .cp1026: return "cp1026"
            case .cp1140: return "cp1140"
            case .cp1250: return "cp1250"
            case .cp1251: return "cp1251"
            case .cp1252: return "cp1252"
            case .cp1253: return "cp1253"
            case .cp1254: return "cp1254"
            case .cp1255: return "cp1255"
            case .cp1256: return "cp1256"
            case .cp1257: return "cp1257"
            case .cp1258: return "cp1258"
            case .cp424: return "cp424"
            case .cp437: return "cp437"
            case .cp500: return "cp500"
            case .cp720: return "cp720"
            case .cp737: return "cp737"
            case .cp775: return "cp775"
            case .cp850: return "cp850"
            case .cp852: return "cp852"
            case .cp855: return "cp855"
            case .cp856: return "cp856"
            case .cp857: return "cp857"
            case .cp858: return "cp858"
            case .cp860: return "cp860"
            case .cp861: return "cp861"
            case .cp862: return "cp862"
            case .cp863: return "cp863"
            case .cp864: return "cp864"
            case .cp865: return "cp865"
            case .cp866: return "cp866"
            case .cp869: return "cp869"
            case .cp874: return "cp874"
            case .cp875: return "cp875"
            case .cp932: return "cp932"
            case .cp949: return "cp949"
            case .cp950: return "cp950"
            case .eucJis2004: return "euc_jis_2004"
            case .eucJisx0213: return "euc_jisx0213"
            case .eucJp: return "euc_jp"
            case .eucKr: return "euc_kr"
            case .gb18030: return "gb18030"
            case .gb2312: return "gb2312"
            case .gbk: return "gbk"
            case .hz: return "hz"
            case .iso2022Jp: return "iso2022_jp"
            case .iso2022Jp1: return "iso2022_jp_1"
            case .iso2022Jp2: return "iso2022_jp_2"
            case .iso2022Jp2004: return "iso2022_jp_2004"
            case .iso2022Jp3: return "iso2022_jp_3"
            case .iso2022JpExt: return "iso2022_jp_ext"
            case .iso2022Kr: return "iso2022_kr"
            case .iso885910: return "iso8859_10"
            case .iso885913: return "iso8859_13"
            case .iso885914: return "iso8859_14"
            case .iso885915: return "iso8859_15"
            case .iso885916: return "iso8859_16"
            case .iso88592: return "iso8859_2"
            case .iso88593: return "iso8859_3"
            case .iso88594: return "iso8859_4"
            case .iso88595: return "iso8859_5"
            case .iso88596: return "iso8859_6"
            case .iso88597: return "iso8859_7"
            case .iso88598: return "iso8859_8"
            case .iso88599: return "iso8859_9"
            case .johab: return "johab"
            case .koi8R: return "koi8_r"
            case .koi8U: return "koi8_u"
            case .latin1: return "latin_1"
            case .macCyrillic: return "mac_cyrillic"
            case .macGreek: return "mac_greek"
            case .macIceland: return "mac_iceland"
            case .macLatin2: return "mac_latin2"
            case .macRoman: return "mac_roman"
            case .macTurkish: return "mac_turkish"
            case .ptcp154: return "ptcp154"
            case .shiftJis: return "shift_jis"
            case .shiftJis2004: return "shift_jis_2004"
            case .shiftJisx0213: return "shift_jisx0213"
            case .utf16: return "utf_16"
            case .utf16Be: return "utf_16_be"
            case .utf16Le: return "utf_16_le"
            case .utf32: return "utf_32"
            case .utf32Be: return "utf_32_be"
            case .utf32Le: return "utf_32_le"
            case .utf7: return "utf_7"
            case .utf8: return "utf_8"
            case .utf8Sig: return "utf_8_sig"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsEncoding(rawValue: rawValue) ?? CloudWatchLogsEncoding.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. It's only used if there is no state persisted for that log stream.
    public enum CloudWatchLogsInitialPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case endOfFile
        case startOfFile
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsInitialPosition] {
            return [
                .endOfFile,
                .startOfFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .endOfFile: return "end_of_file"
            case .startOfFile: return "start_of_file"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsInitialPosition(rawValue: rawValue) ?? CloudWatchLogsInitialPosition.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.CloudWatchLogsLogStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchCount = "BatchCount"
        case batchSize = "BatchSize"
        case bufferDuration = "BufferDuration"
        case datetimeFormat = "DatetimeFormat"
        case encoding = "Encoding"
        case file = "File"
        case fileFingerprintLines = "FileFingerprintLines"
        case initialPosition = "InitialPosition"
        case logGroupName = "LogGroupName"
        case multiLineStartPattern = "MultiLineStartPattern"
        case timeZone = "TimeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchCount = self.batchCount {
            try encodeContainer.encode(batchCount, forKey: .batchCount)
        }
        if let batchSize = self.batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bufferDuration = self.bufferDuration {
            try encodeContainer.encode(bufferDuration, forKey: .bufferDuration)
        }
        if let datetimeFormat = self.datetimeFormat {
            try encodeContainer.encode(datetimeFormat, forKey: .datetimeFormat)
        }
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding.rawValue, forKey: .encoding)
        }
        if let file = self.file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let fileFingerprintLines = self.fileFingerprintLines {
            try encodeContainer.encode(fileFingerprintLines, forKey: .fileFingerprintLines)
        }
        if let initialPosition = self.initialPosition {
            try encodeContainer.encode(initialPosition.rawValue, forKey: .initialPosition)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let multiLineStartPattern = self.multiLineStartPattern {
            try encodeContainer.encode(multiLineStartPattern, forKey: .multiLineStartPattern)
        }
        if let timeZone = self.timeZone {
            try encodeContainer.encode(timeZone.rawValue, forKey: .timeZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let datetimeFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeFormat)
        datetimeFormat = datetimeFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsTimeZone.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let fileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .file)
        file = fileDecoded
        let fileFingerprintLinesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileFingerprintLines)
        fileFingerprintLines = fileFingerprintLinesDecoded
        let multiLineStartPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multiLineStartPattern)
        multiLineStartPattern = multiLineStartPatternDecoded
        let initialPositionDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsInitialPosition.self, forKey: .initialPosition)
        initialPosition = initialPositionDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsEncoding.self, forKey: .encoding)
        encoding = encodingDecoded
        let bufferDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bufferDuration)
        bufferDuration = bufferDurationDecoded
        let batchCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchCount)
        batchCount = batchCountDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes the Amazon CloudWatch logs configuration for a layer. For detailed information about members of this data type, see the [CloudWatch Logs Agent Reference](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
    public struct CloudWatchLogsLogStream: Swift.Equatable {
        /// Specifies the max number of log events in a batch, up to 10000. The default value is 1000.
        public var batchCount: Swift.Int?
        /// Specifies the maximum size of log events in a batch, in bytes, up to 1048576 bytes. The default value is 32768 bytes. This size is calculated as the sum of all event messages in UTF-8, plus 26 bytes for each log event.
        public var batchSize: Swift.Int?
        /// Specifies the time duration for the batching of log events. The minimum value is 5000ms and default value is 5000ms.
        public var bufferDuration: Swift.Int?
        /// Specifies how the time stamp is extracted from logs. For more information, see the [CloudWatch Logs Agent Reference](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AgentReference.html).
        public var datetimeFormat: Swift.String?
        /// Specifies the encoding of the log file so that the file can be read correctly. The default is utf_8. Encodings supported by Python codecs.decode() can be used here.
        public var encoding: OpsWorksClientTypes.CloudWatchLogsEncoding?
        /// Specifies log files that you want to push to CloudWatch Logs. File can point to a specific file or multiple files (by using wild card characters such as /var/log/system.log*). Only the latest file is pushed to CloudWatch Logs, based on file modification time. We recommend that you use wild card characters to specify a series of files of the same type, such as access_log.2014-06-01-01, access_log.2014-06-01-02, and so on by using a pattern like access_log.*. Don't use a wildcard to match multiple file types, such as access_log_80 and access_log_443. To specify multiple, different file types, add another log stream entry to the configuration file, so that each log file type is stored in a different log group. Zipped files are not supported.
        public var file: Swift.String?
        /// Specifies the range of lines for identifying a file. The valid values are one number, or two dash-delimited numbers, such as '1', '2-5'. The default value is '1', meaning the first line is used to calculate the fingerprint. Fingerprint lines are not sent to CloudWatch Logs unless all specified lines are available.
        public var fileFingerprintLines: Swift.String?
        /// Specifies where to start to read data (start_of_file or end_of_file). The default is start_of_file. This setting is only used if there is no state persisted for that log stream.
        public var initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition?
        /// Specifies the destination log group. A log group is created automatically if it doesn't already exist. Log group names can be between 1 and 512 characters long. Allowed characters include a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), and '.' (period).
        public var logGroupName: Swift.String?
        /// Specifies the pattern for identifying the start of a log message.
        public var multiLineStartPattern: Swift.String?
        /// Specifies the time zone of log event time stamps.
        public var timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone?

        public init(
            batchCount: Swift.Int? = nil,
            batchSize: Swift.Int? = nil,
            bufferDuration: Swift.Int? = nil,
            datetimeFormat: Swift.String? = nil,
            encoding: OpsWorksClientTypes.CloudWatchLogsEncoding? = nil,
            file: Swift.String? = nil,
            fileFingerprintLines: Swift.String? = nil,
            initialPosition: OpsWorksClientTypes.CloudWatchLogsInitialPosition? = nil,
            logGroupName: Swift.String? = nil,
            multiLineStartPattern: Swift.String? = nil,
            timeZone: OpsWorksClientTypes.CloudWatchLogsTimeZone? = nil
        )
        {
            self.batchCount = batchCount
            self.batchSize = batchSize
            self.bufferDuration = bufferDuration
            self.datetimeFormat = datetimeFormat
            self.encoding = encoding
            self.file = file
            self.fileFingerprintLines = fileFingerprintLines
            self.initialPosition = initialPosition
            self.logGroupName = logGroupName
            self.multiLineStartPattern = multiLineStartPattern
            self.timeZone = timeZone
        }
    }

}

extension OpsWorksClientTypes {
    /// The preferred time zone for logs streamed to CloudWatch Logs. Valid values are LOCAL and UTC, for Coordinated Universal Time.
    public enum CloudWatchLogsTimeZone: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudWatchLogsTimeZone] {
            return [
                .local,
                .utc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudWatchLogsTimeZone(rawValue: rawValue) ?? CloudWatchLogsTimeZone.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.Command: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgedAt = "AcknowledgedAt"
        case commandId = "CommandId"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case deploymentId = "DeploymentId"
        case exitCode = "ExitCode"
        case instanceId = "InstanceId"
        case logUrl = "LogUrl"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgedAt = self.acknowledgedAt {
            try encodeContainer.encode(acknowledgedAt, forKey: .acknowledgedAt)
        }
        if let commandId = self.commandId {
            try encodeContainer.encode(commandId, forKey: .commandId)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let exitCode = self.exitCode {
            try encodeContainer.encode(exitCode, forKey: .exitCode)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let logUrl = self.logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commandId)
        commandId = commandIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let acknowledgedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acknowledgedAt)
        acknowledgedAt = acknowledgedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let exitCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .exitCode)
        exitCode = exitCodeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a command.
    public struct Command: Swift.Equatable {
        /// Date and time when the command was acknowledged.
        public var acknowledgedAt: Swift.String?
        /// The command ID.
        public var commandId: Swift.String?
        /// Date when the command completed.
        public var completedAt: Swift.String?
        /// Date and time when the command was run.
        public var createdAt: Swift.String?
        /// The command deployment ID.
        public var deploymentId: Swift.String?
        /// The command exit code.
        public var exitCode: Swift.Int?
        /// The ID of the instance where the command was executed.
        public var instanceId: Swift.String?
        /// The URL of the command log.
        public var logUrl: Swift.String?
        /// The command status:
        ///
        /// * failed
        ///
        /// * successful
        ///
        /// * skipped
        ///
        /// * pending
        public var status: Swift.String?
        /// The command type:
        ///
        /// * configure
        ///
        /// * deploy
        ///
        /// * execute_recipes
        ///
        /// * install_dependencies
        ///
        /// * restart
        ///
        /// * rollback
        ///
        /// * setup
        ///
        /// * start
        ///
        /// * stop
        ///
        /// * undeploy
        ///
        /// * update_custom_cookbooks
        ///
        /// * update_dependencies
        public var type: Swift.String?

        public init(
            acknowledgedAt: Swift.String? = nil,
            commandId: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            exitCode: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.acknowledgedAt = acknowledgedAt
            self.commandId = commandId
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.deploymentId = deploymentId
            self.exitCode = exitCode
            self.instanceId = instanceId
            self.logUrl = logUrl
            self.status = status
            self.type = type
        }
    }

}

extension CreateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSource = self.appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appAttributes0) in attributes {
                try attributesContainer.encode(appAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for string0 in domains {
                try domainsContainer.encode(string0)
            }
        }
        if let enableSsl = self.enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariable0 in environment {
                try environmentContainer.encode(environmentvariable0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let shortname = self.shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let sslConfiguration = self.sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppInput: Swift.Equatable {
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// The app's data source.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com'
    public var domains: [Swift.String]?
    /// Whether to enable SSL for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instance. For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20KB)." If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    /// This member is required.
    public var name: Swift.String?
    /// The app's short name.
    public var shortname: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The app type. Each supported type is associated with a particular layer. For example, PHP applications are associated with a PHP layer. AWS OpsWorks Stacks deploys an application to those instances that are members of the corresponding layer. If your app isn't one of the standard types, or you prefer to implement your own Deploy recipes, specify other.
    /// This member is required.
    public var type: OpsWorksClientTypes.AppType?

    public init(
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        shortname: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.shortname = shortname
        self.sslConfiguration = sslConfiguration
        self.stackId = stackId
        self.type = type
    }
}

struct CreateAppInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let shortname: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let dataSources: [OpsWorksClientTypes.DataSource]?
    let type: OpsWorksClientTypes.AppType?
    let appSource: OpsWorksClientTypes.Source?
    let domains: [Swift.String]?
    let enableSsl: Swift.Bool?
    let sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    let attributes: [Swift.String:Swift.String]?
    let environment: [OpsWorksClientTypes.EnvironmentVariable]?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case shortname = "Shortname"
        case sslConfiguration = "SslConfiguration"
        case stackId = "StackId"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension CreateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
        } else {
            self.appId = nil
        }
    }
}

/// Contains the response to a CreateApp request.
public struct CreateAppOutput: Swift.Equatable {
    /// The app ID.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateAppOutputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension CreateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

enum CreateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for string0 in instanceIds {
                try instanceIdsContainer.encode(string0)
            }
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// The app ID. This parameter is required for app deployments, but not for other deployment commands.
    public var appId: Swift.String?
    /// A DeploymentCommand object that specifies the deployment command and any associated arguments.
    /// This member is required.
    public var command: OpsWorksClientTypes.DeploymentCommand?
    /// A user-defined comment.
    public var comment: Swift.String?
    /// A string that contains user-defined, custom JSON. You can use this parameter to override some corresponding default stack configuration JSON values. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html) and [Overriding Attributes With Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html).
    public var customJson: Swift.String?
    /// The instance IDs for the deployment targets.
    public var instanceIds: [Swift.String]?
    /// The layer IDs for the deployment targets.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        command: OpsWorksClientTypes.DeploymentCommand? = nil,
        comment: Swift.String? = nil,
        customJson: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.command = command
        self.comment = comment
        self.customJson = customJson
        self.instanceIds = instanceIds
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let appId: Swift.String?
    let instanceIds: [Swift.String]?
    let layerIds: [Swift.String]?
    let command: OpsWorksClientTypes.DeploymentCommand?
    let comment: Swift.String?
    let customJson: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case customJson = "CustomJson"
        case instanceIds = "InstanceIds"
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let commandDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentId = nil
        }
    }
}

/// Contains the response to a CreateDeployment request.
public struct CreateDeploymentOutput: Swift.Equatable {
    /// The deployment ID, which can be used with other requests to identify the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = self.autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemapping0)
            }
        }
        if let ebsOptimized = self.ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let rootDeviceType = self.rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let sshKeyName = self.sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = self.virtualizationType {
            try encodeContainer.encode(virtualizationType, forKey: .virtualizationType)
        }
    }
}

extension CreateInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    /// * INHERIT - Use the stack's default agent version setting.
    ///
    /// * version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, edit the instance configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the instance.
    ///
    ///
    /// The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// A custom AMI ID to be used to create the instance. The AMI should be based on one of the supported operating systems. For more information, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html). If you specify a custom AMI, you must set Os to Custom.
    public var amiId: Swift.String?
    /// The instance architecture. The default option is x86_64. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// The instance Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
    public var availabilityZone: Swift.String?
    /// An array of BlockDeviceMapping objects that specify the instance's block devices. For more information, see [Block Device Mapping](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html). Note that block device mappings are not supported for custom AMIs.
    public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
    /// Whether to create an Amazon EBS-optimized instance.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name.
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html). The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
    /// This member is required.
    public var instanceType: Swift.String?
    /// An array that contains the instance's layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom.
    ///
    ///
    /// For more information about the supported operating systems, see [AWS OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the [CreateInstance] action's AmiId parameter to specify the custom AMI that you want to use. Block device mappings are not supported if the value is Custom. For more information about supported operating systems, see [Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html)For more information about how to use custom AMIs with AWS OpsWorks Stacks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    public var os: Swift.String?
    /// The instance root device type. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// The instance's Amazon EC2 key-pair name.
    public var sshKeyName: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The ID of the instance's subnet. If the stack is running in a VPC, you can use this parameter to override the stack's default subnet ID value and direct AWS OpsWorks Stacks to launch the instance in a different subnet.
    public var subnetId: Swift.String?
    /// The instance's tenancy option. The default option is no tenancy, or if the instance is running in a VPC, inherit tenancy settings from the VPC. The following are valid values for this parameter: dedicated, default, or host. Because there are costs associated with changes in tenancy options, we recommend that you research tenancy options before choosing them for your instances. For more information about dedicated hosts, see [Dedicated Hosts Overview](http://aws.amazon.com/ec2/dedicated-hosts/) and [Amazon EC2 Dedicated Hosts](http://aws.amazon.com/ec2/dedicated-hosts/). For more information about dedicated instances, see [Dedicated Instances](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html) and [Amazon EC2 Dedicated Instances](http://aws.amazon.com/ec2/purchasing-options/dedicated-instances/).
    public var tenancy: Swift.String?
    /// The instance's virtualization type, paravirtual or hvm.
    public var virtualizationType: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        availabilityZone: Swift.String? = nil,
        blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        sshKeyName: Swift.String? = nil,
        stackId: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tenancy: Swift.String? = nil,
        virtualizationType: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.availabilityZone = availabilityZone
        self.blockDeviceMappings = blockDeviceMappings
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.rootDeviceType = rootDeviceType
        self.sshKeyName = sshKeyName
        self.stackId = stackId
        self.subnetId = subnetId
        self.tenancy = tenancy
        self.virtualizationType = virtualizationType
    }
}

struct CreateInstanceInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let layerIds: [Swift.String]?
    let instanceType: Swift.String?
    let autoScalingType: OpsWorksClientTypes.AutoScalingType?
    let hostname: Swift.String?
    let os: Swift.String?
    let amiId: Swift.String?
    let sshKeyName: Swift.String?
    let availabilityZone: Swift.String?
    let virtualizationType: Swift.String?
    let subnetId: Swift.String?
    let architecture: OpsWorksClientTypes.Architecture?
    let rootDeviceType: OpsWorksClientTypes.RootDeviceType?
    let blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
    let installUpdatesOnBoot: Swift.Bool?
    let ebsOptimized: Swift.Bool?
    let agentVersion: Swift.String?
    let tenancy: Swift.String?
}

extension CreateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case rootDeviceType = "RootDeviceType"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[OpsWorksClientTypes.BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [OpsWorksClientTypes.BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
    }
}

extension CreateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// Contains the response to a CreateInstance request.
public struct CreateInstanceOutput: Swift.Equatable {
    /// The instance ID.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct CreateInstanceOutputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension CreateInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

enum CreateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLayerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerAttributes0) in attributes {
                try attributesContainer.encode(layerAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = self.autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = self.autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = self.customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = self.customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for string0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(string0)
            }
        }
        if let enableAutoHealing = self.enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let lifecycleEventConfiguration = self.lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for string0 in packages {
                try packagesContainer.encode(string0)
            }
        }
        if let shortname = self.shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = self.useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfiguration0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfiguration0)
            }
        }
    }
}

extension CreateLayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLayerInput: Swift.Equatable {
    /// One or more user-defined key-value pairs to be added to the stack attributes. To create a cluster layer, set the EcsClusterArn attribute to the cluster's ARN.
    public var attributes: [Swift.String:Swift.String]?
    /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see [CloudWatchLogsLogStream].
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see [ Using Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html). This feature is supported as of version 1.7.42 of the AWS CLI.
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. To ensure that your instances have the latest security updates, we strongly recommend using the default value of true.
    public var installUpdatesOnBoot: Swift.Bool?
    /// A LifeCycleEventConfiguration object that you can use to configure the Shutdown event to specify an execution timeout and enable or disable Elastic Load Balancer connection draining.
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console.
    /// This member is required.
    public var name: Swift.String?
    /// An array of Package objects that describes the layer packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef recipes. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters, which are limited to the alphanumeric characters, '-', '_', and '.'. The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the [Layer Reference](https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html).
    /// This member is required.
    public var shortname: Swift.String?
    /// The layer stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// The layer type. A stack cannot have more than one built-in layer of the same type. It can have any number of custom layers. Built-in layers are not available in Chef 12 stacks.
    /// This member is required.
    public var type: OpsWorksClientTypes.LayerType?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        stackId: Swift.String? = nil,
        type: OpsWorksClientTypes.LayerType? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.stackId = stackId
        self.type = type
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct CreateLayerInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let type: OpsWorksClientTypes.LayerType?
    let name: Swift.String?
    let shortname: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    let customInstanceProfileArn: Swift.String?
    let customJson: Swift.String?
    let customSecurityGroupIds: [Swift.String]?
    let packages: [Swift.String]?
    let volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?
    let enableAutoHealing: Swift.Bool?
    let autoAssignElasticIps: Swift.Bool?
    let autoAssignPublicIps: Swift.Bool?
    let customRecipes: OpsWorksClientTypes.Recipes?
    let installUpdatesOnBoot: Swift.Bool?
    let useEbsOptimizedInstances: Swift.Bool?
    let lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
}

extension CreateLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension CreateLayerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLayerOutputBody = try responseDecoder.decode(responseBody: data)
            self.layerId = output.layerId
        } else {
            self.layerId = nil
        }
    }
}

/// Contains the response to a CreateLayer request.
public struct CreateLayerOutput: Swift.Equatable {
    /// The layer ID.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct CreateLayerOutputBody: Swift.Equatable {
    let layerId: Swift.String?
}

extension CreateLayerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

enum CreateLayerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackAttributes0) in attributes {
                try attributesContainer.encode(stackAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = self.chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = self.customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = self.defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = self.defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = self.defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = self.defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = self.defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = self.defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = self.hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let useCustomCookbooks = self.useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = self.useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

extension CreateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    /// The default setting is the most recent release of the agent. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you create a stack we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the specified region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see the VpcId parameter description.
    public var defaultAvailabilityZone: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    /// This member is required.
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's default operating system, which is installed on every instance unless you specify a different operating system when you create the instance. You can specify one of the following.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information, see [ Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the current Amazon Linux version. For more information about supported operating systems, see [AWS OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html).
    public var defaultOs: Swift.String?
    /// The default root device type. This value is the default for all instances in the stack, but you can override it when you create an instance. The default option is instance-store. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key pair name. The default value is none. If you specify a key pair name, AWS OpsWorks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack name.
    /// This member is required.
    public var name: Swift.String?
    /// The stack's AWS region, such as ap-south-1. For more information about Amazon regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). In the AWS CLI, this API maps to the --stack-region parameter. If the --stack-region parameter and the AWS CLI common parameter --region are set to the same value, the stack uses a regional endpoint. If the --stack-region parameter is not set, but the AWS CLI --region parameter is, this also results in a stack with a regional endpoint. However, if the --region parameter is set to us-east-1, and the --stack-region parameter is set to one of the following, then the stack uses a legacy or classic region: us-west-1, us-west-2, sa-east-1, eu-central-1, eu-west-1, ap-northeast-1, ap-southeast-1, ap-southeast-2. In this case, the actual API endpoint of the stack is in us-east-1. Only the preceding regions are supported as classic regions in the us-east-1 API endpoint. Because it is a best practice to choose the regional endpoint that is closest to where you manage AWS, we recommend that you use regional endpoints for new stacks. The AWS CLI common --region parameter always specifies a regional API endpoint; it cannot be used to specify a classic AWS OpsWorks Stacks region.
    /// This member is required.
    public var region: Swift.String?
    /// The stack's AWS Identity and Access Management (IAM) role, which allows AWS OpsWorks Stacks to work with AWS resources on your behalf. You must set this parameter to the Amazon Resource Name (ARN) for an existing IAM role. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    /// This member is required.
    public var serviceRoleArn: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers. AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. With UseOpsworksSecurityGroups you can instead provide your own custom security groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    /// * False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on creation; custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?
    /// The ID of the VPC that the stack is to be launched into. The VPC must be in the stack's region. All instances are launched into this VPC. You cannot change the ID later.
    ///
    /// * If your account supports EC2-Classic, the default value is no VPC.
    ///
    /// * If your account does not support EC2-Classic, the default value is the default VPC for the specified region.
    ///
    ///
    /// If the VPC ID corresponds to a default VPC and you have specified either the DefaultAvailabilityZone or the DefaultSubnetId parameter only, AWS OpsWorks Stacks infers the value of the other parameter. If you specify neither parameter, AWS OpsWorks Stacks sets these parameters to the first valid Availability Zone for the specified region and the corresponding default VPC subnet ID, respectively. If you specify a nondefault VPC ID, note the following:
    ///
    /// * It must belong to a VPC in your account that is in the specified region.
    ///
    /// * You must specify a value for DefaultSubnetId.
    ///
    ///
    /// For more information about how to use AWS OpsWorks Stacks with a VPC, see [Running a Stack in a VPC](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-vpc.html). For more information about default VPC and EC2-Classic, see [Supported Platforms](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html).
    public var vpcId: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.region = region
        self.serviceRoleArn = serviceRoleArn
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
        self.vpcId = vpcId
    }
}

struct CreateStackInputBody: Swift.Equatable {
    let name: Swift.String?
    let region: Swift.String?
    let vpcId: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let serviceRoleArn: Swift.String?
    let defaultInstanceProfileArn: Swift.String?
    let defaultOs: Swift.String?
    let hostnameTheme: Swift.String?
    let defaultAvailabilityZone: Swift.String?
    let defaultSubnetId: Swift.String?
    let customJson: Swift.String?
    let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    let useCustomCookbooks: Swift.Bool?
    let useOpsworksSecurityGroups: Swift.Bool?
    let customCookbooksSource: OpsWorksClientTypes.Source?
    let defaultSshKeyName: Swift.String?
    let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    let agentVersion: Swift.String?
}

extension CreateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension CreateStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.stackId = output.stackId
        } else {
            self.stackId = nil
        }
    }
}

/// Contains the response to a CreateStack request.
public struct CreateStackOutput: Swift.Equatable {
    /// The stack ID, which is an opaque string that you use to identify the stack when performing actions such as DescribeStacks.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct CreateStackOutputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension CreateStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

enum CreateStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = self.allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = self.sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

extension CreateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Setting an IAM User's Public SSH Key](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
    public var allowSelfManagement: Swift.Bool?
    /// The user's IAM ARN; this can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's public SSH key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example, my.name will be changed to myname. If you do not specify an SSH user name, AWS OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init(
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    let iamUserArn: Swift.String?
    let sshUsername: Swift.String?
    let sshPublicKey: Swift.String?
    let allowSelfManagement: Swift.Bool?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension CreateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.iamUserArn = output.iamUserArn
        } else {
            self.iamUserArn = nil
        }
    }
}

/// Contains the response to a CreateUserProfile request.
public struct CreateUserProfileOutput: Swift.Equatable {
    /// The user's IAM ARN.
    public var iamUserArn: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct CreateUserProfileOutputBody: Swift.Equatable {
    let iamUserArn: Swift.String?
}

extension CreateUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

enum CreateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case databaseName = "DatabaseName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an app's data source.
    public struct DataSource: Swift.Equatable {
        /// The data source's ARN.
        public var arn: Swift.String?
        /// The database name.
        public var databaseName: Swift.String?
        /// The data source's type, AutoSelectOpsworksMysqlInstance, OpsworksMysqlInstance, RdsDbInstance, or None.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.databaseName = databaseName
            self.type = type
        }
    }

}

extension DeleteAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteElasticIp = self.deleteElasticIp {
            try encodeContainer.encode(deleteElasticIp, forKey: .deleteElasticIp)
        }
        if let deleteVolumes = self.deleteVolumes {
            try encodeContainer.encode(deleteVolumes, forKey: .deleteVolumes)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension DeleteInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceInput: Swift.Equatable {
    /// Whether to delete the instance Elastic IP address.
    public var deleteElasticIp: Swift.Bool?
    /// Whether to delete the instance's Amazon EBS volumes.
    public var deleteVolumes: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        deleteElasticIp: Swift.Bool? = nil,
        deleteVolumes: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.deleteElasticIp = deleteElasticIp
        self.deleteVolumes = deleteVolumes
        self.instanceId = instanceId
    }
}

struct DeleteInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let deleteElasticIp: Swift.Bool?
    let deleteVolumes: Swift.Bool?
}

extension DeleteInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteElasticIp = "DeleteElasticIp"
        case deleteVolumes = "DeleteVolumes"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let deleteElasticIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteElasticIp)
        deleteElasticIp = deleteElasticIpDecoded
        let deleteVolumesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteVolumes)
        deleteVolumes = deleteVolumesDecoded
    }
}

extension DeleteInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLayerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

extension DeleteLayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLayerInput: Swift.Equatable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct DeleteLayerInputBody: Swift.Equatable {
    let layerId: Swift.String?
}

extension DeleteLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DeleteLayerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLayerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLayerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DeleteStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DeleteStackInputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension DeleteStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DeleteStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStackOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
    }
}

extension DeleteUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserProfileInput: Swift.Equatable {
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
    }
}

struct DeleteUserProfileInputBody: Swift.Equatable {
    let iamUserArn: Swift.String?
}

extension DeleteUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
    }
}

extension DeleteUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case command = "Command"
        case comment = "Comment"
        case completedAt = "CompletedAt"
        case createdAt = "CreatedAt"
        case customJson = "CustomJson"
        case deploymentId = "DeploymentId"
        case duration = "Duration"
        case iamUserArn = "IamUserArn"
        case instanceIds = "InstanceIds"
        case stackId = "StackId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encode(completedAt, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for string0 in instanceIds {
                try instanceIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let commandDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommand.self, forKey: .command)
        command = commandDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Describes a deployment of a stack or app.
    public struct Deployment: Swift.Equatable {
        /// The app ID.
        public var appId: Swift.String?
        /// Used to specify a stack or deployment command.
        public var command: OpsWorksClientTypes.DeploymentCommand?
        /// A user-defined comment.
        public var comment: Swift.String?
        /// Date when the deployment completed.
        public var completedAt: Swift.String?
        /// Date when the deployment was created.
        public var createdAt: Swift.String?
        /// A string that contains user-defined custom JSON. It can be used to override the corresponding default stack configuration attribute values for stack or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information on custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
        public var customJson: Swift.String?
        /// The deployment ID.
        public var deploymentId: Swift.String?
        /// The deployment duration.
        public var duration: Swift.Int?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The IDs of the target instances.
        public var instanceIds: [Swift.String]?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The deployment status:
        ///
        /// * running
        ///
        /// * successful
        ///
        /// * failed
        public var status: Swift.String?

        public init(
            appId: Swift.String? = nil,
            command: OpsWorksClientTypes.DeploymentCommand? = nil,
            comment: Swift.String? = nil,
            completedAt: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            customJson: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            duration: Swift.Int? = nil,
            iamUserArn: Swift.String? = nil,
            instanceIds: [Swift.String]? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.appId = appId
            self.command = command
            self.comment = comment
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.customJson = customJson
            self.deploymentId = deploymentId
            self.duration = duration
            self.iamUserArn = iamUserArn
            self.instanceIds = instanceIds
            self.stackId = stackId
            self.status = status
        }
    }

}

extension OpsWorksClientTypes.DeploymentCommand: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case args = "Args"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let args = args {
            var argsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .args)
            for (dictKey0, deploymentCommandArgs0) in args {
                var deploymentCommandArgs0Container = argsContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in deploymentCommandArgs0 {
                    try deploymentCommandArgs0Container.encode(string1)
                }
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.DeploymentCommandName.self, forKey: .name)
        name = nameDecoded
        let argsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .args)
        var argsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let argsContainer = argsContainer {
            argsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, strings0) in argsContainer {
                var strings0Decoded0: [Swift.String]? = nil
                if let strings0 = strings0 {
                    strings0Decoded0 = [Swift.String]()
                    for string1 in strings0 {
                        if let string1 = string1 {
                            strings0Decoded0?.append(string1)
                        }
                    }
                }
                argsDecoded0?[key0] = strings0Decoded0
            }
        }
        args = argsDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Used to specify a stack or deployment command.
    public struct DeploymentCommand: Swift.Equatable {
        /// The arguments of those commands that take arguments. It should be set to a JSON object with the following format: {"arg_name1" : ["value1", "value2", ...], "arg_name2" : ["value1", "value2", ...], ...} The update_dependencies command takes two arguments:
        ///
        /// * upgrade_os_to - Specifies the desired Amazon Linux version for instances whose OS you want to upgrade, such as Amazon Linux 2016.09. You must also set the allow_reboot argument to true.
        ///
        /// * allow_reboot - Specifies whether to allow AWS OpsWorks Stacks to reboot the instances if necessary, after installing the updates. This argument can be set to either true or false. The default value is false.
        ///
        ///
        /// For example, to upgrade an instance to Amazon Linux 2016.09, set Args to the following.  { "upgrade_os_to":["Amazon Linux 2016.09"], "allow_reboot":["true"] }
        public var args: [Swift.String:[Swift.String]]?
        /// Specifies the operation. You can specify only one command. For stacks, the following commands are available:
        ///
        /// * execute_recipes: Execute one or more recipes. To specify the recipes, set an Args parameter named recipes to the list of recipes to be executed. For example, to execute phpapp::appsetup, set Args to {"recipes":["phpapp::appsetup"]}.
        ///
        /// * install_dependencies: Install the stack's dependencies.
        ///
        /// * update_custom_cookbooks: Update the stack's custom cookbooks.
        ///
        /// * update_dependencies: Update the stack's dependencies.
        ///
        ///
        /// The update_dependencies and install_dependencies commands are supported only for Linux instances. You can run the commands successfully on Windows instances, but they do nothing. For apps, the following commands are available:
        ///
        /// * deploy: Deploy an app. Ruby on Rails apps have an optional Args parameter named migrate. Set Args to {"migrate":["true"]} to migrate the database. The default setting is {"migrate":["false"]}.
        ///
        /// * rollback Roll the app back to the previous version. When you update an app, AWS OpsWorks Stacks stores the previous version, up to a maximum of five versions. You can use this command to roll an app back as many as four versions.
        ///
        /// * start: Start the app's web or application server.
        ///
        /// * stop: Stop the app's web or application server.
        ///
        /// * restart: Restart the app's web or application server.
        ///
        /// * undeploy: Undeploy the app.
        /// This member is required.
        public var name: OpsWorksClientTypes.DeploymentCommandName?

        public init(
            args: [Swift.String:[Swift.String]]? = nil,
            name: OpsWorksClientTypes.DeploymentCommandName? = nil
        )
        {
            self.args = args
            self.name = name
        }
    }

}

extension OpsWorksClientTypes {
    public enum DeploymentCommandName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configure
        case deploy
        case executeRecipes
        case installDependencies
        case restart
        case rollback
        case setup
        case start
        case stop
        case undeploy
        case updateCustomCookbooks
        case updateDependencies
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentCommandName] {
            return [
                .configure,
                .deploy,
                .executeRecipes,
                .installDependencies,
                .restart,
                .rollback,
                .setup,
                .start,
                .stop,
                .undeploy,
                .updateCustomCookbooks,
                .updateDependencies,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configure: return "configure"
            case .deploy: return "deploy"
            case .executeRecipes: return "execute_recipes"
            case .installDependencies: return "install_dependencies"
            case .restart: return "restart"
            case .rollback: return "rollback"
            case .setup: return "setup"
            case .start: return "start"
            case .stop: return "stop"
            case .undeploy: return "undeploy"
            case .updateCustomCookbooks: return "update_custom_cookbooks"
            case .updateDependencies: return "update_dependencies"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentCommandName(rawValue: rawValue) ?? DeploymentCommandName.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterEcsClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = self.ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
    }
}

extension DeregisterEcsClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterEcsClusterInput: Swift.Equatable {
    /// The cluster's Amazon Resource Number (ARN).
    /// This member is required.
    public var ecsClusterArn: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct DeregisterEcsClusterInputBody: Swift.Equatable {
    let ecsClusterArn: Swift.String?
}

extension DeregisterEcsClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

extension DeregisterEcsClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterEcsClusterOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterEcsClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterElasticIpInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

extension DeregisterElasticIpInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DeregisterElasticIpInputBody: Swift.Equatable {
    let elasticIp: Swift.String?
}

extension DeregisterElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DeregisterElasticIpOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterElasticIpOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterElasticIpOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension DeregisterInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct DeregisterInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension DeregisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension DeregisterInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterRdsDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArn = self.rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

extension DeregisterRdsDbInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterRdsDbInstanceInput: Swift.Equatable {
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init(
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct DeregisterRdsDbInstanceInputBody: Swift.Equatable {
    let rdsDbInstanceArn: Swift.String?
}

extension DeregisterRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
    }
}

extension DeregisterRdsDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterRdsDbInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterRdsDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

extension DeregisterVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeregisterVolumeInput: Swift.Equatable {
    /// The AWS OpsWorks Stacks volume ID, which is the GUID that AWS OpsWorks Stacks assigned to the instance when you registered the volume with the stack, not the Amazon EC2 volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct DeregisterVolumeInputBody: Swift.Equatable {
    let volumeId: Swift.String?
}

extension DeregisterVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension DeregisterVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterVolumeOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAgentVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeAgentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAgentVersionsInput: Swift.Equatable {
    /// The configuration manager.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.configurationManager = configurationManager
        self.stackId = stackId
    }
}

struct DescribeAgentVersionsInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
}

extension DescribeAgentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManager = "ConfigurationManager"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
    }
}

extension DescribeAgentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAgentVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentVersions = output.agentVersions
        } else {
            self.agentVersions = nil
        }
    }
}

/// Contains the response to a DescribeAgentVersions request.
public struct DescribeAgentVersionsOutput: Swift.Equatable {
    /// The agent versions for the specified stack or configuration manager. Note that this value is the complete version number, not the abbreviated number used by the console.
    public var agentVersions: [OpsWorksClientTypes.AgentVersion]?

    public init(
        agentVersions: [OpsWorksClientTypes.AgentVersion]? = nil
    )
    {
        self.agentVersions = agentVersions
    }
}

struct DescribeAgentVersionsOutputBody: Swift.Equatable {
    let agentVersions: [OpsWorksClientTypes.AgentVersion]?
}

extension DescribeAgentVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersions = "AgentVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.AgentVersion?].self, forKey: .agentVersions)
        var agentVersionsDecoded0:[OpsWorksClientTypes.AgentVersion]? = nil
        if let agentVersionsContainer = agentVersionsContainer {
            agentVersionsDecoded0 = [OpsWorksClientTypes.AgentVersion]()
            for structure0 in agentVersionsContainer {
                if let structure0 = structure0 {
                    agentVersionsDecoded0?.append(structure0)
                }
            }
        }
        agentVersions = agentVersionsDecoded0
    }
}

enum DescribeAgentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIds = appIds {
            var appIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appIds)
            for string0 in appIds {
                try appIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAppsInput: Swift.Equatable {
    /// An array of app IDs for the apps to be described. If you use this parameter, DescribeApps returns a description of the specified apps. Otherwise, it returns a description of every app.
    public var appIds: [Swift.String]?
    /// The app stack ID. If you use this parameter, DescribeApps returns a description of the apps in the specified stack.
    public var stackId: Swift.String?

    public init(
        appIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appIds = appIds
        self.stackId = stackId
    }
}

struct DescribeAppsInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let appIds: [Swift.String]?
}

extension DescribeAppsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds = "AppIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appIds)
        var appIdsDecoded0:[Swift.String]? = nil
        if let appIdsContainer = appIdsContainer {
            appIdsDecoded0 = [Swift.String]()
            for string0 in appIdsContainer {
                if let string0 = string0 {
                    appIdsDecoded0?.append(string0)
                }
            }
        }
        appIds = appIdsDecoded0
    }
}

extension DescribeAppsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppsOutputBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
        } else {
            self.apps = nil
        }
    }
}

/// Contains the response to a DescribeApps request.
public struct DescribeAppsOutput: Swift.Equatable {
    /// An array of App objects that describe the specified apps.
    public var apps: [OpsWorksClientTypes.App]?

    public init(
        apps: [OpsWorksClientTypes.App]? = nil
    )
    {
        self.apps = apps
    }
}

struct DescribeAppsOutputBody: Swift.Equatable {
    let apps: [OpsWorksClientTypes.App]?
}

extension DescribeAppsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps = "Apps"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.App?].self, forKey: .apps)
        var appsDecoded0:[OpsWorksClientTypes.App]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [OpsWorksClientTypes.App]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
    }
}

enum DescribeAppsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCommandsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commandIds = commandIds {
            var commandIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commandIds)
            for string0 in commandIds {
                try commandIdsContainer.encode(string0)
            }
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension DescribeCommandsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCommandsInput: Swift.Equatable {
    /// An array of command IDs. If you include this parameter, DescribeCommands returns a description of the specified commands. Otherwise, it returns a description of every command.
    public var commandIds: [Swift.String]?
    /// The deployment ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified deployment.
    public var deploymentId: Swift.String?
    /// The instance ID. If you include this parameter, DescribeCommands returns a description of the commands associated with the specified instance.
    public var instanceId: Swift.String?

    public init(
        commandIds: [Swift.String]? = nil,
        deploymentId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.commandIds = commandIds
        self.deploymentId = deploymentId
        self.instanceId = instanceId
    }
}

struct DescribeCommandsInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let instanceId: Swift.String?
    let commandIds: [Swift.String]?
}

extension DescribeCommandsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commandIds = "CommandIds"
        case deploymentId = "DeploymentId"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let commandIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .commandIds)
        var commandIdsDecoded0:[Swift.String]? = nil
        if let commandIdsContainer = commandIdsContainer {
            commandIdsDecoded0 = [Swift.String]()
            for string0 in commandIdsContainer {
                if let string0 = string0 {
                    commandIdsDecoded0?.append(string0)
                }
            }
        }
        commandIds = commandIdsDecoded0
    }
}

extension DescribeCommandsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCommandsOutputBody = try responseDecoder.decode(responseBody: data)
            self.commands = output.commands
        } else {
            self.commands = nil
        }
    }
}

/// Contains the response to a DescribeCommands request.
public struct DescribeCommandsOutput: Swift.Equatable {
    /// An array of Command objects that describe each of the specified commands.
    public var commands: [OpsWorksClientTypes.Command]?

    public init(
        commands: [OpsWorksClientTypes.Command]? = nil
    )
    {
        self.commands = commands
    }
}

struct DescribeCommandsOutputBody: Swift.Equatable {
    let commands: [OpsWorksClientTypes.Command]?
}

extension DescribeCommandsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commands = "Commands"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Command?].self, forKey: .commands)
        var commandsDecoded0:[OpsWorksClientTypes.Command]? = nil
        if let commandsContainer = commandsContainer {
            commandsDecoded0 = [OpsWorksClientTypes.Command]()
            for structure0 in commandsContainer {
                if let structure0 = structure0 {
                    commandsDecoded0?.append(structure0)
                }
            }
        }
        commands = commandsDecoded0
    }
}

enum DescribeCommandsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let deploymentIds = deploymentIds {
            var deploymentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploymentIds)
            for string0 in deploymentIds {
                try deploymentIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDeploymentsInput: Swift.Equatable {
    /// The app ID. If you include this parameter, the command returns a description of the commands associated with the specified app.
    public var appId: Swift.String?
    /// An array of deployment IDs to be described. If you include this parameter, the command returns a description of the specified deployments. Otherwise, it returns a description of every deployment.
    public var deploymentIds: [Swift.String]?
    /// The stack ID. If you include this parameter, the command returns a description of the commands associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        deploymentIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.deploymentIds = deploymentIds
        self.stackId = stackId
    }
}

struct DescribeDeploymentsInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let appId: Swift.String?
    let deploymentIds: [Swift.String]?
}

extension DescribeDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case deploymentIds = "DeploymentIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let deploymentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deploymentIds)
        var deploymentIdsDecoded0:[Swift.String]? = nil
        if let deploymentIdsContainer = deploymentIdsContainer {
            deploymentIdsDecoded0 = [Swift.String]()
            for string0 in deploymentIdsContainer {
                if let string0 = string0 {
                    deploymentIdsDecoded0?.append(string0)
                }
            }
        }
        deploymentIds = deploymentIdsDecoded0
    }
}

extension DescribeDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
        } else {
            self.deployments = nil
        }
    }
}

/// Contains the response to a DescribeDeployments request.
public struct DescribeDeploymentsOutput: Swift.Equatable {
    /// An array of Deployment objects that describe the deployments.
    public var deployments: [OpsWorksClientTypes.Deployment]?

    public init(
        deployments: [OpsWorksClientTypes.Deployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

struct DescribeDeploymentsOutputBody: Swift.Equatable {
    let deployments: [OpsWorksClientTypes.Deployment]?
}

extension DescribeDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[OpsWorksClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [OpsWorksClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
    }
}

enum DescribeDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEcsClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArns = ecsClusterArns {
            var ecsClusterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecsClusterArns)
            for string0 in ecsClusterArns {
                try ecsClusterArnsContainer.encode(string0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeEcsClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEcsClustersInput: Swift.Equatable {
    /// A list of ARNs, one for each cluster to be described.
    public var ecsClusterArns: [Swift.String]?
    /// To receive a paginated response, use this parameter to specify the maximum number of results to be returned with a single call. If the number of available results exceeds this maximum, the response includes a NextToken value that you can assign to the NextToken request parameter to get the next set of results.
    public var maxResults: Swift.Int?
    /// If the previous paginated request did not return all of the remaining results, the response object'sNextToken parameter value is set to a token. To retrieve the next set of results, call DescribeEcsClusters again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A stack ID. DescribeEcsClusters returns a description of the cluster that is registered with the stack.
    public var stackId: Swift.String?

    public init(
        ecsClusterArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArns = ecsClusterArns
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackId = stackId
    }
}

struct DescribeEcsClustersInputBody: Swift.Equatable {
    let ecsClusterArns: [Swift.String]?
    let stackId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEcsClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArns = "EcsClusterArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ecsClusterArns)
        var ecsClusterArnsDecoded0:[Swift.String]? = nil
        if let ecsClusterArnsContainer = ecsClusterArnsContainer {
            ecsClusterArnsDecoded0 = [Swift.String]()
            for string0 in ecsClusterArnsContainer {
                if let string0 = string0 {
                    ecsClusterArnsDecoded0?.append(string0)
                }
            }
        }
        ecsClusterArns = ecsClusterArnsDecoded0
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEcsClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEcsClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.ecsClusters = output.ecsClusters
            self.nextToken = output.nextToken
        } else {
            self.ecsClusters = nil
            self.nextToken = nil
        }
    }
}

/// Contains the response to a DescribeEcsClusters request.
public struct DescribeEcsClustersOutput: Swift.Equatable {
    /// A list of EcsCluster objects containing the cluster descriptions.
    public var ecsClusters: [OpsWorksClientTypes.EcsCluster]?
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that you can assign to the request object's NextToken parameter to retrieve the next set of results. If the previous paginated request returned all of the remaining results, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        ecsClusters: [OpsWorksClientTypes.EcsCluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ecsClusters = ecsClusters
        self.nextToken = nextToken
    }
}

struct DescribeEcsClustersOutputBody: Swift.Equatable {
    let ecsClusters: [OpsWorksClientTypes.EcsCluster]?
    let nextToken: Swift.String?
}

extension DescribeEcsClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusters = "EcsClusters"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClustersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EcsCluster?].self, forKey: .ecsClusters)
        var ecsClustersDecoded0:[OpsWorksClientTypes.EcsCluster]? = nil
        if let ecsClustersContainer = ecsClustersContainer {
            ecsClustersDecoded0 = [OpsWorksClientTypes.EcsCluster]()
            for structure0 in ecsClustersContainer {
                if let structure0 = structure0 {
                    ecsClustersDecoded0?.append(structure0)
                }
            }
        }
        ecsClusters = ecsClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEcsClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeElasticIpsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for string0 in ips {
                try ipsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeElasticIpsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeElasticIpsInput: Swift.Equatable {
    /// The instance ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of Elastic IP addresses to be described. If you include this parameter, DescribeElasticIps returns a description of the specified Elastic IP addresses. Otherwise, it returns a description of every Elastic IP address.
    public var ips: [Swift.String]?
    /// A stack ID. If you include this parameter, DescribeElasticIps returns a description of the Elastic IP addresses that are registered with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        ips: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.ips = ips
        self.stackId = stackId
    }
}

struct DescribeElasticIpsInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let stackId: Swift.String?
    let ips: [Swift.String]?
}

extension DescribeElasticIpsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case ips = "Ips"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
    }
}

extension DescribeElasticIpsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeElasticIpsOutputBody = try responseDecoder.decode(responseBody: data)
            self.elasticIps = output.elasticIps
        } else {
            self.elasticIps = nil
        }
    }
}

/// Contains the response to a DescribeElasticIps request.
public struct DescribeElasticIpsOutput: Swift.Equatable {
    /// An ElasticIps object that describes the specified Elastic IP addresses.
    public var elasticIps: [OpsWorksClientTypes.ElasticIp]?

    public init(
        elasticIps: [OpsWorksClientTypes.ElasticIp]? = nil
    )
    {
        self.elasticIps = elasticIps
    }
}

struct DescribeElasticIpsOutputBody: Swift.Equatable {
    let elasticIps: [OpsWorksClientTypes.ElasticIp]?
}

extension DescribeElasticIpsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIps = "ElasticIps"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ElasticIp?].self, forKey: .elasticIps)
        var elasticIpsDecoded0:[OpsWorksClientTypes.ElasticIp]? = nil
        if let elasticIpsContainer = elasticIpsContainer {
            elasticIpsDecoded0 = [OpsWorksClientTypes.ElasticIp]()
            for structure0 in elasticIpsContainer {
                if let structure0 = structure0 {
                    elasticIpsDecoded0?.append(structure0)
                }
            }
        }
        elasticIps = elasticIpsDecoded0
    }
}

enum DescribeElasticIpsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeElasticLoadBalancersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeElasticLoadBalancersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeElasticLoadBalancersInput: Swift.Equatable {
    /// A list of layer IDs. The action describes the Elastic Load Balancing instances for the specified layers.
    public var layerIds: [Swift.String]?
    /// A stack ID. The action describes the stack's Elastic Load Balancing instances.
    public var stackId: Swift.String?

    public init(
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeElasticLoadBalancersInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let layerIds: [Swift.String]?
}

extension DescribeElasticLoadBalancersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeElasticLoadBalancersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeElasticLoadBalancersOutputBody = try responseDecoder.decode(responseBody: data)
            self.elasticLoadBalancers = output.elasticLoadBalancers
        } else {
            self.elasticLoadBalancers = nil
        }
    }
}

/// Contains the response to a DescribeElasticLoadBalancers request.
public struct DescribeElasticLoadBalancersOutput: Swift.Equatable {
    /// A list of ElasticLoadBalancer objects that describe the specified Elastic Load Balancing instances.
    public var elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]?

    public init(
        elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]? = nil
    )
    {
        self.elasticLoadBalancers = elasticLoadBalancers
    }
}

struct DescribeElasticLoadBalancersOutputBody: Swift.Equatable {
    let elasticLoadBalancers: [OpsWorksClientTypes.ElasticLoadBalancer]?
}

extension DescribeElasticLoadBalancersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancers = "ElasticLoadBalancers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ElasticLoadBalancer?].self, forKey: .elasticLoadBalancers)
        var elasticLoadBalancersDecoded0:[OpsWorksClientTypes.ElasticLoadBalancer]? = nil
        if let elasticLoadBalancersContainer = elasticLoadBalancersContainer {
            elasticLoadBalancersDecoded0 = [OpsWorksClientTypes.ElasticLoadBalancer]()
            for structure0 in elasticLoadBalancersContainer {
                if let structure0 = structure0 {
                    elasticLoadBalancersDecoded0?.append(structure0)
                }
            }
        }
        elasticLoadBalancers = elasticLoadBalancersDecoded0
    }
}

enum DescribeElasticLoadBalancersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for string0 in instanceIds {
                try instanceIdsContainer.encode(string0)
            }
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstancesInput: Swift.Equatable {
    /// An array of instance IDs to be described. If you use this parameter, DescribeInstances returns a description of the specified instances. Otherwise, it returns a description of every instance.
    public var instanceIds: [Swift.String]?
    /// A layer ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified layer.
    public var layerId: Swift.String?
    /// A stack ID. If you use this parameter, DescribeInstances returns descriptions of the instances associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceIds: [Swift.String]? = nil,
        layerId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.layerId = layerId
        self.stackId = stackId
    }
}

struct DescribeInstancesInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let layerId: Swift.String?
    let instanceIds: [Swift.String]?
}

extension DescribeInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
        case layerId = "LayerId"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

/// Contains the response to a DescribeInstances request.
public struct DescribeInstancesOutput: Swift.Equatable {
    /// An array of Instance objects that describe the instances.
    public var instances: [OpsWorksClientTypes.Instance]?

    public init(
        instances: [OpsWorksClientTypes.Instance]? = nil
    )
    {
        self.instances = instances
    }
}

struct DescribeInstancesOutputBody: Swift.Equatable {
    let instances: [OpsWorksClientTypes.Instance]?
}

extension DescribeInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Instance?].self, forKey: .instances)
        var instancesDecoded0:[OpsWorksClientTypes.Instance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [OpsWorksClientTypes.Instance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

enum DescribeInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLayersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeLayersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLayersInput: Swift.Equatable {
    /// An array of layer IDs that specify the layers to be described. If you omit this parameter, DescribeLayers returns a description of every layer in the specified stack.
    public var layerIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        layerIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.layerIds = layerIds
        self.stackId = stackId
    }
}

struct DescribeLayersInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let layerIds: [Swift.String]?
}

extension DescribeLayersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLayersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLayersOutputBody = try responseDecoder.decode(responseBody: data)
            self.layers = output.layers
        } else {
            self.layers = nil
        }
    }
}

/// Contains the response to a DescribeLayers request.
public struct DescribeLayersOutput: Swift.Equatable {
    /// An array of Layer objects that describe the layers.
    public var layers: [OpsWorksClientTypes.Layer]?

    public init(
        layers: [OpsWorksClientTypes.Layer]? = nil
    )
    {
        self.layers = layers
    }
}

struct DescribeLayersOutputBody: Swift.Equatable {
    let layers: [OpsWorksClientTypes.Layer]?
}

extension DescribeLayersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layers = "Layers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[OpsWorksClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [OpsWorksClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

enum DescribeLayersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLoadBasedAutoScalingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
    }
}

extension DescribeLoadBasedAutoScalingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeLoadBasedAutoScalingInput: Swift.Equatable {
    /// An array of layer IDs.
    /// This member is required.
    public var layerIds: [Swift.String]?

    public init(
        layerIds: [Swift.String]? = nil
    )
    {
        self.layerIds = layerIds
    }
}

struct DescribeLoadBasedAutoScalingInputBody: Swift.Equatable {
    let layerIds: [Swift.String]?
}

extension DescribeLoadBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerIds = "LayerIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
    }
}

extension DescribeLoadBasedAutoScalingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLoadBasedAutoScalingOutputBody = try responseDecoder.decode(responseBody: data)
            self.loadBasedAutoScalingConfigurations = output.loadBasedAutoScalingConfigurations
        } else {
            self.loadBasedAutoScalingConfigurations = nil
        }
    }
}

/// Contains the response to a DescribeLoadBasedAutoScaling request.
public struct DescribeLoadBasedAutoScalingOutput: Swift.Equatable {
    /// An array of LoadBasedAutoScalingConfiguration objects that describe each layer's configuration.
    public var loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]?

    public init(
        loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]? = nil
    )
    {
        self.loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurations
    }
}

struct DescribeLoadBasedAutoScalingOutputBody: Swift.Equatable {
    let loadBasedAutoScalingConfigurations: [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]?
}

extension DescribeLoadBasedAutoScalingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBasedAutoScalingConfigurations = "LoadBasedAutoScalingConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.LoadBasedAutoScalingConfiguration?].self, forKey: .loadBasedAutoScalingConfigurations)
        var loadBasedAutoScalingConfigurationsDecoded0:[OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]? = nil
        if let loadBasedAutoScalingConfigurationsContainer = loadBasedAutoScalingConfigurationsContainer {
            loadBasedAutoScalingConfigurationsDecoded0 = [OpsWorksClientTypes.LoadBasedAutoScalingConfiguration]()
            for structure0 in loadBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    loadBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loadBasedAutoScalingConfigurations = loadBasedAutoScalingConfigurationsDecoded0
    }
}

enum DescribeLoadBasedAutoScalingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMyUserProfileInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeMyUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMyUserProfileInput: Swift.Equatable {

    public init() { }
}

struct DescribeMyUserProfileInputBody: Swift.Equatable {
}

extension DescribeMyUserProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMyUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMyUserProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.userProfile = output.userProfile
        } else {
            self.userProfile = nil
        }
    }
}

/// Contains the response to a DescribeMyUserProfile request.
public struct DescribeMyUserProfileOutput: Swift.Equatable {
    /// A UserProfile object that describes the user's SSH information.
    public var userProfile: OpsWorksClientTypes.SelfUserProfile?

    public init(
        userProfile: OpsWorksClientTypes.SelfUserProfile? = nil
    )
    {
        self.userProfile = userProfile
    }
}

struct DescribeMyUserProfileOutputBody: Swift.Equatable {
    let userProfile: OpsWorksClientTypes.SelfUserProfile?
}

extension DescribeMyUserProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userProfile = "UserProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfileDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SelfUserProfile.self, forKey: .userProfile)
        userProfile = userProfileDecoded
    }
}

enum DescribeMyUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOperatingSystemsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeOperatingSystemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeOperatingSystemsInput: Swift.Equatable {

    public init() { }
}

struct DescribeOperatingSystemsInputBody: Swift.Equatable {
}

extension DescribeOperatingSystemsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOperatingSystemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOperatingSystemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.operatingSystems = output.operatingSystems
        } else {
            self.operatingSystems = nil
        }
    }
}

/// The response to a DescribeOperatingSystems request.
public struct DescribeOperatingSystemsOutput: Swift.Equatable {
    /// Contains information in response to a DescribeOperatingSystems request.
    public var operatingSystems: [OpsWorksClientTypes.OperatingSystem]?

    public init(
        operatingSystems: [OpsWorksClientTypes.OperatingSystem]? = nil
    )
    {
        self.operatingSystems = operatingSystems
    }
}

struct DescribeOperatingSystemsOutputBody: Swift.Equatable {
    let operatingSystems: [OpsWorksClientTypes.OperatingSystem]?
}

extension DescribeOperatingSystemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operatingSystems = "OperatingSystems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.OperatingSystem?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[OpsWorksClientTypes.OperatingSystem]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [OpsWorksClientTypes.OperatingSystem]()
            for structure0 in operatingSystemsContainer {
                if let structure0 = structure0 {
                    operatingSystemsDecoded0?.append(structure0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
    }
}

enum DescribeOperatingSystemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePermissionsInput: Swift.Equatable {
    /// The user's IAM ARN. This can also be a federated user's ARN. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var iamUserArn: Swift.String?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        iamUserArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.iamUserArn = iamUserArn
        self.stackId = stackId
    }
}

struct DescribePermissionsInputBody: Swift.Equatable {
    let iamUserArn: Swift.String?
    let stackId: Swift.String?
}

extension DescribePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribePermissionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePermissionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissions = output.permissions
        } else {
            self.permissions = nil
        }
    }
}

/// Contains the response to a DescribePermissions request.
public struct DescribePermissionsOutput: Swift.Equatable {
    /// An array of Permission objects that describe the stack permissions.
    ///
    /// * If the request object contains only a stack ID, the array contains a Permission object with permissions for each of the stack IAM ARNs.
    ///
    /// * If the request object contains only an IAM ARN, the array contains a Permission object with permissions for each of the user's stack IDs.
    ///
    /// * If the request contains a stack ID and an IAM ARN, the array contains a single Permission object with permissions for the specified stack and IAM ARN.
    public var permissions: [OpsWorksClientTypes.Permission]?

    public init(
        permissions: [OpsWorksClientTypes.Permission]? = nil
    )
    {
        self.permissions = permissions
    }
}

struct DescribePermissionsOutputBody: Swift.Equatable {
    let permissions: [OpsWorksClientTypes.Permission]?
}

extension DescribePermissionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissions = "Permissions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[OpsWorksClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [OpsWorksClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

enum DescribePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRaidArraysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayIds = raidArrayIds {
            var raidArrayIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .raidArrayIds)
            for string0 in raidArrayIds {
                try raidArrayIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeRaidArraysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRaidArraysInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeRaidArrays returns descriptions of the RAID arrays associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of RAID array IDs. If you use this parameter, DescribeRaidArrays returns descriptions of the specified arrays. Otherwise, it returns a description of every array.
    public var raidArrayIds: [Swift.String]?
    /// The stack ID.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        raidArrayIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayIds = raidArrayIds
        self.stackId = stackId
    }
}

struct DescribeRaidArraysInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let stackId: Swift.String?
    let raidArrayIds: [Swift.String]?
}

extension DescribeRaidArraysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayIds = "RaidArrayIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .raidArrayIds)
        var raidArrayIdsDecoded0:[Swift.String]? = nil
        if let raidArrayIdsContainer = raidArrayIdsContainer {
            raidArrayIdsDecoded0 = [Swift.String]()
            for string0 in raidArrayIdsContainer {
                if let string0 = string0 {
                    raidArrayIdsDecoded0?.append(string0)
                }
            }
        }
        raidArrayIds = raidArrayIdsDecoded0
    }
}

extension DescribeRaidArraysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRaidArraysOutputBody = try responseDecoder.decode(responseBody: data)
            self.raidArrays = output.raidArrays
        } else {
            self.raidArrays = nil
        }
    }
}

/// Contains the response to a DescribeRaidArrays request.
public struct DescribeRaidArraysOutput: Swift.Equatable {
    /// A RaidArrays object that describes the specified RAID arrays.
    public var raidArrays: [OpsWorksClientTypes.RaidArray]?

    public init(
        raidArrays: [OpsWorksClientTypes.RaidArray]? = nil
    )
    {
        self.raidArrays = raidArrays
    }
}

struct DescribeRaidArraysOutputBody: Swift.Equatable {
    let raidArrays: [OpsWorksClientTypes.RaidArray]?
}

extension DescribeRaidArraysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case raidArrays = "RaidArrays"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArraysContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.RaidArray?].self, forKey: .raidArrays)
        var raidArraysDecoded0:[OpsWorksClientTypes.RaidArray]? = nil
        if let raidArraysContainer = raidArraysContainer {
            raidArraysDecoded0 = [OpsWorksClientTypes.RaidArray]()
            for structure0 in raidArraysContainer {
                if let structure0 = structure0 {
                    raidArraysDecoded0?.append(structure0)
                }
            }
        }
        raidArrays = raidArraysDecoded0
    }
}

enum DescribeRaidArraysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRdsDbInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsDbInstanceArns = rdsDbInstanceArns {
            var rdsDbInstanceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rdsDbInstanceArns)
            for string0 in rdsDbInstanceArns {
                try rdsDbInstanceArnsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeRdsDbInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRdsDbInstancesInput: Swift.Equatable {
    /// An array containing the ARNs of the instances to be described.
    public var rdsDbInstanceArns: [Swift.String]?
    /// The ID of the stack with which the instances are registered. The operation returns descriptions of all registered Amazon RDS instances.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        rdsDbInstanceArns: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.rdsDbInstanceArns = rdsDbInstanceArns
        self.stackId = stackId
    }
}

struct DescribeRdsDbInstancesInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let rdsDbInstanceArns: [Swift.String]?
}

extension DescribeRdsDbInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstanceArns = "RdsDbInstanceArns"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rdsDbInstanceArns)
        var rdsDbInstanceArnsDecoded0:[Swift.String]? = nil
        if let rdsDbInstanceArnsContainer = rdsDbInstanceArnsContainer {
            rdsDbInstanceArnsDecoded0 = [Swift.String]()
            for string0 in rdsDbInstanceArnsContainer {
                if let string0 = string0 {
                    rdsDbInstanceArnsDecoded0?.append(string0)
                }
            }
        }
        rdsDbInstanceArns = rdsDbInstanceArnsDecoded0
    }
}

extension DescribeRdsDbInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRdsDbInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.rdsDbInstances = output.rdsDbInstances
        } else {
            self.rdsDbInstances = nil
        }
    }
}

/// Contains the response to a DescribeRdsDbInstances request.
public struct DescribeRdsDbInstancesOutput: Swift.Equatable {
    /// An a array of RdsDbInstance objects that describe the instances.
    public var rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]?

    public init(
        rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]? = nil
    )
    {
        self.rdsDbInstances = rdsDbInstances
    }
}

struct DescribeRdsDbInstancesOutputBody: Swift.Equatable {
    let rdsDbInstances: [OpsWorksClientTypes.RdsDbInstance]?
}

extension DescribeRdsDbInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rdsDbInstances = "RdsDbInstances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstancesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.RdsDbInstance?].self, forKey: .rdsDbInstances)
        var rdsDbInstancesDecoded0:[OpsWorksClientTypes.RdsDbInstance]? = nil
        if let rdsDbInstancesContainer = rdsDbInstancesContainer {
            rdsDbInstancesDecoded0 = [OpsWorksClientTypes.RdsDbInstance]()
            for structure0 in rdsDbInstancesContainer {
                if let structure0 = structure0 {
                    rdsDbInstancesDecoded0?.append(structure0)
                }
            }
        }
        rdsDbInstances = rdsDbInstancesDecoded0
    }
}

enum DescribeRdsDbInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeServiceErrorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let serviceErrorIds = serviceErrorIds {
            var serviceErrorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceErrorIds)
            for string0 in serviceErrorIds {
                try serviceErrorIdsContainer.encode(string0)
            }
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeServiceErrorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServiceErrorsInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified instance.
    public var instanceId: Swift.String?
    /// An array of service error IDs. If you use this parameter, DescribeServiceErrors returns descriptions of the specified errors. Otherwise, it returns a description of every error.
    public var serviceErrorIds: [Swift.String]?
    /// The stack ID. If you use this parameter, DescribeServiceErrors returns descriptions of the errors associated with the specified stack.
    public var stackId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        serviceErrorIds: [Swift.String]? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceErrorIds = serviceErrorIds
        self.stackId = stackId
    }
}

struct DescribeServiceErrorsInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let instanceId: Swift.String?
    let serviceErrorIds: [Swift.String]?
}

extension DescribeServiceErrorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case serviceErrorIds = "ServiceErrorIds"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let serviceErrorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceErrorIds)
        var serviceErrorIdsDecoded0:[Swift.String]? = nil
        if let serviceErrorIdsContainer = serviceErrorIdsContainer {
            serviceErrorIdsDecoded0 = [Swift.String]()
            for string0 in serviceErrorIdsContainer {
                if let string0 = string0 {
                    serviceErrorIdsDecoded0?.append(string0)
                }
            }
        }
        serviceErrorIds = serviceErrorIdsDecoded0
    }
}

extension DescribeServiceErrorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeServiceErrorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.serviceErrors = output.serviceErrors
        } else {
            self.serviceErrors = nil
        }
    }
}

/// Contains the response to a DescribeServiceErrors request.
public struct DescribeServiceErrorsOutput: Swift.Equatable {
    /// An array of ServiceError objects that describe the specified service errors.
    public var serviceErrors: [OpsWorksClientTypes.ServiceError]?

    public init(
        serviceErrors: [OpsWorksClientTypes.ServiceError]? = nil
    )
    {
        self.serviceErrors = serviceErrors
    }
}

struct DescribeServiceErrorsOutputBody: Swift.Equatable {
    let serviceErrors: [OpsWorksClientTypes.ServiceError]?
}

extension DescribeServiceErrorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceErrors = "ServiceErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.ServiceError?].self, forKey: .serviceErrors)
        var serviceErrorsDecoded0:[OpsWorksClientTypes.ServiceError]? = nil
        if let serviceErrorsContainer = serviceErrorsContainer {
            serviceErrorsDecoded0 = [OpsWorksClientTypes.ServiceError]()
            for structure0 in serviceErrorsContainer {
                if let structure0 = structure0 {
                    serviceErrorsDecoded0?.append(structure0)
                }
            }
        }
        serviceErrors = serviceErrorsDecoded0
    }
}

enum DescribeServiceErrorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStackProvisioningParametersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeStackProvisioningParametersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStackProvisioningParametersInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackProvisioningParametersInputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension DescribeStackProvisioningParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackProvisioningParametersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStackProvisioningParametersOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentInstallerUrl = output.agentInstallerUrl
            self.parameters = output.parameters
        } else {
            self.agentInstallerUrl = nil
            self.parameters = nil
        }
    }
}

/// Contains the response to a DescribeStackProvisioningParameters request.
public struct DescribeStackProvisioningParametersOutput: Swift.Equatable {
    /// The AWS OpsWorks Stacks agent installer's URL.
    public var agentInstallerUrl: Swift.String?
    /// An embedded object that contains the provisioning parameters.
    public var parameters: [Swift.String:Swift.String]?

    public init(
        agentInstallerUrl: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentInstallerUrl = agentInstallerUrl
        self.parameters = parameters
    }
}

struct DescribeStackProvisioningParametersOutputBody: Swift.Equatable {
    let agentInstallerUrl: Swift.String?
    let parameters: [Swift.String:Swift.String]?
}

extension DescribeStackProvisioningParametersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentInstallerUrl = "AgentInstallerUrl"
        case parameters = "Parameters"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentInstallerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentInstallerUrl)
        agentInstallerUrl = agentInstallerUrlDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in parametersContainer {
                if let string0 = string0 {
                    parametersDecoded0?[key0] = string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

enum DescribeStackProvisioningParametersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStackSummaryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension DescribeStackSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStackSummaryInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct DescribeStackSummaryInputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension DescribeStackSummaryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension DescribeStackSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStackSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.stackSummary = output.stackSummary
        } else {
            self.stackSummary = nil
        }
    }
}

/// Contains the response to a DescribeStackSummary request.
public struct DescribeStackSummaryOutput: Swift.Equatable {
    /// A StackSummary object that contains the results.
    public var stackSummary: OpsWorksClientTypes.StackSummary?

    public init(
        stackSummary: OpsWorksClientTypes.StackSummary? = nil
    )
    {
        self.stackSummary = stackSummary
    }
}

struct DescribeStackSummaryOutputBody: Swift.Equatable {
    let stackSummary: OpsWorksClientTypes.StackSummary?
}

extension DescribeStackSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSummary = "StackSummary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSummaryDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackSummary.self, forKey: .stackSummary)
        stackSummary = stackSummaryDecoded
    }
}

enum DescribeStackSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackIds = "StackIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackIds = stackIds {
            var stackIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackIds)
            for string0 in stackIds {
                try stackIdsContainer.encode(string0)
            }
        }
    }
}

extension DescribeStacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStacksInput: Swift.Equatable {
    /// An array of stack IDs that specify the stacks to be described. If you omit this parameter, DescribeStacks returns a description of every stack.
    public var stackIds: [Swift.String]?

    public init(
        stackIds: [Swift.String]? = nil
    )
    {
        self.stackIds = stackIds
    }
}

struct DescribeStacksInputBody: Swift.Equatable {
    let stackIds: [Swift.String]?
}

extension DescribeStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackIds = "StackIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackIds)
        var stackIdsDecoded0:[Swift.String]? = nil
        if let stackIdsContainer = stackIdsContainer {
            stackIdsDecoded0 = [Swift.String]()
            for string0 in stackIdsContainer {
                if let string0 = string0 {
                    stackIdsDecoded0?.append(string0)
                }
            }
        }
        stackIds = stackIdsDecoded0
    }
}

extension DescribeStacksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStacksOutputBody = try responseDecoder.decode(responseBody: data)
            self.stacks = output.stacks
        } else {
            self.stacks = nil
        }
    }
}

/// Contains the response to a DescribeStacks request.
public struct DescribeStacksOutput: Swift.Equatable {
    /// An array of Stack objects that describe the stacks.
    public var stacks: [OpsWorksClientTypes.Stack]?

    public init(
        stacks: [OpsWorksClientTypes.Stack]? = nil
    )
    {
        self.stacks = stacks
    }
}

struct DescribeStacksOutputBody: Swift.Equatable {
    let stacks: [OpsWorksClientTypes.Stack]?
}

extension DescribeStacksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stacks = "Stacks"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Stack?].self, forKey: .stacks)
        var stacksDecoded0:[OpsWorksClientTypes.Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [OpsWorksClientTypes.Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
    }
}

enum DescribeStacksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTimeBasedAutoScalingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for string0 in instanceIds {
                try instanceIdsContainer.encode(string0)
            }
        }
    }
}

extension DescribeTimeBasedAutoScalingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTimeBasedAutoScalingInput: Swift.Equatable {
    /// An array of instance IDs.
    /// This member is required.
    public var instanceIds: [Swift.String]?

    public init(
        instanceIds: [Swift.String]? = nil
    )
    {
        self.instanceIds = instanceIds
    }
}

struct DescribeTimeBasedAutoScalingInputBody: Swift.Equatable {
    let instanceIds: [Swift.String]?
}

extension DescribeTimeBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds = "InstanceIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeTimeBasedAutoScalingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTimeBasedAutoScalingOutputBody = try responseDecoder.decode(responseBody: data)
            self.timeBasedAutoScalingConfigurations = output.timeBasedAutoScalingConfigurations
        } else {
            self.timeBasedAutoScalingConfigurations = nil
        }
    }
}

/// Contains the response to a DescribeTimeBasedAutoScaling request.
public struct DescribeTimeBasedAutoScalingOutput: Swift.Equatable {
    /// An array of TimeBasedAutoScalingConfiguration objects that describe the configuration for the specified instances.
    public var timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]?

    public init(
        timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]? = nil
    )
    {
        self.timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurations
    }
}

struct DescribeTimeBasedAutoScalingOutputBody: Swift.Equatable {
    let timeBasedAutoScalingConfigurations: [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]?
}

extension DescribeTimeBasedAutoScalingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeBasedAutoScalingConfigurations = "TimeBasedAutoScalingConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeBasedAutoScalingConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.TimeBasedAutoScalingConfiguration?].self, forKey: .timeBasedAutoScalingConfigurations)
        var timeBasedAutoScalingConfigurationsDecoded0:[OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]? = nil
        if let timeBasedAutoScalingConfigurationsContainer = timeBasedAutoScalingConfigurationsContainer {
            timeBasedAutoScalingConfigurationsDecoded0 = [OpsWorksClientTypes.TimeBasedAutoScalingConfiguration]()
            for structure0 in timeBasedAutoScalingConfigurationsContainer {
                if let structure0 = structure0 {
                    timeBasedAutoScalingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        timeBasedAutoScalingConfigurations = timeBasedAutoScalingConfigurationsDecoded0
    }
}

enum DescribeTimeBasedAutoScalingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArns = iamUserArns {
            var iamUserArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamUserArns)
            for string0 in iamUserArns {
                try iamUserArnsContainer.encode(string0)
            }
        }
    }
}

extension DescribeUserProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserProfilesInput: Swift.Equatable {
    /// An array of IAM or federated user ARNs that identify the users to be described.
    public var iamUserArns: [Swift.String]?

    public init(
        iamUserArns: [Swift.String]? = nil
    )
    {
        self.iamUserArns = iamUserArns
    }
}

struct DescribeUserProfilesInputBody: Swift.Equatable {
    let iamUserArns: [Swift.String]?
}

extension DescribeUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArns = "IamUserArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .iamUserArns)
        var iamUserArnsDecoded0:[Swift.String]? = nil
        if let iamUserArnsContainer = iamUserArnsContainer {
            iamUserArnsDecoded0 = [Swift.String]()
            for string0 in iamUserArnsContainer {
                if let string0 = string0 {
                    iamUserArnsDecoded0?.append(string0)
                }
            }
        }
        iamUserArns = iamUserArnsDecoded0
    }
}

extension DescribeUserProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.userProfiles = output.userProfiles
        } else {
            self.userProfiles = nil
        }
    }
}

/// Contains the response to a DescribeUserProfiles request.
public struct DescribeUserProfilesOutput: Swift.Equatable {
    /// A Users object that describes the specified users.
    public var userProfiles: [OpsWorksClientTypes.UserProfile]?

    public init(
        userProfiles: [OpsWorksClientTypes.UserProfile]? = nil
    )
    {
        self.userProfiles = userProfiles
    }
}

struct DescribeUserProfilesOutputBody: Swift.Equatable {
    let userProfiles: [OpsWorksClientTypes.UserProfile]?
}

extension DescribeUserProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userProfiles = "UserProfiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.UserProfile?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[OpsWorksClientTypes.UserProfile]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [OpsWorksClientTypes.UserProfile]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
    }
}

enum DescribeUserProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVolumesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let raidArrayId = self.raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeIds = volumeIds {
            var volumeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeIds)
            for string0 in volumeIds {
                try volumeIdsContainer.encode(string0)
            }
        }
    }
}

extension DescribeVolumesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVolumesInput: Swift.Equatable {
    /// The instance ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified instance.
    public var instanceId: Swift.String?
    /// The RAID array ID. If you use this parameter, DescribeVolumes returns descriptions of the volumes associated with the specified RAID array.
    public var raidArrayId: Swift.String?
    /// A stack ID. The action describes the stack's registered Amazon EBS volumes.
    public var stackId: Swift.String?
    /// Am array of volume IDs. If you use this parameter, DescribeVolumes returns descriptions of the specified volumes. Otherwise, it returns a description of every volume.
    public var volumeIds: [Swift.String]?

    public init(
        instanceId: Swift.String? = nil,
        raidArrayId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        volumeIds: [Swift.String]? = nil
    )
    {
        self.instanceId = instanceId
        self.raidArrayId = raidArrayId
        self.stackId = stackId
        self.volumeIds = volumeIds
    }
}

struct DescribeVolumesInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let stackId: Swift.String?
    let raidArrayId: Swift.String?
    let volumeIds: [Swift.String]?
}

extension DescribeVolumesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case raidArrayId = "RaidArrayId"
        case stackId = "StackId"
        case volumeIds = "VolumeIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let volumeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .volumeIds)
        var volumeIdsDecoded0:[Swift.String]? = nil
        if let volumeIdsContainer = volumeIdsContainer {
            volumeIdsDecoded0 = [Swift.String]()
            for string0 in volumeIdsContainer {
                if let string0 = string0 {
                    volumeIdsDecoded0?.append(string0)
                }
            }
        }
        volumeIds = volumeIdsDecoded0
    }
}

extension DescribeVolumesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVolumesOutputBody = try responseDecoder.decode(responseBody: data)
            self.volumes = output.volumes
        } else {
            self.volumes = nil
        }
    }
}

/// Contains the response to a DescribeVolumes request.
public struct DescribeVolumesOutput: Swift.Equatable {
    /// An array of volume IDs.
    public var volumes: [OpsWorksClientTypes.Volume]?

    public init(
        volumes: [OpsWorksClientTypes.Volume]? = nil
    )
    {
        self.volumes = volumes
    }
}

struct DescribeVolumesOutputBody: Swift.Equatable {
    let volumes: [OpsWorksClientTypes.Volume]?
}

extension DescribeVolumesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumes = "Volumes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[OpsWorksClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [OpsWorksClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

enum DescribeVolumesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachElasticLoadBalancerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticLoadBalancerName = self.elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

extension DetachElasticLoadBalancerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachElasticLoadBalancerInput: Swift.Equatable {
    /// The Elastic Load Balancing instance's name.
    /// This member is required.
    public var elasticLoadBalancerName: Swift.String?
    /// The ID of the layer that the Elastic Load Balancing instance is attached to.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        elasticLoadBalancerName: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.elasticLoadBalancerName = elasticLoadBalancerName
        self.layerId = layerId
    }
}

struct DetachElasticLoadBalancerInputBody: Swift.Equatable {
    let elasticLoadBalancerName: Swift.String?
    let layerId: Swift.String?
}

extension DetachElasticLoadBalancerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension DetachElasticLoadBalancerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachElasticLoadBalancerOutput: Swift.Equatable {

    public init() { }
}

enum DetachElasticLoadBalancerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateElasticIpInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
    }
}

extension DisassociateElasticIpInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct DisassociateElasticIpInputBody: Swift.Equatable {
    let elasticIp: Swift.String?
}

extension DisassociateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

extension DisassociateElasticIpOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateElasticIpOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateElasticIpOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.EbsBlockDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = self.deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an Amazon EBS volume. This data type maps directly to the Amazon EC2 [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html) data type.
    public struct EbsBlockDevice: Swift.Equatable {
        /// Whether the volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// The number of I/O operations per second (IOPS) that the volume supports. For more information, see [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html).
        public var iops: Swift.Int?
        /// The snapshot ID.
        public var snapshotId: Swift.String?
        /// The volume size, in GiB. For more information, see [EbsBlockDevice](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EbsBlockDevice.html).
        public var volumeSize: Swift.Int?
        /// The volume type. gp2 for General Purpose (SSD) volumes, io1 for Provisioned IOPS (SSD) volumes, st1 for Throughput Optimized hard disk drives (HDD), sc1 for Cold HDD,and standard for Magnetic volumes. If you specify the io1 volume type, you must also specify a value for the Iops attribute. The maximum ratio of provisioned IOPS to requested volume size (in GiB) is 50:1. AWS uses the default volume size (in GiB) specified in the AMI attributes to set IOPS to 50 x (volume size).
        public var volumeType: OpsWorksClientTypes.VolumeType?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            snapshotId: Swift.String? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: OpsWorksClientTypes.VolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.EcsCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case ecsClusterName = "EcsClusterName"
        case registeredAt = "RegisteredAt"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = self.ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsClusterName = self.ecsClusterName {
            try encodeContainer.encode(ecsClusterName, forKey: .ecsClusterName)
        }
        if let registeredAt = self.registeredAt {
            try encodeContainer.encode(registeredAt, forKey: .registeredAt)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsClusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterName)
        ecsClusterName = ecsClusterNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a registered Amazon ECS cluster.
    public struct EcsCluster: Swift.Equatable {
        /// The cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// The cluster name.
        public var ecsClusterName: Swift.String?
        /// The time and date that the cluster was registered with the stack.
        public var registeredAt: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init(
            ecsClusterArn: Swift.String? = nil,
            ecsClusterName: Swift.String? = nil,
            registeredAt: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.ecsClusterArn = ecsClusterArn
            self.ecsClusterName = ecsClusterName
            self.registeredAt = registeredAt
            self.stackId = stackId
        }
    }

}

extension OpsWorksClientTypes.ElasticIp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case instanceId = "InstanceId"
        case ip = "Ip"
        case name = "Name"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let ip = self.ip {
            try encodeContainer.encode(ip, forKey: .ip)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ip)
        ip = ipDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an Elastic IP address.
    public struct ElasticIp: Swift.Equatable {
        /// The domain.
        public var domain: Swift.String?
        /// The ID of the instance that the address is attached to.
        public var instanceId: Swift.String?
        /// The IP address.
        public var ip: Swift.String?
        /// The name.
        public var name: Swift.String?
        /// The AWS region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?

        public init(
            domain: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            ip: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.domain = domain
            self.instanceId = instanceId
            self.ip = ip
            self.name = name
            self.region = region
        }
    }

}

extension OpsWorksClientTypes.ElasticLoadBalancer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case dnsName = "DnsName"
        case ec2InstanceIds = "Ec2InstanceIds"
        case elasticLoadBalancerName = "ElasticLoadBalancerName"
        case layerId = "LayerId"
        case region = "Region"
        case stackId = "StackId"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for string0 in availabilityZones {
                try availabilityZonesContainer.encode(string0)
            }
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ec2InstanceIds = ec2InstanceIds {
            var ec2InstanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceIds)
            for string0 in ec2InstanceIds {
                try ec2InstanceIdsContainer.encode(string0)
            }
        }
        if let elasticLoadBalancerName = self.elasticLoadBalancerName {
            try encodeContainer.encode(elasticLoadBalancerName, forKey: .elasticLoadBalancerName)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticLoadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticLoadBalancerName)
        elasticLoadBalancerName = elasticLoadBalancerNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let ec2InstanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2InstanceIds)
        var ec2InstanceIdsDecoded0:[Swift.String]? = nil
        if let ec2InstanceIdsContainer = ec2InstanceIdsContainer {
            ec2InstanceIdsDecoded0 = [Swift.String]()
            for string0 in ec2InstanceIdsContainer {
                if let string0 = string0 {
                    ec2InstanceIdsDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceIds = ec2InstanceIdsDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Describes an Elastic Load Balancing instance.
    public struct ElasticLoadBalancer: Swift.Equatable {
        /// A list of Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// The instance's public DNS name.
        public var dnsName: Swift.String?
        /// A list of the EC2 instances that the Elastic Load Balancing instance is managing traffic for.
        public var ec2InstanceIds: [Swift.String]?
        /// The Elastic Load Balancing instance's name.
        public var elasticLoadBalancerName: Swift.String?
        /// The ID of the layer that the instance is attached to.
        public var layerId: Swift.String?
        /// The instance's AWS region.
        public var region: Swift.String?
        /// The ID of the stack that the instance is associated with.
        public var stackId: Swift.String?
        /// A list of subnet IDs, if the stack is running in a VPC.
        public var subnetIds: [Swift.String]?
        /// The VPC ID.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            dnsName: Swift.String? = nil,
            ec2InstanceIds: [Swift.String]? = nil,
            elasticLoadBalancerName: Swift.String? = nil,
            layerId: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.dnsName = dnsName
            self.ec2InstanceIds = ec2InstanceIds
            self.elasticLoadBalancerName = elasticLoadBalancerName
            self.layerId = layerId
            self.region = region
            self.stackId = stackId
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension OpsWorksClientTypes.EnvironmentVariable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case secure = "Secure"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let secure = self.secure {
            try encodeContainer.encode(secure, forKey: .secure)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let secureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .secure)
        secure = secureDecoded
    }
}

extension OpsWorksClientTypes {
    /// Represents an app's environment variable.
    public struct EnvironmentVariable: Swift.Equatable {
        /// (Required) The environment variable's name, which can consist of up to 64 characters and must be specified. The name can contain upper- and lowercase letters, numbers, and underscores (_), but it must start with a letter or underscore.
        /// This member is required.
        public var key: Swift.String?
        /// (Optional) Whether the variable's value will be returned by the [DescribeApps] action. To conceal an environment variable's value, set Secure to true. DescribeApps then returns *****FILTERED***** instead of the actual value. The default value for Secure is false.
        public var secure: Swift.Bool?
        /// (Optional) The environment variable's value, which can be left empty. If you specify a value, it can contain up to 256 characters, which must all be printable.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            secure: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.secure = secure
            self.value = value
        }
    }

}

extension GetHostnameSuggestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
    }
}

extension GetHostnameSuggestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetHostnameSuggestionInput: Swift.Equatable {
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?

    public init(
        layerId: Swift.String? = nil
    )
    {
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionInputBody: Swift.Equatable {
    let layerId: Swift.String?
}

extension GetHostnameSuggestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
    }
}

extension GetHostnameSuggestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetHostnameSuggestionOutputBody = try responseDecoder.decode(responseBody: data)
            self.hostname = output.hostname
            self.layerId = output.layerId
        } else {
            self.hostname = nil
            self.layerId = nil
        }
    }
}

/// Contains the response to a GetHostnameSuggestion request.
public struct GetHostnameSuggestionOutput: Swift.Equatable {
    /// The generated host name.
    public var hostname: Swift.String?
    /// The layer ID.
    public var layerId: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        layerId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.layerId = layerId
    }
}

struct GetHostnameSuggestionOutputBody: Swift.Equatable {
    let layerId: Swift.String?
    let hostname: Swift.String?
}

extension GetHostnameSuggestionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case layerId = "LayerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

enum GetHostnameSuggestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GrantAccessInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let validForInMinutes = self.validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }
}

extension GrantAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GrantAccessInput: Swift.Equatable {
    /// The instance's AWS OpsWorks Stacks ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The length of time (in minutes) that the grant is valid. When the grant expires at the end of this period, the user will no longer be able to use the credentials to log in. If the user is logged in at the time, he or she automatically will be logged out.
    public var validForInMinutes: Swift.Int?

    public init(
        instanceId: Swift.String? = nil,
        validForInMinutes: Swift.Int? = nil
    )
    {
        self.instanceId = instanceId
        self.validForInMinutes = validForInMinutes
    }
}

struct GrantAccessInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let validForInMinutes: Swift.Int?
}

extension GrantAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case validForInMinutes = "ValidForInMinutes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
    }
}

extension GrantAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GrantAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.temporaryCredential = output.temporaryCredential
        } else {
            self.temporaryCredential = nil
        }
    }
}

/// Contains the response to a GrantAccess request.
public struct GrantAccessOutput: Swift.Equatable {
    /// A TemporaryCredential object that contains the data needed to log in to the instance by RDP clients, such as the Microsoft Remote Desktop Connection.
    public var temporaryCredential: OpsWorksClientTypes.TemporaryCredential?

    public init(
        temporaryCredential: OpsWorksClientTypes.TemporaryCredential? = nil
    )
    {
        self.temporaryCredential = temporaryCredential
    }
}

struct GrantAccessOutputBody: Swift.Equatable {
    let temporaryCredential: OpsWorksClientTypes.TemporaryCredential?
}

extension GrantAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case temporaryCredential = "TemporaryCredential"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temporaryCredentialDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.TemporaryCredential.self, forKey: .temporaryCredential)
        temporaryCredential = temporaryCredentialDecoded
    }
}

enum GrantAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case arn = "Arn"
        case autoScalingType = "AutoScalingType"
        case availabilityZone = "AvailabilityZone"
        case blockDeviceMappings = "BlockDeviceMappings"
        case createdAt = "CreatedAt"
        case ebsOptimized = "EbsOptimized"
        case ec2InstanceId = "Ec2InstanceId"
        case ecsClusterArn = "EcsClusterArn"
        case ecsContainerInstanceArn = "EcsContainerInstanceArn"
        case elasticIp = "ElasticIp"
        case hostname = "Hostname"
        case infrastructureClass = "InfrastructureClass"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case lastServiceErrorId = "LastServiceErrorId"
        case layerIds = "LayerIds"
        case os = "Os"
        case platform = "Platform"
        case privateDns = "PrivateDns"
        case privateIp = "PrivateIp"
        case publicDns = "PublicDns"
        case publicIp = "PublicIp"
        case registeredBy = "RegisteredBy"
        case reportedAgentVersion = "ReportedAgentVersion"
        case reportedOs = "ReportedOs"
        case rootDeviceType = "RootDeviceType"
        case rootDeviceVolumeId = "RootDeviceVolumeId"
        case securityGroupIds = "SecurityGroupIds"
        case sshHostDsaKeyFingerprint = "SshHostDsaKeyFingerprint"
        case sshHostRsaKeyFingerprint = "SshHostRsaKeyFingerprint"
        case sshKeyName = "SshKeyName"
        case stackId = "StackId"
        case status = "Status"
        case subnetId = "SubnetId"
        case tenancy = "Tenancy"
        case virtualizationType = "VirtualizationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoScalingType = self.autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for blockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(blockdevicemapping0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let ebsOptimized = self.ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let ec2InstanceId = self.ec2InstanceId {
            try encodeContainer.encode(ec2InstanceId, forKey: .ec2InstanceId)
        }
        if let ecsClusterArn = self.ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let ecsContainerInstanceArn = self.ecsContainerInstanceArn {
            try encodeContainer.encode(ecsContainerInstanceArn, forKey: .ecsContainerInstanceArn)
        }
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let infrastructureClass = self.infrastructureClass {
            try encodeContainer.encode(infrastructureClass, forKey: .infrastructureClass)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceProfileArn = self.instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let lastServiceErrorId = self.lastServiceErrorId {
            try encodeContainer.encode(lastServiceErrorId, forKey: .lastServiceErrorId)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let privateDns = self.privateDns {
            try encodeContainer.encode(privateDns, forKey: .privateDns)
        }
        if let privateIp = self.privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicDns = self.publicDns {
            try encodeContainer.encode(publicDns, forKey: .publicDns)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let registeredBy = self.registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let reportedAgentVersion = self.reportedAgentVersion {
            try encodeContainer.encode(reportedAgentVersion, forKey: .reportedAgentVersion)
        }
        if let reportedOs = self.reportedOs {
            try encodeContainer.encode(reportedOs, forKey: .reportedOs)
        }
        if let rootDeviceType = self.rootDeviceType {
            try encodeContainer.encode(rootDeviceType.rawValue, forKey: .rootDeviceType)
        }
        if let rootDeviceVolumeId = self.rootDeviceVolumeId {
            try encodeContainer.encode(rootDeviceVolumeId, forKey: .rootDeviceVolumeId)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let sshHostDsaKeyFingerprint = self.sshHostDsaKeyFingerprint {
            try encodeContainer.encode(sshHostDsaKeyFingerprint, forKey: .sshHostDsaKeyFingerprint)
        }
        if let sshHostRsaKeyFingerprint = self.sshHostRsaKeyFingerprint {
            try encodeContainer.encode(sshHostRsaKeyFingerprint, forKey: .sshHostRsaKeyFingerprint)
        }
        if let sshKeyName = self.sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let virtualizationType = self.virtualizationType {
            try encodeContainer.encode(virtualizationType.rawValue, forKey: .virtualizationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.BlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[OpsWorksClientTypes.BlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [OpsWorksClientTypes.BlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let ec2InstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceId)
        ec2InstanceId = ec2InstanceIdDecoded
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let ecsContainerInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsContainerInstanceArn)
        ecsContainerInstanceArn = ecsContainerInstanceArnDecoded
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let infrastructureClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureClass)
        infrastructureClass = infrastructureClassDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let lastServiceErrorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastServiceErrorId)
        lastServiceErrorId = lastServiceErrorIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let privateDnsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDns)
        privateDns = privateDnsDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let publicDnsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDns)
        publicDns = publicDnsDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let reportedAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedAgentVersion)
        reportedAgentVersion = reportedAgentVersionDecoded
        let reportedOsDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ReportedOs.self, forKey: .reportedOs)
        reportedOs = reportedOsDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let rootDeviceVolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDeviceVolumeId)
        rootDeviceVolumeId = rootDeviceVolumeIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let sshHostDsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshHostDsaKeyFingerprint)
        sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprintDecoded
        let sshHostRsaKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshHostRsaKeyFingerprint)
        sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprintDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an instance.
    public struct Instance: Swift.Equatable {
        /// The agent version. This parameter is set to INHERIT if the instance inherits the default stack setting or to a a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// A custom AMI ID to be used to create the instance. For more information, see [Instances](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html)
        public var amiId: Swift.String?
        /// The instance architecture: "i386" or "x86_64".
        public var architecture: OpsWorksClientTypes.Architecture?
        /// The instance's Amazon Resource Number (ARN).
        public var arn: Swift.String?
        /// For load-based or time-based instances, the type.
        public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
        /// The instance Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// An array of BlockDeviceMapping objects that specify the instance's block device mappings.
        public var blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]?
        /// The time that the instance was created.
        public var createdAt: Swift.String?
        /// Whether this is an Amazon EBS-optimized instance.
        public var ebsOptimized: Swift.Bool?
        /// The ID of the associated Amazon EC2 instance.
        public var ec2InstanceId: Swift.String?
        /// For container instances, the Amazon ECS cluster's ARN.
        public var ecsClusterArn: Swift.String?
        /// For container instances, the instance's ARN.
        public var ecsContainerInstanceArn: Swift.String?
        /// The instance [Elastic IP address ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html).
        public var elasticIp: Swift.String?
        /// The instance host name.
        public var hostname: Swift.String?
        /// For registered instances, the infrastructure class: ec2 or on-premises.
        public var infrastructureClass: Swift.String?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
        public var installUpdatesOnBoot: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// The ARN of the instance's IAM profile. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var instanceProfileArn: Swift.String?
        /// The instance type, such as t2.micro.
        public var instanceType: Swift.String?
        /// The ID of the last service error. For more information, call [DescribeServiceErrors].
        public var lastServiceErrorId: Swift.String?
        /// An array containing the instance layer IDs.
        public var layerIds: [Swift.String]?
        /// The instance's operating system.
        public var os: Swift.String?
        /// The instance's platform.
        public var platform: Swift.String?
        /// The instance's private DNS name.
        public var privateDns: Swift.String?
        /// The instance's private IP address.
        public var privateIp: Swift.String?
        /// The instance public DNS name.
        public var publicDns: Swift.String?
        /// The instance public IP address.
        public var publicIp: Swift.String?
        /// For registered instances, who performed the registration.
        public var registeredBy: Swift.String?
        /// The instance's reported AWS OpsWorks Stacks agent version.
        public var reportedAgentVersion: Swift.String?
        /// For registered instances, the reported operating system.
        public var reportedOs: OpsWorksClientTypes.ReportedOs?
        /// The instance's root device type. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
        public var rootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// The root device volume ID.
        public var rootDeviceVolumeId: Swift.String?
        /// An array containing the instance security group IDs.
        public var securityGroupIds: [Swift.String]?
        /// The SSH key's Deep Security Agent (DSA) fingerprint.
        public var sshHostDsaKeyFingerprint: Swift.String?
        /// The SSH key's RSA fingerprint.
        public var sshHostRsaKeyFingerprint: Swift.String?
        /// The instance's Amazon EC2 key-pair name.
        public var sshKeyName: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The instance status:
        ///
        /// * booting
        ///
        /// * connection_lost
        ///
        /// * online
        ///
        /// * pending
        ///
        /// * rebooting
        ///
        /// * requested
        ///
        /// * running_setup
        ///
        /// * setup_failed
        ///
        /// * shutting_down
        ///
        /// * start_failed
        ///
        /// * stop_failed
        ///
        /// * stopped
        ///
        /// * stopping
        ///
        /// * terminated
        ///
        /// * terminating
        public var status: Swift.String?
        /// The instance's subnet ID; applicable only if the stack is running in a VPC.
        public var subnetId: Swift.String?
        /// The instance's tenancy option, such as dedicated or host.
        public var tenancy: Swift.String?
        /// The instance's virtualization type: paravirtual or hvm.
        public var virtualizationType: OpsWorksClientTypes.VirtualizationType?

        public init(
            agentVersion: Swift.String? = nil,
            amiId: Swift.String? = nil,
            architecture: OpsWorksClientTypes.Architecture? = nil,
            arn: Swift.String? = nil,
            autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
            availabilityZone: Swift.String? = nil,
            blockDeviceMappings: [OpsWorksClientTypes.BlockDeviceMapping]? = nil,
            createdAt: Swift.String? = nil,
            ebsOptimized: Swift.Bool? = nil,
            ec2InstanceId: Swift.String? = nil,
            ecsClusterArn: Swift.String? = nil,
            ecsContainerInstanceArn: Swift.String? = nil,
            elasticIp: Swift.String? = nil,
            hostname: Swift.String? = nil,
            infrastructureClass: Swift.String? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            lastServiceErrorId: Swift.String? = nil,
            layerIds: [Swift.String]? = nil,
            os: Swift.String? = nil,
            platform: Swift.String? = nil,
            privateDns: Swift.String? = nil,
            privateIp: Swift.String? = nil,
            publicDns: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            registeredBy: Swift.String? = nil,
            reportedAgentVersion: Swift.String? = nil,
            reportedOs: OpsWorksClientTypes.ReportedOs? = nil,
            rootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            rootDeviceVolumeId: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            sshHostDsaKeyFingerprint: Swift.String? = nil,
            sshHostRsaKeyFingerprint: Swift.String? = nil,
            sshKeyName: Swift.String? = nil,
            stackId: Swift.String? = nil,
            status: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tenancy: Swift.String? = nil,
            virtualizationType: OpsWorksClientTypes.VirtualizationType? = nil
        )
        {
            self.agentVersion = agentVersion
            self.amiId = amiId
            self.architecture = architecture
            self.arn = arn
            self.autoScalingType = autoScalingType
            self.availabilityZone = availabilityZone
            self.blockDeviceMappings = blockDeviceMappings
            self.createdAt = createdAt
            self.ebsOptimized = ebsOptimized
            self.ec2InstanceId = ec2InstanceId
            self.ecsClusterArn = ecsClusterArn
            self.ecsContainerInstanceArn = ecsContainerInstanceArn
            self.elasticIp = elasticIp
            self.hostname = hostname
            self.infrastructureClass = infrastructureClass
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.instanceId = instanceId
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.lastServiceErrorId = lastServiceErrorId
            self.layerIds = layerIds
            self.os = os
            self.platform = platform
            self.privateDns = privateDns
            self.privateIp = privateIp
            self.publicDns = publicDns
            self.publicIp = publicIp
            self.registeredBy = registeredBy
            self.reportedAgentVersion = reportedAgentVersion
            self.reportedOs = reportedOs
            self.rootDeviceType = rootDeviceType
            self.rootDeviceVolumeId = rootDeviceVolumeId
            self.securityGroupIds = securityGroupIds
            self.sshHostDsaKeyFingerprint = sshHostDsaKeyFingerprint
            self.sshHostRsaKeyFingerprint = sshHostRsaKeyFingerprint
            self.sshKeyName = sshKeyName
            self.stackId = stackId
            self.status = status
            self.subnetId = subnetId
            self.tenancy = tenancy
            self.virtualizationType = virtualizationType
        }
    }

}

extension OpsWorksClientTypes.InstanceIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case signature = "Signature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let signature = self.signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
    }
}

extension OpsWorksClientTypes {
    /// Contains a description of an Amazon EC2 instance from the Amazon EC2 metadata service. For more information, see [Instance Metadata and User Data](https://docs.aws.amazon.com/sdkfornet/latest/apidocs/Index.html).
    public struct InstanceIdentity: Swift.Equatable {
        /// A JSON document that contains the metadata.
        public var document: Swift.String?
        /// A signature that can be used to verify the document's accuracy and authenticity.
        public var signature: Swift.String?

        public init(
            document: Swift.String? = nil,
            signature: Swift.String? = nil
        )
        {
            self.document = document
            self.signature = signature
        }
    }

}

extension OpsWorksClientTypes.InstancesCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assigning = "Assigning"
        case booting = "Booting"
        case connectionLost = "ConnectionLost"
        case deregistering = "Deregistering"
        case online = "Online"
        case pending = "Pending"
        case rebooting = "Rebooting"
        case registered = "Registered"
        case registering = "Registering"
        case requested = "Requested"
        case runningSetup = "RunningSetup"
        case setupFailed = "SetupFailed"
        case shuttingDown = "ShuttingDown"
        case startFailed = "StartFailed"
        case stopFailed = "StopFailed"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case terminated = "Terminated"
        case terminating = "Terminating"
        case unassigning = "Unassigning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assigning = self.assigning {
            try encodeContainer.encode(assigning, forKey: .assigning)
        }
        if let booting = self.booting {
            try encodeContainer.encode(booting, forKey: .booting)
        }
        if let connectionLost = self.connectionLost {
            try encodeContainer.encode(connectionLost, forKey: .connectionLost)
        }
        if let deregistering = self.deregistering {
            try encodeContainer.encode(deregistering, forKey: .deregistering)
        }
        if let online = self.online {
            try encodeContainer.encode(online, forKey: .online)
        }
        if let pending = self.pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
        if let rebooting = self.rebooting {
            try encodeContainer.encode(rebooting, forKey: .rebooting)
        }
        if let registered = self.registered {
            try encodeContainer.encode(registered, forKey: .registered)
        }
        if let registering = self.registering {
            try encodeContainer.encode(registering, forKey: .registering)
        }
        if let requested = self.requested {
            try encodeContainer.encode(requested, forKey: .requested)
        }
        if let runningSetup = self.runningSetup {
            try encodeContainer.encode(runningSetup, forKey: .runningSetup)
        }
        if let setupFailed = self.setupFailed {
            try encodeContainer.encode(setupFailed, forKey: .setupFailed)
        }
        if let shuttingDown = self.shuttingDown {
            try encodeContainer.encode(shuttingDown, forKey: .shuttingDown)
        }
        if let startFailed = self.startFailed {
            try encodeContainer.encode(startFailed, forKey: .startFailed)
        }
        if let stopFailed = self.stopFailed {
            try encodeContainer.encode(stopFailed, forKey: .stopFailed)
        }
        if let stopped = self.stopped {
            try encodeContainer.encode(stopped, forKey: .stopped)
        }
        if let stopping = self.stopping {
            try encodeContainer.encode(stopping, forKey: .stopping)
        }
        if let terminated = self.terminated {
            try encodeContainer.encode(terminated, forKey: .terminated)
        }
        if let terminating = self.terminating {
            try encodeContainer.encode(terminating, forKey: .terminating)
        }
        if let unassigning = self.unassigning {
            try encodeContainer.encode(unassigning, forKey: .unassigning)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assigningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assigning)
        assigning = assigningDecoded
        let bootingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .booting)
        booting = bootingDecoded
        let connectionLostDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionLost)
        connectionLost = connectionLostDecoded
        let deregisteringDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deregistering)
        deregistering = deregisteringDecoded
        let onlineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .online)
        online = onlineDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pending)
        pending = pendingDecoded
        let rebootingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rebooting)
        rebooting = rebootingDecoded
        let registeredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registered)
        registered = registeredDecoded
        let registeringDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registering)
        registering = registeringDecoded
        let requestedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requested)
        requested = requestedDecoded
        let runningSetupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningSetup)
        runningSetup = runningSetupDecoded
        let setupFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .setupFailed)
        setupFailed = setupFailedDecoded
        let shuttingDownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shuttingDown)
        shuttingDown = shuttingDownDecoded
        let startFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startFailed)
        startFailed = startFailedDecoded
        let stopFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopFailed)
        stopFailed = stopFailedDecoded
        let stoppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopped)
        stopped = stoppedDecoded
        let stoppingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopping)
        stopping = stoppingDecoded
        let terminatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminated)
        terminated = terminatedDecoded
        let terminatingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .terminating)
        terminating = terminatingDecoded
        let unassigningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unassigning)
        unassigning = unassigningDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes how many instances a stack has for each status.
    public struct InstancesCount: Swift.Equatable {
        /// The number of instances in the Assigning state.
        public var assigning: Swift.Int?
        /// The number of instances with booting status.
        public var booting: Swift.Int?
        /// The number of instances with connection_lost status.
        public var connectionLost: Swift.Int?
        /// The number of instances in the Deregistering state.
        public var deregistering: Swift.Int?
        /// The number of instances with online status.
        public var online: Swift.Int?
        /// The number of instances with pending status.
        public var pending: Swift.Int?
        /// The number of instances with rebooting status.
        public var rebooting: Swift.Int?
        /// The number of instances in the Registered state.
        public var registered: Swift.Int?
        /// The number of instances in the Registering state.
        public var registering: Swift.Int?
        /// The number of instances with requested status.
        public var requested: Swift.Int?
        /// The number of instances with running_setup status.
        public var runningSetup: Swift.Int?
        /// The number of instances with setup_failed status.
        public var setupFailed: Swift.Int?
        /// The number of instances with shutting_down status.
        public var shuttingDown: Swift.Int?
        /// The number of instances with start_failed status.
        public var startFailed: Swift.Int?
        /// The number of instances with stop_failed status.
        public var stopFailed: Swift.Int?
        /// The number of instances with stopped status.
        public var stopped: Swift.Int?
        /// The number of instances with stopping status.
        public var stopping: Swift.Int?
        /// The number of instances with terminated status.
        public var terminated: Swift.Int?
        /// The number of instances with terminating status.
        public var terminating: Swift.Int?
        /// The number of instances in the Unassigning state.
        public var unassigning: Swift.Int?

        public init(
            assigning: Swift.Int? = nil,
            booting: Swift.Int? = nil,
            connectionLost: Swift.Int? = nil,
            deregistering: Swift.Int? = nil,
            online: Swift.Int? = nil,
            pending: Swift.Int? = nil,
            rebooting: Swift.Int? = nil,
            registered: Swift.Int? = nil,
            registering: Swift.Int? = nil,
            requested: Swift.Int? = nil,
            runningSetup: Swift.Int? = nil,
            setupFailed: Swift.Int? = nil,
            shuttingDown: Swift.Int? = nil,
            startFailed: Swift.Int? = nil,
            stopFailed: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            stopping: Swift.Int? = nil,
            terminated: Swift.Int? = nil,
            terminating: Swift.Int? = nil,
            unassigning: Swift.Int? = nil
        )
        {
            self.assigning = assigning
            self.booting = booting
            self.connectionLost = connectionLost
            self.deregistering = deregistering
            self.online = online
            self.pending = pending
            self.rebooting = rebooting
            self.registered = registered
            self.registering = registering
            self.requested = requested
            self.runningSetup = runningSetup
            self.setupFailed = setupFailed
            self.shuttingDown = shuttingDown
            self.startFailed = startFailed
            self.stopFailed = stopFailed
            self.stopped = stopped
            self.stopping = stopping
            self.terminated = terminated
            self.terminating = terminating
            self.unassigning = unassigning
        }
    }

}

extension OpsWorksClientTypes.Layer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case createdAt = "CreatedAt"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case defaultRecipes = "DefaultRecipes"
        case defaultSecurityGroupNames = "DefaultSecurityGroupNames"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case stackId = "StackId"
        case type = "Type"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerAttributes0) in attributes {
                try attributesContainer.encode(layerAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = self.autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = self.autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customInstanceProfileArn = self.customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = self.customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for string0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(string0)
            }
        }
        if let defaultRecipes = self.defaultRecipes {
            try encodeContainer.encode(defaultRecipes, forKey: .defaultRecipes)
        }
        if let defaultSecurityGroupNames = defaultSecurityGroupNames {
            var defaultSecurityGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultSecurityGroupNames)
            for string0 in defaultSecurityGroupNames {
                try defaultSecurityGroupNamesContainer.encode(string0)
            }
        }
        if let enableAutoHealing = self.enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = self.lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for string0 in packages {
                try packagesContainer.encode(string0)
            }
        }
        if let shortname = self.shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let useEbsOptimizedInstances = self.useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfiguration0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LayerType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let defaultSecurityGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultSecurityGroupNames)
        var defaultSecurityGroupNamesDecoded0:[Swift.String]? = nil
        if let defaultSecurityGroupNamesContainer = defaultSecurityGroupNamesContainer {
            defaultSecurityGroupNamesDecoded0 = [Swift.String]()
            for string0 in defaultSecurityGroupNamesContainer {
                if let string0 = string0 {
                    defaultSecurityGroupNamesDecoded0?.append(string0)
                }
            }
        }
        defaultSecurityGroupNames = defaultSecurityGroupNamesDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let defaultRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .defaultRecipes)
        defaultRecipes = defaultRecipesDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a layer.
    public struct Layer: Swift.Equatable {
        /// The Amazon Resource Number (ARN) of a layer.
        public var arn: Swift.String?
        /// The layer attributes. For the HaproxyStatsPassword, MysqlRootPassword, and GangliaPassword attributes, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value For an ECS Cluster layer, AWS OpsWorks Stacks the EcsClusterArn attribute is set to the cluster's ARN.
        public var attributes: [Swift.String:Swift.String]?
        /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
        public var autoAssignElasticIps: Swift.Bool?
        /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
        public var autoAssignPublicIps: Swift.Bool?
        /// The Amazon CloudWatch Logs configuration settings for the layer.
        public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
        /// Date when the layer was created.
        public var createdAt: Swift.String?
        /// The ARN of the default IAM profile to be used for the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var customInstanceProfileArn: Swift.String?
        /// A JSON formatted string containing the layer's custom stack configuration and deployment attributes.
        public var customJson: Swift.String?
        /// A LayerCustomRecipes object that specifies the layer's custom recipes.
        public var customRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's custom security group IDs.
        public var customSecurityGroupIds: [Swift.String]?
        /// AWS OpsWorks Stacks supports five lifecycle events: setup, configuration, deploy, undeploy, and shutdown. For each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. You can also provide custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the standard recipes. LayerCustomRecipes specifies the custom recipes for a particular layer to be run in response to each of the five events. To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.
        public var defaultRecipes: OpsWorksClientTypes.Recipes?
        /// An array containing the layer's security group names.
        public var defaultSecurityGroupNames: [Swift.String]?
        /// Whether auto healing is disabled for the layer.
        public var enableAutoHealing: Swift.Bool?
        /// Whether to install operating system and package updates when the instance boots. The default value is true. If this value is set to false, you must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
        public var installUpdatesOnBoot: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// A LifeCycleEventConfiguration object that specifies the Shutdown event configuration.
        public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
        /// The layer name.
        public var name: Swift.String?
        /// An array of Package objects that describe the layer's packages.
        public var packages: [Swift.String]?
        /// The layer short name.
        public var shortname: Swift.String?
        /// The layer stack ID.
        public var stackId: Swift.String?
        /// The layer type.
        public var type: OpsWorksClientTypes.LayerType?
        /// Whether the layer uses Amazon EBS-optimized instances.
        public var useEbsOptimizedInstances: Swift.Bool?
        /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
        public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            autoAssignElasticIps: Swift.Bool? = nil,
            autoAssignPublicIps: Swift.Bool? = nil,
            cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
            createdAt: Swift.String? = nil,
            customInstanceProfileArn: Swift.String? = nil,
            customJson: Swift.String? = nil,
            customRecipes: OpsWorksClientTypes.Recipes? = nil,
            customSecurityGroupIds: [Swift.String]? = nil,
            defaultRecipes: OpsWorksClientTypes.Recipes? = nil,
            defaultSecurityGroupNames: [Swift.String]? = nil,
            enableAutoHealing: Swift.Bool? = nil,
            installUpdatesOnBoot: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
            name: Swift.String? = nil,
            packages: [Swift.String]? = nil,
            shortname: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: OpsWorksClientTypes.LayerType? = nil,
            useEbsOptimizedInstances: Swift.Bool? = nil,
            volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.autoAssignElasticIps = autoAssignElasticIps
            self.autoAssignPublicIps = autoAssignPublicIps
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.createdAt = createdAt
            self.customInstanceProfileArn = customInstanceProfileArn
            self.customJson = customJson
            self.customRecipes = customRecipes
            self.customSecurityGroupIds = customSecurityGroupIds
            self.defaultRecipes = defaultRecipes
            self.defaultSecurityGroupNames = defaultSecurityGroupNames
            self.enableAutoHealing = enableAutoHealing
            self.installUpdatesOnBoot = installUpdatesOnBoot
            self.layerId = layerId
            self.lifecycleEventConfiguration = lifecycleEventConfiguration
            self.name = name
            self.packages = packages
            self.shortname = shortname
            self.stackId = stackId
            self.type = type
            self.useEbsOptimizedInstances = useEbsOptimizedInstances
            self.volumeConfigurations = volumeConfigurations
        }
    }

}

extension OpsWorksClientTypes {
    public enum LayerAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bundlerversion
        case ecsclusterarn
        case enablehaproxystats
        case gangliapassword
        case gangliaurl
        case gangliauser
        case haproxyhealthcheckmethod
        case haproxyhealthcheckurl
        case haproxystatspassword
        case haproxystatsurl
        case haproxystatsuser
        case javaappserver
        case javaappserverversion
        case jvm
        case jvmoptions
        case jvmversion
        case managebundler
        case memcachedmemory
        case mysqlrootpassword
        case mysqlrootpasswordubiquitous
        case nodejsversion
        case passengerversion
        case railsstack
        case rubyversion
        case rubygemsversion
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAttributesKeys] {
            return [
                .bundlerversion,
                .ecsclusterarn,
                .enablehaproxystats,
                .gangliapassword,
                .gangliaurl,
                .gangliauser,
                .haproxyhealthcheckmethod,
                .haproxyhealthcheckurl,
                .haproxystatspassword,
                .haproxystatsurl,
                .haproxystatsuser,
                .javaappserver,
                .javaappserverversion,
                .jvm,
                .jvmoptions,
                .jvmversion,
                .managebundler,
                .memcachedmemory,
                .mysqlrootpassword,
                .mysqlrootpasswordubiquitous,
                .nodejsversion,
                .passengerversion,
                .railsstack,
                .rubyversion,
                .rubygemsversion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bundlerversion: return "BundlerVersion"
            case .ecsclusterarn: return "EcsClusterArn"
            case .enablehaproxystats: return "EnableHaproxyStats"
            case .gangliapassword: return "GangliaPassword"
            case .gangliaurl: return "GangliaUrl"
            case .gangliauser: return "GangliaUser"
            case .haproxyhealthcheckmethod: return "HaproxyHealthCheckMethod"
            case .haproxyhealthcheckurl: return "HaproxyHealthCheckUrl"
            case .haproxystatspassword: return "HaproxyStatsPassword"
            case .haproxystatsurl: return "HaproxyStatsUrl"
            case .haproxystatsuser: return "HaproxyStatsUser"
            case .javaappserver: return "JavaAppServer"
            case .javaappserverversion: return "JavaAppServerVersion"
            case .jvm: return "Jvm"
            case .jvmoptions: return "JvmOptions"
            case .jvmversion: return "JvmVersion"
            case .managebundler: return "ManageBundler"
            case .memcachedmemory: return "MemcachedMemory"
            case .mysqlrootpassword: return "MysqlRootPassword"
            case .mysqlrootpasswordubiquitous: return "MysqlRootPasswordUbiquitous"
            case .nodejsversion: return "NodejsVersion"
            case .passengerversion: return "PassengerVersion"
            case .railsstack: return "RailsStack"
            case .rubyversion: return "RubyVersion"
            case .rubygemsversion: return "RubygemsVersion"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAttributesKeys(rawValue: rawValue) ?? LayerAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes {
    public enum LayerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsFlowRuby
        case custom
        case dbMaster
        case ecsCluster
        case javaApp
        case lb
        case memcached
        case monitoringMaster
        case nodejsApp
        case phpApp
        case railsApp
        case web
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerType] {
            return [
                .awsFlowRuby,
                .custom,
                .dbMaster,
                .ecsCluster,
                .javaApp,
                .lb,
                .memcached,
                .monitoringMaster,
                .nodejsApp,
                .phpApp,
                .railsApp,
                .web,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsFlowRuby: return "aws-flow-ruby"
            case .custom: return "custom"
            case .dbMaster: return "db-master"
            case .ecsCluster: return "ecs-cluster"
            case .javaApp: return "java-app"
            case .lb: return "lb"
            case .memcached: return "memcached"
            case .monitoringMaster: return "monitoring-master"
            case .nodejsApp: return "nodejs-app"
            case .phpApp: return "php-app"
            case .railsApp: return "rails-app"
            case .web: return "web"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerType(rawValue: rawValue) ?? LayerType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.LifecycleEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shutdown = "Shutdown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shutdown = self.shutdown {
            try encodeContainer.encode(shutdown, forKey: .shutdown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shutdownDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ShutdownEventConfiguration.self, forKey: .shutdown)
        shutdown = shutdownDecoded
    }
}

extension OpsWorksClientTypes {
    /// Specifies the lifecycle event configuration
    public struct LifecycleEventConfiguration: Swift.Equatable {
        /// A ShutdownEventConfiguration object that specifies the Shutdown event configuration.
        public var shutdown: OpsWorksClientTypes.ShutdownEventConfiguration?

        public init(
            shutdown: OpsWorksClientTypes.ShutdownEventConfiguration? = nil
        )
        {
            self.shutdown = shutdown
        }
    }

}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// Do not use. A validation exception occurs if you add a MaxResults parameter to a ListTagsRequest call.
    public var maxResults: Swift.Int?
    /// Do not use. A validation exception occurs if you add a NextToken parameter to a ListTagsRequest call.
    public var nextToken: Swift.String?
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// Contains the response to a ListTags request.
public struct ListTagsOutput: Swift.Equatable {
    /// If a paginated request does not return all of the remaining results, this parameter is set to a token that you can assign to the request object's NextToken parameter to get the next set of results. If the previous paginated request returned all of the remaining results, this parameter is set to null.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that contain tag keys and tag values that are attached to a stack or layer.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.LoadBasedAutoScalingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = self.downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = self.upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a layer's load-based auto scaling configuration.
    public struct LoadBasedAutoScalingConfiguration: Swift.Equatable {
        /// An AutoScalingThresholds object that describes the downscaling configuration, which defines how and when AWS OpsWorks Stacks reduces the number of instances.
        public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
        /// Whether load-based auto scaling is enabled for the layer.
        public var enable: Swift.Bool?
        /// The layer ID.
        public var layerId: Swift.String?
        /// An AutoScalingThresholds object that describes the upscaling configuration, which defines how and when AWS OpsWorks Stacks increases the number of instances.
        public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

        public init(
            downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
            enable: Swift.Bool? = nil,
            layerId: Swift.String? = nil,
            upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
        )
        {
            self.downScaling = downScaling
            self.enable = enable
            self.layerId = layerId
            self.upScaling = upScaling
        }
    }

}

extension OpsWorksClientTypes.OperatingSystem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationManagers = "ConfigurationManagers"
        case id = "Id"
        case name = "Name"
        case reportedName = "ReportedName"
        case reportedVersion = "ReportedVersion"
        case supported = "Supported"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationManagers = configurationManagers {
            var configurationManagersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationManagers)
            for operatingsystemconfigurationmanager0 in configurationManagers {
                try configurationManagersContainer.encode(operatingsystemconfigurationmanager0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reportedName = self.reportedName {
            try encodeContainer.encode(reportedName, forKey: .reportedName)
        }
        if let reportedVersion = self.reportedVersion {
            try encodeContainer.encode(reportedVersion, forKey: .reportedVersion)
        }
        if let supported = self.supported {
            try encodeContainer.encode(supported, forKey: .supported)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let configurationManagersContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.OperatingSystemConfigurationManager?].self, forKey: .configurationManagers)
        var configurationManagersDecoded0:[OpsWorksClientTypes.OperatingSystemConfigurationManager]? = nil
        if let configurationManagersContainer = configurationManagersContainer {
            configurationManagersDecoded0 = [OpsWorksClientTypes.OperatingSystemConfigurationManager]()
            for structure0 in configurationManagersContainer {
                if let structure0 = structure0 {
                    configurationManagersDecoded0?.append(structure0)
                }
            }
        }
        configurationManagers = configurationManagersDecoded0
        let reportedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedName)
        reportedName = reportedNameDecoded
        let reportedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportedVersion)
        reportedVersion = reportedVersionDecoded
        let supportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supported)
        supported = supportedDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes supported operating systems in AWS OpsWorks Stacks.
    public struct OperatingSystem: Swift.Equatable {
        /// Supported configuration manager name and versions for an AWS OpsWorks Stacks operating system.
        public var configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]?
        /// The ID of a supported operating system, such as Amazon Linux 2018.03.
        public var id: Swift.String?
        /// The name of the operating system, such as Amazon Linux 2018.03.
        public var name: Swift.String?
        /// A short name for the operating system manufacturer.
        public var reportedName: Swift.String?
        /// The version of the operating system, including the release and edition, if applicable.
        public var reportedVersion: Swift.String?
        /// Indicates that an operating system is not supported for new instances.
        public var supported: Swift.Bool?
        /// The type of a supported operating system, either Linux or Windows.
        public var type: Swift.String?

        public init(
            configurationManagers: [OpsWorksClientTypes.OperatingSystemConfigurationManager]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reportedName: Swift.String? = nil,
            reportedVersion: Swift.String? = nil,
            supported: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.configurationManagers = configurationManagers
            self.id = id
            self.name = name
            self.reportedName = reportedName
            self.reportedVersion = reportedVersion
            self.supported = supported
            self.type = type
        }
    }

}

extension OpsWorksClientTypes.OperatingSystemConfigurationManager: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes {
    /// A block that contains information about the configuration manager (Chef) and the versions of the configuration manager that are supported for an operating system.
    public struct OperatingSystemConfigurationManager: Swift.Equatable {
        /// The name of the configuration manager, which is Chef.
        public var name: Swift.String?
        /// The versions of the configuration manager that are supported by an operating system.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = self.allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = self.allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = self.level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .level)
        level = levelDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes stack or user permissions.
    public struct Permission: Swift.Equatable {
        /// Whether the user can use SSH.
        public var allowSsh: Swift.Bool?
        /// Whether the user can use sudo.
        public var allowSudo: Swift.Bool?
        /// The Amazon Resource Name (ARN) for an AWS Identity and Access Management (IAM) role. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var iamUserArn: Swift.String?
        /// The user's permission level, which must be the following:
        ///
        /// * deny
        ///
        /// * show
        ///
        /// * deploy
        ///
        /// * manage
        ///
        /// * iam_only
        ///
        ///
        /// For more information on the permissions associated with these levels, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html)
        public var level: Swift.String?
        /// A stack ID.
        public var stackId: Swift.String?

        public init(
            allowSsh: Swift.Bool? = nil,
            allowSudo: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            level: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.allowSsh = allowSsh
            self.allowSudo = allowSudo
            self.iamUserArn = iamUserArn
            self.level = level
            self.stackId = stackId
        }
    }

}

extension OpsWorksClientTypes.RaidArray: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case createdAt = "CreatedAt"
        case device = "Device"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case numberOfDisks = "NumberOfDisks"
        case raidArrayId = "RaidArrayId"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case stackId = "StackId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfDisks = self.numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidArrayId = self.raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let raidLevel = self.raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an instance's RAID array.
    public struct RaidArray: Swift.Equatable {
        /// The array's Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// When the RAID array was created.
        public var createdAt: Swift.String?
        /// The array's Linux device. For example /dev/mdadm0.
        public var device: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The array's mount point.
        public var mountPoint: Swift.String?
        /// The array name.
        public var name: Swift.String?
        /// The number of disks in the array.
        public var numberOfDisks: Swift.Int?
        /// The array ID.
        public var raidArrayId: Swift.String?
        /// The [RAID level](http://en.wikipedia.org/wiki/Standard_RAID_levels).
        public var raidLevel: Swift.Int?
        /// The array's size.
        public var size: Swift.Int?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The volume type, standard or PIOPS.
        public var volumeType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            device: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidArrayId: Swift.String? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            stackId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.createdAt = createdAt
            self.device = device
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.numberOfDisks = numberOfDisks
            self.raidArrayId = raidArrayId
            self.raidLevel = raidLevel
            self.size = size
            self.stackId = stackId
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.RdsDbInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case engine = "Engine"
        case missingOnRds = "MissingOnRds"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case region = "Region"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbPassword = self.dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let missingOnRds = self.missingOnRds {
            try encodeContainer.encode(missingOnRds, forKey: .missingOnRds)
        }
        if let rdsDbInstanceArn = self.rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let missingOnRdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .missingOnRds)
        missingOnRds = missingOnRdsDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an Amazon RDS instance.
    public struct RdsDbInstance: Swift.Equatable {
        /// The instance's address.
        public var address: Swift.String?
        /// The DB instance identifier.
        public var dbInstanceIdentifier: Swift.String?
        /// AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var dbPassword: Swift.String?
        /// The master user name.
        public var dbUser: Swift.String?
        /// The instance's database engine.
        public var engine: Swift.String?
        /// Set to true if AWS OpsWorks Stacks is unable to discover the Amazon RDS instance. AWS OpsWorks Stacks attempts to discover the instance only once. If this value is set to true, you must deregister the instance, and then register it again.
        public var missingOnRds: Swift.Bool?
        /// The instance's ARN.
        public var rdsDbInstanceArn: Swift.String?
        /// The instance's AWS region.
        public var region: Swift.String?
        /// The ID of the stack with which the instance is registered.
        public var stackId: Swift.String?

        public init(
            address: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbPassword: Swift.String? = nil,
            dbUser: Swift.String? = nil,
            engine: Swift.String? = nil,
            missingOnRds: Swift.Bool? = nil,
            rdsDbInstanceArn: Swift.String? = nil,
            region: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.address = address
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbPassword = dbPassword
            self.dbUser = dbUser
            self.engine = engine
            self.missingOnRds = missingOnRds
            self.rdsDbInstanceArn = rdsDbInstanceArn
            self.region = region
            self.stackId = stackId
        }
    }

}

extension RebootInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension RebootInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RebootInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RebootInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension RebootInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension RebootInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RebootInstanceOutput: Swift.Equatable {

    public init() { }
}

enum RebootInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.Recipes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configure = "Configure"
        case deploy = "Deploy"
        case setup = "Setup"
        case shutdown = "Shutdown"
        case undeploy = "Undeploy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configure = configure {
            var configureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configure)
            for string0 in configure {
                try configureContainer.encode(string0)
            }
        }
        if let deploy = deploy {
            var deployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deploy)
            for string0 in deploy {
                try deployContainer.encode(string0)
            }
        }
        if let setup = setup {
            var setupContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setup)
            for string0 in setup {
                try setupContainer.encode(string0)
            }
        }
        if let shutdown = shutdown {
            var shutdownContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shutdown)
            for string0 in shutdown {
                try shutdownContainer.encode(string0)
            }
        }
        if let undeploy = undeploy {
            var undeployContainer = encodeContainer.nestedUnkeyedContainer(forKey: .undeploy)
            for string0 in undeploy {
                try undeployContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let setupContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .setup)
        var setupDecoded0:[Swift.String]? = nil
        if let setupContainer = setupContainer {
            setupDecoded0 = [Swift.String]()
            for string0 in setupContainer {
                if let string0 = string0 {
                    setupDecoded0?.append(string0)
                }
            }
        }
        setup = setupDecoded0
        let configureContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configure)
        var configureDecoded0:[Swift.String]? = nil
        if let configureContainer = configureContainer {
            configureDecoded0 = [Swift.String]()
            for string0 in configureContainer {
                if let string0 = string0 {
                    configureDecoded0?.append(string0)
                }
            }
        }
        configure = configureDecoded0
        let deployContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deploy)
        var deployDecoded0:[Swift.String]? = nil
        if let deployContainer = deployContainer {
            deployDecoded0 = [Swift.String]()
            for string0 in deployContainer {
                if let string0 = string0 {
                    deployDecoded0?.append(string0)
                }
            }
        }
        deploy = deployDecoded0
        let undeployContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .undeploy)
        var undeployDecoded0:[Swift.String]? = nil
        if let undeployContainer = undeployContainer {
            undeployDecoded0 = [Swift.String]()
            for string0 in undeployContainer {
                if let string0 = string0 {
                    undeployDecoded0?.append(string0)
                }
            }
        }
        undeploy = undeployDecoded0
        let shutdownContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .shutdown)
        var shutdownDecoded0:[Swift.String]? = nil
        if let shutdownContainer = shutdownContainer {
            shutdownDecoded0 = [Swift.String]()
            for string0 in shutdownContainer {
                if let string0 = string0 {
                    shutdownDecoded0?.append(string0)
                }
            }
        }
        shutdown = shutdownDecoded0
    }
}

extension OpsWorksClientTypes {
    /// AWS OpsWorks Stacks supports five lifecycle events: setup, configuration, deploy, undeploy, and shutdown. For each layer, AWS OpsWorks Stacks runs a set of standard recipes for each event. In addition, you can provide custom recipes for any or all layers and events. AWS OpsWorks Stacks runs custom event recipes after the standard recipes. LayerCustomRecipes specifies the custom recipes for a particular layer to be run in response to each of the five events. To specify a recipe, use the cookbook's directory name in the repository followed by two colons and the recipe name, which is the recipe's file name without the .rb extension. For example: phpapp2::dbsetup specifies the dbsetup.rb recipe in the repository's phpapp2 folder.
    public struct Recipes: Swift.Equatable {
        /// An array of custom recipe names to be run following a configure event.
        public var configure: [Swift.String]?
        /// An array of custom recipe names to be run following a deploy event.
        public var deploy: [Swift.String]?
        /// An array of custom recipe names to be run following a setup event.
        public var setup: [Swift.String]?
        /// An array of custom recipe names to be run following a shutdown event.
        public var shutdown: [Swift.String]?
        /// An array of custom recipe names to be run following a undeploy event.
        public var undeploy: [Swift.String]?

        public init(
            configure: [Swift.String]? = nil,
            deploy: [Swift.String]? = nil,
            setup: [Swift.String]? = nil,
            shutdown: [Swift.String]? = nil,
            undeploy: [Swift.String]? = nil
        )
        {
            self.configure = configure
            self.deploy = deploy
            self.setup = setup
            self.shutdown = shutdown
            self.undeploy = undeploy
        }
    }

}

extension RegisterEcsClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecsClusterArn = self.ecsClusterArn {
            try encodeContainer.encode(ecsClusterArn, forKey: .ecsClusterArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension RegisterEcsClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterEcsClusterInput: Swift.Equatable {
    /// The cluster's ARN.
    /// This member is required.
    public var ecsClusterArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
        self.stackId = stackId
    }
}

struct RegisterEcsClusterInputBody: Swift.Equatable {
    let ecsClusterArn: Swift.String?
    let stackId: Swift.String?
}

extension RegisterEcsClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterEcsClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterEcsClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.ecsClusterArn = output.ecsClusterArn
        } else {
            self.ecsClusterArn = nil
        }
    }
}

/// Contains the response to a RegisterEcsCluster request.
public struct RegisterEcsClusterOutput: Swift.Equatable {
    /// The cluster's ARN.
    public var ecsClusterArn: Swift.String?

    public init(
        ecsClusterArn: Swift.String? = nil
    )
    {
        self.ecsClusterArn = ecsClusterArn
    }
}

struct RegisterEcsClusterOutputBody: Swift.Equatable {
    let ecsClusterArn: Swift.String?
}

extension RegisterEcsClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecsClusterArn = "EcsClusterArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecsClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecsClusterArn)
        ecsClusterArn = ecsClusterArnDecoded
    }
}

enum RegisterEcsClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterElasticIpInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension RegisterElasticIpInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterElasticIpInput: Swift.Equatable {
    /// The Elastic IP address.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.stackId = stackId
    }
}

struct RegisterElasticIpInputBody: Swift.Equatable {
    let elasticIp: Swift.String?
    let stackId: Swift.String?
}

extension RegisterElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterElasticIpOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterElasticIpOutputBody = try responseDecoder.decode(responseBody: data)
            self.elasticIp = output.elasticIp
        } else {
            self.elasticIp = nil
        }
    }
}

/// Contains the response to a RegisterElasticIp request.
public struct RegisterElasticIpOutput: Swift.Equatable {
    /// The Elastic IP address.
    public var elasticIp: Swift.String?

    public init(
        elasticIp: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
    }
}

struct RegisterElasticIpOutputBody: Swift.Equatable {
    let elasticIp: Swift.String?
}

extension RegisterElasticIpOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
    }
}

enum RegisterElasticIpOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let instanceIdentity = self.instanceIdentity {
            try encodeContainer.encode(instanceIdentity, forKey: .instanceIdentity)
        }
        if let privateIp = self.privateIp {
            try encodeContainer.encode(privateIp, forKey: .privateIp)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let rsaPublicKey = self.rsaPublicKey {
            try encodeContainer.encode(rsaPublicKey, forKey: .rsaPublicKey)
        }
        if let rsaPublicKeyFingerprint = self.rsaPublicKeyFingerprint {
            try encodeContainer.encode(rsaPublicKeyFingerprint, forKey: .rsaPublicKeyFingerprint)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension RegisterInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterInstanceInput: Swift.Equatable {
    /// The instance's hostname.
    public var hostname: Swift.String?
    /// An InstanceIdentity object that contains the instance's identity.
    public var instanceIdentity: OpsWorksClientTypes.InstanceIdentity?
    /// The instance's private IP address.
    public var privateIp: Swift.String?
    /// The instance's public IP address.
    public var publicIp: Swift.String?
    /// The instances public RSA key. This key is used to encrypt communication between the instance and the service.
    public var rsaPublicKey: Swift.String?
    /// The instances public RSA key fingerprint.
    public var rsaPublicKeyFingerprint: Swift.String?
    /// The ID of the stack that the instance is to be registered with.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        hostname: Swift.String? = nil,
        instanceIdentity: OpsWorksClientTypes.InstanceIdentity? = nil,
        privateIp: Swift.String? = nil,
        publicIp: Swift.String? = nil,
        rsaPublicKey: Swift.String? = nil,
        rsaPublicKeyFingerprint: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.hostname = hostname
        self.instanceIdentity = instanceIdentity
        self.privateIp = privateIp
        self.publicIp = publicIp
        self.rsaPublicKey = rsaPublicKey
        self.rsaPublicKeyFingerprint = rsaPublicKeyFingerprint
        self.stackId = stackId
    }
}

struct RegisterInstanceInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let hostname: Swift.String?
    let publicIp: Swift.String?
    let privateIp: Swift.String?
    let rsaPublicKey: Swift.String?
    let rsaPublicKeyFingerprint: Swift.String?
    let instanceIdentity: OpsWorksClientTypes.InstanceIdentity?
}

extension RegisterInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case instanceIdentity = "InstanceIdentity"
        case privateIp = "PrivateIp"
        case publicIp = "PublicIp"
        case rsaPublicKey = "RsaPublicKey"
        case rsaPublicKeyFingerprint = "RsaPublicKeyFingerprint"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let privateIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIp)
        privateIp = privateIpDecoded
        let rsaPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rsaPublicKey)
        rsaPublicKey = rsaPublicKeyDecoded
        let rsaPublicKeyFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rsaPublicKeyFingerprint)
        rsaPublicKeyFingerprint = rsaPublicKeyFingerprintDecoded
        let instanceIdentityDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.InstanceIdentity.self, forKey: .instanceIdentity)
        instanceIdentity = instanceIdentityDecoded
    }
}

extension RegisterInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceId = output.instanceId
        } else {
            self.instanceId = nil
        }
    }
}

/// Contains the response to a RegisterInstanceResult request.
public struct RegisterInstanceOutput: Swift.Equatable {
    /// The registered instance's AWS OpsWorks Stacks ID.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct RegisterInstanceOutputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension RegisterInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

enum RegisterInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterRdsDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = self.dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = self.rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension RegisterRdsDbInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterRdsDbInstanceInput: Swift.Equatable {
    /// The database password.
    /// This member is required.
    public var dbPassword: Swift.String?
    /// The database's master user name.
    /// This member is required.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
        self.stackId = stackId
    }
}

struct RegisterRdsDbInstanceInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let rdsDbInstanceArn: Swift.String?
    let dbUser: Swift.String?
    let dbPassword: Swift.String?
}

extension RegisterRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension RegisterRdsDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterRdsDbInstanceOutput: Swift.Equatable {

    public init() { }
}

enum RegisterRdsDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2VolumeId = self.ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension RegisterVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterVolumeInput: Swift.Equatable {
    /// The Amazon EBS volume ID.
    public var ec2VolumeId: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        ec2VolumeId: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.ec2VolumeId = ec2VolumeId
        self.stackId = stackId
    }
}

struct RegisterVolumeInputBody: Swift.Equatable {
    let ec2VolumeId: Swift.String?
    let stackId: Swift.String?
}

extension RegisterVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2VolumeId = "Ec2VolumeId"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension RegisterVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterVolumeOutputBody = try responseDecoder.decode(responseBody: data)
            self.volumeId = output.volumeId
        } else {
            self.volumeId = nil
        }
    }
}

/// Contains the response to a RegisterVolume request.
public struct RegisterVolumeOutput: Swift.Equatable {
    /// The volume ID.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct RegisterVolumeOutputBody: Swift.Equatable {
    let volumeId: Swift.String?
}

extension RegisterVolumeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

enum RegisterVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.ReportedOs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case family = "Family"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes {
    /// A registered instance's reported operating system.
    public struct ReportedOs: Swift.Equatable {
        /// The operating system family.
        public var family: Swift.String?
        /// The operating system name.
        public var name: Swift.String?
        /// The operating system version.
        public var version: Swift.String?

        public init(
            family: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.family = family
            self.name = name
            self.version = version
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsWorksClientTypes {
    public enum RootDeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case instanceStore
        case sdkUnknown(Swift.String)

        public static var allCases: [RootDeviceType] {
            return [
                .ebs,
                .instanceStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "ebs"
            case .instanceStore: return "instance-store"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RootDeviceType(rawValue: rawValue) ?? RootDeviceType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.SelfUserProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = self.sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a user's SSH information.
    public struct SelfUserProfile: Swift.Equatable {
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init(
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }

}

extension OpsWorksClientTypes.ServiceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case instanceId = "InstanceId"
        case message = "Message"
        case serviceErrorId = "ServiceErrorId"
        case stackId = "StackId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serviceErrorId = self.serviceErrorId {
            try encodeContainer.encode(serviceErrorId, forKey: .serviceErrorId)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceErrorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceErrorId)
        serviceErrorId = serviceErrorIdDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an AWS OpsWorks Stacks service error.
    public struct ServiceError: Swift.Equatable {
        /// When the error occurred.
        public var createdAt: Swift.String?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// A message that describes the error.
        public var message: Swift.String?
        /// The error ID.
        public var serviceErrorId: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// The error type.
        public var type: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            message: Swift.String? = nil,
            serviceErrorId: Swift.String? = nil,
            stackId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.instanceId = instanceId
            self.message = message
            self.serviceErrorId = serviceErrorId
            self.stackId = stackId
            self.type = type
        }
    }

}

extension SetLoadBasedAutoScalingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downScaling = self.downScaling {
            try encodeContainer.encode(downScaling, forKey: .downScaling)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let upScaling = self.upScaling {
            try encodeContainer.encode(upScaling, forKey: .upScaling)
        }
    }
}

extension SetLoadBasedAutoScalingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetLoadBasedAutoScalingInput: Swift.Equatable {
    /// An AutoScalingThresholds object with the downscaling threshold configuration. If the load falls below these thresholds for a specified amount of time, AWS OpsWorks Stacks stops a specified number of instances.
    public var downScaling: OpsWorksClientTypes.AutoScalingThresholds?
    /// Enables load-based auto scaling for the layer.
    public var enable: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    /// An AutoScalingThresholds object with the upscaling threshold configuration. If the load exceeds these thresholds for a specified amount of time, AWS OpsWorks Stacks starts a specified number of instances.
    public var upScaling: OpsWorksClientTypes.AutoScalingThresholds?

    public init(
        downScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil,
        enable: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        upScaling: OpsWorksClientTypes.AutoScalingThresholds? = nil
    )
    {
        self.downScaling = downScaling
        self.enable = enable
        self.layerId = layerId
        self.upScaling = upScaling
    }
}

struct SetLoadBasedAutoScalingInputBody: Swift.Equatable {
    let layerId: Swift.String?
    let enable: Swift.Bool?
    let upScaling: OpsWorksClientTypes.AutoScalingThresholds?
    let downScaling: OpsWorksClientTypes.AutoScalingThresholds?
}

extension SetLoadBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downScaling = "DownScaling"
        case enable = "Enable"
        case layerId = "LayerId"
        case upScaling = "UpScaling"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let upScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .upScaling)
        upScaling = upScalingDecoded
        let downScalingDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingThresholds.self, forKey: .downScaling)
        downScaling = downScalingDecoded
    }
}

extension SetLoadBasedAutoScalingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetLoadBasedAutoScalingOutput: Swift.Equatable {

    public init() { }
}

enum SetLoadBasedAutoScalingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSsh = self.allowSsh {
            try encodeContainer.encode(allowSsh, forKey: .allowSsh)
        }
        if let allowSudo = self.allowSudo {
            try encodeContainer.encode(allowSudo, forKey: .allowSudo)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let level = self.level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension SetPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetPermissionInput: Swift.Equatable {
    /// The user is allowed to use SSH to communicate with the instance.
    public var allowSsh: Swift.Bool?
    /// The user is allowed to use sudo to elevate privileges.
    public var allowSudo: Swift.Bool?
    /// The user's IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's permission level, which must be set to one of the following strings. You cannot set your own permissions level.
    ///
    /// * deny
    ///
    /// * show
    ///
    /// * deploy
    ///
    /// * manage
    ///
    /// * iam_only
    ///
    ///
    /// For more information about the permissions associated with these levels, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/opsworks-security-users.html).
    public var level: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        allowSsh: Swift.Bool? = nil,
        allowSudo: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        level: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.allowSsh = allowSsh
        self.allowSudo = allowSudo
        self.iamUserArn = iamUserArn
        self.level = level
        self.stackId = stackId
    }
}

struct SetPermissionInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let iamUserArn: Swift.String?
    let allowSsh: Swift.Bool?
    let allowSudo: Swift.Bool?
    let level: Swift.String?
}

extension SetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSsh = "AllowSsh"
        case allowSudo = "AllowSudo"
        case iamUserArn = "IamUserArn"
        case level = "Level"
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let allowSshDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSsh)
        allowSsh = allowSshDecoded
        let allowSudoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSudo)
        allowSudo = allowSudoDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .level)
        level = levelDecoded
    }
}

extension SetPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetPermissionOutput: Swift.Equatable {

    public init() { }
}

enum SetPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetTimeBasedAutoScalingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = self.autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension SetTimeBasedAutoScalingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetTimeBasedAutoScalingInput: Swift.Equatable {
    /// An AutoScalingSchedule with the instance schedule.
    public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.autoScalingSchedule = autoScalingSchedule
        self.instanceId = instanceId
    }
}

struct SetTimeBasedAutoScalingInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
}

extension SetTimeBasedAutoScalingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension SetTimeBasedAutoScalingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SetTimeBasedAutoScalingOutput: Swift.Equatable {

    public init() { }
}

enum SetTimeBasedAutoScalingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.ShutdownEventConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delayUntilElbConnectionsDrained = "DelayUntilElbConnectionsDrained"
        case executionTimeout = "ExecutionTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delayUntilElbConnectionsDrained = self.delayUntilElbConnectionsDrained {
            try encodeContainer.encode(delayUntilElbConnectionsDrained, forKey: .delayUntilElbConnectionsDrained)
        }
        if let executionTimeout = self.executionTimeout {
            try encodeContainer.encode(executionTimeout, forKey: .executionTimeout)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeout)
        executionTimeout = executionTimeoutDecoded
        let delayUntilElbConnectionsDrainedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .delayUntilElbConnectionsDrained)
        delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrainedDecoded
    }
}

extension OpsWorksClientTypes {
    /// The Shutdown event configuration.
    public struct ShutdownEventConfiguration: Swift.Equatable {
        /// Whether to enable Elastic Load Balancing connection draining. For more information, see [Connection Draining](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#conn-drain)
        public var delayUntilElbConnectionsDrained: Swift.Bool?
        /// The time, in seconds, that AWS OpsWorks Stacks will wait after triggering a Shutdown event before shutting down an instance.
        public var executionTimeout: Swift.Int?

        public init(
            delayUntilElbConnectionsDrained: Swift.Bool? = nil,
            executionTimeout: Swift.Int? = nil
        )
        {
            self.delayUntilElbConnectionsDrained = delayUntilElbConnectionsDrained
            self.executionTimeout = executionTimeout
        }
    }

}

extension OpsWorksClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case revision = "Revision"
        case sshKey = "SshKey"
        case type = "Type"
        case url = "Url"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sshKey = self.sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SourceType.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension OpsWorksClientTypes {
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Creating Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Custom Recipes and Cookbooks](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public struct Source: Swift.Equatable {
        /// When included in a request, the parameter depends on the repository type.
        ///
        /// * For Amazon S3 bundles, set Password to the appropriate IAM secret access key.
        ///
        /// * For HTTP bundles and Subversion repositories, set Password to the password.
        ///
        ///
        /// For more information on how to safely handle IAM credentials, see [https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html). In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var password: Swift.String?
        /// The application's version. AWS OpsWorks Stacks enables you to easily deploy new versions of an application. One of the simplest approaches is to have branches or revisions in your repository that represent different versions that can potentially be deployed.
        public var revision: Swift.String?
        /// In requests, the repository's SSH key. In responses, AWS OpsWorks Stacks returns *****FILTERED***** instead of the actual value.
        public var sshKey: Swift.String?
        /// The repository type.
        public var type: OpsWorksClientTypes.SourceType?
        /// The source URL. The following is an example of an Amazon S3 source URL: https://s3.amazonaws.com/opsworks-demo-bucket/opsworks_cookbook_demo.tar.gz.
        public var url: Swift.String?
        /// This parameter depends on the repository type.
        ///
        /// * For Amazon S3 bundles, set Username to the appropriate IAM access key ID.
        ///
        /// * For HTTP bundles, Git repositories, and Subversion repositories, set Username to the user name.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            revision: Swift.String? = nil,
            sshKey: Swift.String? = nil,
            type: OpsWorksClientTypes.SourceType? = nil,
            url: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.revision = revision
            self.sshKey = sshKey
            self.type = type
            self.url = url
            self.username = username
        }
    }

}

extension OpsWorksClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case git
        case s3
        case svn
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .archive,
                .git,
                .s3,
                .svn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "archive"
            case .git: return "git"
            case .s3: return "s3"
            case .svn: return "svn"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.SslConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case chain = "Chain"
        case privateKey = "PrivateKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let chain = self.chain {
            try encodeContainer.encode(chain, forKey: .chain)
        }
        if let privateKey = self.privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let chainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .chain)
        chain = chainDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an app's SSL configuration.
    public struct SslConfiguration: Swift.Equatable {
        /// The contents of the certificate's domain.crt file.
        /// This member is required.
        public var certificate: Swift.String?
        /// Optional. Can be used to specify an intermediate certificate authority key or client authentication.
        public var chain: Swift.String?
        /// The private key; the contents of the certificate's domain.kex file.
        /// This member is required.
        public var privateKey: Swift.String?

        public init(
            certificate: Swift.String? = nil,
            chain: Swift.String? = nil,
            privateKey: Swift.String? = nil
        )
        {
            self.certificate = certificate
            self.chain = chain
            self.privateKey = privateKey
        }
    }

}

extension OpsWorksClientTypes.Stack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case arn = "Arn"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case createdAt = "CreatedAt"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case region = "Region"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackAttributes0) in attributes {
                try attributesContainer.encode(stackAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = self.chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let customCookbooksSource = self.customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = self.defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = self.defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = self.defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = self.defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = self.defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = self.defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = self.hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = self.useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = self.useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a stack.
    public struct Stack: Swift.Equatable {
        /// The agent version. This parameter is set to LATEST for auto-update. or a version number for a fixed agent version.
        public var agentVersion: Swift.String?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// The stack's attributes.
        public var attributes: [Swift.String:Swift.String]?
        /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
        public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
        /// The configuration manager.
        public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
        /// The date when the stack was created.
        public var createdAt: Swift.String?
        /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
        public var customCookbooksSource: OpsWorksClientTypes.Source?
        /// A JSON object that contains user-defined attributes to be added to the stack configuration and deployment attributes. You can use custom JSON to override the corresponding default stack configuration attribute values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information on custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
        public var customJson: Swift.String?
        /// The stack's default Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var defaultAvailabilityZone: Swift.String?
        /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
        public var defaultInstanceProfileArn: Swift.String?
        /// The stack's default operating system.
        public var defaultOs: Swift.String?
        /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
        public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
        /// A default Amazon EC2 key pair for the stack's instances. You can override this value when you create or update an instance.
        public var defaultSshKeyName: Swift.String?
        /// The default subnet ID; applicable only if the stack is running in a VPC.
        public var defaultSubnetId: Swift.String?
        /// The stack host name theme, with spaces replaced by underscores.
        public var hostnameTheme: Swift.String?
        /// The stack name.
        public var name: Swift.String?
        /// The stack AWS region, such as "ap-northeast-2". For more information about AWS regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?
        /// The stack AWS Identity and Access Management (IAM) role.
        public var serviceRoleArn: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?
        /// Whether the stack uses custom cookbooks.
        public var useCustomCookbooks: Swift.Bool?
        /// Whether the stack automatically associates the AWS OpsWorks Stacks built-in security groups with the stack's layers.
        public var useOpsworksSecurityGroups: Swift.Bool?
        /// The VPC ID; applicable only if the stack is running in a VPC.
        public var vpcId: Swift.String?

        public init(
            agentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
            configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
            createdAt: Swift.String? = nil,
            customCookbooksSource: OpsWorksClientTypes.Source? = nil,
            customJson: Swift.String? = nil,
            defaultAvailabilityZone: Swift.String? = nil,
            defaultInstanceProfileArn: Swift.String? = nil,
            defaultOs: Swift.String? = nil,
            defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
            defaultSshKeyName: Swift.String? = nil,
            defaultSubnetId: Swift.String? = nil,
            hostnameTheme: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            stackId: Swift.String? = nil,
            useCustomCookbooks: Swift.Bool? = nil,
            useOpsworksSecurityGroups: Swift.Bool? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.arn = arn
            self.attributes = attributes
            self.chefConfiguration = chefConfiguration
            self.configurationManager = configurationManager
            self.createdAt = createdAt
            self.customCookbooksSource = customCookbooksSource
            self.customJson = customJson
            self.defaultAvailabilityZone = defaultAvailabilityZone
            self.defaultInstanceProfileArn = defaultInstanceProfileArn
            self.defaultOs = defaultOs
            self.defaultRootDeviceType = defaultRootDeviceType
            self.defaultSshKeyName = defaultSshKeyName
            self.defaultSubnetId = defaultSubnetId
            self.hostnameTheme = hostnameTheme
            self.name = name
            self.region = region
            self.serviceRoleArn = serviceRoleArn
            self.stackId = stackId
            self.useCustomCookbooks = useCustomCookbooks
            self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
            self.vpcId = vpcId
        }
    }

}

extension OpsWorksClientTypes {
    public enum StackAttributesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case color
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttributesKeys] {
            return [
                .color,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .color: return "Color"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackAttributesKeys(rawValue: rawValue) ?? StackAttributesKeys.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.StackConfigurationManager: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes the configuration manager.
    public struct StackConfigurationManager: Swift.Equatable {
        /// The name. This parameter must be set to "Chef".
        public var name: Swift.String?
        /// The Chef version. This parameter must be set to 12, 11.10, or 11.4 for Linux stacks, and to 12.2 for Windows stacks. The default value for Linux stacks is 11.4.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension OpsWorksClientTypes.StackSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appsCount = "AppsCount"
        case arn = "Arn"
        case instancesCount = "InstancesCount"
        case layersCount = "LayersCount"
        case name = "Name"
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appsCount = self.appsCount {
            try encodeContainer.encode(appsCount, forKey: .appsCount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let instancesCount = self.instancesCount {
            try encodeContainer.encode(instancesCount, forKey: .instancesCount)
        }
        if let layersCount = self.layersCount {
            try encodeContainer.encode(layersCount, forKey: .layersCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let layersCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layersCount)
        layersCount = layersCountDecoded
        let appsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appsCount)
        appsCount = appsCountDecoded
        let instancesCountDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.InstancesCount.self, forKey: .instancesCount)
        instancesCount = instancesCountDecoded
    }
}

extension OpsWorksClientTypes {
    /// Summarizes the number of layers, instances, and apps in a stack.
    public struct StackSummary: Swift.Equatable {
        /// The number of apps.
        public var appsCount: Swift.Int?
        /// The stack's ARN.
        public var arn: Swift.String?
        /// An InstancesCount object with the number of instances in each status.
        public var instancesCount: OpsWorksClientTypes.InstancesCount?
        /// The number of layers.
        public var layersCount: Swift.Int?
        /// The stack name.
        public var name: Swift.String?
        /// The stack ID.
        public var stackId: Swift.String?

        public init(
            appsCount: Swift.Int? = nil,
            arn: Swift.String? = nil,
            instancesCount: OpsWorksClientTypes.InstancesCount? = nil,
            layersCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            stackId: Swift.String? = nil
        )
        {
            self.appsCount = appsCount
            self.arn = arn
            self.instancesCount = instancesCount
            self.layersCount = layersCount
            self.name = name
            self.stackId = stackId
        }
    }

}

extension StartInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StartInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct StartInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension StartInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension StartInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartInstanceOutput: Swift.Equatable {

    public init() { }
}

enum StartInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension StartStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StartStackInputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension StartStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StartStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartStackOutput: Swift.Equatable {

    public init() { }
}

enum StartStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension StopInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopInstanceInput: Swift.Equatable {
    /// Specifies whether to force an instance to stop. If the instance's root device type is ebs, or EBS-backed, adding the Force parameter to the StopInstances API call disassociates the AWS OpsWorks Stacks instance from EC2, and forces deletion of only the OpsWorks Stacks instance. You must also delete the formerly-associated instance in EC2 after troubleshooting and replacing the AWS OpsWorks Stacks instance with a new one.
    public var force: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.force = force
        self.instanceId = instanceId
    }
}

struct StopInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let force: Swift.Bool?
}

extension StopInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension StopInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopInstanceOutput: Swift.Equatable {

    public init() { }
}

enum StopInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
    }
}

extension StopStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopStackInput: Swift.Equatable {
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?

    public init(
        stackId: Swift.String? = nil
    )
    {
        self.stackId = stackId
    }
}

struct StopStackInputBody: Swift.Equatable {
    let stackId: Swift.String?
}

extension StopStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackId = "StackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension StopStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopStackOutput: Swift.Equatable {

    public init() { }
}

enum StopStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a stack or layer.
    ///
    /// * The key cannot be empty.
    ///
    /// * The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: + - = . _ : /
    ///
    /// * Leading and trailing white spaces are trimmed from both the key and value.
    ///
    /// * A maximum of 40 tags is allowed for any resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.TemporaryCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
        case password = "Password"
        case username = "Username"
        case validForInMinutes = "ValidForInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
        if let validForInMinutes = self.validForInMinutes {
            try encodeContainer.encode(validForInMinutes, forKey: .validForInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let validForInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validForInMinutes)
        validForInMinutes = validForInMinutesDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension OpsWorksClientTypes {
    /// Contains the data needed by RDP clients such as the Microsoft Remote Desktop Connection to log in to the instance.
    public struct TemporaryCredential: Swift.Equatable {
        /// The instance's AWS OpsWorks Stacks ID.
        public var instanceId: Swift.String?
        /// The password.
        public var password: Swift.String?
        /// The user name.
        public var username: Swift.String?
        /// The length of time (in minutes) that the grant is valid. When the grant expires, at the end of this period, the user will no longer be able to use the credentials to log in. If they are logged in at the time, they will be automatically logged out.
        public var validForInMinutes: Swift.Int?

        public init(
            instanceId: Swift.String? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil,
            validForInMinutes: Swift.Int? = nil
        )
        {
            self.instanceId = instanceId
            self.password = password
            self.username = username
            self.validForInMinutes = validForInMinutes
        }
    }

}

extension OpsWorksClientTypes.TimeBasedAutoScalingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSchedule = "AutoScalingSchedule"
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSchedule = self.autoScalingSchedule {
            try encodeContainer.encode(autoScalingSchedule, forKey: .autoScalingSchedule)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let autoScalingScheduleDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.WeeklyAutoScalingSchedule.self, forKey: .autoScalingSchedule)
        autoScalingSchedule = autoScalingScheduleDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an instance's time-based auto scaling configuration.
    public struct TimeBasedAutoScalingConfiguration: Swift.Equatable {
        /// A WeeklyAutoScalingSchedule object with the instance schedule.
        public var autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule?
        /// The instance ID.
        public var instanceId: Swift.String?

        public init(
            autoScalingSchedule: OpsWorksClientTypes.WeeklyAutoScalingSchedule? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.autoScalingSchedule = autoScalingSchedule
            self.instanceId = instanceId
        }
    }

}

extension UnassignInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }
}

extension UnassignInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UnassignInstanceInput: Swift.Equatable {
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

struct UnassignInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
}

extension UnassignInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension UnassignInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnassignInstanceOutput: Swift.Equatable {

    public init() { }
}

enum UnassignInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnassignVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

extension UnassignVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UnassignVolumeInput: Swift.Equatable {
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    )
    {
        self.volumeId = volumeId
    }
}

struct UnassignVolumeInputBody: Swift.Equatable {
    let volumeId: Swift.String?
}

extension UnassignVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeId = "VolumeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension UnassignVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnassignVolumeOutput: Swift.Equatable {

    public init() { }
}

enum UnassignVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The stack or layer's Amazon Resource Number (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys of tags to be removed from a stack or layer.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appSource = self.appSource {
            try encodeContainer.encode(appSource, forKey: .appSource)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, appAttributes0) in attributes {
                try attributesContainer.encode(appAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for string0 in domains {
                try domainsContainer.encode(string0)
            }
        }
        if let enableSsl = self.enableSsl {
            try encodeContainer.encode(enableSsl, forKey: .enableSsl)
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for environmentvariable0 in environment {
                try environmentContainer.encode(environmentvariable0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sslConfiguration = self.sslConfiguration {
            try encodeContainer.encode(sslConfiguration, forKey: .sslConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAppInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public var appId: Swift.String?
    /// A Source object that specifies the app repository.
    public var appSource: OpsWorksClientTypes.Source?
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// The app's data sources.
    public var dataSources: [OpsWorksClientTypes.DataSource]?
    /// A description of the app.
    public var description: Swift.String?
    /// The app's virtual host settings, with multiple domains separated by commas. For example: 'www.example.com, example.com'
    public var domains: [Swift.String]?
    /// Whether SSL is enabled for the app.
    public var enableSsl: Swift.Bool?
    /// An array of EnvironmentVariable objects that specify environment variables to be associated with the app. After you deploy the app, these variables are defined on the associated app server instances.For more information, see [ Environment Variables](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-environment). There is no specific limit on the number of environment variables. However, the size of the associated data structure - which includes the variables' names, values, and protected flag values - cannot exceed 20 KB. This limit should accommodate most if not all use cases. Exceeding it will cause an exception with the message, "Environment: is too large (maximum is 20 KB)." If you have specified one or more environment variables, you cannot modify the stack's Chef version.
    public var environment: [OpsWorksClientTypes.EnvironmentVariable]?
    /// The app name.
    public var name: Swift.String?
    /// An SslConfiguration object with the SSL configuration.
    public var sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    /// The app type.
    public var type: OpsWorksClientTypes.AppType?

    public init(
        appId: Swift.String? = nil,
        appSource: OpsWorksClientTypes.Source? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        dataSources: [OpsWorksClientTypes.DataSource]? = nil,
        description: Swift.String? = nil,
        domains: [Swift.String]? = nil,
        enableSsl: Swift.Bool? = nil,
        environment: [OpsWorksClientTypes.EnvironmentVariable]? = nil,
        name: Swift.String? = nil,
        sslConfiguration: OpsWorksClientTypes.SslConfiguration? = nil,
        type: OpsWorksClientTypes.AppType? = nil
    )
    {
        self.appId = appId
        self.appSource = appSource
        self.attributes = attributes
        self.dataSources = dataSources
        self.description = description
        self.domains = domains
        self.enableSsl = enableSsl
        self.environment = environment
        self.name = name
        self.sslConfiguration = sslConfiguration
        self.type = type
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    let appId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let dataSources: [OpsWorksClientTypes.DataSource]?
    let type: OpsWorksClientTypes.AppType?
    let appSource: OpsWorksClientTypes.Source?
    let domains: [Swift.String]?
    let enableSsl: Swift.Bool?
    let sslConfiguration: OpsWorksClientTypes.SslConfiguration?
    let attributes: [Swift.String:Swift.String]?
    let environment: [OpsWorksClientTypes.EnvironmentVariable]?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "AppId"
        case appSource = "AppSource"
        case attributes = "Attributes"
        case dataSources = "DataSources"
        case description = "Description"
        case domains = "Domains"
        case enableSsl = "EnableSsl"
        case environment = "Environment"
        case name = "Name"
        case sslConfiguration = "SslConfiguration"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourcesContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[OpsWorksClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [OpsWorksClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AppType.self, forKey: .type)
        type = typeDecoded
        let appSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .appSource)
        appSource = appSourceDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
        let enableSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSsl)
        enableSsl = enableSslDecoded
        let sslConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.SslConfiguration.self, forKey: .sslConfiguration)
        sslConfiguration = sslConfigurationDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.EnvironmentVariable?].self, forKey: .environment)
        var environmentDecoded0:[OpsWorksClientTypes.EnvironmentVariable]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [OpsWorksClientTypes.EnvironmentVariable]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
    }
}

extension UpdateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAppOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateElasticIpInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateElasticIpInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateElasticIpInput: Swift.Equatable {
    /// The IP address for which you want to update the name.
    /// This member is required.
    public var elasticIp: Swift.String?
    /// The new name.
    public var name: Swift.String?

    public init(
        elasticIp: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.elasticIp = elasticIp
        self.name = name
    }
}

struct UpdateElasticIpInputBody: Swift.Equatable {
    let elasticIp: Swift.String?
    let name: Swift.String?
}

extension UpdateElasticIpInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateElasticIpOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateElasticIpOutput: Swift.Equatable {

    public init() { }
}

enum UpdateElasticIpOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture.rawValue, forKey: .architecture)
        }
        if let autoScalingType = self.autoScalingType {
            try encodeContainer.encode(autoScalingType.rawValue, forKey: .autoScalingType)
        }
        if let ebsOptimized = self.ebsOptimized {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let layerIds = layerIds {
            var layerIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerIds)
            for string0 in layerIds {
                try layerIdsContainer.encode(string0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if let sshKeyName = self.sshKeyName {
            try encodeContainer.encode(sshKeyName, forKey: .sshKeyName)
        }
    }
}

extension UpdateInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    /// * INHERIT - Use the stack's default agent version setting.
    ///
    /// * version_number - Use the specified agent version. This value overrides the stack's default setting. To update the agent version, you must edit the instance configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the instance.
    ///
    ///
    /// The default setting is INHERIT. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2.
    public var agentVersion: Swift.String?
    /// The ID of the AMI that was used to create the instance. The value of this parameter must be the same AMI ID that the instance is already using. You cannot apply a new AMI to an instance by running UpdateInstance. UpdateInstance does not work on instances that are using custom AMIs.
    public var amiId: Swift.String?
    /// The instance architecture. Instance types do not necessarily support both architectures. For a list of the architectures that are supported by the different instance types, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).
    public var architecture: OpsWorksClientTypes.Architecture?
    /// For load-based or time-based instances, the type. Windows stacks can use only time-based instances.
    public var autoScalingType: OpsWorksClientTypes.AutoScalingType?
    /// This property cannot be updated.
    public var ebsOptimized: Swift.Bool?
    /// The instance host name.
    public var hostname: Swift.String?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or by manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The instance ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The instance type, such as t2.micro. For a list of supported instance types, open the stack in the console, choose Instances, and choose + Instance. The Size list contains the currently supported types. For more information, see [Instance Families and Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html). The parameter values that you use to specify the various types are in the API Name column of the Available Instance Types table.
    public var instanceType: Swift.String?
    /// The instance's layer IDs.
    public var layerIds: [Swift.String]?
    /// The instance's operating system, which must be set to one of the following. You cannot update an instance that is using a custom AMI.
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    ///
    /// For more information about supported operating systems, see [AWS OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). The default option is the current Amazon Linux version. If you set this parameter to Custom, you must use the AmiId parameter to specify the custom AMI that you want to use. For more information about supported operating systems, see [Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html). For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html). You can specify a different Linux operating system for the updated stack, but you cannot change from Linux to Windows or Windows to Linux.
    public var os: Swift.String?
    /// The instance's Amazon EC2 key name.
    public var sshKeyName: Swift.String?

    public init(
        agentVersion: Swift.String? = nil,
        amiId: Swift.String? = nil,
        architecture: OpsWorksClientTypes.Architecture? = nil,
        autoScalingType: OpsWorksClientTypes.AutoScalingType? = nil,
        ebsOptimized: Swift.Bool? = nil,
        hostname: Swift.String? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        instanceId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        layerIds: [Swift.String]? = nil,
        os: Swift.String? = nil,
        sshKeyName: Swift.String? = nil
    )
    {
        self.agentVersion = agentVersion
        self.amiId = amiId
        self.architecture = architecture
        self.autoScalingType = autoScalingType
        self.ebsOptimized = ebsOptimized
        self.hostname = hostname
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.instanceId = instanceId
        self.instanceType = instanceType
        self.layerIds = layerIds
        self.os = os
        self.sshKeyName = sshKeyName
    }
}

struct UpdateInstanceInputBody: Swift.Equatable {
    let instanceId: Swift.String?
    let layerIds: [Swift.String]?
    let instanceType: Swift.String?
    let autoScalingType: OpsWorksClientTypes.AutoScalingType?
    let hostname: Swift.String?
    let os: Swift.String?
    let amiId: Swift.String?
    let sshKeyName: Swift.String?
    let architecture: OpsWorksClientTypes.Architecture?
    let installUpdatesOnBoot: Swift.Bool?
    let ebsOptimized: Swift.Bool?
    let agentVersion: Swift.String?
}

extension UpdateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case amiId = "AmiId"
        case architecture = "Architecture"
        case autoScalingType = "AutoScalingType"
        case ebsOptimized = "EbsOptimized"
        case hostname = "Hostname"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case instanceId = "InstanceId"
        case instanceType = "InstanceType"
        case layerIds = "LayerIds"
        case os = "Os"
        case sshKeyName = "SshKeyName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let layerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerIds)
        var layerIdsDecoded0:[Swift.String]? = nil
        if let layerIdsContainer = layerIdsContainer {
            layerIdsDecoded0 = [Swift.String]()
            for string0 in layerIdsContainer {
                if let string0 = string0 {
                    layerIdsDecoded0?.append(string0)
                }
            }
        }
        layerIds = layerIdsDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let autoScalingTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.AutoScalingType.self, forKey: .autoScalingType)
        autoScalingType = autoScalingTypeDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let osDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .os)
        os = osDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let sshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyName)
        sshKeyName = sshKeyNameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Architecture.self, forKey: .architecture)
        architecture = architectureDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLayerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, layerAttributes0) in attributes {
                try attributesContainer.encode(layerAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoAssignElasticIps = self.autoAssignElasticIps {
            try encodeContainer.encode(autoAssignElasticIps, forKey: .autoAssignElasticIps)
        }
        if let autoAssignPublicIps = self.autoAssignPublicIps {
            try encodeContainer.encode(autoAssignPublicIps, forKey: .autoAssignPublicIps)
        }
        if let cloudWatchLogsConfiguration = self.cloudWatchLogsConfiguration {
            try encodeContainer.encode(cloudWatchLogsConfiguration, forKey: .cloudWatchLogsConfiguration)
        }
        if let customInstanceProfileArn = self.customInstanceProfileArn {
            try encodeContainer.encode(customInstanceProfileArn, forKey: .customInstanceProfileArn)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let customRecipes = self.customRecipes {
            try encodeContainer.encode(customRecipes, forKey: .customRecipes)
        }
        if let customSecurityGroupIds = customSecurityGroupIds {
            var customSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customSecurityGroupIds)
            for string0 in customSecurityGroupIds {
                try customSecurityGroupIdsContainer.encode(string0)
            }
        }
        if let enableAutoHealing = self.enableAutoHealing {
            try encodeContainer.encode(enableAutoHealing, forKey: .enableAutoHealing)
        }
        if let installUpdatesOnBoot = self.installUpdatesOnBoot {
            try encodeContainer.encode(installUpdatesOnBoot, forKey: .installUpdatesOnBoot)
        }
        if let layerId = self.layerId {
            try encodeContainer.encode(layerId, forKey: .layerId)
        }
        if let lifecycleEventConfiguration = self.lifecycleEventConfiguration {
            try encodeContainer.encode(lifecycleEventConfiguration, forKey: .lifecycleEventConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packages = packages {
            var packagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packages)
            for string0 in packages {
                try packagesContainer.encode(string0)
            }
        }
        if let shortname = self.shortname {
            try encodeContainer.encode(shortname, forKey: .shortname)
        }
        if let useEbsOptimizedInstances = self.useEbsOptimizedInstances {
            try encodeContainer.encode(useEbsOptimizedInstances, forKey: .useEbsOptimizedInstances)
        }
        if let volumeConfigurations = volumeConfigurations {
            var volumeConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeConfigurations)
            for volumeconfiguration0 in volumeConfigurations {
                try volumeConfigurationsContainer.encode(volumeconfiguration0)
            }
        }
    }
}

extension UpdateLayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLayerInput: Swift.Equatable {
    /// One or more user-defined key/value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// Whether to automatically assign an [Elastic IP address](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignElasticIps: Swift.Bool?
    /// For stacks that are running in a VPC, whether to automatically assign a public IP address to the layer's instances. For more information, see [How to Edit a Layer](https://docs.aws.amazon.com/opsworks/latest/userguide/workinglayers-basics-edit.html).
    public var autoAssignPublicIps: Swift.Bool?
    /// Specifies CloudWatch Logs configuration options for the layer. For more information, see [CloudWatchLogsLogStream].
    public var cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    /// The ARN of an IAM profile to be used for all of the layer's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var customInstanceProfileArn: Swift.String?
    /// A JSON-formatted string containing custom stack configuration and deployment attributes to be installed on the layer's instances. For more information, see [ Using Custom JSON](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook-json-override.html).
    public var customJson: Swift.String?
    /// A LayerCustomRecipes object that specifies the layer's custom recipes.
    public var customRecipes: OpsWorksClientTypes.Recipes?
    /// An array containing the layer's custom security group IDs.
    public var customSecurityGroupIds: [Swift.String]?
    /// Whether to disable auto healing for the layer.
    public var enableAutoHealing: Swift.Bool?
    /// Whether to install operating system and package updates when the instance boots. The default value is true. To control when updates are installed, set this value to false. You must then update your instances manually by using [CreateDeployment] to run the update_dependencies stack command or manually running yum (Amazon Linux) or apt-get (Ubuntu) on the instances. We strongly recommend using the default value of true, to ensure that your instances have the latest security updates.
    public var installUpdatesOnBoot: Swift.Bool?
    /// The layer ID.
    /// This member is required.
    public var layerId: Swift.String?
    ///
    public var lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
    /// The layer name, which is used by the console.
    public var name: Swift.String?
    /// An array of Package objects that describe the layer's packages.
    public var packages: [Swift.String]?
    /// For custom layers only, use this parameter to specify the layer's short name, which is used internally by AWS OpsWorks Stacks and by Chef. The short name is also used as the name for the directory where your app files are installed. It can have a maximum of 200 characters and must be in the following format: /\A[a-z0-9\-\_\.]+\Z/. The built-in layers' short names are defined by AWS OpsWorks Stacks. For more information, see the [Layer Reference](https://docs.aws.amazon.com/opsworks/latest/userguide/layers.html)
    public var shortname: Swift.String?
    /// Whether to use Amazon EBS-optimized instances.
    public var useEbsOptimizedInstances: Swift.Bool?
    /// A VolumeConfigurations object that describes the layer's Amazon EBS volumes.
    public var volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        autoAssignElasticIps: Swift.Bool? = nil,
        autoAssignPublicIps: Swift.Bool? = nil,
        cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration? = nil,
        customInstanceProfileArn: Swift.String? = nil,
        customJson: Swift.String? = nil,
        customRecipes: OpsWorksClientTypes.Recipes? = nil,
        customSecurityGroupIds: [Swift.String]? = nil,
        enableAutoHealing: Swift.Bool? = nil,
        installUpdatesOnBoot: Swift.Bool? = nil,
        layerId: Swift.String? = nil,
        lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration? = nil,
        name: Swift.String? = nil,
        packages: [Swift.String]? = nil,
        shortname: Swift.String? = nil,
        useEbsOptimizedInstances: Swift.Bool? = nil,
        volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]? = nil
    )
    {
        self.attributes = attributes
        self.autoAssignElasticIps = autoAssignElasticIps
        self.autoAssignPublicIps = autoAssignPublicIps
        self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
        self.customInstanceProfileArn = customInstanceProfileArn
        self.customJson = customJson
        self.customRecipes = customRecipes
        self.customSecurityGroupIds = customSecurityGroupIds
        self.enableAutoHealing = enableAutoHealing
        self.installUpdatesOnBoot = installUpdatesOnBoot
        self.layerId = layerId
        self.lifecycleEventConfiguration = lifecycleEventConfiguration
        self.name = name
        self.packages = packages
        self.shortname = shortname
        self.useEbsOptimizedInstances = useEbsOptimizedInstances
        self.volumeConfigurations = volumeConfigurations
    }
}

struct UpdateLayerInputBody: Swift.Equatable {
    let layerId: Swift.String?
    let name: Swift.String?
    let shortname: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let cloudWatchLogsConfiguration: OpsWorksClientTypes.CloudWatchLogsConfiguration?
    let customInstanceProfileArn: Swift.String?
    let customJson: Swift.String?
    let customSecurityGroupIds: [Swift.String]?
    let packages: [Swift.String]?
    let volumeConfigurations: [OpsWorksClientTypes.VolumeConfiguration]?
    let enableAutoHealing: Swift.Bool?
    let autoAssignElasticIps: Swift.Bool?
    let autoAssignPublicIps: Swift.Bool?
    let customRecipes: OpsWorksClientTypes.Recipes?
    let installUpdatesOnBoot: Swift.Bool?
    let useEbsOptimizedInstances: Swift.Bool?
    let lifecycleEventConfiguration: OpsWorksClientTypes.LifecycleEventConfiguration?
}

extension UpdateLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case autoAssignElasticIps = "AutoAssignElasticIps"
        case autoAssignPublicIps = "AutoAssignPublicIps"
        case cloudWatchLogsConfiguration = "CloudWatchLogsConfiguration"
        case customInstanceProfileArn = "CustomInstanceProfileArn"
        case customJson = "CustomJson"
        case customRecipes = "CustomRecipes"
        case customSecurityGroupIds = "CustomSecurityGroupIds"
        case enableAutoHealing = "EnableAutoHealing"
        case installUpdatesOnBoot = "InstallUpdatesOnBoot"
        case layerId = "LayerId"
        case lifecycleEventConfiguration = "LifecycleEventConfiguration"
        case name = "Name"
        case packages = "Packages"
        case shortname = "Shortname"
        case useEbsOptimizedInstances = "UseEbsOptimizedInstances"
        case volumeConfigurations = "VolumeConfigurations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerId)
        layerId = layerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let shortnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortname)
        shortname = shortnameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let cloudWatchLogsConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.CloudWatchLogsConfiguration.self, forKey: .cloudWatchLogsConfiguration)
        cloudWatchLogsConfiguration = cloudWatchLogsConfigurationDecoded
        let customInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customInstanceProfileArn)
        customInstanceProfileArn = customInstanceProfileArnDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let customSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customSecurityGroupIds)
        var customSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let customSecurityGroupIdsContainer = customSecurityGroupIdsContainer {
            customSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in customSecurityGroupIdsContainer {
                if let string0 = string0 {
                    customSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        customSecurityGroupIds = customSecurityGroupIdsDecoded0
        let packagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .packages)
        var packagesDecoded0:[Swift.String]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [Swift.String]()
            for string0 in packagesContainer {
                if let string0 = string0 {
                    packagesDecoded0?.append(string0)
                }
            }
        }
        packages = packagesDecoded0
        let volumeConfigurationsContainer = try containerValues.decodeIfPresent([OpsWorksClientTypes.VolumeConfiguration?].self, forKey: .volumeConfigurations)
        var volumeConfigurationsDecoded0:[OpsWorksClientTypes.VolumeConfiguration]? = nil
        if let volumeConfigurationsContainer = volumeConfigurationsContainer {
            volumeConfigurationsDecoded0 = [OpsWorksClientTypes.VolumeConfiguration]()
            for structure0 in volumeConfigurationsContainer {
                if let structure0 = structure0 {
                    volumeConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        volumeConfigurations = volumeConfigurationsDecoded0
        let enableAutoHealingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAutoHealing)
        enableAutoHealing = enableAutoHealingDecoded
        let autoAssignElasticIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignElasticIps)
        autoAssignElasticIps = autoAssignElasticIpsDecoded
        let autoAssignPublicIpsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssignPublicIps)
        autoAssignPublicIps = autoAssignPublicIpsDecoded
        let customRecipesDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Recipes.self, forKey: .customRecipes)
        customRecipes = customRecipesDecoded
        let installUpdatesOnBootDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .installUpdatesOnBoot)
        installUpdatesOnBoot = installUpdatesOnBootDecoded
        let useEbsOptimizedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEbsOptimizedInstances)
        useEbsOptimizedInstances = useEbsOptimizedInstancesDecoded
        let lifecycleEventConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.LifecycleEventConfiguration.self, forKey: .lifecycleEventConfiguration)
        lifecycleEventConfiguration = lifecycleEventConfigurationDecoded
    }
}

extension UpdateLayerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLayerOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLayerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMyUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
    }
}

extension UpdateMyUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateMyUserProfileInput: Swift.Equatable {
    /// The user's SSH public key.
    public var sshPublicKey: Swift.String?

    public init(
        sshPublicKey: Swift.String? = nil
    )
    {
        self.sshPublicKey = sshPublicKey
    }
}

struct UpdateMyUserProfileInputBody: Swift.Equatable {
    let sshPublicKey: Swift.String?
}

extension UpdateMyUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sshPublicKey = "SshPublicKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateMyUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMyUserProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMyUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRdsDbInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbPassword = self.dbPassword {
            try encodeContainer.encode(dbPassword, forKey: .dbPassword)
        }
        if let dbUser = self.dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let rdsDbInstanceArn = self.rdsDbInstanceArn {
            try encodeContainer.encode(rdsDbInstanceArn, forKey: .rdsDbInstanceArn)
        }
    }
}

extension UpdateRdsDbInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRdsDbInstanceInput: Swift.Equatable {
    /// The database password.
    public var dbPassword: Swift.String?
    /// The master user name.
    public var dbUser: Swift.String?
    /// The Amazon RDS instance's ARN.
    /// This member is required.
    public var rdsDbInstanceArn: Swift.String?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        rdsDbInstanceArn: Swift.String? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.rdsDbInstanceArn = rdsDbInstanceArn
    }
}

struct UpdateRdsDbInstanceInputBody: Swift.Equatable {
    let rdsDbInstanceArn: Swift.String?
    let dbUser: Swift.String?
    let dbPassword: Swift.String?
}

extension UpdateRdsDbInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbPassword = "DbPassword"
        case dbUser = "DbUser"
        case rdsDbInstanceArn = "RdsDbInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rdsDbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsDbInstanceArn)
        rdsDbInstanceArn = rdsDbInstanceArnDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let dbPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbPassword)
        dbPassword = dbPasswordDecoded
    }
}

extension UpdateRdsDbInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRdsDbInstanceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRdsDbInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, stackAttributes0) in attributes {
                try attributesContainer.encode(stackAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let chefConfiguration = self.chefConfiguration {
            try encodeContainer.encode(chefConfiguration, forKey: .chefConfiguration)
        }
        if let configurationManager = self.configurationManager {
            try encodeContainer.encode(configurationManager, forKey: .configurationManager)
        }
        if let customCookbooksSource = self.customCookbooksSource {
            try encodeContainer.encode(customCookbooksSource, forKey: .customCookbooksSource)
        }
        if let customJson = self.customJson {
            try encodeContainer.encode(customJson, forKey: .customJson)
        }
        if let defaultAvailabilityZone = self.defaultAvailabilityZone {
            try encodeContainer.encode(defaultAvailabilityZone, forKey: .defaultAvailabilityZone)
        }
        if let defaultInstanceProfileArn = self.defaultInstanceProfileArn {
            try encodeContainer.encode(defaultInstanceProfileArn, forKey: .defaultInstanceProfileArn)
        }
        if let defaultOs = self.defaultOs {
            try encodeContainer.encode(defaultOs, forKey: .defaultOs)
        }
        if let defaultRootDeviceType = self.defaultRootDeviceType {
            try encodeContainer.encode(defaultRootDeviceType.rawValue, forKey: .defaultRootDeviceType)
        }
        if let defaultSshKeyName = self.defaultSshKeyName {
            try encodeContainer.encode(defaultSshKeyName, forKey: .defaultSshKeyName)
        }
        if let defaultSubnetId = self.defaultSubnetId {
            try encodeContainer.encode(defaultSubnetId, forKey: .defaultSubnetId)
        }
        if let hostnameTheme = self.hostnameTheme {
            try encodeContainer.encode(hostnameTheme, forKey: .hostnameTheme)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serviceRoleArn = self.serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let useCustomCookbooks = self.useCustomCookbooks {
            try encodeContainer.encode(useCustomCookbooks, forKey: .useCustomCookbooks)
        }
        if let useOpsworksSecurityGroups = self.useOpsworksSecurityGroups {
            try encodeContainer.encode(useOpsworksSecurityGroups, forKey: .useOpsworksSecurityGroups)
        }
    }
}

extension UpdateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateStackInput: Swift.Equatable {
    /// The default AWS OpsWorks Stacks agent version. You have the following options:
    ///
    /// * Auto-update - Set this parameter to LATEST. AWS OpsWorks Stacks automatically installs new agent versions on the stack's instances as soon as they are available.
    ///
    /// * Fixed version - Set this parameter to your preferred agent version. To update the agent version, you must edit the stack configuration and specify a new version. AWS OpsWorks Stacks then automatically installs that version on the stack's instances.
    ///
    ///
    /// The default setting is LATEST. To specify an agent version, you must use the complete version number, not the abbreviated number shown on the console. For a list of available agent version numbers, call [DescribeAgentVersions]. AgentVersion cannot be set to Chef 12.2. You can also specify an agent version when you create or update an instance, which overrides the stack's default setting.
    public var agentVersion: Swift.String?
    /// One or more user-defined key-value pairs to be added to the stack attributes.
    public var attributes: [Swift.String:Swift.String]?
    /// A ChefConfiguration object that specifies whether to enable Berkshelf and the Berkshelf version on Chef 11.10 stacks. For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    /// The configuration manager. When you update a stack, we recommend that you use the configuration manager to specify the Chef version: 12, 11.10, or 11.4 for Linux stacks, or 12.2 for Windows stacks. The default value for Linux stacks is currently 12.
    public var configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    /// Contains the information required to retrieve an app or cookbook from a repository. For more information, see [Adding Apps](https://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html) or [Cookbooks and Recipes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingcookbook.html).
    public var customCookbooksSource: OpsWorksClientTypes.Source?
    /// A string that contains user-defined, custom JSON. It can be used to override the corresponding default stack configuration JSON values or to pass data to recipes. The string should be in the following format: "{\"key1\": \"value1\", \"key2\": \"value2\",...}" For more information about custom JSON, see [Use Custom JSON to Modify the Stack Configuration Attributes](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-json.html).
    public var customJson: Swift.String?
    /// The stack's default Availability Zone, which must be in the stack's region. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html). If you also specify a value for DefaultSubnetId, the subnet must be in the same zone. For more information, see [CreateStack].
    public var defaultAvailabilityZone: Swift.String?
    /// The ARN of an IAM profile that is the default profile for all of the stack's EC2 instances. For more information about IAM ARNs, see [Using Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html).
    public var defaultInstanceProfileArn: Swift.String?
    /// The stack's operating system, which must be set to one of the following:
    ///
    /// * A supported Linux operating system: An Amazon Linux version, such as Amazon Linux 2018.03, Amazon Linux 2017.09, Amazon Linux 2017.03, Amazon Linux 2016.09, Amazon Linux 2016.03, Amazon Linux 2015.09, or Amazon Linux 2015.03.
    ///
    /// * A supported Ubuntu operating system, such as Ubuntu 16.04 LTS, Ubuntu 14.04 LTS, or Ubuntu 12.04 LTS.
    ///
    /// * CentOS Linux 7
    ///
    /// * Red Hat Enterprise Linux 7
    ///
    /// * A supported Windows operating system, such as Microsoft Windows Server 2012 R2 Base, Microsoft Windows Server 2012 R2 with SQL Server Express, Microsoft Windows Server 2012 R2 with SQL Server Standard, or Microsoft Windows Server 2012 R2 with SQL Server Web.
    ///
    /// * A custom AMI: Custom. You specify the custom AMI you want to use when you create instances. For more information about how to use custom AMIs with OpsWorks, see [Using Custom AMIs](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-custom-ami.html).
    ///
    ///
    /// The default option is the stack's current operating system. For more information about supported operating systems, see [AWS OpsWorks Stacks Operating Systems](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-os.html).
    public var defaultOs: Swift.String?
    /// The default root device type. This value is used by default for all instances in the stack, but you can override it when you create an instance. For more information, see [Storage for the Root Device](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ComponentsAMIs.html#storage-for-the-root-device).
    public var defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    /// A default Amazon EC2 key-pair name. The default value is none. If you specify a key-pair name, AWS OpsWorks Stacks installs the public key on the instance and you can use the private key with an SSH client to log in to the instance. For more information, see [ Using SSH to Communicate with an Instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-ssh.html) and [ Managing SSH Access](https://docs.aws.amazon.com/opsworks/latest/userguide/security-ssh-access.html). You can override this setting by specifying a different key pair, or no key pair, when you [ create an instance](https://docs.aws.amazon.com/opsworks/latest/userguide/workinginstances-add.html).
    public var defaultSshKeyName: Swift.String?
    /// The stack's default VPC subnet ID. This parameter is required if you specify a value for the VpcId parameter. All instances are launched into this subnet unless you specify otherwise when you create the instance. If you also specify a value for DefaultAvailabilityZone, the subnet must be in that zone. For information on default values and when this parameter is required, see the VpcId parameter description.
    public var defaultSubnetId: Swift.String?
    /// The stack's new host name theme, with spaces replaced by underscores. The theme is used to generate host names for the stack's instances. By default, HostnameTheme is set to Layer_Dependent, which creates host names by appending integers to the layer's short name. The other themes are:
    ///
    /// * Baked_Goods
    ///
    /// * Clouds
    ///
    /// * Europe_Cities
    ///
    /// * Fruits
    ///
    /// * Greek_Deities_and_Titans
    ///
    /// * Legendary_creatures_from_Japan
    ///
    /// * Planets_and_Moons
    ///
    /// * Roman_Deities
    ///
    /// * Scottish_Islands
    ///
    /// * US_Cities
    ///
    /// * Wild_Cats
    ///
    ///
    /// To obtain a generated host name, call GetHostNameSuggestion, which returns a host name based on the current theme.
    public var hostnameTheme: Swift.String?
    /// The stack's new name.
    public var name: Swift.String?
    /// Do not use this parameter. You cannot update a stack's service role.
    public var serviceRoleArn: Swift.String?
    /// The stack ID.
    /// This member is required.
    public var stackId: Swift.String?
    /// Whether the stack uses custom cookbooks.
    public var useCustomCookbooks: Swift.Bool?
    /// Whether to associate the AWS OpsWorks Stacks built-in security groups with the stack's layers. AWS OpsWorks Stacks provides a standard set of built-in security groups, one for each layer, which are associated with layers by default. UseOpsworksSecurityGroups allows you to provide your own custom security groups instead of using the built-in groups. UseOpsworksSecurityGroups has the following settings:
    ///
    /// * True - AWS OpsWorks Stacks automatically associates the appropriate built-in security group with each layer (default setting). You can associate additional security groups with a layer after you create it, but you cannot delete the built-in security group.
    ///
    /// * False - AWS OpsWorks Stacks does not associate built-in security groups with layers. You must create appropriate EC2 security groups and associate a security group with each layer that you create. However, you can still manually associate a built-in security group with a layer on. Custom security groups are required only for those layers that need custom settings.
    ///
    ///
    /// For more information, see [Create a New Stack](https://docs.aws.amazon.com/opsworks/latest/userguide/workingstacks-creating.html).
    public var useOpsworksSecurityGroups: Swift.Bool?

    public init(
        agentVersion: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        chefConfiguration: OpsWorksClientTypes.ChefConfiguration? = nil,
        configurationManager: OpsWorksClientTypes.StackConfigurationManager? = nil,
        customCookbooksSource: OpsWorksClientTypes.Source? = nil,
        customJson: Swift.String? = nil,
        defaultAvailabilityZone: Swift.String? = nil,
        defaultInstanceProfileArn: Swift.String? = nil,
        defaultOs: Swift.String? = nil,
        defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType? = nil,
        defaultSshKeyName: Swift.String? = nil,
        defaultSubnetId: Swift.String? = nil,
        hostnameTheme: Swift.String? = nil,
        name: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        stackId: Swift.String? = nil,
        useCustomCookbooks: Swift.Bool? = nil,
        useOpsworksSecurityGroups: Swift.Bool? = nil
    )
    {
        self.agentVersion = agentVersion
        self.attributes = attributes
        self.chefConfiguration = chefConfiguration
        self.configurationManager = configurationManager
        self.customCookbooksSource = customCookbooksSource
        self.customJson = customJson
        self.defaultAvailabilityZone = defaultAvailabilityZone
        self.defaultInstanceProfileArn = defaultInstanceProfileArn
        self.defaultOs = defaultOs
        self.defaultRootDeviceType = defaultRootDeviceType
        self.defaultSshKeyName = defaultSshKeyName
        self.defaultSubnetId = defaultSubnetId
        self.hostnameTheme = hostnameTheme
        self.name = name
        self.serviceRoleArn = serviceRoleArn
        self.stackId = stackId
        self.useCustomCookbooks = useCustomCookbooks
        self.useOpsworksSecurityGroups = useOpsworksSecurityGroups
    }
}

struct UpdateStackInputBody: Swift.Equatable {
    let stackId: Swift.String?
    let name: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let serviceRoleArn: Swift.String?
    let defaultInstanceProfileArn: Swift.String?
    let defaultOs: Swift.String?
    let hostnameTheme: Swift.String?
    let defaultAvailabilityZone: Swift.String?
    let defaultSubnetId: Swift.String?
    let customJson: Swift.String?
    let configurationManager: OpsWorksClientTypes.StackConfigurationManager?
    let chefConfiguration: OpsWorksClientTypes.ChefConfiguration?
    let useCustomCookbooks: Swift.Bool?
    let customCookbooksSource: OpsWorksClientTypes.Source?
    let defaultSshKeyName: Swift.String?
    let defaultRootDeviceType: OpsWorksClientTypes.RootDeviceType?
    let useOpsworksSecurityGroups: Swift.Bool?
    let agentVersion: Swift.String?
}

extension UpdateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion = "AgentVersion"
        case attributes = "Attributes"
        case chefConfiguration = "ChefConfiguration"
        case configurationManager = "ConfigurationManager"
        case customCookbooksSource = "CustomCookbooksSource"
        case customJson = "CustomJson"
        case defaultAvailabilityZone = "DefaultAvailabilityZone"
        case defaultInstanceProfileArn = "DefaultInstanceProfileArn"
        case defaultOs = "DefaultOs"
        case defaultRootDeviceType = "DefaultRootDeviceType"
        case defaultSshKeyName = "DefaultSshKeyName"
        case defaultSubnetId = "DefaultSubnetId"
        case hostnameTheme = "HostnameTheme"
        case name = "Name"
        case serviceRoleArn = "ServiceRoleArn"
        case stackId = "StackId"
        case useCustomCookbooks = "UseCustomCookbooks"
        case useOpsworksSecurityGroups = "UseOpsworksSecurityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let defaultInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultInstanceProfileArn)
        defaultInstanceProfileArn = defaultInstanceProfileArnDecoded
        let defaultOsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultOs)
        defaultOs = defaultOsDecoded
        let hostnameThemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameTheme)
        hostnameTheme = hostnameThemeDecoded
        let defaultAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAvailabilityZone)
        defaultAvailabilityZone = defaultAvailabilityZoneDecoded
        let defaultSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSubnetId)
        defaultSubnetId = defaultSubnetIdDecoded
        let customJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customJson)
        customJson = customJsonDecoded
        let configurationManagerDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.StackConfigurationManager.self, forKey: .configurationManager)
        configurationManager = configurationManagerDecoded
        let chefConfigurationDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.ChefConfiguration.self, forKey: .chefConfiguration)
        chefConfiguration = chefConfigurationDecoded
        let useCustomCookbooksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCustomCookbooks)
        useCustomCookbooks = useCustomCookbooksDecoded
        let customCookbooksSourceDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.Source.self, forKey: .customCookbooksSource)
        customCookbooksSource = customCookbooksSourceDecoded
        let defaultSshKeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultSshKeyName)
        defaultSshKeyName = defaultSshKeyNameDecoded
        let defaultRootDeviceTypeDecoded = try containerValues.decodeIfPresent(OpsWorksClientTypes.RootDeviceType.self, forKey: .defaultRootDeviceType)
        defaultRootDeviceType = defaultRootDeviceTypeDecoded
        let useOpsworksSecurityGroupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useOpsworksSecurityGroups)
        useOpsworksSecurityGroups = useOpsworksSecurityGroupsDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension UpdateStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateStackOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = self.allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = self.sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }
}

extension UpdateUserProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
    public var allowSelfManagement: Swift.Bool?
    /// The user IAM ARN. This can also be a federated user's ARN.
    /// This member is required.
    public var iamUserArn: Swift.String?
    /// The user's new SSH public key.
    public var sshPublicKey: Swift.String?
    /// The user's SSH user name. The allowable characters are [a-z], [A-Z], [0-9], '-', and '_'. If the specified name includes other punctuation marks, AWS OpsWorks Stacks removes them. For example, my.name will be changed to myname. If you do not specify an SSH user name, AWS OpsWorks Stacks generates one from the IAM user name.
    public var sshUsername: Swift.String?

    public init(
        allowSelfManagement: Swift.Bool? = nil,
        iamUserArn: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        sshUsername: Swift.String? = nil
    )
    {
        self.allowSelfManagement = allowSelfManagement
        self.iamUserArn = iamUserArn
        self.sshPublicKey = sshPublicKey
        self.sshUsername = sshUsername
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    let iamUserArn: Swift.String?
    let sshUsername: Swift.String?
    let sshPublicKey: Swift.String?
    let allowSelfManagement: Swift.Bool?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension UpdateUserProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserProfileOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVolumeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }
}

extension UpdateVolumeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVolumeInput: Swift.Equatable {
    /// The new mount point.
    public var mountPoint: Swift.String?
    /// The new name.
    public var name: Swift.String?
    /// The volume ID.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        mountPoint: Swift.String? = nil,
        name: Swift.String? = nil,
        volumeId: Swift.String? = nil
    )
    {
        self.mountPoint = mountPoint
        self.name = name
        self.volumeId = volumeId
    }
}

struct UpdateVolumeInputBody: Swift.Equatable {
    let volumeId: Swift.String?
    let name: Swift.String?
    let mountPoint: Swift.String?
}

extension UpdateVolumeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPoint = "MountPoint"
        case name = "Name"
        case volumeId = "VolumeId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
    }
}

extension UpdateVolumeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateVolumeOutput: Swift.Equatable {

    public init() { }
}

enum UpdateVolumeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OpsWorksClientTypes.UserProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowSelfManagement = "AllowSelfManagement"
        case iamUserArn = "IamUserArn"
        case name = "Name"
        case sshPublicKey = "SshPublicKey"
        case sshUsername = "SshUsername"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowSelfManagement = self.allowSelfManagement {
            try encodeContainer.encode(allowSelfManagement, forKey: .allowSelfManagement)
        }
        if let iamUserArn = self.iamUserArn {
            try encodeContainer.encode(iamUserArn, forKey: .iamUserArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sshPublicKey = self.sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let sshUsername = self.sshUsername {
            try encodeContainer.encode(sshUsername, forKey: .sshUsername)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamUserArn)
        iamUserArn = iamUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sshUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshUsername)
        sshUsername = sshUsernameDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let allowSelfManagementDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowSelfManagement)
        allowSelfManagement = allowSelfManagementDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes a user's SSH information.
    public struct UserProfile: Swift.Equatable {
        /// Whether users can specify their own SSH public key through the My Settings page. For more information, see [Managing User Permissions](https://docs.aws.amazon.com/opsworks/latest/userguide/security-settingsshkey.html).
        public var allowSelfManagement: Swift.Bool?
        /// The user's IAM ARN.
        public var iamUserArn: Swift.String?
        /// The user's name.
        public var name: Swift.String?
        /// The user's SSH public key.
        public var sshPublicKey: Swift.String?
        /// The user's SSH user name.
        public var sshUsername: Swift.String?

        public init(
            allowSelfManagement: Swift.Bool? = nil,
            iamUserArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            sshUsername: Swift.String? = nil
        )
        {
            self.allowSelfManagement = allowSelfManagement
            self.iamUserArn = iamUserArn
            self.name = name
            self.sshPublicKey = sshPublicKey
            self.sshUsername = sshUsername
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a request was not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpsWorksClientTypes {
    public enum VirtualizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hvm
        case paravirtual
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualizationType] {
            return [
                .hvm,
                .paravirtual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hvm: return "hvm"
            case .paravirtual: return "paravirtual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualizationType(rawValue: rawValue) ?? VirtualizationType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.Volume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case device = "Device"
        case ec2VolumeId = "Ec2VolumeId"
        case encrypted = "Encrypted"
        case instanceId = "InstanceId"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case name = "Name"
        case raidArrayId = "RaidArrayId"
        case region = "Region"
        case size = "Size"
        case status = "Status"
        case volumeId = "VolumeId"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let device = self.device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let ec2VolumeId = self.ec2VolumeId {
            try encodeContainer.encode(ec2VolumeId, forKey: .ec2VolumeId)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let raidArrayId = self.raidArrayId {
            try encodeContainer.encode(raidArrayId, forKey: .raidArrayId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let ec2VolumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2VolumeId)
        ec2VolumeId = ec2VolumeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let raidArrayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .raidArrayId)
        raidArrayId = raidArrayIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let deviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .device)
        device = deviceDecoded
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an instance's Amazon EBS volume.
    public struct Volume: Swift.Equatable {
        /// The volume Availability Zone. For more information, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var availabilityZone: Swift.String?
        /// The device name.
        public var device: Swift.String?
        /// The Amazon EC2 volume ID.
        public var ec2VolumeId: Swift.String?
        /// Specifies whether an Amazon EBS volume is encrypted. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html).
        public var encrypted: Swift.Bool?
        /// The instance ID.
        public var instanceId: Swift.String?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example, "/mnt/disk1".
        public var mountPoint: Swift.String?
        /// The volume name.
        public var name: Swift.String?
        /// The RAID array ID.
        public var raidArrayId: Swift.String?
        /// The AWS region. For more information about AWS regions, see [Regions and Endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html).
        public var region: Swift.String?
        /// The volume size.
        public var size: Swift.Int?
        /// The value returned by [DescribeVolumes](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html).
        public var status: Swift.String?
        /// The volume ID.
        public var volumeId: Swift.String?
        /// The volume type. For more information, see [ Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
        ///
        /// * standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        /// * io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        /// * gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        /// * st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        /// * sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        public var volumeType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            device: Swift.String? = nil,
            ec2VolumeId: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            name: Swift.String? = nil,
            raidArrayId: Swift.String? = nil,
            region: Swift.String? = nil,
            size: Swift.Int? = nil,
            status: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.device = device
            self.ec2VolumeId = ec2VolumeId
            self.encrypted = encrypted
            self.instanceId = instanceId
            self.iops = iops
            self.mountPoint = mountPoint
            self.name = name
            self.raidArrayId = raidArrayId
            self.region = region
            self.size = size
            self.status = status
            self.volumeId = volumeId
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes.VolumeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encrypted = "Encrypted"
        case iops = "Iops"
        case mountPoint = "MountPoint"
        case numberOfDisks = "NumberOfDisks"
        case raidLevel = "RaidLevel"
        case size = "Size"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let mountPoint = self.mountPoint {
            try encodeContainer.encode(mountPoint, forKey: .mountPoint)
        }
        if let numberOfDisks = self.numberOfDisks {
            try encodeContainer.encode(numberOfDisks, forKey: .numberOfDisks)
        }
        if let raidLevel = self.raidLevel {
            try encodeContainer.encode(raidLevel, forKey: .raidLevel)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPoint)
        mountPoint = mountPointDecoded
        let raidLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .raidLevel)
        raidLevel = raidLevelDecoded
        let numberOfDisksDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDisks)
        numberOfDisks = numberOfDisksDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
    }
}

extension OpsWorksClientTypes {
    /// Describes an Amazon EBS volume configuration.
    public struct VolumeConfiguration: Swift.Equatable {
        /// Specifies whether an Amazon EBS volume is encrypted. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html).
        public var encrypted: Swift.Bool?
        /// For PIOPS volumes, the IOPS per disk.
        public var iops: Swift.Int?
        /// The volume mount point. For example "/dev/sdh".
        /// This member is required.
        public var mountPoint: Swift.String?
        /// The number of disks in the volume.
        /// This member is required.
        public var numberOfDisks: Swift.Int?
        /// The volume [RAID level](http://en.wikipedia.org/wiki/Standard_RAID_levels).
        public var raidLevel: Swift.Int?
        /// The volume size.
        /// This member is required.
        public var size: Swift.Int?
        /// The volume type. For more information, see [ Amazon EBS Volume Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html).
        ///
        /// * standard - Magnetic. Magnetic volumes must have a minimum size of 1 GiB and a maximum size of 1024 GiB.
        ///
        /// * io1 - Provisioned IOPS (SSD). PIOPS volumes must have a minimum size of 4 GiB and a maximum size of 16384 GiB.
        ///
        /// * gp2 - General Purpose (SSD). General purpose volumes must have a minimum size of 1 GiB and a maximum size of 16384 GiB.
        ///
        /// * st1 - Throughput Optimized hard disk drive (HDD). Throughput optimized HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        ///
        /// * sc1 - Cold HDD. Cold HDD volumes must have a minimum size of 500 GiB and a maximum size of 16384 GiB.
        public var volumeType: Swift.String?

        public init(
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            mountPoint: Swift.String? = nil,
            numberOfDisks: Swift.Int? = nil,
            raidLevel: Swift.Int? = nil,
            size: Swift.Int? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.encrypted = encrypted
            self.iops = iops
            self.mountPoint = mountPoint
            self.numberOfDisks = numberOfDisks
            self.raidLevel = raidLevel
            self.size = size
            self.volumeType = volumeType
        }
    }

}

extension OpsWorksClientTypes {
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case io1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .io1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .io1: return "io1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksClientTypes.WeeklyAutoScalingSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case friday = "Friday"
        case monday = "Monday"
        case saturday = "Saturday"
        case sunday = "Sunday"
        case thursday = "Thursday"
        case tuesday = "Tuesday"
        case wednesday = "Wednesday"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let friday = friday {
            var fridayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .friday)
            for (dictKey0, dailyAutoScalingSchedule0) in friday {
                try fridayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let monday = monday {
            var mondayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .monday)
            for (dictKey0, dailyAutoScalingSchedule0) in monday {
                try mondayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let saturday = saturday {
            var saturdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .saturday)
            for (dictKey0, dailyAutoScalingSchedule0) in saturday {
                try saturdayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sunday = sunday {
            var sundayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sunday)
            for (dictKey0, dailyAutoScalingSchedule0) in sunday {
                try sundayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thursday = thursday {
            var thursdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .thursday)
            for (dictKey0, dailyAutoScalingSchedule0) in thursday {
                try thursdayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tuesday = tuesday {
            var tuesdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tuesday)
            for (dictKey0, dailyAutoScalingSchedule0) in tuesday {
                try tuesdayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let wednesday = wednesday {
            var wednesdayContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .wednesday)
            for (dictKey0, dailyAutoScalingSchedule0) in wednesday {
                try wednesdayContainer.encode(dailyAutoScalingSchedule0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mondayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .monday)
        var mondayDecoded0: [Swift.String:Swift.String]? = nil
        if let mondayContainer = mondayContainer {
            mondayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in mondayContainer {
                if let switch0 = switch0 {
                    mondayDecoded0?[key0] = switch0
                }
            }
        }
        monday = mondayDecoded0
        let tuesdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tuesday)
        var tuesdayDecoded0: [Swift.String:Swift.String]? = nil
        if let tuesdayContainer = tuesdayContainer {
            tuesdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in tuesdayContainer {
                if let switch0 = switch0 {
                    tuesdayDecoded0?[key0] = switch0
                }
            }
        }
        tuesday = tuesdayDecoded0
        let wednesdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .wednesday)
        var wednesdayDecoded0: [Swift.String:Swift.String]? = nil
        if let wednesdayContainer = wednesdayContainer {
            wednesdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in wednesdayContainer {
                if let switch0 = switch0 {
                    wednesdayDecoded0?[key0] = switch0
                }
            }
        }
        wednesday = wednesdayDecoded0
        let thursdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .thursday)
        var thursdayDecoded0: [Swift.String:Swift.String]? = nil
        if let thursdayContainer = thursdayContainer {
            thursdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in thursdayContainer {
                if let switch0 = switch0 {
                    thursdayDecoded0?[key0] = switch0
                }
            }
        }
        thursday = thursdayDecoded0
        let fridayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .friday)
        var fridayDecoded0: [Swift.String:Swift.String]? = nil
        if let fridayContainer = fridayContainer {
            fridayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in fridayContainer {
                if let switch0 = switch0 {
                    fridayDecoded0?[key0] = switch0
                }
            }
        }
        friday = fridayDecoded0
        let saturdayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .saturday)
        var saturdayDecoded0: [Swift.String:Swift.String]? = nil
        if let saturdayContainer = saturdayContainer {
            saturdayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in saturdayContainer {
                if let switch0 = switch0 {
                    saturdayDecoded0?[key0] = switch0
                }
            }
        }
        saturday = saturdayDecoded0
        let sundayContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sunday)
        var sundayDecoded0: [Swift.String:Swift.String]? = nil
        if let sundayContainer = sundayContainer {
            sundayDecoded0 = [Swift.String:Swift.String]()
            for (key0, switch0) in sundayContainer {
                if let switch0 = switch0 {
                    sundayDecoded0?[key0] = switch0
                }
            }
        }
        sunday = sundayDecoded0
    }
}

extension OpsWorksClientTypes {
    /// Describes a time-based instance's auto scaling schedule. The schedule consists of a set of key-value pairs.
    ///
    /// * The key is the time period (a UTC hour) and must be an integer from 0 - 23.
    ///
    /// * The value indicates whether the instance should be online or offline for the specified period, and must be set to "on" or "off"
    ///
    ///
    /// The default setting for all time periods is off, so you use the following parameters primarily to specify the online periods. You don't have to explicitly specify offline periods unless you want to change an online period to an offline period. The following example specifies that the instance should be online for four hours, from UTC 1200 - 1600. It will be off for the remainder of the day.  { "12":"on", "13":"on", "14":"on", "15":"on" }
    public struct WeeklyAutoScalingSchedule: Swift.Equatable {
        /// The schedule for Friday.
        public var friday: [Swift.String:Swift.String]?
        /// The schedule for Monday.
        public var monday: [Swift.String:Swift.String]?
        /// The schedule for Saturday.
        public var saturday: [Swift.String:Swift.String]?
        /// The schedule for Sunday.
        public var sunday: [Swift.String:Swift.String]?
        /// The schedule for Thursday.
        public var thursday: [Swift.String:Swift.String]?
        /// The schedule for Tuesday.
        public var tuesday: [Swift.String:Swift.String]?
        /// The schedule for Wednesday.
        public var wednesday: [Swift.String:Swift.String]?

        public init(
            friday: [Swift.String:Swift.String]? = nil,
            monday: [Swift.String:Swift.String]? = nil,
            saturday: [Swift.String:Swift.String]? = nil,
            sunday: [Swift.String:Swift.String]? = nil,
            thursday: [Swift.String:Swift.String]? = nil,
            tuesday: [Swift.String:Swift.String]? = nil,
            wednesday: [Swift.String:Swift.String]? = nil
        )
        {
            self.friday = friday
            self.monday = monday
            self.saturday = saturday
            self.sunday = sunday
            self.thursday = thursday
            self.tuesday = tuesday
            self.wednesday = wednesday
        }
    }

}
