//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was a conflict processing the request. Updating or deleting the resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request has failed due to an internal error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Indicates when to retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The specified resource could not be found.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Indicates when to retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension NetworkManagerClientTypes {
    /// Describes a validation exception for a field.
    public struct ValidationExceptionField {
        /// The message for the field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .other: return "Other"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [NetworkManagerClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the error.
        public internal(set) var reason: NetworkManagerClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [NetworkManagerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: NetworkManagerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcceptAttachmentInput {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

extension NetworkManagerClientTypes {

    public enum AttachmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connect
        case siteToSiteVpn
        case transitGatewayRouteTable
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentType] {
            return [
                .connect,
                .siteToSiteVpn,
                .transitGatewayRouteTable,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connect: return "CONNECT"
            case .siteToSiteVpn: return "SITE_TO_SITE_VPN"
            case .transitGatewayRouteTable: return "TRANSIT_GATEWAY_ROUTE_TABLE"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum AttachmentErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case maximumNoEncapLimitExceeded
        case subnetDuplicatedInAvailabilityZone
        case subnetNotFound
        case subnetNoFreeAddresses
        case subnetNoIpv6Cidrs
        case subnetUnsupportedAvailabilityZone
        case vpcNotFound
        case vpnConnectionNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentErrorCode] {
            return [
                .maximumNoEncapLimitExceeded,
                .subnetDuplicatedInAvailabilityZone,
                .subnetNotFound,
                .subnetNoFreeAddresses,
                .subnetNoIpv6Cidrs,
                .subnetUnsupportedAvailabilityZone,
                .vpcNotFound,
                .vpnConnectionNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .maximumNoEncapLimitExceeded: return "MAXIMUM_NO_ENCAP_LIMIT_EXCEEDED"
            case .subnetDuplicatedInAvailabilityZone: return "SUBNET_DUPLICATED_IN_AVAILABILITY_ZONE"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case .subnetNoFreeAddresses: return "SUBNET_NO_FREE_ADDRESSES"
            case .subnetNoIpv6Cidrs: return "SUBNET_NO_IPV6_CIDRS"
            case .subnetUnsupportedAvailabilityZone: return "SUBNET_UNSUPPORTED_AVAILABILITY_ZONE"
            case .vpcNotFound: return "VPC_NOT_FOUND"
            case .vpnConnectionNotFound: return "VPN_CONNECTION_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes the error associated with an attachment request.
    public struct AttachmentError {
        /// The error code for the attachment request.
        public var code: NetworkManagerClientTypes.AttachmentErrorCode?
        /// The message associated with the error code.
        public var message: Swift.String?
        /// The ID of the attachment request.
        public var requestId: Swift.String?
        /// The ARN of the requested attachment resource.
        public var resourceArn: Swift.String?

        public init(
            code: NetworkManagerClientTypes.AttachmentErrorCode? = nil,
            message: Swift.String? = nil,
            requestId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resourceArn = resourceArn
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a tag.
    public struct Tag {
        /// The tag key. Constraints: Maximum length of 128 characters.
        public var key: Swift.String?
        /// The tag value. Constraints: Maximum length of 256 characters.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes proposed changes to a network function group.
    public struct ProposedNetworkFunctionGroupChange {
        /// The proposed new attachment policy rule number for the network function group.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The proposed name change for the network function group name.
        public var networkFunctionGroupName: Swift.String?
        /// The list of proposed changes to the key-value tags associated with the network function group.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            networkFunctionGroupName: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.networkFunctionGroupName = networkFunctionGroupName
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a proposed segment change. In some cases, the segment change must first be evaluated and accepted.
    public struct ProposedSegmentChange {
        /// The rule number in the policy document that applies to this change.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The name of the segment to change.
        public var segmentName: Swift.String?
        /// The list of key-value tags that changed for the segment.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            segmentName: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.segmentName = segmentName
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {

    public enum AttachmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case pendingAttachmentAcceptance
        case pendingNetworkUpdate
        case pendingTagAcceptance
        case rejected
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .pendingAttachmentAcceptance,
                .pendingNetworkUpdate,
                .pendingTagAcceptance,
                .rejected,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pendingAttachmentAcceptance: return "PENDING_ATTACHMENT_ACCEPTANCE"
            case .pendingNetworkUpdate: return "PENDING_NETWORK_UPDATE"
            case .pendingTagAcceptance: return "PENDING_TAG_ACCEPTANCE"
            case .rejected: return "REJECTED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network attachment.
    public struct Attachment {
        /// The ID of the attachment.
        public var attachmentId: Swift.String?
        /// The policy rule number associated with the attachment.
        public var attachmentPolicyRuleNumber: Swift.Int?
        /// The type of attachment.
        public var attachmentType: NetworkManagerClientTypes.AttachmentType?
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the attachment was created.
        public var createdAt: Foundation.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// Describes the error associated with the attachment request.
        public var lastModificationErrors: [NetworkManagerClientTypes.AttachmentError]?
        /// The name of the network function group.
        public var networkFunctionGroupName: Swift.String?
        /// The ID of the attachment account owner.
        public var ownerAccountId: Swift.String?
        /// Describes a proposed change to a network function group associated with the attachment.
        public var proposedNetworkFunctionGroupChange: NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange?
        /// The attachment to move from one segment to another.
        public var proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange?
        /// The attachment resource ARN.
        public var resourceArn: Swift.String?
        /// The name of the segment attachment.
        public var segmentName: Swift.String?
        /// The state of the attachment.
        public var state: NetworkManagerClientTypes.AttachmentState?
        /// The tags associated with the attachment.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The timestamp when the attachment was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            attachmentId: Swift.String? = nil,
            attachmentPolicyRuleNumber: Swift.Int? = nil,
            attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            edgeLocation: Swift.String? = nil,
            lastModificationErrors: [NetworkManagerClientTypes.AttachmentError]? = nil,
            networkFunctionGroupName: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            proposedNetworkFunctionGroupChange: NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange? = nil,
            proposedSegmentChange: NetworkManagerClientTypes.ProposedSegmentChange? = nil,
            resourceArn: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            state: NetworkManagerClientTypes.AttachmentState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentPolicyRuleNumber = attachmentPolicyRuleNumber
            self.attachmentType = attachmentType
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.lastModificationErrors = lastModificationErrors
            self.networkFunctionGroupName = networkFunctionGroupName
            self.ownerAccountId = ownerAccountId
            self.proposedNetworkFunctionGroupChange = proposedNetworkFunctionGroupChange
            self.proposedSegmentChange = proposedSegmentChange
            self.resourceArn = resourceArn
            self.segmentName = segmentName
            self.state = state
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

public struct AcceptAttachmentOutput {
    /// The response to the attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init(
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

extension NetworkManagerClientTypes {
    /// Describes the current status of an account within an Amazon Web Services Organization, including service-linked roles (SLRs).
    public struct AccountStatus {
        /// The ID of an account within the Amazon Web Services Organization.
        public var accountId: Swift.String?
        /// The status of SLR deployment for the account.
        public var slrDeploymentStatus: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            slrDeploymentStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.slrDeploymentStatus = slrDeploymentStatus
        }
    }

}

/// A service limit was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The limit code.
        /// This member is required.
        public internal(set) var limitCode: Swift.String? = nil
        /// The error message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.limitCode = limitCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct AssociateConnectPeerInput {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init(
        connectPeerId: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

extension NetworkManagerClientTypes {

    public enum ConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer association.
    public struct ConnectPeerAssociation {
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of the device to connect to.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the Connect peer association.
        public var state: NetworkManagerClientTypes.ConnectPeerAssociationState?

        public init(
            connectPeerId: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectPeerAssociationState? = nil
        )
        {
            self.connectPeerId = connectPeerId
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

public struct AssociateConnectPeerOutput {
    /// The response to the Connect peer request.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init(
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

public struct AssociateCustomerGatewayInput {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?

    public init(
        customerGatewayArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

extension NetworkManagerClientTypes {

    public enum CustomerGatewayAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerGatewayAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes the association between a customer gateway, a device, and a link.
    public struct CustomerGatewayAssociation {
        /// The Amazon Resource Name (ARN) of the customer gateway.
        public var customerGatewayArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The association state.
        public var state: NetworkManagerClientTypes.CustomerGatewayAssociationState?

        public init(
            customerGatewayArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CustomerGatewayAssociationState? = nil
        )
        {
            self.customerGatewayArn = customerGatewayArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
        }
    }

}

public struct AssociateCustomerGatewayOutput {
    /// The customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init(
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

public struct AssociateLinkInput {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

extension NetworkManagerClientTypes {

    public enum LinkAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes the association between a device and a link.
    public struct LinkAssociation {
        /// The device ID for the link association.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the association.
        public var linkAssociationState: NetworkManagerClientTypes.LinkAssociationState?
        /// The ID of the link.
        public var linkId: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkAssociationState: NetworkManagerClientTypes.LinkAssociationState? = nil,
            linkId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkAssociationState = linkAssociationState
            self.linkId = linkId
        }
    }

}

public struct AssociateLinkOutput {
    /// The link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init(
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

public struct AssociateTransitGatewayConnectPeerInput {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

extension NetworkManagerClientTypes {

    public enum TransitGatewayConnectPeerAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayConnectPeerAssociationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway Connect peer association.
    public struct TransitGatewayConnectPeerAssociation {
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The state of the association.
        public var state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState?
        /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
        public var transitGatewayConnectPeerArn: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociationState? = nil,
            transitGatewayConnectPeerArn: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
        }
    }

}

public struct AssociateTransitGatewayConnectPeerOutput {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init(
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

extension NetworkManagerClientTypes {
    /// Specifies a location in Amazon Web Services.
    public struct AWSLocation {
        /// The Amazon Resource Name (ARN) of the subnet that the device is located in.
        public var subnetArn: Swift.String?
        /// The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
        public var zone: Swift.String?

        public init(
            subnetArn: Swift.String? = nil,
            zone: Swift.String? = nil
        )
        {
            self.subnetArn = subnetArn
            self.zone = zone
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes bandwidth information.
    public struct Bandwidth {
        /// Download speed in Mbps.
        public var downloadSpeed: Swift.Int?
        /// Upload speed in Mbps.
        public var uploadSpeed: Swift.Int?

        public init(
            downloadSpeed: Swift.Int? = nil,
            uploadSpeed: Swift.Int? = nil
        )
        {
            self.downloadSpeed = downloadSpeed
            self.uploadSpeed = uploadSpeed
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes the BGP options.
    public struct BgpOptions {
        /// The Peer ASN of the BGP.
        public var peerAsn: Swift.Int?

        public init(
            peerAsn: Swift.Int? = nil
        )
        {
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum ChangeSetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executing
        case executionSucceeded
        case failedGeneration
        case outOfDate
        case pendingGeneration
        case readyToExecute
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeSetState] {
            return [
                .executing,
                .executionSucceeded,
                .failedGeneration,
                .outOfDate,
                .pendingGeneration,
                .readyToExecute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executing: return "EXECUTING"
            case .executionSucceeded: return "EXECUTION_SUCCEEDED"
            case .failedGeneration: return "FAILED_GENERATION"
            case .outOfDate: return "OUT_OF_DATE"
            case .pendingGeneration: return "PENDING_GENERATION"
            case .readyToExecute: return "READY_TO_EXECUTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum ChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachmentMapping
        case attachmentPoliciesConfiguration
        case attachmentRoutePropagation
        case attachmentRouteStatic
        case coreNetworkConfiguration
        case coreNetworkEdge
        case coreNetworkSegment
        case networkFunctionGroup
        case segmentsConfiguration
        case segmentActionsConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .attachmentMapping,
                .attachmentPoliciesConfiguration,
                .attachmentRoutePropagation,
                .attachmentRouteStatic,
                .coreNetworkConfiguration,
                .coreNetworkEdge,
                .coreNetworkSegment,
                .networkFunctionGroup,
                .segmentsConfiguration,
                .segmentActionsConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachmentMapping: return "ATTACHMENT_MAPPING"
            case .attachmentPoliciesConfiguration: return "ATTACHMENT_POLICIES_CONFIGURATION"
            case .attachmentRoutePropagation: return "ATTACHMENT_ROUTE_PROPAGATION"
            case .attachmentRouteStatic: return "ATTACHMENT_ROUTE_STATIC"
            case .coreNetworkConfiguration: return "CORE_NETWORK_CONFIGURATION"
            case .coreNetworkEdge: return "CORE_NETWORK_EDGE"
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case .networkFunctionGroup: return "NETWORK_FUNCTION_GROUP"
            case .segmentsConfiguration: return "SEGMENTS_CONFIGURATION"
            case .segmentActionsConfiguration: return "SEGMENT_ACTIONS_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum TunnelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gre
        case noEncap
        case sdkUnknown(Swift.String)

        public static var allCases: [TunnelProtocol] {
            return [
                .gre,
                .noEncap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gre: return "GRE"
            case .noEncap: return "NO_ENCAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment options.
    public struct ConnectAttachmentOptions {
        /// The protocol used for the attachment connection.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?

        public init(
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil
        )
        {
            self.`protocol` = `protocol`
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect attachment.
    public struct ConnectAttachment {
        /// The attachment details.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Options for connecting an attachment.
        public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
        /// The ID of the transport attachment.
        public var transportAttachmentId: Swift.String?

        public init(
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
            transportAttachmentId: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.transportAttachmentId = transportAttachmentId
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a connection.
    public struct Connection {
        /// The ID of the second device in the connection.
        public var connectedDeviceId: Swift.String?
        /// The ID of the link for the second device in the connection.
        public var connectedLinkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the connection.
        public var connectionArn: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The date and time that the connection was created.
        public var createdAt: Foundation.Date?
        /// The description of the connection.
        public var description: Swift.String?
        /// The ID of the first device in the connection.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The ID of the link for the first device in the connection.
        public var linkId: Swift.String?
        /// The state of the connection.
        public var state: NetworkManagerClientTypes.ConnectionState?
        /// The tags for the connection.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            connectedDeviceId: Swift.String? = nil,
            connectedLinkId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.ConnectionState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectedDeviceId = connectedDeviceId
            self.connectedLinkId = connectedLinkId
            self.connectionArn = connectionArn
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.linkId = linkId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case down
        case up
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .down,
                .up
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .down: return "DOWN"
            case .up: return "UP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bgp
        case ipsec
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .bgp,
                .ipsec
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bgp: return "BGP"
            case .ipsec: return "IPSEC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes connection health.
    public struct ConnectionHealth {
        /// The connection status.
        public var status: NetworkManagerClientTypes.ConnectionStatus?
        /// The time the status was last updated.
        public var timestamp: Foundation.Date?
        /// The connection type.
        public var type: NetworkManagerClientTypes.ConnectionType?

        public init(
            status: NetworkManagerClientTypes.ConnectionStatus? = nil,
            timestamp: Foundation.Date? = nil,
            type: NetworkManagerClientTypes.ConnectionType? = nil
        )
        {
            self.status = status
            self.timestamp = timestamp
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network BGP configuration.
    public struct ConnectPeerBgpConfiguration {
        /// The address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The ASN of the Coret Network.
        public var coreNetworkAsn: Swift.Int?
        /// The address of a core network Connect peer.
        public var peerAddress: Swift.String?
        /// The ASN of the Connect peer.
        public var peerAsn: Swift.Int?

        public init(
            coreNetworkAddress: Swift.String? = nil,
            coreNetworkAsn: Swift.Int? = nil,
            peerAddress: Swift.String? = nil,
            peerAsn: Swift.Int? = nil
        )
        {
            self.coreNetworkAddress = coreNetworkAddress
            self.coreNetworkAsn = coreNetworkAsn
            self.peerAddress = peerAddress
            self.peerAsn = peerAsn
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer configuration.
    public struct ConnectPeerConfiguration {
        /// The Connect peer BGP configurations.
        public var bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]?
        /// The IP address of a core network.
        public var coreNetworkAddress: Swift.String?
        /// The inside IP addresses used for a Connect peer configuration.
        public var insideCidrBlocks: [Swift.String]?
        /// The IP address of the Connect peer.
        public var peerAddress: Swift.String?
        /// The protocol used for a Connect peer configuration.
        public var `protocol`: NetworkManagerClientTypes.TunnelProtocol?

        public init(
            bgpConfigurations: [NetworkManagerClientTypes.ConnectPeerBgpConfiguration]? = nil,
            coreNetworkAddress: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            peerAddress: Swift.String? = nil,
            `protocol`: NetworkManagerClientTypes.TunnelProtocol? = nil
        )
        {
            self.bgpConfigurations = bgpConfigurations
            self.coreNetworkAddress = coreNetworkAddress
            self.insideCidrBlocks = insideCidrBlocks
            self.peerAddress = peerAddress
            self.`protocol` = `protocol`
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ConnectPeerErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edgeLocationNoFreeIps
        case edgeLocationPeerDuplicate
        case invalidInsideCidrBlock
        case ipOutsideSubnetCidrRange
        case noAssociatedCidrBlock
        case subnetNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerErrorCode] {
            return [
                .edgeLocationNoFreeIps,
                .edgeLocationPeerDuplicate,
                .invalidInsideCidrBlock,
                .ipOutsideSubnetCidrRange,
                .noAssociatedCidrBlock,
                .subnetNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edgeLocationNoFreeIps: return "EDGE_LOCATION_NO_FREE_IPS"
            case .edgeLocationPeerDuplicate: return "EDGE_LOCATION_PEER_DUPLICATE"
            case .invalidInsideCidrBlock: return "INVALID_INSIDE_CIDR_BLOCK"
            case .ipOutsideSubnetCidrRange: return "IP_OUTSIDE_SUBNET_CIDR_RANGE"
            case .noAssociatedCidrBlock: return "NO_ASSOCIATED_CIDR_BLOCK"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes an error associated with a Connect peer request
    public struct ConnectPeerError {
        /// The error code for the Connect peer request.
        public var code: NetworkManagerClientTypes.ConnectPeerErrorCode?
        /// The message associated with the error code.
        public var message: Swift.String?
        /// The ID of the Connect peer request.
        public var requestId: Swift.String?
        /// The ARN of the requested Connect peer resource.
        public var resourceArn: Swift.String?

        public init(
            code: NetworkManagerClientTypes.ConnectPeerErrorCode? = nil,
            message: Swift.String? = nil,
            requestId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.requestId = requestId
            self.resourceArn = resourceArn
        }
    }

}

extension NetworkManagerClientTypes {

    public enum ConnectPeerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectPeerState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network Connect peer.
    public struct ConnectPeer {
        /// The configuration of the Connect peer.
        public var configuration: NetworkManagerClientTypes.ConnectPeerConfiguration?
        /// The ID of the attachment to connect.
        public var connectAttachmentId: Swift.String?
        /// The ID of the Connect peer.
        public var connectPeerId: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the Connect peer was created.
        public var createdAt: Foundation.Date?
        /// The Connect peer Regions where edges are located.
        public var edgeLocation: Swift.String?
        /// Describes the error associated with the attachment request.
        public var lastModificationErrors: [NetworkManagerClientTypes.ConnectPeerError]?
        /// The state of the Connect peer.
        public var state: NetworkManagerClientTypes.ConnectPeerState?
        /// The subnet ARN for the Connect peer. This only applies only when the protocol is NO_ENCAP.
        public var subnetArn: Swift.String?
        /// The list of key-value tags associated with the Connect peer.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            configuration: NetworkManagerClientTypes.ConnectPeerConfiguration? = nil,
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            edgeLocation: Swift.String? = nil,
            lastModificationErrors: [NetworkManagerClientTypes.ConnectPeerError]? = nil,
            state: NetworkManagerClientTypes.ConnectPeerState? = nil,
            subnetArn: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.configuration = configuration
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.lastModificationErrors = lastModificationErrors
            self.state = state
            self.subnetArn = subnetArn
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    /// Summary description of a Connect peer.
    public struct ConnectPeerSummary {
        /// The ID of a Connect peer attachment.
        public var connectAttachmentId: Swift.String?
        /// The ID of a Connect peer.
        public var connectPeerId: Swift.String?
        /// The state of a Connect peer.
        public var connectPeerState: NetworkManagerClientTypes.ConnectPeerState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a Connect peer was created.
        public var createdAt: Foundation.Date?
        /// The Region where the edge is located.
        public var edgeLocation: Swift.String?
        /// The subnet ARN for the Connect peer summary.
        public var subnetArn: Swift.String?
        /// The list of key-value tags associated with the Connect peer summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            connectAttachmentId: Swift.String? = nil,
            connectPeerId: Swift.String? = nil,
            connectPeerState: NetworkManagerClientTypes.ConnectPeerState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            edgeLocation: Swift.String? = nil,
            subnetArn: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.connectAttachmentId = connectAttachmentId
            self.connectPeerId = connectPeerId
            self.connectPeerState = connectPeerState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.subnetArn = subnetArn
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network edge.
    public struct CoreNetworkEdge {
        /// The ASN of a core network edge.
        public var asn: Swift.Int?
        /// The Region where a core network edge is located.
        public var edgeLocation: Swift.String?
        /// The inside IP addresses used for core network edges.
        public var insideCidrBlocks: [Swift.String]?

        public init(
            asn: Swift.Int? = nil,
            edgeLocation: Swift.String? = nil,
            insideCidrBlocks: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.edgeLocation = edgeLocation
            self.insideCidrBlocks = insideCidrBlocks
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes the segments associated with the service insertion action.
    public struct ServiceInsertionSegments {
        /// The list of segments associated with the send-to action.
        public var sendTo: [Swift.String]?
        /// The list of segments associated with the send-via action.
        public var sendVia: [Swift.String]?

        public init(
            sendTo: [Swift.String]? = nil,
            sendVia: [Swift.String]? = nil
        )
        {
            self.sendTo = sendTo
            self.sendVia = sendVia
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a network function group.
    public struct CoreNetworkNetworkFunctionGroup {
        /// The core network edge locations.
        public var edgeLocations: [Swift.String]?
        /// The name of the network function group.
        public var name: Swift.String?
        /// The segments associated with the network function group.
        public var segments: NetworkManagerClientTypes.ServiceInsertionSegments?

        public init(
            edgeLocations: [Swift.String]? = nil,
            name: Swift.String? = nil,
            segments: NetworkManagerClientTypes.ServiceInsertionSegments? = nil
        )
        {
            self.edgeLocations = edgeLocations
            self.name = name
            self.segments = segments
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network segment, which are dedicated routes. Only attachments within this segment can communicate with each other.
    public struct CoreNetworkSegment {
        /// The Regions where the edges are located.
        public var edgeLocations: [Swift.String]?
        /// The name of a core network segment.
        public var name: Swift.String?
        /// The shared segments of a core network.
        public var sharedSegments: [Swift.String]?

        public init(
            edgeLocations: [Swift.String]? = nil,
            name: Swift.String? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.edgeLocations = edgeLocations
            self.name = name
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes {

    public enum CoreNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkState] {
            return [
                .available,
                .creating,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network.
    public struct CoreNetwork {
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network was created.
        public var createdAt: Foundation.Date?
        /// The description of a core network.
        public var description: Swift.String?
        /// The edges within a core network.
        public var edges: [NetworkManagerClientTypes.CoreNetworkEdge]?
        /// The ID of the global network that your core network is a part of.
        public var globalNetworkId: Swift.String?
        /// The network function groups associated with a core network.
        public var networkFunctionGroups: [NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup]?
        /// The segments within a core network.
        public var segments: [NetworkManagerClientTypes.CoreNetworkSegment]?
        /// The current state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The list of key-value tags associated with a core network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            edges: [NetworkManagerClientTypes.CoreNetworkEdge]? = nil,
            globalNetworkId: Swift.String? = nil,
            networkFunctionGroups: [NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup]? = nil,
            segments: [NetworkManagerClientTypes.CoreNetworkSegment]? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.edges = edges
            self.globalNetworkId = globalNetworkId
            self.networkFunctionGroups = networkFunctionGroups
            self.segments = segments
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {

    public enum SegmentActionServiceInsertion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sendTo
        case sendVia
        case sdkUnknown(Swift.String)

        public static var allCases: [SegmentActionServiceInsertion] {
            return [
                .sendTo,
                .sendVia
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sendTo: return "send-to"
            case .sendVia: return "send-via"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum SendViaMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualHop
        case singleHop
        case sdkUnknown(Swift.String)

        public static var allCases: [SendViaMode] {
            return [
                .dualHop,
                .singleHop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualHop: return "dual-hop"
            case .singleHop: return "single-hop"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a network function group for service insertion.
    public struct NetworkFunctionGroup {
        /// The name of the network function group.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes the edge that's used for the override.
    public struct EdgeOverride {
        /// The list of edge locations.
        public var edgeSets: [[Swift.String]]?
        /// The edge that should be used when overriding the current edge order.
        public var useEdge: Swift.String?

        public init(
            edgeSets: [[Swift.String]]? = nil,
            useEdge: Swift.String? = nil
        )
        {
            self.edgeSets = edgeSets
            self.useEdge = useEdge
        }
    }

}

extension NetworkManagerClientTypes {
    /// The list of network function groups and edge overrides for the service insertion action. Used for both the send-to and send-via actions.
    public struct Via {
        /// The list of network function groups associated with the service insertion action.
        public var networkFunctionGroups: [NetworkManagerClientTypes.NetworkFunctionGroup]?
        /// Describes any edge overrides. An edge override is a specific edge to be used for traffic.
        public var withEdgeOverrides: [NetworkManagerClientTypes.EdgeOverride]?

        public init(
            networkFunctionGroups: [NetworkManagerClientTypes.NetworkFunctionGroup]? = nil,
            withEdgeOverrides: [NetworkManagerClientTypes.EdgeOverride]? = nil
        )
        {
            self.networkFunctionGroups = networkFunctionGroups
            self.withEdgeOverrides = withEdgeOverrides
        }
    }

}

extension NetworkManagerClientTypes {
    /// Displays a list of the destination segments. Used only when the service insertion action is send-to.
    public struct WhenSentTo {
        /// The list of destination segments when the service insertion action is send-to.
        public var whenSentToSegmentsList: [Swift.String]?

        public init(
            whenSentToSegmentsList: [Swift.String]? = nil
        )
        {
            self.whenSentToSegmentsList = whenSentToSegmentsList
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes the action that the service insertion will take for any segments associated with it.
    public struct ServiceInsertionAction {
        /// The action the service insertion takes for traffic. send-via sends east-west traffic between attachments. send-to sends north-south traffic to the security appliance, and then from that to either the Internet or to an on-premesis location.
        public var action: NetworkManagerClientTypes.SegmentActionServiceInsertion?
        /// Describes the mode packets take for the send-via action. This is not used when the action is send-to. dual-hop packets traverse attachments in both the source to the destination core network edges. This mode requires that an inspection attachment must be present in all Regions of the service insertion-enabled segments. For single-hop, packets traverse a single intermediate inserted attachment. You can use EdgeOverride to specify a specific edge to use.
        public var mode: NetworkManagerClientTypes.SendViaMode?
        /// The list of network function groups and any edge overrides for the chosen service insertion action. Used for both send-to or send-via.
        public var via: NetworkManagerClientTypes.Via?
        /// The list of destination segments if the service insertion action is send-via.
        public var whenSentTo: NetworkManagerClientTypes.WhenSentTo?

        public init(
            action: NetworkManagerClientTypes.SegmentActionServiceInsertion? = nil,
            mode: NetworkManagerClientTypes.SendViaMode? = nil,
            via: NetworkManagerClientTypes.Via? = nil,
            whenSentTo: NetworkManagerClientTypes.WhenSentTo? = nil
        )
        {
            self.action = action
            self.mode = mode
            self.via = via
            self.whenSentTo = whenSentTo
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network change.
    public struct CoreNetworkChangeValues {
        /// The ASN of a core network.
        public var asn: Swift.Int?
        /// The IP addresses used for a core network.
        public var cidr: Swift.String?
        /// The ID of the destination.
        public var destinationIdentifier: Swift.String?
        /// The Regions where edges are located in a core network.
        public var edgeLocations: [Swift.String]?
        /// The inside IP addresses used for core network change values.
        public var insideCidrBlocks: [Swift.String]?
        /// The network function group name if the change event is associated with a network function group.
        public var networkFunctionGroupName: Swift.String?
        /// The names of the segments in a core network.
        public var segmentName: Swift.String?
        /// Describes the service insertion action.
        public var serviceInsertionActions: [NetworkManagerClientTypes.ServiceInsertionAction]?
        /// The shared segments for a core network change value.
        public var sharedSegments: [Swift.String]?

        public init(
            asn: Swift.Int? = nil,
            cidr: Swift.String? = nil,
            destinationIdentifier: Swift.String? = nil,
            edgeLocations: [Swift.String]? = nil,
            insideCidrBlocks: [Swift.String]? = nil,
            networkFunctionGroupName: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            serviceInsertionActions: [NetworkManagerClientTypes.ServiceInsertionAction]? = nil,
            sharedSegments: [Swift.String]? = nil
        )
        {
            self.asn = asn
            self.cidr = cidr
            self.destinationIdentifier = destinationIdentifier
            self.edgeLocations = edgeLocations
            self.insideCidrBlocks = insideCidrBlocks
            self.networkFunctionGroupName = networkFunctionGroupName
            self.segmentName = segmentName
            self.serviceInsertionActions = serviceInsertionActions
            self.sharedSegments = sharedSegments
        }
    }

}

extension NetworkManagerClientTypes {
    /// Details describing a core network change.
    public struct CoreNetworkChange {
        /// The action to take for a core network.
        public var action: NetworkManagerClientTypes.ChangeAction?
        /// The resource identifier.
        public var identifier: Swift.String?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public var identifierPath: Swift.String?
        /// The new value for a core network
        public var newValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The previous values for a core network.
        public var previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues?
        /// The type of change.
        public var type: NetworkManagerClientTypes.ChangeType?

        public init(
            action: NetworkManagerClientTypes.ChangeAction? = nil,
            identifier: Swift.String? = nil,
            identifierPath: Swift.String? = nil,
            newValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            previousValues: NetworkManagerClientTypes.CoreNetworkChangeValues? = nil,
            type: NetworkManagerClientTypes.ChangeType? = nil
        )
        {
            self.action = action
            self.identifier = identifier
            self.identifierPath = identifierPath
            self.newValues = newValues
            self.previousValues = previousValues
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network change event.
    public struct CoreNetworkChangeEventValues {
        /// The ID of the attachment if the change event is associated with an attachment.
        public var attachmentId: Swift.String?
        /// For a STATIC_ROUTE event, this is the IP address.
        public var cidr: Swift.String?
        /// The edge location for the core network change event.
        public var edgeLocation: Swift.String?
        /// The changed network function group name.
        public var networkFunctionGroupName: Swift.String?
        /// The segment name if the change event is associated with a segment.
        public var segmentName: Swift.String?

        public init(
            attachmentId: Swift.String? = nil,
            cidr: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            networkFunctionGroupName: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.cidr = cidr
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
            self.segmentName = segmentName
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network change event. This can be a change to a segment, attachment, route, etc.
    public struct CoreNetworkChangeEvent {
        /// The action taken for the change event.
        public var action: NetworkManagerClientTypes.ChangeAction?
        /// The timestamp for an event change in status.
        public var eventTime: Foundation.Date?
        /// Uniquely identifies the path for a change within the changeset. For example, the IdentifierPath for a core network segment change might be "CORE_NETWORK_SEGMENT/us-east-1/devsegment".
        public var identifierPath: Swift.String?
        /// The status of the core network change event.
        public var status: NetworkManagerClientTypes.ChangeStatus?
        /// Describes the type of change event.
        public var type: NetworkManagerClientTypes.ChangeType?
        /// Details of the change event.
        public var values: NetworkManagerClientTypes.CoreNetworkChangeEventValues?

        public init(
            action: NetworkManagerClientTypes.ChangeAction? = nil,
            eventTime: Foundation.Date? = nil,
            identifierPath: Swift.String? = nil,
            status: NetworkManagerClientTypes.ChangeStatus? = nil,
            type: NetworkManagerClientTypes.ChangeType? = nil,
            values: NetworkManagerClientTypes.CoreNetworkChangeEventValues? = nil
        )
        {
            self.action = action
            self.eventTime = eventTime
            self.identifierPath = identifierPath
            self.status = status
            self.type = type
            self.values = values
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network
    public struct CoreNetworkNetworkFunctionGroupIdentifier {
        /// The ID of the core network.
        public var coreNetworkId: Swift.String?
        /// The location for the core network edge.
        public var edgeLocation: Swift.String?
        /// The network function group name.
        public var networkFunctionGroupName: Swift.String?

        public init(
            coreNetworkId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            networkFunctionGroupName: Swift.String? = nil
        )
        {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
        }
    }

}

extension NetworkManagerClientTypes {

    public enum CoreNetworkPolicyAlias: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latest
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [CoreNetworkPolicyAlias] {
            return [
                .latest,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Provides details about an error in a core network policy.
    public struct CoreNetworkPolicyError {
        /// The error code associated with a core network policy error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with a core network policy error code.
        /// This member is required.
        public var message: Swift.String?
        /// The JSON path where the error was discovered in the policy document.
        public var path: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.path = path
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a core network policy. You can have only one LIVE Core Policy.
    public struct CoreNetworkPolicy {
        /// Whether a core network policy is the current LIVE policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The state of a core network policy.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy was created.
        public var createdAt: Foundation.Date?
        /// The description of a core network policy.
        public var description: Swift.String?
        /// Describes a core network policy.
        public var policyDocument: Swift.String?
        /// Describes any errors in a core network policy.
        public var policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init(
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            policyDocument: Swift.String? = nil,
            policyErrors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyDocument = policyDocument
            self.policyErrors = policyErrors
            self.policyVersionId = policyVersionId
        }
    }

}

/// Describes a core network policy exception.
public struct CoreNetworkPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Describes a core network policy exception.
        public internal(set) var errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CoreNetworkPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errors: [NetworkManagerClientTypes.CoreNetworkPolicyError]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errors = errors
        self.properties.message = message
    }
}

extension NetworkManagerClientTypes {
    /// Describes a core network policy version.
    public struct CoreNetworkPolicyVersion {
        /// Whether a core network policy is the current policy or the most recently submitted policy.
        public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
        /// The status of the policy version change set.
        public var changeSetState: NetworkManagerClientTypes.ChangeSetState?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The timestamp when a core network policy version was created.
        public var createdAt: Foundation.Date?
        /// The description of a core network policy version.
        public var description: Swift.String?
        /// The ID of the policy version.
        public var policyVersionId: Swift.Int?

        public init(
            alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
            changeSetState: NetworkManagerClientTypes.ChangeSetState? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            policyVersionId: Swift.Int? = nil
        )
        {
            self.alias = alias
            self.changeSetState = changeSetState
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.description = description
            self.policyVersionId = policyVersionId
        }
    }

}

extension NetworkManagerClientTypes {
    /// Returns details about a core network edge.
    public struct CoreNetworkSegmentEdgeIdentifier {
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The Region where the segment edge is located.
        public var edgeLocation: Swift.String?
        /// The name of the segment edge.
        public var segmentName: Swift.String?

        public init(
            coreNetworkId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            segmentName: Swift.String? = nil
        )
        {
            self.coreNetworkId = coreNetworkId
            self.edgeLocation = edgeLocation
            self.segmentName = segmentName
        }
    }

}

extension NetworkManagerClientTypes {
    /// Returns summary information about a core network.
    public struct CoreNetworkSummary {
        /// a core network ARN.
        public var coreNetworkArn: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The description of a core network.
        public var description: Swift.String?
        /// The global network ID.
        public var globalNetworkId: Swift.String?
        /// The ID of the account owner.
        public var ownerAccountId: Swift.String?
        /// The state of a core network.
        public var state: NetworkManagerClientTypes.CoreNetworkState?
        /// The key-value tags associated with a core network summary.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            state: NetworkManagerClientTypes.CoreNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.ownerAccountId = ownerAccountId
            self.state = state
            self.tags = tags
        }
    }

}

public struct CreateConnectAttachmentInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you want to create the attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    /// This member is required.
    public var edgeLocation: Swift.String?
    /// Options for creating an attachment.
    /// This member is required.
    public var options: NetworkManagerClientTypes.ConnectAttachmentOptions?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ID of the attachment between the two connections.
    /// This member is required.
    public var transportAttachmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        options: NetworkManagerClientTypes.ConnectAttachmentOptions? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transportAttachmentId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.options = options
        self.tags = tags
        self.transportAttachmentId = transportAttachmentId
    }
}

public struct CreateConnectAttachmentOutput {
    /// The response to a Connect attachment request.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init(
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

public struct CreateConnectionInput {
    /// The ID of the second device in the connection.
    /// This member is required.
    public var connectedDeviceId: Swift.String?
    /// The ID of the link for the second device.
    public var connectedLinkId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the first device in the connection.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device.
    public var linkId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        connectedDeviceId: Swift.String? = nil,
        connectedLinkId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.tags = tags
    }
}

public struct CreateConnectionOutput {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init(
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

public struct CreateConnectPeerInput {
    /// The Connect peer BGP options. This only applies only when the protocol is GRE.
    public var bgpOptions: NetworkManagerClientTypes.BgpOptions?
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of the connection attachment.
    /// This member is required.
    public var connectAttachmentId: Swift.String?
    /// A Connect peer core network address. This only applies only when the protocol is GRE.
    public var coreNetworkAddress: Swift.String?
    /// The inside IP addresses used for BGP peering.
    public var insideCidrBlocks: [Swift.String]?
    /// The Connect peer address.
    /// This member is required.
    public var peerAddress: Swift.String?
    /// The subnet ARN for the Connect peer. This only applies only when the protocol is NO_ENCAP.
    public var subnetArn: Swift.String?
    /// The tags associated with the peer request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        bgpOptions: NetworkManagerClientTypes.BgpOptions? = nil,
        clientToken: Swift.String? = nil,
        connectAttachmentId: Swift.String? = nil,
        coreNetworkAddress: Swift.String? = nil,
        insideCidrBlocks: [Swift.String]? = nil,
        peerAddress: Swift.String? = nil,
        subnetArn: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.bgpOptions = bgpOptions
        self.clientToken = clientToken
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkAddress = coreNetworkAddress
        self.insideCidrBlocks = insideCidrBlocks
        self.peerAddress = peerAddress
        self.subnetArn = subnetArn
        self.tags = tags
    }
}

public struct CreateConnectPeerOutput {
    /// The response to the request.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init(
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

public struct CreateCoreNetworkInput {
    /// The client token associated with a core network request.
    public var clientToken: Swift.String?
    /// The description of a core network.
    public var description: Swift.String?
    /// The ID of the global network that a core network will be a part of.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The policy document for creating a core network.
    public var policyDocument: Swift.String?
    /// Key-value tags associated with a core network request.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.policyDocument = policyDocument
        self.tags = tags
    }
}

public struct CreateCoreNetworkOutput {
    /// Returns details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init(
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

extension NetworkManagerClientTypes {
    /// Describes a location.
    public struct Location {
        /// The physical address.
        public var address: Swift.String?
        /// The latitude.
        public var latitude: Swift.String?
        /// The longitude.
        public var longitude: Swift.String?

        public init(
            address: Swift.String? = nil,
            latitude: Swift.String? = nil,
            longitude: Swift.String? = nil
        )
        {
            self.address = address
            self.latitude = latitude
            self.longitude = longitude
        }
    }

}

extension NetworkManagerClientTypes.Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreateDeviceInput {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var awsLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The location of the device.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init(
        awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.awsLocation = awsLocation
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

extension CreateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeviceInput(awsLocation: \(Swift.String(describing: awsLocation)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

extension NetworkManagerClientTypes {

    public enum DeviceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a device.
    public struct Device {
        /// The Amazon Web Services location of the device.
        public var awsLocation: NetworkManagerClientTypes.AWSLocation?
        /// The date and time that the site was created.
        public var createdAt: Foundation.Date?
        /// The description of the device.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var deviceArn: Swift.String?
        /// The ID of the device.
        public var deviceId: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The site location.
        public var location: NetworkManagerClientTypes.Location?
        /// The device model.
        public var model: Swift.String?
        /// The device serial number.
        public var serialNumber: Swift.String?
        /// The site ID.
        public var siteId: Swift.String?
        /// The device state.
        public var state: NetworkManagerClientTypes.DeviceState?
        /// The tags for the device.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The device type.
        public var type: Swift.String?
        /// The device vendor.
        public var vendor: Swift.String?

        public init(
            awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            model: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.DeviceState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.awsLocation = awsLocation
            self.createdAt = createdAt
            self.description = description
            self.deviceArn = deviceArn
            self.deviceId = deviceId
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.model = model
            self.serialNumber = serialNumber
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
            self.vendor = vendor
        }
    }

}

extension NetworkManagerClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(awsLocation: \(Swift.String(describing: awsLocation)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), deviceArn: \(Swift.String(describing: deviceArn)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

public struct CreateDeviceOutput {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init(
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

public struct CreateGlobalNetworkInput {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

extension NetworkManagerClientTypes {

    public enum GlobalNetworkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalNetworkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a global network. This is a single private network acting as a high-level container for your network objects, including an Amazon Web Services-managed Core Network.
    public struct GlobalNetwork {
        /// The date and time that the global network was created.
        public var createdAt: Foundation.Date?
        /// The description of the global network.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the global network.
        public var globalNetworkArn: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the global network.
        public var state: NetworkManagerClientTypes.GlobalNetworkState?
        /// The tags for the global network.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkArn: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.GlobalNetworkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkArn = globalNetworkArn
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.tags = tags
        }
    }

}

public struct CreateGlobalNetworkOutput {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init(
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

public struct CreateLinkInput {
    /// The upload speed and download speed in Mbps.
    /// This member is required.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var provider: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The type of the link. Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^
    public var type: Swift.String?

    public init(
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.provider = provider
        self.siteId = siteId
        self.tags = tags
        self.type = type
    }
}

extension NetworkManagerClientTypes {

    public enum LinkState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a link.
    public struct Link {
        /// The bandwidth for the link.
        public var bandwidth: NetworkManagerClientTypes.Bandwidth?
        /// The date and time that the link was created.
        public var createdAt: Foundation.Date?
        /// The description of the link.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The Amazon Resource Name (ARN) of the link.
        public var linkArn: Swift.String?
        /// The ID of the link.
        public var linkId: Swift.String?
        /// The provider of the link.
        public var provider: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the link.
        public var state: NetworkManagerClientTypes.LinkState?
        /// The tags for the link.
        public var tags: [NetworkManagerClientTypes.Tag]?
        /// The type of the link.
        public var type: Swift.String?

        public init(
            bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            linkArn: Swift.String? = nil,
            linkId: Swift.String? = nil,
            provider: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.LinkState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.bandwidth = bandwidth
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.linkArn = linkArn
            self.linkId = linkId
            self.provider = provider
            self.siteId = siteId
            self.state = state
            self.tags = tags
            self.type = type
        }
    }

}

public struct CreateLinkOutput {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init(
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

public struct CreateSiteInput {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The tags to apply to the resource during creation.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.tags = tags
    }
}

extension CreateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), tags: \(Swift.String(describing: tags)), location: \"CONTENT_REDACTED\")"}
}

extension NetworkManagerClientTypes {

    public enum SiteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case pending
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [SiteState] {
            return [
                .available,
                .deleting,
                .pending,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .pending: return "PENDING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a site.
    public struct Site {
        /// The date and time that the site was created.
        public var createdAt: Foundation.Date?
        /// The description of the site.
        public var description: Swift.String?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The location of the site.
        public var location: NetworkManagerClientTypes.Location?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The state of the site.
        public var state: NetworkManagerClientTypes.SiteState?
        /// The tags for the site.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            globalNetworkId: Swift.String? = nil,
            location: NetworkManagerClientTypes.Location? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            state: NetworkManagerClientTypes.SiteState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.globalNetworkId = globalNetworkId
            self.location = location
            self.siteArn = siteArn
            self.siteId = siteId
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), location: \"CONTENT_REDACTED\")"}
}

public struct CreateSiteOutput {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init(
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct CreateSiteToSiteVpnAttachmentInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network where you're creating a site-to-site VPN attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN identifying the VPN attachment.
    /// This member is required.
    public var vpnConnectionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpnConnectionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.tags = tags
        self.vpnConnectionArn = vpnConnectionArn
    }
}

extension NetworkManagerClientTypes {
    /// Creates a site-to-site VPN attachment.
    public struct SiteToSiteVpnAttachment {
        /// Provides details about a site-to-site VPN attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// The ARN of the site-to-site VPN attachment.
        public var vpnConnectionArn: Swift.String?

        public init(
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            vpnConnectionArn: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.vpnConnectionArn = vpnConnectionArn
        }
    }

}

public struct CreateSiteToSiteVpnAttachmentOutput {
    /// Details about a site-to-site VPN attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init(
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

public struct CreateTransitGatewayPeeringInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the transit gateway for the peering request.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.tags = tags
        self.transitGatewayArn = transitGatewayArn
    }
}

extension NetworkManagerClientTypes {

    public enum PeeringErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edgeLocationPeerDuplicate
        case internalError
        case invalidTransitGatewayState
        case missingRequiredPermissions
        case transitGatewayNotFound
        case transitGatewayPeersLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PeeringErrorCode] {
            return [
                .edgeLocationPeerDuplicate,
                .internalError,
                .invalidTransitGatewayState,
                .missingRequiredPermissions,
                .transitGatewayNotFound,
                .transitGatewayPeersLimitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edgeLocationPeerDuplicate: return "EDGE_LOCATION_PEER_DUPLICATE"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidTransitGatewayState: return "INVALID_TRANSIT_GATEWAY_STATE"
            case .missingRequiredPermissions: return "MISSING_PERMISSIONS"
            case .transitGatewayNotFound: return "TRANSIT_GATEWAY_NOT_FOUND"
            case .transitGatewayPeersLimitExceeded: return "TRANSIT_GATEWAY_PEERS_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes additional information about missing permissions.
    public struct PermissionsErrorContext {
        /// The missing permissions.
        public var missingPermission: Swift.String?

        public init(
            missingPermission: Swift.String? = nil
        )
        {
            self.missingPermission = missingPermission
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes an error associated with a peering request.
    public struct PeeringError {
        /// The error code for the peering request.
        public var code: NetworkManagerClientTypes.PeeringErrorCode?
        /// The message associated with the error code.
        public var message: Swift.String?
        /// Provides additional information about missing permissions for the peering error.
        public var missingPermissionsContext: NetworkManagerClientTypes.PermissionsErrorContext?
        /// The ID of the Peering request.
        public var requestId: Swift.String?
        /// The ARN of the requested peering resource.
        public var resourceArn: Swift.String?

        public init(
            code: NetworkManagerClientTypes.PeeringErrorCode? = nil,
            message: Swift.String? = nil,
            missingPermissionsContext: NetworkManagerClientTypes.PermissionsErrorContext? = nil,
            requestId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.missingPermissionsContext = missingPermissionsContext
            self.requestId = requestId
            self.resourceArn = resourceArn
        }
    }

}

extension NetworkManagerClientTypes {

    public enum PeeringType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case transitGateway
        case sdkUnknown(Swift.String)

        public static var allCases: [PeeringType] {
            return [
                .transitGateway
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .transitGateway: return "TRANSIT_GATEWAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum PeeringState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [PeeringState] {
            return [
                .available,
                .creating,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a peering connection.
    public struct Peering {
        /// The ARN of a core network.
        public var coreNetworkArn: Swift.String?
        /// The ID of the core network for the peering request.
        public var coreNetworkId: Swift.String?
        /// The timestamp when the attachment peer was created.
        public var createdAt: Foundation.Date?
        /// The edge location for the peer.
        public var edgeLocation: Swift.String?
        /// Describes the error associated with the Connect peer request.
        public var lastModificationErrors: [NetworkManagerClientTypes.PeeringError]?
        /// The ID of the account owner.
        public var ownerAccountId: Swift.String?
        /// The ID of the peering attachment.
        public var peeringId: Swift.String?
        /// The type of peering. This will be TRANSIT_GATEWAY.
        public var peeringType: NetworkManagerClientTypes.PeeringType?
        /// The resource ARN of the peer.
        public var resourceArn: Swift.String?
        /// The current state of the peering connection.
        public var state: NetworkManagerClientTypes.PeeringState?
        /// The list of key-value tags associated with the peering.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            coreNetworkArn: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            edgeLocation: Swift.String? = nil,
            lastModificationErrors: [NetworkManagerClientTypes.PeeringError]? = nil,
            ownerAccountId: Swift.String? = nil,
            peeringId: Swift.String? = nil,
            peeringType: NetworkManagerClientTypes.PeeringType? = nil,
            resourceArn: Swift.String? = nil,
            state: NetworkManagerClientTypes.PeeringState? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.coreNetworkArn = coreNetworkArn
            self.coreNetworkId = coreNetworkId
            self.createdAt = createdAt
            self.edgeLocation = edgeLocation
            self.lastModificationErrors = lastModificationErrors
            self.ownerAccountId = ownerAccountId
            self.peeringId = peeringId
            self.peeringType = peeringType
            self.resourceArn = resourceArn
            self.state = state
            self.tags = tags
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway peering attachment.
    public struct TransitGatewayPeering {
        /// Describes a transit gateway peer connection.
        public var peering: NetworkManagerClientTypes.Peering?
        /// The ARN of the transit gateway.
        public var transitGatewayArn: Swift.String?
        /// The ID of the transit gateway peering attachment.
        public var transitGatewayPeeringAttachmentId: Swift.String?

        public init(
            peering: NetworkManagerClientTypes.Peering? = nil,
            transitGatewayArn: Swift.String? = nil,
            transitGatewayPeeringAttachmentId: Swift.String? = nil
        )
        {
            self.peering = peering
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayPeeringAttachmentId = transitGatewayPeeringAttachmentId
        }
    }

}

public struct CreateTransitGatewayPeeringOutput {
    /// Returns information about the transit gateway peering connection request.
    public var transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?

    public init(
        transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering? = nil
    )
    {
        self.transitGatewayPeering = transitGatewayPeering
    }
}

public struct CreateTransitGatewayRouteTableAttachmentInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of the peer for the
    /// This member is required.
    public var peeringId: Swift.String?
    /// The list of key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
    /// This member is required.
    public var transitGatewayRouteTableArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        peeringId: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        transitGatewayRouteTableArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.peeringId = peeringId
        self.tags = tags
        self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
    }
}

extension NetworkManagerClientTypes {
    /// Describes a transit gateway route table attachment.
    public struct TransitGatewayRouteTableAttachment {
        /// Describes a core network attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// The ID of the peering attachment.
        public var peeringId: Swift.String?
        /// The ARN of the transit gateway attachment route table. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public var transitGatewayRouteTableArn: Swift.String?

        public init(
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            peeringId: Swift.String? = nil,
            transitGatewayRouteTableArn: Swift.String? = nil
        )
        {
            self.attachment = attachment
            self.peeringId = peeringId
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }
    }

}

public struct CreateTransitGatewayRouteTableAttachmentOutput {
    /// The route table associated with the create transit gateway route table attachment request.
    public var transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?

    public init(
        transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment? = nil
    )
    {
        self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
    }
}

extension NetworkManagerClientTypes {
    /// Describes the VPC options.
    public struct VpcOptions {
        /// Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is false.
        public var applianceModeSupport: Swift.Bool
        /// Indicates whether IPv6 is supported.
        public var ipv6Support: Swift.Bool

        public init(
            applianceModeSupport: Swift.Bool = false,
            ipv6Support: Swift.Bool = false
        )
        {
            self.applianceModeSupport = applianceModeSupport
            self.ipv6Support = ipv6Support
        }
    }

}

public struct CreateVpcAttachmentInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network for the VPC attachment.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// Options for the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// The subnet ARN of the VPC attachment.
    /// This member is required.
    public var subnetArns: [Swift.String]?
    /// The key-value tags associated with the request.
    public var tags: [NetworkManagerClientTypes.Tag]?
    /// The ARN of the VPC.
    /// This member is required.
    public var vpcArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        subnetArns: [Swift.String]? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil,
        vpcArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.options = options
        self.subnetArns = subnetArns
        self.tags = tags
        self.vpcArn = vpcArn
    }
}

extension NetworkManagerClientTypes {
    /// Describes a VPC attachment.
    public struct VpcAttachment {
        /// Provides details about the VPC attachment.
        public var attachment: NetworkManagerClientTypes.Attachment?
        /// Provides details about the VPC attachment.
        public var options: NetworkManagerClientTypes.VpcOptions?
        /// The subnet ARNs.
        public var subnetArns: [Swift.String]?

        public init(
            attachment: NetworkManagerClientTypes.Attachment? = nil,
            options: NetworkManagerClientTypes.VpcOptions? = nil,
            subnetArns: [Swift.String]? = nil
        )
        {
            self.attachment = attachment
            self.options = options
            self.subnetArns = subnetArns
        }
    }

}

public struct CreateVpcAttachmentOutput {
    /// Provides details about the VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init(
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

public struct DeleteAttachmentInput {
    /// The ID of the attachment to delete.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct DeleteAttachmentOutput {
    /// Information about the deleted attachment.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init(
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

public struct DeleteConnectionInput {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.globalNetworkId = globalNetworkId
    }
}

public struct DeleteConnectionOutput {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init(
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

public struct DeleteConnectPeerInput {
    /// The ID of the deleted Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init(
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

public struct DeleteConnectPeerOutput {
    /// Information about the deleted Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init(
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

public struct DeleteCoreNetworkInput {
    /// The network ID of the deleted core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init(
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

public struct DeleteCoreNetworkOutput {
    /// Information about the deleted core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init(
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

public struct DeleteCoreNetworkPolicyVersionInput {
    /// The ID of a core network for the deleted policy.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The version ID of the deleted policy.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init(
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

public struct DeleteCoreNetworkPolicyVersionOutput {
    /// Returns information about the deleted policy version.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init(
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

public struct DeleteDeviceInput {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
    }
}

public struct DeleteDeviceOutput {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init(
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

public struct DeleteGlobalNetworkInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
    }
}

public struct DeleteGlobalNetworkOutput {
    /// Information about the global network.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init(
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

public struct DeleteLinkInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

public struct DeleteLinkOutput {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init(
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

public struct DeletePeeringInput {
    /// The ID of the peering connection to delete.
    /// This member is required.
    public var peeringId: Swift.String?

    public init(
        peeringId: Swift.String? = nil
    )
    {
        self.peeringId = peeringId
    }
}

public struct DeletePeeringOutput {
    /// Information about a deleted peering connection.
    public var peering: NetworkManagerClientTypes.Peering?

    public init(
        peering: NetworkManagerClientTypes.Peering? = nil
    )
    {
        self.peering = peering
    }
}

public struct DeleteResourcePolicyInput {
    /// The ARN of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

public struct DeleteSiteInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.siteId = siteId
    }
}

public struct DeleteSiteOutput {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init(
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct DeregisterTransitGatewayInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

extension NetworkManagerClientTypes {

    public enum TransitGatewayRegistrationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitGatewayRegistrationState] {
            return [
                .available,
                .deleted,
                .deleting,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes the status of a transit gateway registration.
    public struct TransitGatewayRegistrationStateReason {
        /// The code for the state reason.
        public var code: NetworkManagerClientTypes.TransitGatewayRegistrationState?
        /// The message for the state reason.
        public var message: Swift.String?

        public init(
            code: NetworkManagerClientTypes.TransitGatewayRegistrationState? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes the registration of a transit gateway to a global network.
    public struct TransitGatewayRegistration {
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// The state of the transit gateway registration.
        public var state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason?
        /// The Amazon Resource Name (ARN) of the transit gateway.
        public var transitGatewayArn: Swift.String?

        public init(
            globalNetworkId: Swift.String? = nil,
            state: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason? = nil,
            transitGatewayArn: Swift.String? = nil
        )
        {
            self.globalNetworkId = globalNetworkId
            self.state = state
            self.transitGatewayArn = transitGatewayArn
        }
    }

}

public struct DeregisterTransitGatewayOutput {
    /// The transit gateway registration information.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init(
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

public struct DescribeGlobalNetworksInput {
    /// The IDs of one or more global networks. The maximum is 10.
    public var globalNetworkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        globalNetworkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworkIds = globalNetworkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeGlobalNetworksOutput {
    /// Information about the global networks.
    public var globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        globalNetworks: [NetworkManagerClientTypes.GlobalNetwork]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.globalNetworks = globalNetworks
        self.nextToken = nextToken
    }
}

public struct DisassociateConnectPeerInput {
    /// The ID of the Connect peer to disassociate from a device.
    /// This member is required.
    public var connectPeerId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        connectPeerId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
        self.globalNetworkId = globalNetworkId
    }
}

public struct DisassociateConnectPeerOutput {
    /// Describes the Connect peer association.
    public var connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation?

    public init(
        connectPeerAssociation: NetworkManagerClientTypes.ConnectPeerAssociation? = nil
    )
    {
        self.connectPeerAssociation = connectPeerAssociation
    }
}

public struct DisassociateCustomerGatewayInput {
    /// The Amazon Resource Name (ARN) of the customer gateway.
    /// This member is required.
    public var customerGatewayArn: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        customerGatewayArn: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.globalNetworkId = globalNetworkId
    }
}

public struct DisassociateCustomerGatewayOutput {
    /// Information about the customer gateway association.
    public var customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation?

    public init(
        customerGatewayAssociation: NetworkManagerClientTypes.CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

public struct DisassociateLinkInput {
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

public struct DisassociateLinkOutput {
    /// Information about the link association.
    public var linkAssociation: NetworkManagerClientTypes.LinkAssociation?

    public init(
        linkAssociation: NetworkManagerClientTypes.LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

public struct DisassociateTransitGatewayConnectPeerInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway Connect peer.
    /// This member is required.
    public var transitGatewayConnectPeerArn: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        transitGatewayConnectPeerArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

public struct DisassociateTransitGatewayConnectPeerOutput {
    /// The transit gateway Connect peer association.
    public var transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation?

    public init(
        transitGatewayConnectPeerAssociation: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

public struct ExecuteCoreNetworkChangeSetInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init(
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

public struct ExecuteCoreNetworkChangeSetOutput {

    public init() { }
}

public struct GetConnectAttachmentInput {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct GetConnectAttachmentOutput {
    /// Details about the Connect attachment.
    public var connectAttachment: NetworkManagerClientTypes.ConnectAttachment?

    public init(
        connectAttachment: NetworkManagerClientTypes.ConnectAttachment? = nil
    )
    {
        self.connectAttachment = connectAttachment
    }
}

public struct GetConnectionsInput {
    /// One or more connection IDs.
    public var connectionIds: [Swift.String]?
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connectionIds: [Swift.String]? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionIds = connectionIds
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetConnectionsOutput {
    /// Information about the connections.
    public var connections: [NetworkManagerClientTypes.Connection]?
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connections: [NetworkManagerClientTypes.Connection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

public struct GetConnectPeerInput {
    /// The ID of the Connect peer.
    /// This member is required.
    public var connectPeerId: Swift.String?

    public init(
        connectPeerId: Swift.String? = nil
    )
    {
        self.connectPeerId = connectPeerId
    }
}

public struct GetConnectPeerOutput {
    /// Returns information about a core network Connect peer.
    public var connectPeer: NetworkManagerClientTypes.ConnectPeer?

    public init(
        connectPeer: NetworkManagerClientTypes.ConnectPeer? = nil
    )
    {
        self.connectPeer = connectPeer
    }
}

public struct GetConnectPeerAssociationsInput {
    /// The IDs of the Connect peers.
    public var connectPeerIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connectPeerIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerIds = connectPeerIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetConnectPeerAssociationsOutput {
    /// Displays a list of Connect peer associations.
    public var connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connectPeerAssociations: [NetworkManagerClientTypes.ConnectPeerAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeerAssociations = connectPeerAssociations
        self.nextToken = nextToken
    }
}

public struct GetCoreNetworkInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?

    public init(
        coreNetworkId: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
    }
}

public struct GetCoreNetworkOutput {
    /// Details about a core network.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init(
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

public struct GetCoreNetworkChangeEventsInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init(
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyVersionId = policyVersionId
    }
}

public struct GetCoreNetworkChangeEventsOutput {
    /// The response to GetCoreNetworkChangeEventsRequest.
    public var coreNetworkChangeEvents: [NetworkManagerClientTypes.CoreNetworkChangeEvent]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        coreNetworkChangeEvents: [NetworkManagerClientTypes.CoreNetworkChangeEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkChangeEvents = coreNetworkChangeEvents
        self.nextToken = nextToken
    }
}

public struct GetCoreNetworkChangeSetInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the policy version.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init(
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyVersionId = policyVersionId
    }
}

public struct GetCoreNetworkChangeSetOutput {
    /// Describes a core network changes.
    public var coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        coreNetworkChanges: [NetworkManagerClientTypes.CoreNetworkChange]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkChanges = coreNetworkChanges
        self.nextToken = nextToken
    }
}

public struct GetCoreNetworkPolicyInput {
    /// The alias of a core network policy
    public var alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of a core network policy version.
    public var policyVersionId: Swift.Int?

    public init(
        alias: NetworkManagerClientTypes.CoreNetworkPolicyAlias? = nil,
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.alias = alias
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

public struct GetCoreNetworkPolicyOutput {
    /// The details about a core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init(
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

public struct GetCustomerGatewayAssociationsInput {
    /// One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.
    public var customerGatewayArns: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        customerGatewayArns: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayArns = customerGatewayArns
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetCustomerGatewayAssociationsOutput {
    /// The customer gateway associations.
    public var customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        customerGatewayAssociations: [NetworkManagerClientTypes.CustomerGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerGatewayAssociations = customerGatewayAssociations
        self.nextToken = nextToken
    }
}

public struct GetDevicesInput {
    /// One or more device IDs. The maximum is 10.
    public var deviceIds: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?

    public init(
        deviceIds: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteId = siteId
    }
}

public struct GetDevicesOutput {
    /// The devices.
    public var devices: [NetworkManagerClientTypes.Device]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        devices: [NetworkManagerClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct GetLinkAssociationsInput {
    /// The ID of the device.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    public var linkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetLinkAssociationsOutput {
    /// The link associations.
    public var linkAssociations: [NetworkManagerClientTypes.LinkAssociation]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        linkAssociations: [NetworkManagerClientTypes.LinkAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkAssociations = linkAssociations
        self.nextToken = nextToken
    }
}

public struct GetLinksInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// One or more link IDs. The maximum is 10.
    public var linkIds: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The link provider.
    public var provider: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The link type.
    public var type: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        linkIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provider: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkIds = linkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provider = provider
        self.siteId = siteId
        self.type = type
    }
}

public struct GetLinksOutput {
    /// The links.
    public var links: [NetworkManagerClientTypes.Link]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        links: [NetworkManagerClientTypes.Link]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.links = links
        self.nextToken = nextToken
    }
}

public struct GetNetworkResourceCountsInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * attachment
    ///
    /// * connect-peer
    ///
    /// * connection
    ///
    /// * core-network
    ///
    /// * device
    ///
    /// * link
    ///
    /// * peering
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

extension NetworkManagerClientTypes {
    /// Describes a resource count.
    public struct NetworkResourceCount {
        /// The resource count.
        public var count: Swift.Int?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            count: Swift.Int? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.count = count
            self.resourceType = resourceType
        }
    }

}

public struct GetNetworkResourceCountsOutput {
    /// The count of resources.
    public var networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkResourceCounts: [NetworkManagerClientTypes.NetworkResourceCount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResourceCounts = networkResourceCounts
        self.nextToken = nextToken
    }
}

public struct GetNetworkResourceRelationshipsInput {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the registered gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the gateway.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * attachment
    ///
    /// * connect-peer
    ///
    /// * connection
    ///
    /// * core-network
    ///
    /// * device
    ///
    /// * link
    ///
    /// * peering
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

extension NetworkManagerClientTypes {
    /// Describes a resource relationship.
    public struct Relationship {
        /// The ARN of the resource.
        public var from: Swift.String?
        /// The ARN of the resource.
        public var to: Swift.String?

        public init(
            from: Swift.String? = nil,
            to: Swift.String? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

public struct GetNetworkResourceRelationshipsOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The resource relationships.
    public var relationships: [NetworkManagerClientTypes.Relationship]?

    public init(
        nextToken: Swift.String? = nil,
        relationships: [NetworkManagerClientTypes.Relationship]? = nil
    )
    {
        self.nextToken = nextToken
        self.relationships = relationships
    }
}

public struct GetNetworkResourcesInput {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types for Direct Connect:
    ///
    /// * dxcon
    ///
    /// * dx-gateway
    ///
    /// * dx-vif
    ///
    ///
    /// The following are the supported resource types for Network Manager:
    ///
    /// * attachment
    ///
    /// * connect-peer
    ///
    /// * connection
    ///
    /// * core-network
    ///
    /// * device
    ///
    /// * link
    ///
    /// * peering
    ///
    /// * site
    ///
    ///
    /// The following are the supported resource types for Amazon VPC:
    ///
    /// * customer-gateway
    ///
    /// * transit-gateway
    ///
    /// * transit-gateway-attachment
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * transit-gateway-route-table
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResource {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// The time that the resource definition was retrieved.
        public var definitionTimestamp: Foundation.Date?
        /// The resource metadata.
        public var metadata: [Swift.String: Swift.String]?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type. The following are the supported resource types for Direct Connect:
        ///
        /// * dxcon
        ///
        /// * dx-gateway
        ///
        /// * dx-vif
        ///
        ///
        /// The following are the supported resource types for Network Manager:
        ///
        /// * attachment
        ///
        /// * connect-peer
        ///
        /// * connection
        ///
        /// * core-network
        ///
        /// * device
        ///
        /// * link
        ///
        /// * peering
        ///
        /// * site
        ///
        ///
        /// The following are the supported resource types for Amazon VPC:
        ///
        /// * customer-gateway
        ///
        /// * transit-gateway
        ///
        /// * transit-gateway-attachment
        ///
        /// * transit-gateway-connect-peer
        ///
        /// * transit-gateway-route-table
        ///
        /// * vpn-connection
        public var resourceType: Swift.String?
        /// The tags.
        public var tags: [NetworkManagerClientTypes.Tag]?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            definition: Swift.String? = nil,
            definitionTimestamp: Foundation.Date? = nil,
            metadata: [Swift.String: Swift.String]? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            tags: [NetworkManagerClientTypes.Tag]? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.definition = definition
            self.definitionTimestamp = definitionTimestamp
            self.metadata = metadata
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.tags = tags
        }
    }

}

public struct GetNetworkResourcesOutput {
    /// The network resources.
    public var networkResources: [NetworkManagerClientTypes.NetworkResource]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkResources: [NetworkManagerClientTypes.NetworkResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkResources = networkResources
        self.nextToken = nextToken
    }
}

extension NetworkManagerClientTypes {
    /// Describes a route table.
    public struct RouteTableIdentifier {
        /// The route table identifier associated with the network function group.
        public var coreNetworkNetworkFunctionGroup: NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroupIdentifier?
        /// The segment edge in a core network.
        public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
        /// The ARN of the transit gateway route table for the attachment request. For example, "TransitGatewayRouteTableArn": "arn:aws:ec2:us-west-2:123456789012:transit-gateway-route-table/tgw-rtb-9876543210123456".
        public var transitGatewayRouteTableArn: Swift.String?

        public init(
            coreNetworkNetworkFunctionGroup: NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroupIdentifier? = nil,
            coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
            transitGatewayRouteTableArn: Swift.String? = nil
        )
        {
            self.coreNetworkNetworkFunctionGroup = coreNetworkNetworkFunctionGroup
            self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
            self.transitGatewayRouteTableArn = transitGatewayRouteTableArn
        }
    }

}

extension NetworkManagerClientTypes {

    public enum RouteState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case blackhole
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteState] {
            return [
                .active,
                .blackhole
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .blackhole: return "BLACKHOLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case propagated
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .propagated,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .propagated: return "PROPAGATED"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNetworkRoutesInput {
    /// Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.
    public var destinationFilters: [Swift.String: [Swift.String]]?
    /// An exact CIDR block.
    public var exactCidrMatches: [Swift.String]?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The most specific route that matches the traffic (longest prefix match).
    public var longestPrefixMatches: [Swift.String]?
    /// The IDs of the prefix lists.
    public var prefixListIds: [Swift.String]?
    /// The ID of the route table.
    /// This member is required.
    public var routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier?
    /// The route states.
    public var states: [NetworkManagerClientTypes.RouteState]?
    /// The routes with a subnet that match the specified CIDR filter.
    public var subnetOfMatches: [Swift.String]?
    /// The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.
    public var supernetOfMatches: [Swift.String]?
    /// The route types.
    public var types: [NetworkManagerClientTypes.RouteType]?

    public init(
        destinationFilters: [Swift.String: [Swift.String]]? = nil,
        exactCidrMatches: [Swift.String]? = nil,
        globalNetworkId: Swift.String? = nil,
        longestPrefixMatches: [Swift.String]? = nil,
        prefixListIds: [Swift.String]? = nil,
        routeTableIdentifier: NetworkManagerClientTypes.RouteTableIdentifier? = nil,
        states: [NetworkManagerClientTypes.RouteState]? = nil,
        subnetOfMatches: [Swift.String]? = nil,
        supernetOfMatches: [Swift.String]? = nil,
        types: [NetworkManagerClientTypes.RouteType]? = nil
    )
    {
        self.destinationFilters = destinationFilters
        self.exactCidrMatches = exactCidrMatches
        self.globalNetworkId = globalNetworkId
        self.longestPrefixMatches = longestPrefixMatches
        self.prefixListIds = prefixListIds
        self.routeTableIdentifier = routeTableIdentifier
        self.states = states
        self.subnetOfMatches = subnetOfMatches
        self.supernetOfMatches = supernetOfMatches
        self.types = types
    }
}

extension NetworkManagerClientTypes {
    /// Describes the destination of a network route.
    public struct NetworkRouteDestination {
        /// The ID of a core network attachment.
        public var coreNetworkAttachmentId: Swift.String?
        /// The edge location for the network destination.
        public var edgeLocation: Swift.String?
        /// The network function group name associated with the destination.
        public var networkFunctionGroupName: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The name of the segment.
        public var segmentName: Swift.String?
        /// The ID of the transit gateway attachment.
        public var transitGatewayAttachmentId: Swift.String?

        public init(
            coreNetworkAttachmentId: Swift.String? = nil,
            edgeLocation: Swift.String? = nil,
            networkFunctionGroupName: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            segmentName: Swift.String? = nil,
            transitGatewayAttachmentId: Swift.String? = nil
        )
        {
            self.coreNetworkAttachmentId = coreNetworkAttachmentId
            self.edgeLocation = edgeLocation
            self.networkFunctionGroupName = networkFunctionGroupName
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.segmentName = segmentName
            self.transitGatewayAttachmentId = transitGatewayAttachmentId
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a network route.
    public struct NetworkRoute {
        /// A unique identifier for the route, such as a CIDR block.
        public var destinationCidrBlock: Swift.String?
        /// The destinations.
        public var destinations: [NetworkManagerClientTypes.NetworkRouteDestination]?
        /// The ID of the prefix list.
        public var prefixListId: Swift.String?
        /// The route state. The possible values are active and blackhole.
        public var state: NetworkManagerClientTypes.RouteState?
        /// The route type. The possible values are propagated and static.
        public var type: NetworkManagerClientTypes.RouteType?

        public init(
            destinationCidrBlock: Swift.String? = nil,
            destinations: [NetworkManagerClientTypes.NetworkRouteDestination]? = nil,
            prefixListId: Swift.String? = nil,
            state: NetworkManagerClientTypes.RouteState? = nil,
            type: NetworkManagerClientTypes.RouteType? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.destinations = destinations
            self.prefixListId = prefixListId
            self.state = state
            self.type = type
        }
    }

}

extension NetworkManagerClientTypes {

    public enum RouteTableType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coreNetworkSegment
        case networkFunctionGroup
        case transitGatewayRouteTable
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTableType] {
            return [
                .coreNetworkSegment,
                .networkFunctionGroup,
                .transitGatewayRouteTable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coreNetworkSegment: return "CORE_NETWORK_SEGMENT"
            case .networkFunctionGroup: return "NETWORK_FUNCTION_GROUP"
            case .transitGatewayRouteTable: return "TRANSIT_GATEWAY_ROUTE_TABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetNetworkRoutesOutput {
    /// Describes a core network segment edge.
    public var coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?
    /// The network routes.
    public var networkRoutes: [NetworkManagerClientTypes.NetworkRoute]?
    /// The ARN of the route table.
    public var routeTableArn: Swift.String?
    /// The route table creation time.
    public var routeTableTimestamp: Foundation.Date?
    /// The route table type.
    public var routeTableType: NetworkManagerClientTypes.RouteTableType?

    public init(
        coreNetworkSegmentEdge: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier? = nil,
        networkRoutes: [NetworkManagerClientTypes.NetworkRoute]? = nil,
        routeTableArn: Swift.String? = nil,
        routeTableTimestamp: Foundation.Date? = nil,
        routeTableType: NetworkManagerClientTypes.RouteTableType? = nil
    )
    {
        self.coreNetworkSegmentEdge = coreNetworkSegmentEdge
        self.networkRoutes = networkRoutes
        self.routeTableArn = routeTableArn
        self.routeTableTimestamp = routeTableTimestamp
        self.routeTableType = routeTableType
    }
}

public struct GetNetworkTelemetryInput {
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The Amazon Web Services Region.
    public var awsRegion: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the gateway.
    public var registeredGatewayArn: Swift.String?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// The resource type. The following are the supported resource types:
    ///
    /// * connect-peer
    ///
    /// * transit-gateway-connect-peer
    ///
    /// * vpn-connection
    public var resourceType: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registeredGatewayArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.coreNetworkId = coreNetworkId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registeredGatewayArn = registeredGatewayArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

extension NetworkManagerClientTypes {
    /// Describes the telemetry information for a resource.
    public struct NetworkTelemetry {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The address.
        public var address: Swift.String?
        /// The Amazon Web Services Region.
        public var awsRegion: Swift.String?
        /// The ID of a core network.
        public var coreNetworkId: Swift.String?
        /// The connection health.
        public var health: NetworkManagerClientTypes.ConnectionHealth?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            address: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            coreNetworkId: Swift.String? = nil,
            health: NetworkManagerClientTypes.ConnectionHealth? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.address = address
            self.awsRegion = awsRegion
            self.coreNetworkId = coreNetworkId
            self.health = health
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

public struct GetNetworkTelemetryOutput {
    /// The network telemetry.
    public var networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        networkTelemetry: [NetworkManagerClientTypes.NetworkTelemetry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkTelemetry = networkTelemetry
        self.nextToken = nextToken
    }
}

public struct GetResourcePolicyInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput {
    /// The resource policy document.
    public var policyDocument: Swift.String?

    public init(
        policyDocument: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
    }
}

public struct GetRouteAnalysisInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the route analysis.
    /// This member is required.
    public var routeAnalysisId: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        routeAnalysisId: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.routeAnalysisId = routeAnalysisId
    }
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptions {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway.
        public var transitGatewayArn: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            transitGatewayArn: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayArn = transitGatewayArn
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

extension NetworkManagerClientTypes {

    public enum RouteAnalysisCompletionReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blackholeRouteForDestinationFound
        case cyclicPathDetected
        case inactiveRouteForDestinationFound
        case maxHopsExceeded
        case noDestinationArnProvided
        case possibleMiddlebox
        case routeNotFound
        case transitGatewayAttachment
        case transitGatewayAttachmentNotFound
        case transitGatewayAttachmentNotInTransitGateway
        case transitGatewayAttachmentStableRouteTableNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionReasonCode] {
            return [
                .blackholeRouteForDestinationFound,
                .cyclicPathDetected,
                .inactiveRouteForDestinationFound,
                .maxHopsExceeded,
                .noDestinationArnProvided,
                .possibleMiddlebox,
                .routeNotFound,
                .transitGatewayAttachment,
                .transitGatewayAttachmentNotFound,
                .transitGatewayAttachmentNotInTransitGateway,
                .transitGatewayAttachmentStableRouteTableNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blackholeRouteForDestinationFound: return "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND"
            case .cyclicPathDetected: return "CYCLIC_PATH_DETECTED"
            case .inactiveRouteForDestinationFound: return "INACTIVE_ROUTE_FOR_DESTINATION_FOUND"
            case .maxHopsExceeded: return "MAX_HOPS_EXCEEDED"
            case .noDestinationArnProvided: return "NO_DESTINATION_ARN_PROVIDED"
            case .possibleMiddlebox: return "POSSIBLE_MIDDLEBOX"
            case .routeNotFound: return "ROUTE_NOT_FOUND"
            case .transitGatewayAttachment: return "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH"
            case .transitGatewayAttachmentNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND"
            case .transitGatewayAttachmentNotInTransitGateway: return "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY"
            case .transitGatewayAttachmentStableRouteTableNotFound: return "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {

    public enum RouteAnalysisCompletionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisCompletionResultCode] {
            return [
                .connected,
                .notConnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes the status of an analysis at completion.
    public struct RouteAnalysisCompletion {
        /// The reason code. Available only if a connection is not found.
        ///
        /// * BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND - Found a black hole route with the destination CIDR block.
        ///
        /// * CYCLIC_PATH_DETECTED - Found the same resource multiple times while traversing the path.
        ///
        /// * INACTIVE_ROUTE_FOR_DESTINATION_FOUND - Found an inactive route with the destination CIDR block.
        ///
        /// * MAX_HOPS_EXCEEDED - Analysis exceeded 64 hops without finding the destination.
        ///
        /// * ROUTE_NOT_FOUND - Cannot find a route table with the destination CIDR block.
        ///
        /// * TGW_ATTACH_ARN_NO_MATCH - Found an attachment, but not with the correct destination ARN.
        ///
        /// * TGW_ATTACH_NOT_FOUND - Cannot find an attachment.
        ///
        /// * TGW_ATTACH_NOT_IN_TGW - Found an attachment, but not to the correct transit gateway.
        ///
        /// * TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND - The state of the route table association is not associated.
        public var reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode?
        /// Additional information about the path. Available only if a connection is not found.
        public var reasonContext: [Swift.String: Swift.String]?
        /// The result of the analysis. If the status is NOT_CONNECTED, check the reason code.
        public var resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode?

        public init(
            reasonCode: NetworkManagerClientTypes.RouteAnalysisCompletionReasonCode? = nil,
            reasonContext: [Swift.String: Swift.String]? = nil,
            resultCode: NetworkManagerClientTypes.RouteAnalysisCompletionResultCode? = nil
        )
        {
            self.reasonCode = reasonCode
            self.reasonContext = reasonContext
            self.resultCode = resultCode
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a network resource.
    public struct NetworkResourceSummary {
        /// Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.
        public var definition: Swift.String?
        /// Indicates whether this is a middlebox appliance.
        public var isMiddlebox: Swift.Bool
        /// The value for the Name tag.
        public var nameTag: Swift.String?
        /// The ARN of the gateway.
        public var registeredGatewayArn: Swift.String?
        /// The ARN of the resource.
        public var resourceArn: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?

        public init(
            definition: Swift.String? = nil,
            isMiddlebox: Swift.Bool = false,
            nameTag: Swift.String? = nil,
            registeredGatewayArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.definition = definition
            self.isMiddlebox = isMiddlebox
            self.nameTag = nameTag
            self.registeredGatewayArn = registeredGatewayArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a path component.
    public struct PathComponent {
        /// The destination CIDR block in the route table.
        public var destinationCidrBlock: Swift.String?
        /// The resource.
        public var resource: NetworkManagerClientTypes.NetworkResourceSummary?
        /// The sequence number in the path. The destination is 0.
        public var sequence: Swift.Int?

        public init(
            destinationCidrBlock: Swift.String? = nil,
            resource: NetworkManagerClientTypes.NetworkResourceSummary? = nil,
            sequence: Swift.Int? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.resource = resource
            self.sequence = sequence
        }
    }

}

extension NetworkManagerClientTypes {
    /// Describes a route analysis path.
    public struct RouteAnalysisPath {
        /// The status of the analysis at completion.
        public var completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion?
        /// The route analysis path.
        public var path: [NetworkManagerClientTypes.PathComponent]?

        public init(
            completionStatus: NetworkManagerClientTypes.RouteAnalysisCompletion? = nil,
            path: [NetworkManagerClientTypes.PathComponent]? = nil
        )
        {
            self.completionStatus = completionStatus
            self.path = path
        }
    }

}

extension NetworkManagerClientTypes {

    public enum RouteAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteAnalysisStatus] {
            return [
                .completed,
                .failed,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NetworkManagerClientTypes {
    /// Describes a route analysis.
    public struct RouteAnalysis {
        /// The destination.
        public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The forward path.
        public var forwardPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the global network.
        public var globalNetworkId: Swift.String?
        /// Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.
        public var includeReturnPath: Swift.Bool
        /// The ID of the AWS account that created the route analysis.
        public var ownerAccountId: Swift.String?
        /// The return path.
        public var returnPath: NetworkManagerClientTypes.RouteAnalysisPath?
        /// The ID of the route analysis.
        public var routeAnalysisId: Swift.String?
        /// The source.
        public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions?
        /// The time that the analysis started.
        public var startTimestamp: Foundation.Date?
        /// The status of the route analysis.
        public var status: NetworkManagerClientTypes.RouteAnalysisStatus?
        /// Indicates whether to include the location of middlebox appliances in the route analysis.
        public var useMiddleboxes: Swift.Bool

        public init(
            destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            forwardPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            globalNetworkId: Swift.String? = nil,
            includeReturnPath: Swift.Bool = false,
            ownerAccountId: Swift.String? = nil,
            returnPath: NetworkManagerClientTypes.RouteAnalysisPath? = nil,
            routeAnalysisId: Swift.String? = nil,
            source: NetworkManagerClientTypes.RouteAnalysisEndpointOptions? = nil,
            startTimestamp: Foundation.Date? = nil,
            status: NetworkManagerClientTypes.RouteAnalysisStatus? = nil,
            useMiddleboxes: Swift.Bool = false
        )
        {
            self.destination = destination
            self.forwardPath = forwardPath
            self.globalNetworkId = globalNetworkId
            self.includeReturnPath = includeReturnPath
            self.ownerAccountId = ownerAccountId
            self.returnPath = returnPath
            self.routeAnalysisId = routeAnalysisId
            self.source = source
            self.startTimestamp = startTimestamp
            self.status = status
            self.useMiddleboxes = useMiddleboxes
        }
    }

}

public struct GetRouteAnalysisOutput {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init(
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

public struct GetSitesInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more site IDs. The maximum is 10.
    public var siteIds: [Swift.String]?

    public init(
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        siteIds: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteIds = siteIds
    }
}

public struct GetSitesOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The sites.
    public var sites: [NetworkManagerClientTypes.Site]?

    public init(
        nextToken: Swift.String? = nil,
        sites: [NetworkManagerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

public struct GetSiteToSiteVpnAttachmentInput {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct GetSiteToSiteVpnAttachmentOutput {
    /// Describes the site-to-site attachment.
    public var siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment?

    public init(
        siteToSiteVpnAttachment: NetworkManagerClientTypes.SiteToSiteVpnAttachment? = nil
    )
    {
        self.siteToSiteVpnAttachment = siteToSiteVpnAttachment
    }
}

public struct GetTransitGatewayConnectPeerAssociationsInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// One or more transit gateway Connect peer Amazon Resource Names (ARNs).
    public var transitGatewayConnectPeerArns: [Swift.String]?

    public init(
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
    }
}

public struct GetTransitGatewayConnectPeerAssociationsOutput {
    /// The token to use for the next page of results.
    public var nextToken: Swift.String?
    /// Information about the transit gateway Connect peer associations.
    public var transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]?

    public init(
        nextToken: Swift.String? = nil,
        transitGatewayConnectPeerAssociations: [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
    }
}

public struct GetTransitGatewayPeeringInput {
    /// The ID of the peering request.
    /// This member is required.
    public var peeringId: Swift.String?

    public init(
        peeringId: Swift.String? = nil
    )
    {
        self.peeringId = peeringId
    }
}

public struct GetTransitGatewayPeeringOutput {
    /// Returns information about a transit gateway peering.
    public var transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering?

    public init(
        transitGatewayPeering: NetworkManagerClientTypes.TransitGatewayPeering? = nil
    )
    {
        self.transitGatewayPeering = transitGatewayPeering
    }
}

public struct GetTransitGatewayRegistrationsInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.
    public var transitGatewayArns: [Swift.String]?

    public init(
        globalNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        transitGatewayArns: [Swift.String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayArns = transitGatewayArns
    }
}

public struct GetTransitGatewayRegistrationsOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The transit gateway registrations.
    public var transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]?

    public init(
        nextToken: Swift.String? = nil,
        transitGatewayRegistrations: [NetworkManagerClientTypes.TransitGatewayRegistration]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayRegistrations = transitGatewayRegistrations
    }
}

public struct GetTransitGatewayRouteTableAttachmentInput {
    /// The ID of the transit gateway route table attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct GetTransitGatewayRouteTableAttachmentOutput {
    /// Returns information about the transit gateway route table attachment.
    public var transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment?

    public init(
        transitGatewayRouteTableAttachment: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment? = nil
    )
    {
        self.transitGatewayRouteTableAttachment = transitGatewayRouteTableAttachment
    }
}

public struct GetVpcAttachmentInput {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct GetVpcAttachmentOutput {
    /// Returns details about a VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init(
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

public struct ListAttachmentsInput {
    /// The type of attachment.
    public var attachmentType: NetworkManagerClientTypes.AttachmentType?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The Region where the edge is located.
    public var edgeLocation: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The state of the attachment.
    public var state: NetworkManagerClientTypes.AttachmentState?

    public init(
        attachmentType: NetworkManagerClientTypes.AttachmentType? = nil,
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: NetworkManagerClientTypes.AttachmentState? = nil
    )
    {
        self.attachmentType = attachmentType
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

public struct ListAttachmentsOutput {
    /// Describes the list of attachments.
    public var attachments: [NetworkManagerClientTypes.Attachment]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        attachments: [NetworkManagerClientTypes.Attachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.nextToken = nextToken
    }
}

public struct ListConnectPeersInput {
    /// The ID of the attachment.
    public var connectAttachmentId: Swift.String?
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connectAttachmentId: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectAttachmentId = connectAttachmentId
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectPeersOutput {
    /// Describes the Connect peers.
    public var connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        connectPeers: [NetworkManagerClientTypes.ConnectPeerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectPeers = connectPeers
        self.nextToken = nextToken
    }
}

public struct ListCoreNetworkPolicyVersionsInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        coreNetworkId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCoreNetworkPolicyVersionsOutput {
    /// Describes core network policy versions.
    public var coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        coreNetworkPolicyVersions: [NetworkManagerClientTypes.CoreNetworkPolicyVersion]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworkPolicyVersions = coreNetworkPolicyVersions
        self.nextToken = nextToken
    }
}

public struct ListCoreNetworksInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCoreNetworksOutput {
    /// Describes the list of core networks.
    public var coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        coreNetworks: [NetworkManagerClientTypes.CoreNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreNetworks = coreNetworks
        self.nextToken = nextToken
    }
}

public struct ListOrganizationServiceAccessStatusInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension NetworkManagerClientTypes {
    /// The status of an Amazon Web Services Organization and the accounts within that organization.
    public struct OrganizationStatus {
        /// The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either SUCCEEDED or IN_PROGRESS.
        public var accountStatusList: [NetworkManagerClientTypes.AccountStatus]?
        /// The status of the organization's AWS service access. This will be ENABLED or DISABLED.
        public var organizationAwsServiceAccessStatus: Swift.String?
        /// The ID of an Amazon Web Services Organization.
        public var organizationId: Swift.String?
        /// The status of the SLR deployment for the account. This will be either SUCCEEDED or IN_PROGRESS.
        public var slrDeploymentStatus: Swift.String?

        public init(
            accountStatusList: [NetworkManagerClientTypes.AccountStatus]? = nil,
            organizationAwsServiceAccessStatus: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            slrDeploymentStatus: Swift.String? = nil
        )
        {
            self.accountStatusList = accountStatusList
            self.organizationAwsServiceAccessStatus = organizationAwsServiceAccessStatus
            self.organizationId = organizationId
            self.slrDeploymentStatus = slrDeploymentStatus
        }
    }

}

public struct ListOrganizationServiceAccessStatusOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Displays the status of an Amazon Web Services Organization.
    public var organizationStatus: NetworkManagerClientTypes.OrganizationStatus?

    public init(
        nextToken: Swift.String? = nil,
        organizationStatus: NetworkManagerClientTypes.OrganizationStatus? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationStatus = organizationStatus
    }
}

public struct ListPeeringsInput {
    /// The ID of a core network.
    public var coreNetworkId: Swift.String?
    /// Returns a list edge locations for the
    public var edgeLocation: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Returns a list of a peering requests.
    public var peeringType: NetworkManagerClientTypes.PeeringType?
    /// Returns a list of the peering request states.
    public var state: NetworkManagerClientTypes.PeeringState?

    public init(
        coreNetworkId: Swift.String? = nil,
        edgeLocation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        peeringType: NetworkManagerClientTypes.PeeringType? = nil,
        state: NetworkManagerClientTypes.PeeringState? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.edgeLocation = edgeLocation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.peeringType = peeringType
        self.state = state
    }
}

public struct ListPeeringsOutput {
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// Lists the transit gateway peerings for the ListPeerings request.
    public var peerings: [NetworkManagerClientTypes.Peering]?

    public init(
        nextToken: Swift.String? = nil,
        peerings: [NetworkManagerClientTypes.Peering]? = nil
    )
    {
        self.nextToken = nextToken
        self.peerings = peerings
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags.
    public var tagList: [NetworkManagerClientTypes.Tag]?

    public init(
        tagList: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct PutCoreNetworkPolicyInput {
    /// The client token associated with the request.
    public var clientToken: Swift.String?
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// a core network policy description.
    public var description: Swift.String?
    /// The ID of a core network policy.
    public var latestVersionId: Swift.Int?
    /// The policy document.
    /// This member is required.
    public var policyDocument: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionId: Swift.Int? = nil,
        policyDocument: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.coreNetworkId = coreNetworkId
        self.description = description
        self.latestVersionId = latestVersionId
        self.policyDocument = policyDocument
    }
}

public struct PutCoreNetworkPolicyOutput {
    /// Describes the changed core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init(
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

public struct PutResourcePolicyInput {
    /// The JSON resource policy document.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The ARN of the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput {

    public init() { }
}

public struct RegisterTransitGatewayInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The Amazon Resource Name (ARN) of the transit gateway.
    /// This member is required.
    public var transitGatewayArn: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        transitGatewayArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

public struct RegisterTransitGatewayOutput {
    /// Information about the transit gateway registration.
    public var transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration?

    public init(
        transitGatewayRegistration: NetworkManagerClientTypes.TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

public struct RejectAttachmentInput {
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

public struct RejectAttachmentOutput {
    /// Describes the rejected attachment request.
    public var attachment: NetworkManagerClientTypes.Attachment?

    public init(
        attachment: NetworkManagerClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

public struct RestoreCoreNetworkPolicyVersionInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The ID of the policy version to restore.
    /// This member is required.
    public var policyVersionId: Swift.Int?

    public init(
        coreNetworkId: Swift.String? = nil,
        policyVersionId: Swift.Int? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.policyVersionId = policyVersionId
    }
}

public struct RestoreCoreNetworkPolicyVersionOutput {
    /// Describes the restored core network policy.
    public var coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy?

    public init(
        coreNetworkPolicy: NetworkManagerClientTypes.CoreNetworkPolicy? = nil
    )
    {
        self.coreNetworkPolicy = coreNetworkPolicy
    }
}

public struct StartOrganizationServiceAccessUpdateInput {
    /// The action to take for the update request. This can be either ENABLE or DISABLE.
    /// This member is required.
    public var action: Swift.String?

    public init(
        action: Swift.String? = nil
    )
    {
        self.action = action
    }
}

public struct StartOrganizationServiceAccessUpdateOutput {
    /// The status of the service access update request for an Amazon Web Services Organization.
    public var organizationStatus: NetworkManagerClientTypes.OrganizationStatus?

    public init(
        organizationStatus: NetworkManagerClientTypes.OrganizationStatus? = nil
    )
    {
        self.organizationStatus = organizationStatus
    }
}

extension NetworkManagerClientTypes {
    /// Describes a source or a destination.
    public struct RouteAnalysisEndpointOptionsSpecification {
        /// The IP address.
        public var ipAddress: Swift.String?
        /// The ARN of the transit gateway attachment.
        public var transitGatewayAttachmentArn: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            transitGatewayAttachmentArn: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.transitGatewayAttachmentArn = transitGatewayAttachmentArn
        }
    }

}

public struct StartRouteAnalysisInput {
    /// The destination.
    /// This member is required.
    public var destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Indicates whether to analyze the return path. The default is false.
    public var includeReturnPath: Swift.Bool?
    /// The source from which traffic originates.
    /// This member is required.
    public var source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?
    /// Indicates whether to include the location of middlebox appliances in the route analysis. The default is false.
    public var useMiddleboxes: Swift.Bool?

    public init(
        destination: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        globalNetworkId: Swift.String? = nil,
        includeReturnPath: Swift.Bool? = false,
        source: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification? = nil,
        useMiddleboxes: Swift.Bool? = false
    )
    {
        self.destination = destination
        self.globalNetworkId = globalNetworkId
        self.includeReturnPath = includeReturnPath
        self.source = source
        self.useMiddleboxes = useMiddleboxes
    }
}

public struct StartRouteAnalysisOutput {
    /// The route analysis.
    public var routeAnalysis: NetworkManagerClientTypes.RouteAnalysis?

    public init(
        routeAnalysis: NetworkManagerClientTypes.RouteAnalysis? = nil
    )
    {
        self.routeAnalysis = routeAnalysis
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the specified resource.
    /// This member is required.
    public var tags: [NetworkManagerClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [NetworkManagerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateConnectionInput {
    /// The ID of the link for the second device in the connection.
    public var connectedLinkId: Swift.String?
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// A description of the connection. Length Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link for the first device in the connection.
    public var linkId: Swift.String?

    public init(
        connectedLinkId: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil
    )
    {
        self.connectedLinkId = connectedLinkId
        self.connectionId = connectionId
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

public struct UpdateConnectionOutput {
    /// Information about the connection.
    public var connection: NetworkManagerClientTypes.Connection?

    public init(
        connection: NetworkManagerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

public struct UpdateCoreNetworkInput {
    /// The ID of a core network.
    /// This member is required.
    public var coreNetworkId: Swift.String?
    /// The description of the update.
    public var description: Swift.String?

    public init(
        coreNetworkId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.coreNetworkId = coreNetworkId
        self.description = description
    }
}

public struct UpdateCoreNetworkOutput {
    /// Returns information about a core network update.
    public var coreNetwork: NetworkManagerClientTypes.CoreNetwork?

    public init(
        coreNetwork: NetworkManagerClientTypes.CoreNetwork? = nil
    )
    {
        self.coreNetwork = coreNetwork
    }
}

public struct UpdateDeviceInput {
    /// The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.
    public var awsLocation: NetworkManagerClientTypes.AWSLocation?
    /// A description of the device. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// Describes a location.
    public var location: NetworkManagerClientTypes.Location?
    /// The model of the device. Constraints: Maximum length of 128 characters.
    public var model: Swift.String?
    /// The serial number of the device. Constraints: Maximum length of 128 characters.
    public var serialNumber: Swift.String?
    /// The ID of the site.
    public var siteId: Swift.String?
    /// The type of the device.
    public var type: Swift.String?
    /// The vendor of the device. Constraints: Maximum length of 128 characters.
    public var vendor: Swift.String?

    public init(
        awsLocation: NetworkManagerClientTypes.AWSLocation? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        model: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        siteId: Swift.String? = nil,
        type: Swift.String? = nil,
        vendor: Swift.String? = nil
    )
    {
        self.awsLocation = awsLocation
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.type = type
        self.vendor = vendor
    }
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(awsLocation: \(Swift.String(describing: awsLocation)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), model: \(Swift.String(describing: model)), serialNumber: \(Swift.String(describing: serialNumber)), siteId: \(Swift.String(describing: siteId)), type: \(Swift.String(describing: type)), vendor: \(Swift.String(describing: vendor)), location: \"CONTENT_REDACTED\")"}
}

public struct UpdateDeviceOutput {
    /// Information about the device.
    public var device: NetworkManagerClientTypes.Device?

    public init(
        device: NetworkManagerClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

public struct UpdateGlobalNetworkInput {
    /// A description of the global network. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of your global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?

    public init(
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
    }
}

public struct UpdateGlobalNetworkOutput {
    /// Information about the global network object.
    public var globalNetwork: NetworkManagerClientTypes.GlobalNetwork?

    public init(
        globalNetwork: NetworkManagerClientTypes.GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

public struct UpdateLinkInput {
    /// The upload and download speed in Mbps.
    public var bandwidth: NetworkManagerClientTypes.Bandwidth?
    /// A description of the link. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The ID of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The provider of the link. Constraints: Maximum length of 128 characters.
    public var provider: Swift.String?
    /// The type of the link. Constraints: Maximum length of 128 characters.
    public var type: Swift.String?

    public init(
        bandwidth: NetworkManagerClientTypes.Bandwidth? = nil,
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        provider: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.provider = provider
        self.type = type
    }
}

public struct UpdateLinkOutput {
    /// Information about the link.
    public var link: NetworkManagerClientTypes.Link?

    public init(
        link: NetworkManagerClientTypes.Link? = nil
    )
    {
        self.link = link
    }
}

public struct UpdateNetworkResourceMetadataInput {
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The resource metadata.
    /// This member is required.
    public var metadata: [Swift.String: Swift.String]?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        globalNetworkId: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

public struct UpdateNetworkResourceMetadataOutput {
    /// The updated resource metadata.
    public var metadata: [Swift.String: Swift.String]?
    /// The ARN of the resource.
    public var resourceArn: Swift.String?

    public init(
        metadata: [Swift.String: Swift.String]? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.resourceArn = resourceArn
    }
}

public struct UpdateSiteInput {
    /// A description of your site. Constraints: Maximum length of 256 characters.
    public var description: Swift.String?
    /// The ID of the global network.
    /// This member is required.
    public var globalNetworkId: Swift.String?
    /// The site location:
    ///
    /// * Address: The physical address of the site.
    ///
    /// * Latitude: The latitude of the site.
    ///
    /// * Longitude: The longitude of the site.
    public var location: NetworkManagerClientTypes.Location?
    /// The ID of your site.
    /// This member is required.
    public var siteId: Swift.String?

    public init(
        description: Swift.String? = nil,
        globalNetworkId: Swift.String? = nil,
        location: NetworkManagerClientTypes.Location? = nil,
        siteId: Swift.String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteId = siteId
    }
}

extension UpdateSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSiteInput(description: \(Swift.String(describing: description)), globalNetworkId: \(Swift.String(describing: globalNetworkId)), siteId: \(Swift.String(describing: siteId)), location: \"CONTENT_REDACTED\")"}
}

public struct UpdateSiteOutput {
    /// Information about the site.
    public var site: NetworkManagerClientTypes.Site?

    public init(
        site: NetworkManagerClientTypes.Site? = nil
    )
    {
        self.site = site
    }
}

public struct UpdateVpcAttachmentInput {
    /// Adds a subnet ARN to the VPC attachment.
    public var addSubnetArns: [Swift.String]?
    /// The ID of the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// Additional options for updating the VPC attachment.
    public var options: NetworkManagerClientTypes.VpcOptions?
    /// Removes a subnet ARN from the attachment.
    public var removeSubnetArns: [Swift.String]?

    public init(
        addSubnetArns: [Swift.String]? = nil,
        attachmentId: Swift.String? = nil,
        options: NetworkManagerClientTypes.VpcOptions? = nil,
        removeSubnetArns: [Swift.String]? = nil
    )
    {
        self.addSubnetArns = addSubnetArns
        self.attachmentId = attachmentId
        self.options = options
        self.removeSubnetArns = removeSubnetArns
    }
}

public struct UpdateVpcAttachmentOutput {
    /// Describes the updated VPC attachment.
    public var vpcAttachment: NetworkManagerClientTypes.VpcAttachment?

    public init(
        vpcAttachment: NetworkManagerClientTypes.VpcAttachment? = nil
    )
    {
        self.vpcAttachment = vpcAttachment
    }
}

extension AcceptAttachmentInput {

    static func urlPathProvider(_ value: AcceptAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())/accept"
    }
}

extension AssociateConnectPeerInput {

    static func urlPathProvider(_ value: AssociateConnectPeerInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
    }
}

extension AssociateCustomerGatewayInput {

    static func urlPathProvider(_ value: AssociateCustomerGatewayInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
    }
}

extension AssociateLinkInput {

    static func urlPathProvider(_ value: AssociateLinkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

extension AssociateTransitGatewayConnectPeerInput {

    static func urlPathProvider(_ value: AssociateTransitGatewayConnectPeerInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
    }
}

extension CreateConnectAttachmentInput {

    static func urlPathProvider(_ value: CreateConnectAttachmentInput) -> Swift.String? {
        return "/connect-attachments"
    }
}

extension CreateConnectionInput {

    static func urlPathProvider(_ value: CreateConnectionInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
    }
}

extension CreateConnectPeerInput {

    static func urlPathProvider(_ value: CreateConnectPeerInput) -> Swift.String? {
        return "/connect-peers"
    }
}

extension CreateCoreNetworkInput {

    static func urlPathProvider(_ value: CreateCoreNetworkInput) -> Swift.String? {
        return "/core-networks"
    }
}

extension CreateDeviceInput {

    static func urlPathProvider(_ value: CreateDeviceInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
    }
}

extension CreateGlobalNetworkInput {

    static func urlPathProvider(_ value: CreateGlobalNetworkInput) -> Swift.String? {
        return "/global-networks"
    }
}

extension CreateLinkInput {

    static func urlPathProvider(_ value: CreateLinkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
    }
}

extension CreateSiteInput {

    static func urlPathProvider(_ value: CreateSiteInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
    }
}

extension CreateSiteToSiteVpnAttachmentInput {

    static func urlPathProvider(_ value: CreateSiteToSiteVpnAttachmentInput) -> Swift.String? {
        return "/site-to-site-vpn-attachments"
    }
}

extension CreateTransitGatewayPeeringInput {

    static func urlPathProvider(_ value: CreateTransitGatewayPeeringInput) -> Swift.String? {
        return "/transit-gateway-peerings"
    }
}

extension CreateTransitGatewayRouteTableAttachmentInput {

    static func urlPathProvider(_ value: CreateTransitGatewayRouteTableAttachmentInput) -> Swift.String? {
        return "/transit-gateway-route-table-attachments"
    }
}

extension CreateVpcAttachmentInput {

    static func urlPathProvider(_ value: CreateVpcAttachmentInput) -> Swift.String? {
        return "/vpc-attachments"
    }
}

extension DeleteAttachmentInput {

    static func urlPathProvider(_ value: DeleteAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension DeleteConnectionInput {

    static func urlPathProvider(_ value: DeleteConnectionInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
    }
}

extension DeleteConnectPeerInput {

    static func urlPathProvider(_ value: DeleteConnectPeerInput) -> Swift.String? {
        guard let connectPeerId = value.connectPeerId else {
            return nil
        }
        return "/connect-peers/\(connectPeerId.urlPercentEncoding())"
    }
}

extension DeleteCoreNetworkInput {

    static func urlPathProvider(_ value: DeleteCoreNetworkInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

extension DeleteCoreNetworkPolicyVersionInput {

    static func urlPathProvider(_ value: DeleteCoreNetworkPolicyVersionInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)"
    }
}

extension DeleteDeviceInput {

    static func urlPathProvider(_ value: DeleteDeviceInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension DeleteGlobalNetworkInput {

    static func urlPathProvider(_ value: DeleteGlobalNetworkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())"
    }
}

extension DeleteLinkInput {

    static func urlPathProvider(_ value: DeleteLinkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
    }
}

extension DeletePeeringInput {

    static func urlPathProvider(_ value: DeletePeeringInput) -> Swift.String? {
        guard let peeringId = value.peeringId else {
            return nil
        }
        return "/peerings/\(peeringId.urlPercentEncoding())"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

extension DeleteSiteInput {

    static func urlPathProvider(_ value: DeleteSiteInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let siteId = value.siteId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
    }
}

extension DeregisterTransitGatewayInput {

    static func urlPathProvider(_ value: DeregisterTransitGatewayInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let transitGatewayArn = value.transitGatewayArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations/\(transitGatewayArn.urlPercentEncoding())"
    }
}

extension DescribeGlobalNetworksInput {

    static func urlPathProvider(_ value: DescribeGlobalNetworksInput) -> Swift.String? {
        return "/global-networks"
    }
}

extension DescribeGlobalNetworksInput {

    static func queryItemProvider(_ value: DescribeGlobalNetworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let globalNetworkIds = value.globalNetworkIds {
            globalNetworkIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "globalNetworkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DisassociateConnectPeerInput {

    static func urlPathProvider(_ value: DisassociateConnectPeerInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let connectPeerId = value.connectPeerId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations/\(connectPeerId.urlPercentEncoding())"
    }
}

extension DisassociateCustomerGatewayInput {

    static func urlPathProvider(_ value: DisassociateCustomerGatewayInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let customerGatewayArn = value.customerGatewayArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations/\(customerGatewayArn.urlPercentEncoding())"
    }
}

extension DisassociateLinkInput {

    static func urlPathProvider(_ value: DisassociateLinkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

extension DisassociateLinkInput {

    static func queryItemProvider(_ value: DisassociateLinkInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let deviceId = value.deviceId else {
            let message = "Creating a URL Query Item failed. deviceId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let deviceIdQueryItem = Smithy.URIQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
        items.append(deviceIdQueryItem)
        guard let linkId = value.linkId else {
            let message = "Creating a URL Query Item failed. linkId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let linkIdQueryItem = Smithy.URIQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
        items.append(linkIdQueryItem)
        return items
    }
}

extension DisassociateTransitGatewayConnectPeerInput {

    static func urlPathProvider(_ value: DisassociateTransitGatewayConnectPeerInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let transitGatewayConnectPeerArn = value.transitGatewayConnectPeerArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations/\(transitGatewayConnectPeerArn.urlPercentEncoding())"
    }
}

extension ExecuteCoreNetworkChangeSetInput {

    static func urlPathProvider(_ value: ExecuteCoreNetworkChangeSetInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)/execute"
    }
}

extension GetConnectAttachmentInput {

    static func urlPathProvider(_ value: GetConnectAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/connect-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension GetConnectionsInput {

    static func urlPathProvider(_ value: GetConnectionsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections"
    }
}

extension GetConnectionsInput {

    static func queryItemProvider(_ value: GetConnectionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceId = value.deviceId {
            let deviceIdQueryItem = Smithy.URIQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            items.append(deviceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let connectionIds = value.connectionIds {
            connectionIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "connectionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetConnectPeerInput {

    static func urlPathProvider(_ value: GetConnectPeerInput) -> Swift.String? {
        guard let connectPeerId = value.connectPeerId else {
            return nil
        }
        return "/connect-peers/\(connectPeerId.urlPercentEncoding())"
    }
}

extension GetConnectPeerAssociationsInput {

    static func urlPathProvider(_ value: GetConnectPeerAssociationsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connect-peer-associations"
    }
}

extension GetConnectPeerAssociationsInput {

    static func queryItemProvider(_ value: GetConnectPeerAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let connectPeerIds = value.connectPeerIds {
            connectPeerIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "connectPeerIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetCoreNetworkInput {

    static func urlPathProvider(_ value: GetCoreNetworkInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

extension GetCoreNetworkChangeEventsInput {

    static func urlPathProvider(_ value: GetCoreNetworkChangeEventsInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-events/\(policyVersionId)"
    }
}

extension GetCoreNetworkChangeEventsInput {

    static func queryItemProvider(_ value: GetCoreNetworkChangeEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetCoreNetworkChangeSetInput {

    static func urlPathProvider(_ value: GetCoreNetworkChangeSetInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-change-sets/\(policyVersionId)"
    }
}

extension GetCoreNetworkChangeSetInput {

    static func queryItemProvider(_ value: GetCoreNetworkChangeSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetCoreNetworkPolicyInput {

    static func urlPathProvider(_ value: GetCoreNetworkPolicyInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
    }
}

extension GetCoreNetworkPolicyInput {

    static func queryItemProvider(_ value: GetCoreNetworkPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let alias = value.alias {
            let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias.rawValue).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        if let policyVersionId = value.policyVersionId {
            let policyVersionIdQueryItem = Smithy.URIQueryItem(name: "policyVersionId".urlPercentEncoding(), value: Swift.String(policyVersionId).urlPercentEncoding())
            items.append(policyVersionIdQueryItem)
        }
        return items
    }
}

extension GetCustomerGatewayAssociationsInput {

    static func urlPathProvider(_ value: GetCustomerGatewayAssociationsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/customer-gateway-associations"
    }
}

extension GetCustomerGatewayAssociationsInput {

    static func queryItemProvider(_ value: GetCustomerGatewayAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let customerGatewayArns = value.customerGatewayArns {
            customerGatewayArns.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "customerGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetDevicesInput {

    static func urlPathProvider(_ value: GetDevicesInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices"
    }
}

extension GetDevicesInput {

    static func queryItemProvider(_ value: GetDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deviceIds = value.deviceIds {
            deviceIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "deviceIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let siteId = value.siteId {
            let siteIdQueryItem = Smithy.URIQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            items.append(siteIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetLinkAssociationsInput {

    static func urlPathProvider(_ value: GetLinkAssociationsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/link-associations"
    }
}

extension GetLinkAssociationsInput {

    static func queryItemProvider(_ value: GetLinkAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceId = value.deviceId {
            let deviceIdQueryItem = Smithy.URIQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            items.append(deviceIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let linkId = value.linkId {
            let linkIdQueryItem = Smithy.URIQueryItem(name: "linkId".urlPercentEncoding(), value: Swift.String(linkId).urlPercentEncoding())
            items.append(linkIdQueryItem)
        }
        return items
    }
}

extension GetLinksInput {

    static func urlPathProvider(_ value: GetLinksInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links"
    }
}

extension GetLinksInput {

    static func queryItemProvider(_ value: GetLinksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let siteId = value.siteId {
            let siteIdQueryItem = Smithy.URIQueryItem(name: "siteId".urlPercentEncoding(), value: Swift.String(siteId).urlPercentEncoding())
            items.append(siteIdQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let linkIds = value.linkIds {
            linkIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "linkIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let provider = value.provider {
            let providerQueryItem = Smithy.URIQueryItem(name: "provider".urlPercentEncoding(), value: Swift.String(provider).urlPercentEncoding())
            items.append(providerQueryItem)
        }
        return items
    }
}

extension GetNetworkResourceCountsInput {

    static func urlPathProvider(_ value: GetNetworkResourceCountsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-count"
    }
}

extension GetNetworkResourceCountsInput {

    static func queryItemProvider(_ value: GetNetworkResourceCountsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension GetNetworkResourceRelationshipsInput {

    static func urlPathProvider(_ value: GetNetworkResourceRelationshipsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resource-relationships"
    }
}

extension GetNetworkResourceRelationshipsInput {

    static func queryItemProvider(_ value: GetNetworkResourceRelationshipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceArn = value.resourceArn {
            let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let registeredGatewayArn = value.registeredGatewayArn {
            let registeredGatewayArnQueryItem = Smithy.URIQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            items.append(registeredGatewayArnQueryItem)
        }
        if let awsRegion = value.awsRegion {
            let awsRegionQueryItem = Smithy.URIQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            items.append(awsRegionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension GetNetworkResourcesInput {

    static func urlPathProvider(_ value: GetNetworkResourcesInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources"
    }
}

extension GetNetworkResourcesInput {

    static func queryItemProvider(_ value: GetNetworkResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceArn = value.resourceArn {
            let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let registeredGatewayArn = value.registeredGatewayArn {
            let registeredGatewayArnQueryItem = Smithy.URIQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            items.append(registeredGatewayArnQueryItem)
        }
        if let awsRegion = value.awsRegion {
            let awsRegionQueryItem = Smithy.URIQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            items.append(awsRegionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension GetNetworkRoutesInput {

    static func urlPathProvider(_ value: GetNetworkRoutesInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-routes"
    }
}

extension GetNetworkTelemetryInput {

    static func urlPathProvider(_ value: GetNetworkTelemetryInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-telemetry"
    }
}

extension GetNetworkTelemetryInput {

    static func queryItemProvider(_ value: GetNetworkTelemetryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceArn = value.resourceArn {
            let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
        }
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let accountId = value.accountId {
            let accountIdQueryItem = Smithy.URIQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(accountId).urlPercentEncoding())
            items.append(accountIdQueryItem)
        }
        if let registeredGatewayArn = value.registeredGatewayArn {
            let registeredGatewayArnQueryItem = Smithy.URIQueryItem(name: "registeredGatewayArn".urlPercentEncoding(), value: Swift.String(registeredGatewayArn).urlPercentEncoding())
            items.append(registeredGatewayArnQueryItem)
        }
        if let awsRegion = value.awsRegion {
            let awsRegionQueryItem = Smithy.URIQueryItem(name: "awsRegion".urlPercentEncoding(), value: Swift.String(awsRegion).urlPercentEncoding())
            items.append(awsRegionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetRouteAnalysisInput {

    static func urlPathProvider(_ value: GetRouteAnalysisInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let routeAnalysisId = value.routeAnalysisId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses/\(routeAnalysisId.urlPercentEncoding())"
    }
}

extension GetSitesInput {

    static func urlPathProvider(_ value: GetSitesInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites"
    }
}

extension GetSitesInput {

    static func queryItemProvider(_ value: GetSitesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let siteIds = value.siteIds {
            siteIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "siteIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetSiteToSiteVpnAttachmentInput {

    static func urlPathProvider(_ value: GetSiteToSiteVpnAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/site-to-site-vpn-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput {

    static func urlPathProvider(_ value: GetTransitGatewayConnectPeerAssociationsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-connect-peer-associations"
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput {

    static func queryItemProvider(_ value: GetTransitGatewayConnectPeerAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let transitGatewayConnectPeerArns = value.transitGatewayConnectPeerArns {
            transitGatewayConnectPeerArns.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "transitGatewayConnectPeerArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetTransitGatewayPeeringInput {

    static func urlPathProvider(_ value: GetTransitGatewayPeeringInput) -> Swift.String? {
        guard let peeringId = value.peeringId else {
            return nil
        }
        return "/transit-gateway-peerings/\(peeringId.urlPercentEncoding())"
    }
}

extension GetTransitGatewayRegistrationsInput {

    static func urlPathProvider(_ value: GetTransitGatewayRegistrationsInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
    }
}

extension GetTransitGatewayRegistrationsInput {

    static func queryItemProvider(_ value: GetTransitGatewayRegistrationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let transitGatewayArns = value.transitGatewayArns {
            transitGatewayArns.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "transitGatewayArns".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetTransitGatewayRouteTableAttachmentInput {

    static func urlPathProvider(_ value: GetTransitGatewayRouteTableAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/transit-gateway-route-table-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension GetVpcAttachmentInput {

    static func urlPathProvider(_ value: GetVpcAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension ListAttachmentsInput {

    static func urlPathProvider(_ value: ListAttachmentsInput) -> Swift.String? {
        return "/attachments"
    }
}

extension ListAttachmentsInput {

    static func queryItemProvider(_ value: ListAttachmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let attachmentType = value.attachmentType {
            let attachmentTypeQueryItem = Smithy.URIQueryItem(name: "attachmentType".urlPercentEncoding(), value: Swift.String(attachmentType.rawValue).urlPercentEncoding())
            items.append(attachmentTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let edgeLocation = value.edgeLocation {
            let edgeLocationQueryItem = Smithy.URIQueryItem(name: "edgeLocation".urlPercentEncoding(), value: Swift.String(edgeLocation).urlPercentEncoding())
            items.append(edgeLocationQueryItem)
        }
        return items
    }
}

extension ListConnectPeersInput {

    static func urlPathProvider(_ value: ListConnectPeersInput) -> Swift.String? {
        return "/connect-peers"
    }
}

extension ListConnectPeersInput {

    static func queryItemProvider(_ value: ListConnectPeersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let connectAttachmentId = value.connectAttachmentId {
            let connectAttachmentIdQueryItem = Smithy.URIQueryItem(name: "connectAttachmentId".urlPercentEncoding(), value: Swift.String(connectAttachmentId).urlPercentEncoding())
            items.append(connectAttachmentIdQueryItem)
        }
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreNetworkPolicyVersionsInput {

    static func urlPathProvider(_ value: ListCoreNetworkPolicyVersionsInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions"
    }
}

extension ListCoreNetworkPolicyVersionsInput {

    static func queryItemProvider(_ value: ListCoreNetworkPolicyVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreNetworksInput {

    static func urlPathProvider(_ value: ListCoreNetworksInput) -> Swift.String? {
        return "/core-networks"
    }
}

extension ListCoreNetworksInput {

    static func queryItemProvider(_ value: ListCoreNetworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOrganizationServiceAccessStatusInput {

    static func urlPathProvider(_ value: ListOrganizationServiceAccessStatusInput) -> Swift.String? {
        return "/organizations/service-access"
    }
}

extension ListOrganizationServiceAccessStatusInput {

    static func queryItemProvider(_ value: ListOrganizationServiceAccessStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPeeringsInput {

    static func urlPathProvider(_ value: ListPeeringsInput) -> Swift.String? {
        return "/peerings"
    }
}

extension ListPeeringsInput {

    static func queryItemProvider(_ value: ListPeeringsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let coreNetworkId = value.coreNetworkId {
            let coreNetworkIdQueryItem = Smithy.URIQueryItem(name: "coreNetworkId".urlPercentEncoding(), value: Swift.String(coreNetworkId).urlPercentEncoding())
            items.append(coreNetworkIdQueryItem)
        }
        if let peeringType = value.peeringType {
            let peeringTypeQueryItem = Smithy.URIQueryItem(name: "peeringType".urlPercentEncoding(), value: Swift.String(peeringType.rawValue).urlPercentEncoding())
            items.append(peeringTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let edgeLocation = value.edgeLocation {
            let edgeLocationQueryItem = Smithy.URIQueryItem(name: "edgeLocation".urlPercentEncoding(), value: Swift.String(edgeLocation).urlPercentEncoding())
            items.append(edgeLocationQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutCoreNetworkPolicyInput {

    static func urlPathProvider(_ value: PutCoreNetworkPolicyInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resource-policy/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterTransitGatewayInput {

    static func urlPathProvider(_ value: RegisterTransitGatewayInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/transit-gateway-registrations"
    }
}

extension RejectAttachmentInput {

    static func urlPathProvider(_ value: RejectAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/attachments/\(attachmentId.urlPercentEncoding())/reject"
    }
}

extension RestoreCoreNetworkPolicyVersionInput {

    static func urlPathProvider(_ value: RestoreCoreNetworkPolicyVersionInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        guard let policyVersionId = value.policyVersionId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())/core-network-policy-versions/\(policyVersionId)/restore"
    }
}

extension StartOrganizationServiceAccessUpdateInput {

    static func urlPathProvider(_ value: StartOrganizationServiceAccessUpdateInput) -> Swift.String? {
        return "/organizations/service-access"
    }
}

extension StartRouteAnalysisInput {

    static func urlPathProvider(_ value: StartRouteAnalysisInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/route-analyses"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateConnectionInput {

    static func urlPathProvider(_ value: UpdateConnectionInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/connections/\(connectionId.urlPercentEncoding())"
    }
}

extension UpdateCoreNetworkInput {

    static func urlPathProvider(_ value: UpdateCoreNetworkInput) -> Swift.String? {
        guard let coreNetworkId = value.coreNetworkId else {
            return nil
        }
        return "/core-networks/\(coreNetworkId.urlPercentEncoding())"
    }
}

extension UpdateDeviceInput {

    static func urlPathProvider(_ value: UpdateDeviceInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension UpdateGlobalNetworkInput {

    static func urlPathProvider(_ value: UpdateGlobalNetworkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())"
    }
}

extension UpdateLinkInput {

    static func urlPathProvider(_ value: UpdateLinkInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/links/\(linkId.urlPercentEncoding())"
    }
}

extension UpdateNetworkResourceMetadataInput {

    static func urlPathProvider(_ value: UpdateNetworkResourceMetadataInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/network-resources/\(resourceArn.urlPercentEncoding())/metadata"
    }
}

extension UpdateSiteInput {

    static func urlPathProvider(_ value: UpdateSiteInput) -> Swift.String? {
        guard let globalNetworkId = value.globalNetworkId else {
            return nil
        }
        guard let siteId = value.siteId else {
            return nil
        }
        return "/global-networks/\(globalNetworkId.urlPercentEncoding())/sites/\(siteId.urlPercentEncoding())"
    }
}

extension UpdateVpcAttachmentInput {

    static func urlPathProvider(_ value: UpdateVpcAttachmentInput) -> Swift.String? {
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/vpc-attachments/\(attachmentId.urlPercentEncoding())"
    }
}

extension AssociateConnectPeerInput {

    static func write(value: AssociateConnectPeerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectPeerId"].write(value.connectPeerId)
        try writer["DeviceId"].write(value.deviceId)
        try writer["LinkId"].write(value.linkId)
    }
}

extension AssociateCustomerGatewayInput {

    static func write(value: AssociateCustomerGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomerGatewayArn"].write(value.customerGatewayArn)
        try writer["DeviceId"].write(value.deviceId)
        try writer["LinkId"].write(value.linkId)
    }
}

extension AssociateLinkInput {

    static func write(value: AssociateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["LinkId"].write(value.linkId)
    }
}

extension AssociateTransitGatewayConnectPeerInput {

    static func write(value: AssociateTransitGatewayConnectPeerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["LinkId"].write(value.linkId)
        try writer["TransitGatewayConnectPeerArn"].write(value.transitGatewayConnectPeerArn)
    }
}

extension CreateConnectAttachmentInput {

    static func write(value: CreateConnectAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["EdgeLocation"].write(value.edgeLocation)
        try writer["Options"].write(value.options, with: NetworkManagerClientTypes.ConnectAttachmentOptions.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransportAttachmentId"].write(value.transportAttachmentId)
    }
}

extension CreateConnectionInput {

    static func write(value: CreateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectedDeviceId"].write(value.connectedDeviceId)
        try writer["ConnectedLinkId"].write(value.connectedLinkId)
        try writer["Description"].write(value.description)
        try writer["DeviceId"].write(value.deviceId)
        try writer["LinkId"].write(value.linkId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateConnectPeerInput {

    static func write(value: CreateConnectPeerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BgpOptions"].write(value.bgpOptions, with: NetworkManagerClientTypes.BgpOptions.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectAttachmentId"].write(value.connectAttachmentId)
        try writer["CoreNetworkAddress"].write(value.coreNetworkAddress)
        try writer["InsideCidrBlocks"].writeList(value.insideCidrBlocks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PeerAddress"].write(value.peerAddress)
        try writer["SubnetArn"].write(value.subnetArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCoreNetworkInput {

    static func write(value: CreateCoreNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["GlobalNetworkId"].write(value.globalNetworkId)
        try writer["PolicyDocument"].write(value.policyDocument)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDeviceInput {

    static func write(value: CreateDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSLocation"].write(value.awsLocation, with: NetworkManagerClientTypes.AWSLocation.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Location"].write(value.location, with: NetworkManagerClientTypes.Location.write(value:to:))
        try writer["Model"].write(value.model)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["SiteId"].write(value.siteId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
        try writer["Vendor"].write(value.vendor)
    }
}

extension CreateGlobalNetworkInput {

    static func write(value: CreateGlobalNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLinkInput {

    static func write(value: CreateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bandwidth"].write(value.bandwidth, with: NetworkManagerClientTypes.Bandwidth.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Provider"].write(value.provider)
        try writer["SiteId"].write(value.siteId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension CreateSiteInput {

    static func write(value: CreateSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Location"].write(value.location, with: NetworkManagerClientTypes.Location.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSiteToSiteVpnAttachmentInput {

    static func write(value: CreateSiteToSiteVpnAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpnConnectionArn"].write(value.vpnConnectionArn)
    }
}

extension CreateTransitGatewayPeeringInput {

    static func write(value: CreateTransitGatewayPeeringInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransitGatewayArn"].write(value.transitGatewayArn)
    }
}

extension CreateTransitGatewayRouteTableAttachmentInput {

    static func write(value: CreateTransitGatewayRouteTableAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["PeeringId"].write(value.peeringId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TransitGatewayRouteTableArn"].write(value.transitGatewayRouteTableArn)
    }
}

extension CreateVpcAttachmentInput {

    static func write(value: CreateVpcAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["Options"].write(value.options, with: NetworkManagerClientTypes.VpcOptions.write(value:to:))
        try writer["SubnetArns"].writeList(value.subnetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcArn"].write(value.vpcArn)
    }
}

extension GetNetworkRoutesInput {

    static func write(value: GetNetworkRoutesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationFilters"].writeMap(value.destinationFilters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ExactCidrMatches"].writeList(value.exactCidrMatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LongestPrefixMatches"].writeList(value.longestPrefixMatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PrefixListIds"].writeList(value.prefixListIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RouteTableIdentifier"].write(value.routeTableIdentifier, with: NetworkManagerClientTypes.RouteTableIdentifier.write(value:to:))
        try writer["States"].writeList(value.states, memberWritingClosure: SmithyReadWrite.WritingClosureBox<NetworkManagerClientTypes.RouteState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetOfMatches"].writeList(value.subnetOfMatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SupernetOfMatches"].writeList(value.supernetOfMatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<NetworkManagerClientTypes.RouteType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutCoreNetworkPolicyInput {

    static func write(value: PutCoreNetworkPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["LatestVersionId"].write(value.latestVersionId)
        try writer["PolicyDocument"].write(value.policyDocument)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyDocument"].write(value.policyDocument)
    }
}

extension RegisterTransitGatewayInput {

    static func write(value: RegisterTransitGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransitGatewayArn"].write(value.transitGatewayArn)
    }
}

extension StartOrganizationServiceAccessUpdateInput {

    static func write(value: StartOrganizationServiceAccessUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
    }
}

extension StartRouteAnalysisInput {

    static func write(value: StartRouteAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.write(value:to:))
        try writer["IncludeReturnPath"].write(value.includeReturnPath)
        try writer["Source"].write(value.source, with: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification.write(value:to:))
        try writer["UseMiddleboxes"].write(value.useMiddleboxes)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: NetworkManagerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateConnectionInput {

    static func write(value: UpdateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectedLinkId"].write(value.connectedLinkId)
        try writer["Description"].write(value.description)
        try writer["LinkId"].write(value.linkId)
    }
}

extension UpdateCoreNetworkInput {

    static func write(value: UpdateCoreNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension UpdateDeviceInput {

    static func write(value: UpdateDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSLocation"].write(value.awsLocation, with: NetworkManagerClientTypes.AWSLocation.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Location"].write(value.location, with: NetworkManagerClientTypes.Location.write(value:to:))
        try writer["Model"].write(value.model)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["SiteId"].write(value.siteId)
        try writer["Type"].write(value.type)
        try writer["Vendor"].write(value.vendor)
    }
}

extension UpdateGlobalNetworkInput {

    static func write(value: UpdateGlobalNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension UpdateLinkInput {

    static func write(value: UpdateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bandwidth"].write(value.bandwidth, with: NetworkManagerClientTypes.Bandwidth.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Provider"].write(value.provider)
        try writer["Type"].write(value.type)
    }
}

extension UpdateNetworkResourceMetadataInput {

    static func write(value: UpdateNetworkResourceMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].writeMap(value.metadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSiteInput {

    static func write(value: UpdateSiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Location"].write(value.location, with: NetworkManagerClientTypes.Location.write(value:to:))
    }
}

extension UpdateVpcAttachmentInput {

    static func write(value: UpdateVpcAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddSubnetArns"].writeList(value.addSubnetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Options"].write(value.options, with: NetworkManagerClientTypes.VpcOptions.write(value:to:))
        try writer["RemoveSubnetArns"].writeList(value.removeSubnetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AcceptAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptAttachmentOutput()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        return value
    }
}

extension AssociateConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateConnectPeerOutput()
        value.connectPeerAssociation = try reader["ConnectPeerAssociation"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeerAssociation.read(from:))
        return value
    }
}

extension AssociateCustomerGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateCustomerGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateCustomerGatewayOutput()
        value.customerGatewayAssociation = try reader["CustomerGatewayAssociation"].readIfPresent(with: NetworkManagerClientTypes.CustomerGatewayAssociation.read(from:))
        return value
    }
}

extension AssociateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateLinkOutput()
        value.linkAssociation = try reader["LinkAssociation"].readIfPresent(with: NetworkManagerClientTypes.LinkAssociation.read(from:))
        return value
    }
}

extension AssociateTransitGatewayConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTransitGatewayConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateTransitGatewayConnectPeerOutput()
        value.transitGatewayConnectPeerAssociation = try reader["TransitGatewayConnectPeerAssociation"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.read(from:))
        return value
    }
}

extension CreateConnectAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectAttachmentOutput()
        value.connectAttachment = try reader["ConnectAttachment"].readIfPresent(with: NetworkManagerClientTypes.ConnectAttachment.read(from:))
        return value
    }
}

extension CreateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: NetworkManagerClientTypes.Connection.read(from:))
        return value
    }
}

extension CreateConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectPeerOutput()
        value.connectPeer = try reader["ConnectPeer"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeer.read(from:))
        return value
    }
}

extension CreateCoreNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCoreNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCoreNetworkOutput()
        value.coreNetwork = try reader["CoreNetwork"].readIfPresent(with: NetworkManagerClientTypes.CoreNetwork.read(from:))
        return value
    }
}

extension CreateDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceOutput()
        value.device = try reader["Device"].readIfPresent(with: NetworkManagerClientTypes.Device.read(from:))
        return value
    }
}

extension CreateGlobalNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGlobalNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlobalNetworkOutput()
        value.globalNetwork = try reader["GlobalNetwork"].readIfPresent(with: NetworkManagerClientTypes.GlobalNetwork.read(from:))
        return value
    }
}

extension CreateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLinkOutput()
        value.link = try reader["Link"].readIfPresent(with: NetworkManagerClientTypes.Link.read(from:))
        return value
    }
}

extension CreateSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: NetworkManagerClientTypes.Site.read(from:))
        return value
    }
}

extension CreateSiteToSiteVpnAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSiteToSiteVpnAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSiteToSiteVpnAttachmentOutput()
        value.siteToSiteVpnAttachment = try reader["SiteToSiteVpnAttachment"].readIfPresent(with: NetworkManagerClientTypes.SiteToSiteVpnAttachment.read(from:))
        return value
    }
}

extension CreateTransitGatewayPeeringOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTransitGatewayPeeringOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTransitGatewayPeeringOutput()
        value.transitGatewayPeering = try reader["TransitGatewayPeering"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayPeering.read(from:))
        return value
    }
}

extension CreateTransitGatewayRouteTableAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTransitGatewayRouteTableAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTransitGatewayRouteTableAttachmentOutput()
        value.transitGatewayRouteTableAttachment = try reader["TransitGatewayRouteTableAttachment"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment.read(from:))
        return value
    }
}

extension CreateVpcAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcAttachmentOutput()
        value.vpcAttachment = try reader["VpcAttachment"].readIfPresent(with: NetworkManagerClientTypes.VpcAttachment.read(from:))
        return value
    }
}

extension DeleteAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAttachmentOutput()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        return value
    }
}

extension DeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: NetworkManagerClientTypes.Connection.read(from:))
        return value
    }
}

extension DeleteConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectPeerOutput()
        value.connectPeer = try reader["ConnectPeer"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeer.read(from:))
        return value
    }
}

extension DeleteCoreNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCoreNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCoreNetworkOutput()
        value.coreNetwork = try reader["CoreNetwork"].readIfPresent(with: NetworkManagerClientTypes.CoreNetwork.read(from:))
        return value
    }
}

extension DeleteCoreNetworkPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCoreNetworkPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCoreNetworkPolicyVersionOutput()
        value.coreNetworkPolicy = try reader["CoreNetworkPolicy"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkPolicy.read(from:))
        return value
    }
}

extension DeleteDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDeviceOutput()
        value.device = try reader["Device"].readIfPresent(with: NetworkManagerClientTypes.Device.read(from:))
        return value
    }
}

extension DeleteGlobalNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGlobalNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGlobalNetworkOutput()
        value.globalNetwork = try reader["GlobalNetwork"].readIfPresent(with: NetworkManagerClientTypes.GlobalNetwork.read(from:))
        return value
    }
}

extension DeleteLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLinkOutput()
        value.link = try reader["Link"].readIfPresent(with: NetworkManagerClientTypes.Link.read(from:))
        return value
    }
}

extension DeletePeeringOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePeeringOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePeeringOutput()
        value.peering = try reader["Peering"].readIfPresent(with: NetworkManagerClientTypes.Peering.read(from:))
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: NetworkManagerClientTypes.Site.read(from:))
        return value
    }
}

extension DeregisterTransitGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterTransitGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTransitGatewayOutput()
        value.transitGatewayRegistration = try reader["TransitGatewayRegistration"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayRegistration.read(from:))
        return value
    }
}

extension DescribeGlobalNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGlobalNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGlobalNetworksOutput()
        value.globalNetworks = try reader["GlobalNetworks"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.GlobalNetwork.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DisassociateConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateConnectPeerOutput()
        value.connectPeerAssociation = try reader["ConnectPeerAssociation"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeerAssociation.read(from:))
        return value
    }
}

extension DisassociateCustomerGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateCustomerGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateCustomerGatewayOutput()
        value.customerGatewayAssociation = try reader["CustomerGatewayAssociation"].readIfPresent(with: NetworkManagerClientTypes.CustomerGatewayAssociation.read(from:))
        return value
    }
}

extension DisassociateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateLinkOutput()
        value.linkAssociation = try reader["LinkAssociation"].readIfPresent(with: NetworkManagerClientTypes.LinkAssociation.read(from:))
        return value
    }
}

extension DisassociateTransitGatewayConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateTransitGatewayConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateTransitGatewayConnectPeerOutput()
        value.transitGatewayConnectPeerAssociation = try reader["TransitGatewayConnectPeerAssociation"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.read(from:))
        return value
    }
}

extension ExecuteCoreNetworkChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteCoreNetworkChangeSetOutput {
        return ExecuteCoreNetworkChangeSetOutput()
    }
}

extension GetConnectAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectAttachmentOutput()
        value.connectAttachment = try reader["ConnectAttachment"].readIfPresent(with: NetworkManagerClientTypes.ConnectAttachment.read(from:))
        return value
    }
}

extension GetConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionsOutput()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetConnectPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectPeerOutput()
        value.connectPeer = try reader["ConnectPeer"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeer.read(from:))
        return value
    }
}

extension GetConnectPeerAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectPeerAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectPeerAssociationsOutput()
        value.connectPeerAssociations = try reader["ConnectPeerAssociations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ConnectPeerAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCoreNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreNetworkOutput()
        value.coreNetwork = try reader["CoreNetwork"].readIfPresent(with: NetworkManagerClientTypes.CoreNetwork.read(from:))
        return value
    }
}

extension GetCoreNetworkChangeEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreNetworkChangeEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreNetworkChangeEventsOutput()
        value.coreNetworkChangeEvents = try reader["CoreNetworkChangeEvents"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkChangeEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCoreNetworkChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreNetworkChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreNetworkChangeSetOutput()
        value.coreNetworkChanges = try reader["CoreNetworkChanges"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCoreNetworkPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreNetworkPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreNetworkPolicyOutput()
        value.coreNetworkPolicy = try reader["CoreNetworkPolicy"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkPolicy.read(from:))
        return value
    }
}

extension GetCustomerGatewayAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomerGatewayAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomerGatewayAssociationsOutput()
        value.customerGatewayAssociations = try reader["CustomerGatewayAssociations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CustomerGatewayAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicesOutput()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Device.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetLinkAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLinkAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLinkAssociationsOutput()
        value.linkAssociations = try reader["LinkAssociations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.LinkAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLinksOutput()
        value.links = try reader["Links"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Link.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetNetworkResourceCountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkResourceCountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkResourceCountsOutput()
        value.networkResourceCounts = try reader["NetworkResourceCounts"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkResourceCount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetNetworkResourceRelationshipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkResourceRelationshipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkResourceRelationshipsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.relationships = try reader["Relationships"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Relationship.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetNetworkResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkResourcesOutput()
        value.networkResources = try reader["NetworkResources"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetNetworkRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkRoutesOutput()
        value.coreNetworkSegmentEdge = try reader["CoreNetworkSegmentEdge"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.read(from:))
        value.networkRoutes = try reader["NetworkRoutes"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableArn = try reader["RouteTableArn"].readIfPresent()
        value.routeTableTimestamp = try reader["RouteTableTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.routeTableType = try reader["RouteTableType"].readIfPresent()
        return value
    }
}

extension GetNetworkTelemetryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkTelemetryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkTelemetryOutput()
        value.networkTelemetry = try reader["NetworkTelemetry"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkTelemetry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent()
        return value
    }
}

extension GetRouteAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRouteAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRouteAnalysisOutput()
        value.routeAnalysis = try reader["RouteAnalysis"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysis.read(from:))
        return value
    }
}

extension GetSitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSitesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sites = try reader["Sites"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Site.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSiteToSiteVpnAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSiteToSiteVpnAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSiteToSiteVpnAttachmentOutput()
        value.siteToSiteVpnAttachment = try reader["SiteToSiteVpnAttachment"].readIfPresent(with: NetworkManagerClientTypes.SiteToSiteVpnAttachment.read(from:))
        return value
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransitGatewayConnectPeerAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransitGatewayConnectPeerAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.transitGatewayConnectPeerAssociations = try reader["TransitGatewayConnectPeerAssociations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTransitGatewayPeeringOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransitGatewayPeeringOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransitGatewayPeeringOutput()
        value.transitGatewayPeering = try reader["TransitGatewayPeering"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayPeering.read(from:))
        return value
    }
}

extension GetTransitGatewayRegistrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransitGatewayRegistrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransitGatewayRegistrationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.transitGatewayRegistrations = try reader["TransitGatewayRegistrations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.TransitGatewayRegistration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTransitGatewayRouteTableAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransitGatewayRouteTableAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransitGatewayRouteTableAttachmentOutput()
        value.transitGatewayRouteTableAttachment = try reader["TransitGatewayRouteTableAttachment"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayRouteTableAttachment.read(from:))
        return value
    }
}

extension GetVpcAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVpcAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVpcAttachmentOutput()
        value.vpcAttachment = try reader["VpcAttachment"].readIfPresent(with: NetworkManagerClientTypes.VpcAttachment.read(from:))
        return value
    }
}

extension ListAttachmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttachmentsOutput()
        value.attachments = try reader["Attachments"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Attachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectPeersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectPeersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectPeersOutput()
        value.connectPeers = try reader["ConnectPeers"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ConnectPeerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCoreNetworkPolicyVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoreNetworkPolicyVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreNetworkPolicyVersionsOutput()
        value.coreNetworkPolicyVersions = try reader["CoreNetworkPolicyVersions"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkPolicyVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCoreNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoreNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreNetworksOutput()
        value.coreNetworks = try reader["CoreNetworks"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOrganizationServiceAccessStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrganizationServiceAccessStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationServiceAccessStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationStatus = try reader["OrganizationStatus"].readIfPresent(with: NetworkManagerClientTypes.OrganizationStatus.read(from:))
        return value
    }
}

extension ListPeeringsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPeeringsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPeeringsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.peerings = try reader["Peerings"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Peering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutCoreNetworkPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutCoreNetworkPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutCoreNetworkPolicyOutput()
        value.coreNetworkPolicy = try reader["CoreNetworkPolicy"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkPolicy.read(from:))
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        return PutResourcePolicyOutput()
    }
}

extension RegisterTransitGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterTransitGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTransitGatewayOutput()
        value.transitGatewayRegistration = try reader["TransitGatewayRegistration"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayRegistration.read(from:))
        return value
    }
}

extension RejectAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectAttachmentOutput()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        return value
    }
}

extension RestoreCoreNetworkPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreCoreNetworkPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreCoreNetworkPolicyVersionOutput()
        value.coreNetworkPolicy = try reader["CoreNetworkPolicy"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkPolicy.read(from:))
        return value
    }
}

extension StartOrganizationServiceAccessUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOrganizationServiceAccessUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartOrganizationServiceAccessUpdateOutput()
        value.organizationStatus = try reader["OrganizationStatus"].readIfPresent(with: NetworkManagerClientTypes.OrganizationStatus.read(from:))
        return value
    }
}

extension StartRouteAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRouteAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRouteAnalysisOutput()
        value.routeAnalysis = try reader["RouteAnalysis"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysis.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: NetworkManagerClientTypes.Connection.read(from:))
        return value
    }
}

extension UpdateCoreNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCoreNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCoreNetworkOutput()
        value.coreNetwork = try reader["CoreNetwork"].readIfPresent(with: NetworkManagerClientTypes.CoreNetwork.read(from:))
        return value
    }
}

extension UpdateDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeviceOutput()
        value.device = try reader["Device"].readIfPresent(with: NetworkManagerClientTypes.Device.read(from:))
        return value
    }
}

extension UpdateGlobalNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlobalNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlobalNetworkOutput()
        value.globalNetwork = try reader["GlobalNetwork"].readIfPresent(with: NetworkManagerClientTypes.GlobalNetwork.read(from:))
        return value
    }
}

extension UpdateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLinkOutput()
        value.link = try reader["Link"].readIfPresent(with: NetworkManagerClientTypes.Link.read(from:))
        return value
    }
}

extension UpdateNetworkResourceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkResourceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkResourceMetadataOutput()
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension UpdateSiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSiteOutput()
        value.site = try reader["Site"].readIfPresent(with: NetworkManagerClientTypes.Site.read(from:))
        return value
    }
}

extension UpdateVpcAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcAttachmentOutput()
        value.vpcAttachment = try reader["VpcAttachment"].readIfPresent(with: NetworkManagerClientTypes.VpcAttachment.read(from:))
        return value
    }
}

enum AcceptAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateCustomerGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTransitGatewayConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCoreNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CoreNetworkPolicyException": return try CoreNetworkPolicyException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGlobalNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSiteToSiteVpnAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTransitGatewayPeeringOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTransitGatewayRouteTableAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCoreNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCoreNetworkPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGlobalNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePeeringOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterTransitGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGlobalNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateCustomerGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateTransitGatewayConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteCoreNetworkChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectPeerAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreNetworkChangeEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreNetworkChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreNetworkPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomerGatewayAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLinkAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkResourceCountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkResourceRelationshipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkTelemetryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRouteAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSiteToSiteVpnAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransitGatewayConnectPeerAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransitGatewayPeeringOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransitGatewayRegistrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransitGatewayRouteTableAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVpcAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectPeersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoreNetworkPolicyVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoreNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrganizationServiceAccessStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPeeringsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutCoreNetworkPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CoreNetworkPolicyException": return try CoreNetworkPolicyException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterTransitGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreCoreNetworkPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOrganizationServiceAccessUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRouteAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCoreNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlobalNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkResourceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.context = try reader["Context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.limitCode = try reader["LimitCode"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CoreNetworkPolicyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CoreNetworkPolicyException {
        let reader = baseError.errorBodyReader
        var value = CoreNetworkPolicyException()
        value.properties.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkPolicyError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NetworkManagerClientTypes.Attachment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Attachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Attachment()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.coreNetworkArn = try reader["CoreNetworkArn"].readIfPresent()
        value.attachmentId = try reader["AttachmentId"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.attachmentType = try reader["AttachmentType"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.attachmentPolicyRuleNumber = try reader["AttachmentPolicyRuleNumber"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        value.networkFunctionGroupName = try reader["NetworkFunctionGroupName"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.proposedSegmentChange = try reader["ProposedSegmentChange"].readIfPresent(with: NetworkManagerClientTypes.ProposedSegmentChange.read(from:))
        value.proposedNetworkFunctionGroupChange = try reader["ProposedNetworkFunctionGroupChange"].readIfPresent(with: NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationErrors = try reader["LastModificationErrors"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.AttachmentError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.AttachmentError {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.AttachmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.AttachmentError()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ProposedNetworkFunctionGroupChange()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachmentPolicyRuleNumber = try reader["AttachmentPolicyRuleNumber"].readIfPresent()
        value.networkFunctionGroupName = try reader["NetworkFunctionGroupName"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.Tag {

    static func write(value: NetworkManagerClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ProposedSegmentChange {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ProposedSegmentChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ProposedSegmentChange()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachmentPolicyRuleNumber = try reader["AttachmentPolicyRuleNumber"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeerAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeerAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeerAssociation()
        value.connectPeerId = try reader["ConnectPeerId"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CustomerGatewayAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CustomerGatewayAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CustomerGatewayAssociation()
        value.customerGatewayArn = try reader["CustomerGatewayArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.LinkAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.LinkAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.LinkAssociation()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.linkAssociationState = try reader["LinkAssociationState"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation()
        value.transitGatewayConnectPeerArn = try reader["TransitGatewayConnectPeerArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ConnectAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectAttachment()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        value.transportAttachmentId = try reader["TransportAttachmentId"].readIfPresent()
        value.options = try reader["Options"].readIfPresent(with: NetworkManagerClientTypes.ConnectAttachmentOptions.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.ConnectAttachmentOptions {

    static func write(value: NetworkManagerClientTypes.ConnectAttachmentOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectAttachmentOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectAttachmentOptions()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Connection()
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionArn = try reader["ConnectionArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.connectedDeviceId = try reader["ConnectedDeviceId"].readIfPresent()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.connectedLinkId = try reader["ConnectedLinkId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeer {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeer()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.connectAttachmentId = try reader["ConnectAttachmentId"].readIfPresent()
        value.connectPeerId = try reader["ConnectPeerId"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configuration = try reader["Configuration"].readIfPresent(with: NetworkManagerClientTypes.ConnectPeerConfiguration.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetArn = try reader["SubnetArn"].readIfPresent()
        value.lastModificationErrors = try reader["LastModificationErrors"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ConnectPeerError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeerError {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeerError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeerError()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeerConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeerConfiguration()
        value.coreNetworkAddress = try reader["CoreNetworkAddress"].readIfPresent()
        value.peerAddress = try reader["PeerAddress"].readIfPresent()
        value.insideCidrBlocks = try reader["InsideCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.bgpConfigurations = try reader["BgpConfigurations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ConnectPeerBgpConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeerBgpConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeerBgpConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeerBgpConfiguration()
        value.coreNetworkAsn = try reader["CoreNetworkAsn"].readIfPresent()
        value.peerAsn = try reader["PeerAsn"].readIfPresent()
        value.coreNetworkAddress = try reader["CoreNetworkAddress"].readIfPresent()
        value.peerAddress = try reader["PeerAddress"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetwork {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetwork()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.coreNetworkArn = try reader["CoreNetworkArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.segments = try reader["Segments"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkFunctionGroups = try reader["NetworkFunctionGroups"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.edges = try reader["Edges"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkEdge.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkEdge {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkEdge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkEdge()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.asn = try reader["Asn"].readIfPresent()
        value.insideCidrBlocks = try reader["InsideCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroup()
        value.name = try reader["Name"].readIfPresent()
        value.edgeLocations = try reader["EdgeLocations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.segments = try reader["Segments"].readIfPresent(with: NetworkManagerClientTypes.ServiceInsertionSegments.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.ServiceInsertionSegments {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ServiceInsertionSegments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ServiceInsertionSegments()
        value.sendVia = try reader["SendVia"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sendTo = try reader["SendTo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkSegment()
        value.name = try reader["Name"].readIfPresent()
        value.edgeLocations = try reader["EdgeLocations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sharedSegments = try reader["SharedSegments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Device()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.deviceArn = try reader["DeviceArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.awsLocation = try reader["AWSLocation"].readIfPresent(with: NetworkManagerClientTypes.AWSLocation.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.vendor = try reader["Vendor"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.location = try reader["Location"].readIfPresent(with: NetworkManagerClientTypes.Location.read(from:))
        value.siteId = try reader["SiteId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.Location {

    static func write(value: NetworkManagerClientTypes.Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Latitude"].write(value.latitude)
        try writer["Longitude"].write(value.longitude)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Location()
        value.address = try reader["Address"].readIfPresent()
        value.latitude = try reader["Latitude"].readIfPresent()
        value.longitude = try reader["Longitude"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.AWSLocation {

    static func write(value: NetworkManagerClientTypes.AWSLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubnetArn"].write(value.subnetArn)
        try writer["Zone"].write(value.zone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.AWSLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.AWSLocation()
        value.zone = try reader["Zone"].readIfPresent()
        value.subnetArn = try reader["SubnetArn"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.GlobalNetwork {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.GlobalNetwork {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.GlobalNetwork()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.globalNetworkArn = try reader["GlobalNetworkArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.Link {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Link {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Link()
        value.linkId = try reader["LinkId"].readIfPresent()
        value.linkArn = try reader["LinkArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.siteId = try reader["SiteId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.bandwidth = try reader["Bandwidth"].readIfPresent(with: NetworkManagerClientTypes.Bandwidth.read(from:))
        value.provider = try reader["Provider"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.Bandwidth {

    static func write(value: NetworkManagerClientTypes.Bandwidth?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DownloadSpeed"].write(value.downloadSpeed)
        try writer["UploadSpeed"].write(value.uploadSpeed)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Bandwidth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Bandwidth()
        value.uploadSpeed = try reader["UploadSpeed"].readIfPresent()
        value.downloadSpeed = try reader["DownloadSpeed"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.Site {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Site {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Site()
        value.siteId = try reader["SiteId"].readIfPresent()
        value.siteArn = try reader["SiteArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.location = try reader["Location"].readIfPresent(with: NetworkManagerClientTypes.Location.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.SiteToSiteVpnAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.SiteToSiteVpnAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.SiteToSiteVpnAttachment()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        value.vpnConnectionArn = try reader["VpnConnectionArn"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.TransitGatewayPeering {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.TransitGatewayPeering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.TransitGatewayPeering()
        value.peering = try reader["Peering"].readIfPresent(with: NetworkManagerClientTypes.Peering.read(from:))
        value.transitGatewayArn = try reader["TransitGatewayArn"].readIfPresent()
        value.transitGatewayPeeringAttachmentId = try reader["TransitGatewayPeeringAttachmentId"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.Peering {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Peering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Peering()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.coreNetworkArn = try reader["CoreNetworkArn"].readIfPresent()
        value.peeringId = try reader["PeeringId"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.peeringType = try reader["PeeringType"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationErrors = try reader["LastModificationErrors"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.PeeringError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.PeeringError {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.PeeringError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.PeeringError()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.missingPermissionsContext = try reader["MissingPermissionsContext"].readIfPresent(with: NetworkManagerClientTypes.PermissionsErrorContext.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.PermissionsErrorContext {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.PermissionsErrorContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.PermissionsErrorContext()
        value.missingPermission = try reader["MissingPermission"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.TransitGatewayRouteTableAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.TransitGatewayRouteTableAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.TransitGatewayRouteTableAttachment()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        value.peeringId = try reader["PeeringId"].readIfPresent()
        value.transitGatewayRouteTableArn = try reader["TransitGatewayRouteTableArn"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.VpcAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.VpcAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.VpcAttachment()
        value.attachment = try reader["Attachment"].readIfPresent(with: NetworkManagerClientTypes.Attachment.read(from:))
        value.subnetArns = try reader["SubnetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.options = try reader["Options"].readIfPresent(with: NetworkManagerClientTypes.VpcOptions.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.VpcOptions {

    static func write(value: NetworkManagerClientTypes.VpcOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplianceModeSupport"].write(value.applianceModeSupport)
        try writer["Ipv6Support"].write(value.ipv6Support)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.VpcOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.VpcOptions()
        value.ipv6Support = try reader["Ipv6Support"].readIfPresent() ?? false
        value.applianceModeSupport = try reader["ApplianceModeSupport"].readIfPresent() ?? false
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkPolicy()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.policyVersionId = try reader["PolicyVersionId"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.changeSetState = try reader["ChangeSetState"].readIfPresent()
        value.policyErrors = try reader["PolicyErrors"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.CoreNetworkPolicyError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.policyDocument = try reader["PolicyDocument"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyError {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkPolicyError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkPolicyError()
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistration {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.TransitGatewayRegistration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.TransitGatewayRegistration()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.transitGatewayArn = try reader["TransitGatewayArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent(with: NetworkManagerClientTypes.TransitGatewayRegistrationStateReason.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.TransitGatewayRegistrationStateReason {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.TransitGatewayRegistrationStateReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.TransitGatewayRegistrationStateReason()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkChangeEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkChangeEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkChangeEvent()
        value.type = try reader["Type"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.identifierPath = try reader["IdentifierPath"].readIfPresent()
        value.eventTime = try reader["EventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.values = try reader["Values"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkChangeEventValues.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkChangeEventValues {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkChangeEventValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkChangeEventValues()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        value.networkFunctionGroupName = try reader["NetworkFunctionGroupName"].readIfPresent()
        value.attachmentId = try reader["AttachmentId"].readIfPresent()
        value.cidr = try reader["Cidr"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkChange {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkChange()
        value.type = try reader["Type"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.identifier = try reader["Identifier"].readIfPresent()
        value.previousValues = try reader["PreviousValues"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkChangeValues.read(from:))
        value.newValues = try reader["NewValues"].readIfPresent(with: NetworkManagerClientTypes.CoreNetworkChangeValues.read(from:))
        value.identifierPath = try reader["IdentifierPath"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkChangeValues {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkChangeValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkChangeValues()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        value.networkFunctionGroupName = try reader["NetworkFunctionGroupName"].readIfPresent()
        value.edgeLocations = try reader["EdgeLocations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.asn = try reader["Asn"].readIfPresent()
        value.cidr = try reader["Cidr"].readIfPresent()
        value.destinationIdentifier = try reader["DestinationIdentifier"].readIfPresent()
        value.insideCidrBlocks = try reader["InsideCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sharedSegments = try reader["SharedSegments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceInsertionActions = try reader["ServiceInsertionActions"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.ServiceInsertionAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.ServiceInsertionAction {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ServiceInsertionAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ServiceInsertionAction()
        value.action = try reader["Action"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.whenSentTo = try reader["WhenSentTo"].readIfPresent(with: NetworkManagerClientTypes.WhenSentTo.read(from:))
        value.via = try reader["Via"].readIfPresent(with: NetworkManagerClientTypes.Via.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.Via {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Via {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Via()
        value.networkFunctionGroups = try reader["NetworkFunctionGroups"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkFunctionGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.withEdgeOverrides = try reader["WithEdgeOverrides"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.EdgeOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.EdgeOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.EdgeOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.EdgeOverride()
        value.edgeSets = try reader["EdgeSets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.useEdge = try reader["UseEdge"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkFunctionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkFunctionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkFunctionGroup()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.WhenSentTo {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.WhenSentTo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.WhenSentTo()
        value.whenSentToSegmentsList = try reader["WhenSentToSegmentsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.NetworkResourceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkResourceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkResourceCount()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.count = try reader["Count"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.Relationship {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.Relationship {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.Relationship()
        value.from = try reader["From"].readIfPresent()
        value.to = try reader["To"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkResource {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkResource()
        value.registeredGatewayArn = try reader["RegisteredGatewayArn"].readIfPresent()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent()
        value.definitionTimestamp = try reader["DefinitionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier {

    static func write(value: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["EdgeLocation"].write(value.edgeLocation)
        try writer["SegmentName"].write(value.segmentName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkRoute {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkRoute()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.NetworkRouteDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prefixListId = try reader["PrefixListId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkRouteDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkRouteDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkRouteDestination()
        value.coreNetworkAttachmentId = try reader["CoreNetworkAttachmentId"].readIfPresent()
        value.transitGatewayAttachmentId = try reader["TransitGatewayAttachmentId"].readIfPresent()
        value.segmentName = try reader["SegmentName"].readIfPresent()
        value.networkFunctionGroupName = try reader["NetworkFunctionGroupName"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkTelemetry {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkTelemetry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkTelemetry()
        value.registeredGatewayArn = try reader["RegisteredGatewayArn"].readIfPresent()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.address = try reader["Address"].readIfPresent()
        value.health = try reader["Health"].readIfPresent(with: NetworkManagerClientTypes.ConnectionHealth.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.ConnectionHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectionHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectionHealth()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension NetworkManagerClientTypes.RouteAnalysis {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.RouteAnalysis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.RouteAnalysis()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.routeAnalysisId = try reader["RouteAnalysisId"].readIfPresent()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.source = try reader["Source"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysisEndpointOptions.read(from:))
        value.destination = try reader["Destination"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysisEndpointOptions.read(from:))
        value.includeReturnPath = try reader["IncludeReturnPath"].readIfPresent() ?? false
        value.useMiddleboxes = try reader["UseMiddleboxes"].readIfPresent() ?? false
        value.forwardPath = try reader["ForwardPath"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysisPath.read(from:))
        value.returnPath = try reader["ReturnPath"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysisPath.read(from:))
        return value
    }
}

extension NetworkManagerClientTypes.RouteAnalysisPath {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.RouteAnalysisPath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.RouteAnalysisPath()
        value.completionStatus = try reader["CompletionStatus"].readIfPresent(with: NetworkManagerClientTypes.RouteAnalysisCompletion.read(from:))
        value.path = try reader["Path"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.PathComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.PathComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.PathComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.PathComponent()
        value.sequence = try reader["Sequence"].readIfPresent()
        value.resource = try reader["Resource"].readIfPresent(with: NetworkManagerClientTypes.NetworkResourceSummary.read(from:))
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.NetworkResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.NetworkResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.NetworkResourceSummary()
        value.registeredGatewayArn = try reader["RegisteredGatewayArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent()
        value.nameTag = try reader["NameTag"].readIfPresent()
        value.isMiddlebox = try reader["IsMiddlebox"].readIfPresent() ?? false
        return value
    }
}

extension NetworkManagerClientTypes.RouteAnalysisCompletion {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.RouteAnalysisCompletion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.RouteAnalysisCompletion()
        value.resultCode = try reader["ResultCode"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.reasonContext = try reader["ReasonContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.RouteAnalysisEndpointOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.RouteAnalysisEndpointOptions()
        value.transitGatewayAttachmentArn = try reader["TransitGatewayAttachmentArn"].readIfPresent()
        value.transitGatewayArn = try reader["TransitGatewayArn"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ConnectPeerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ConnectPeerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ConnectPeerSummary()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.connectAttachmentId = try reader["ConnectAttachmentId"].readIfPresent()
        value.connectPeerId = try reader["ConnectPeerId"].readIfPresent()
        value.edgeLocation = try reader["EdgeLocation"].readIfPresent()
        value.connectPeerState = try reader["ConnectPeerState"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetArn = try reader["SubnetArn"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkPolicyVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkPolicyVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkPolicyVersion()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.policyVersionId = try reader["PolicyVersionId"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.changeSetState = try reader["ChangeSetState"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.CoreNetworkSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.CoreNetworkSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.CoreNetworkSummary()
        value.coreNetworkId = try reader["CoreNetworkId"].readIfPresent()
        value.coreNetworkArn = try reader["CoreNetworkArn"].readIfPresent()
        value.globalNetworkId = try reader["GlobalNetworkId"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.OrganizationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.OrganizationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.OrganizationStatus()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.organizationAwsServiceAccessStatus = try reader["OrganizationAwsServiceAccessStatus"].readIfPresent()
        value.slrDeploymentStatus = try reader["SLRDeploymentStatus"].readIfPresent()
        value.accountStatusList = try reader["AccountStatusList"].readListIfPresent(memberReadingClosure: NetworkManagerClientTypes.AccountStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NetworkManagerClientTypes.AccountStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.AccountStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.AccountStatus()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.slrDeploymentStatus = try reader["SLRDeploymentStatus"].readIfPresent()
        return value
    }
}

extension NetworkManagerClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> NetworkManagerClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NetworkManagerClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension NetworkManagerClientTypes.BgpOptions {

    static func write(value: NetworkManagerClientTypes.BgpOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PeerAsn"].write(value.peerAsn)
    }
}

extension NetworkManagerClientTypes.RouteTableIdentifier {

    static func write(value: NetworkManagerClientTypes.RouteTableIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CoreNetworkNetworkFunctionGroup"].write(value.coreNetworkNetworkFunctionGroup, with: NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroupIdentifier.write(value:to:))
        try writer["CoreNetworkSegmentEdge"].write(value.coreNetworkSegmentEdge, with: NetworkManagerClientTypes.CoreNetworkSegmentEdgeIdentifier.write(value:to:))
        try writer["TransitGatewayRouteTableArn"].write(value.transitGatewayRouteTableArn)
    }
}

extension NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroupIdentifier {

    static func write(value: NetworkManagerClientTypes.CoreNetworkNetworkFunctionGroupIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CoreNetworkId"].write(value.coreNetworkId)
        try writer["EdgeLocation"].write(value.edgeLocation)
        try writer["NetworkFunctionGroupName"].write(value.networkFunctionGroupName)
    }
}

extension NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification {

    static func write(value: NetworkManagerClientTypes.RouteAnalysisEndpointOptionsSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddress"].write(value.ipAddress)
        try writer["TransitGatewayAttachmentArn"].write(value.transitGatewayAttachmentArn)
    }
}

public enum NetworkManagerClientTypes {}
