//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You don't have sufficient access permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KeyspacesClientTypes {
    /// The auto scaling policy that scales a table based on the ratio of consumed to provisioned capacity.
    public struct TargetTrackingScalingPolicyConfiguration {
        /// Specifies if scale-in is enabled. When auto scaling automatically decreases capacity for a table, the table scales in. When scaling policies are set, they can't scale in the table lower than its minimum capacity.
        public var disableScaleIn: Swift.Bool
        /// Specifies a scale-in cool down period. A cooldown period in seconds between scaling activities that lets the table stabilize before another scaling activity starts.
        public var scaleInCooldown: Swift.Int
        /// Specifies a scale out cool down period. A cooldown period in seconds between scaling activities that lets the table stabilize before another scaling activity starts.
        public var scaleOutCooldown: Swift.Int
        /// Specifies the target value for the target tracking auto scaling policy. Amazon Keyspaces auto scaling scales up capacity automatically when traffic exceeds this target utilization rate, and then back down when it falls below the target. This ensures that the ratio of consumed capacity to provisioned capacity stays at or near this value. You define targetValue as a percentage. A double between 20 and 90.
        /// This member is required.
        public var targetValue: Swift.Double

        public init(
            disableScaleIn: Swift.Bool = false,
            scaleInCooldown: Swift.Int = 0,
            scaleOutCooldown: Swift.Int = 0,
            targetValue: Swift.Double = 0.0
        )
        {
            self.disableScaleIn = disableScaleIn
            self.scaleInCooldown = scaleInCooldown
            self.scaleOutCooldown = scaleOutCooldown
            self.targetValue = targetValue
        }
    }

}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces supports the target tracking auto scaling policy. With this policy, Amazon Keyspaces auto scaling ensures that the table's ratio of consumed to provisioned capacity stays at or near the target value that you specify. You define the target value as a percentage between 20 and 90.
    public struct AutoScalingPolicy {
        /// Auto scaling scales up capacity automatically when traffic exceeds this target utilization rate, and then back down when it falls below the target. A double between 20 and 90.
        public var targetTrackingScalingPolicyConfiguration: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration?

        public init(
            targetTrackingScalingPolicyConfiguration: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration? = nil
        )
        {
            self.targetTrackingScalingPolicyConfiguration = targetTrackingScalingPolicyConfiguration
        }
    }

}

extension KeyspacesClientTypes {
    /// The optional auto scaling settings for a table with provisioned throughput capacity. To turn on auto scaling for a table in throughputMode:PROVISIONED, you must specify the following parameters. Configure the minimum and maximum capacity units. The auto scaling policy ensures that capacity never goes below the minimum or above the maximum range.
    ///
    /// * minimumUnits: The minimum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
    ///
    /// * maximumUnits: The maximum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
    ///
    /// * scalingPolicy: Amazon Keyspaces supports the target tracking scaling policy. The auto scaling target is the provisioned capacity of the table.
    ///
    /// * targetTrackingScalingPolicyConfiguration: To define the target tracking policy, you must define the target value.
    ///
    /// * targetValue: The target utilization rate of the table. Amazon Keyspaces auto scaling ensures that the ratio of consumed capacity to provisioned capacity stays at or near this value. You define targetValue as a percentage. A double between 20 and 90. (Required)
    ///
    /// * disableScaleIn: A boolean that specifies if scale-in is disabled or enabled for the table. This parameter is disabled by default. To turn on scale-in, set the boolean value to FALSE. This means that capacity for a table can be automatically scaled down on your behalf. (Optional)
    ///
    /// * scaleInCooldown: A cooldown period in seconds between scaling activities that lets the table stabilize before another scale in activity starts. If no value is provided, the default is 0. (Optional)
    ///
    /// * scaleOutCooldown: A cooldown period in seconds between scaling activities that lets the table stabilize before another scale out activity starts. If no value is provided, the default is 0. (Optional)
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public struct AutoScalingSettings {
        /// This optional parameter enables auto scaling for the table if set to false.
        public var autoScalingDisabled: Swift.Bool
        /// Manage costs by specifying the maximum amount of throughput to provision. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
        public var maximumUnits: Swift.Int?
        /// The minimum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
        public var minimumUnits: Swift.Int?
        /// Amazon Keyspaces supports the target tracking auto scaling policy. With this policy, Amazon Keyspaces auto scaling ensures that the table's ratio of consumed to provisioned capacity stays at or near the target value that you specify. You define the target value as a percentage between 20 and 90.
        public var scalingPolicy: KeyspacesClientTypes.AutoScalingPolicy?

        public init(
            autoScalingDisabled: Swift.Bool = false,
            maximumUnits: Swift.Int? = nil,
            minimumUnits: Swift.Int? = nil,
            scalingPolicy: KeyspacesClientTypes.AutoScalingPolicy? = nil
        )
        {
            self.autoScalingDisabled = autoScalingDisabled
            self.maximumUnits = maximumUnits
            self.minimumUnits = minimumUnits
            self.scalingPolicy = scalingPolicy
        }
    }

}

extension KeyspacesClientTypes {
    /// The optional auto scaling capacity settings for a table in provisioned capacity mode.
    public struct AutoScalingSpecification {
        /// The auto scaling settings for the table's read capacity.
        public var readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?
        /// The auto scaling settings for the table's write capacity.
        public var writeCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?

        public init(
            readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil,
            writeCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil
        )
        {
            self.readCapacityAutoScaling = readCapacityAutoScaling
            self.writeCapacityAutoScaling = writeCapacityAutoScaling
        }
    }

}

extension KeyspacesClientTypes {

    public enum ThroughputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case payPerRequest
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ThroughputMode] {
            return [
                .payPerRequest,
                .provisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .payPerRequest: return "PAY_PER_REQUEST"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces has two read/write capacity modes for processing reads and writes on your tables:
    ///
    /// * On-demand (default)
    ///
    /// * Provisioned
    ///
    ///
    /// The read/write capacity mode that you choose controls how you are charged for read and write throughput and how table throughput capacity is managed. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecification {
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
        ///
        ///
        /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init(
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes {
    /// The read/write throughput capacity mode for a table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED.
    ///
    ///
    /// For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecificationSummary {
        /// The timestamp of the last operation that changed the provisioned throughput capacity of a table.
        public var lastUpdateToPayPerRequestTimestamp: Foundation.Date?
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
        ///
        ///
        /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init(
            lastUpdateToPayPerRequestTimestamp: Foundation.Date? = nil,
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.lastUpdateToPayPerRequestTimestamp = lastUpdateToPayPerRequestTimestamp
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes {

    public enum ClientSideTimestampsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientSideTimestampsStatus] {
            return [
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// The client-side timestamp setting of the table. For more information, see [How it works: Amazon Keyspaces client-side timestamps](https://docs.aws.amazon.com/keyspaces/latest/devguide/client-side-timestamps-how-it-works.html) in the Amazon Keyspaces Developer Guide.
    public struct ClientSideTimestamps {
        /// Shows how to enable client-side timestamps settings for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.ClientSideTimestampsStatus?

        public init(
            status: KeyspacesClientTypes.ClientSideTimestampsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.
    public struct ClusteringKey {
        /// The name(s) of the clustering column(s).
        /// This member is required.
        public var name: Swift.String?
        /// Sets the ascendant (ASC) or descendant (DESC) order modifier.
        /// This member is required.
        public var orderBy: KeyspacesClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            orderBy: KeyspacesClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.orderBy = orderBy
        }
    }

}

extension KeyspacesClientTypes {
    /// The names and data types of regular columns.
    public struct ColumnDefinition {
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column. For a list of available data types, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension KeyspacesClientTypes {
    /// An optional comment that describes the table.
    public struct Comment {
        /// An optional description of the table.
        /// This member is required.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

/// Amazon Keyspaces couldn't complete the requested action. This error may occur if you try to perform an action and the same or a different action is already in progress, or if you try to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Amazon Keyspaces was unable to fully process this request because of an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation exceeded the service quota for this resource. For more information on service quotas, see [Quotas](https://docs.aws.amazon.com/keyspaces/latest/devguide/quotas.html) in the Amazon Keyspaces Developer Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation failed due to an invalid or malformed request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KeyspacesClientTypes {

    public enum Rs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiRegion
        case singleRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [Rs] {
            return [
                .multiRegion,
                .singleRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiRegion: return "MULTI_REGION"
            case .singleRegion: return "SINGLE_REGION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// The replication specification of the keyspace includes:
    ///
    /// * regionList - up to six Amazon Web Services Regions where the keyspace is replicated in.
    ///
    /// * replicationStrategy - the required value is SINGLE_REGION or MULTI_REGION.
    public struct ReplicationSpecification {
        /// The regionList can contain up to six Amazon Web Services Regions where the keyspace is replicated in.
        public var regionList: [Swift.String]?
        /// The replicationStrategy of a keyspace, the required value is SINGLE_REGION or MULTI_REGION.
        /// This member is required.
        public var replicationStrategy: KeyspacesClientTypes.Rs?

        public init(
            regionList: [Swift.String]? = nil,
            replicationStrategy: KeyspacesClientTypes.Rs? = nil
        )
        {
            self.regionList = regionList
            self.replicationStrategy = replicationStrategy
        }
    }

}

extension KeyspacesClientTypes {
    /// Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single Amazon Keyspaces resource. Amazon Web Services-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. Amazon Web Services-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user: in the Cost Allocation Report. You cannot backdate the application of a tag. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public struct Tag {
        /// The key of the tag. Tag keys are case sensitive. Each Amazon Keyspaces resource can only have up to one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateKeyspaceInput {
    /// The name of the keyspace to be created.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The replication specification of the keyspace includes:
    ///
    /// * replicationStrategy - the required value is SINGLE_REGION or MULTI_REGION.
    ///
    /// * regionList - if the replicationStrategy is MULTI_REGION, the regionList requires the current Region and at least one additional Amazon Web Services Region where the keyspace is going to be replicated in. The maximum number of supported replication Regions including the current Region is six.
    public var replicationSpecification: KeyspacesClientTypes.ReplicationSpecification?
    /// A list of key-value pair tags to be attached to the keyspace. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        keyspaceName: Swift.String? = nil,
        replicationSpecification: KeyspacesClientTypes.ReplicationSpecification? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.replicationSpecification = replicationSpecification
        self.tags = tags
    }
}

public struct CreateKeyspaceOutput {
    /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

/// The operation tried to access a keyspace or table that doesn't exist. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier in the format of Amazon Resource Name (ARN), for the resource not found.
        public internal(set) var resourceArn: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
    }
}

extension KeyspacesClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOwnedKmsKey
        case customerManagedKmsKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .awsOwnedKmsKey,
                .customerManagedKmsKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKmsKey: return "AWS_OWNED_KMS_KEY"
            case .customerManagedKmsKey: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces encrypts and decrypts the table data at rest transparently and integrates with Key Management Service for storing and managing the encryption key. You can choose one of the following KMS keys (KMS keys):
    ///
    /// * Amazon Web Services owned key - This is the default encryption type. The key is owned by Amazon Keyspaces (no additional charge).
    ///
    /// * Customer managed key - This key is stored in your account and is created, owned, and managed by you. You have full control over the customer managed key (KMS charges apply).
    ///
    ///
    /// For more information about encryption at rest in Amazon Keyspaces, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide. For more information about KMS, see [KMS management service concepts](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Key Management Service Developer Guide.
    public struct EncryptionSpecification {
        /// The Amazon Resource Name (ARN) of the customer managed KMS key, for example kms_key_identifier:ARN.
        public var kmsKeyIdentifier: Swift.String?
        /// The encryption option specified for the table. You can choose one of the following KMS keys (KMS keys):
        ///
        /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
        ///
        /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
        ///
        ///
        /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: KeyspacesClientTypes.EncryptionType?

        public init(
            kmsKeyIdentifier: Swift.String? = nil,
            type: KeyspacesClientTypes.EncryptionType? = nil
        )
        {
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.type = type
        }
    }

}

extension KeyspacesClientTypes {

    public enum PointInTimeRecoveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PointInTimeRecoveryStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// Point-in-time recovery (PITR) helps protect your Amazon Keyspaces tables from accidental write or delete operations by providing you continuous backups of your table data. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public struct PointInTimeRecovery {
        /// The options are:
        ///
        /// * status=ENABLED
        ///
        /// * status=DISABLED
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init(
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    /// The Amazon Web Services Region specific settings of a multi-Region table. For a multi-Region table, you can configure the table's read capacity differently per Amazon Web Services Region. You can do this by configuring the following parameters.
    ///
    /// * region: The Region where these settings are applied. (Required)
    ///
    /// * readCapacityUnits: The provisioned read capacity units. (Optional)
    ///
    /// * readCapacityAutoScaling: The read capacity auto scaling settings for the table. (Optional)
    public struct ReplicaSpecification {
        /// The read capacity auto scaling settings for the multi-Region table in the specified Amazon Web Services Region.
        public var readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?
        /// The provisioned read capacity units for the multi-Region table in the specified Amazon Web Services Region.
        public var readCapacityUnits: Swift.Int?
        /// The Amazon Web Services Region.
        /// This member is required.
        public var region: Swift.String?

        public init(
            readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil,
            readCapacityUnits: Swift.Int? = nil,
            region: Swift.String? = nil
        )
        {
            self.readCapacityAutoScaling = readCapacityAutoScaling
            self.readCapacityUnits = readCapacityUnits
            self.region = region
        }
    }

}

extension KeyspacesClientTypes {
    /// The partition key portion of the primary key is required and determines how Amazon Keyspaces stores the data. The partition key can be a single column, or it can be a compound value composed of two or more columns.
    public struct PartitionKey {
        /// The name(s) of the partition key column(s).
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes {
    /// The static columns of the table. Static columns store values that are shared by all rows in the same partition.
    public struct StaticColumn {
        /// The name of the static column.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes {
    /// Describes the schema of the table.
    public struct SchemaDefinition {
        /// The regular columns of the table.
        /// This member is required.
        public var allColumns: [KeyspacesClientTypes.ColumnDefinition]?
        /// The columns that are part of the clustering key of the table.
        public var clusteringKeys: [KeyspacesClientTypes.ClusteringKey]?
        /// The columns that are part of the partition key of the table .
        /// This member is required.
        public var partitionKeys: [KeyspacesClientTypes.PartitionKey]?
        /// The columns that have been defined as STATIC. Static columns store values that are shared by all rows in the same partition.
        public var staticColumns: [KeyspacesClientTypes.StaticColumn]?

        public init(
            allColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
            clusteringKeys: [KeyspacesClientTypes.ClusteringKey]? = nil,
            partitionKeys: [KeyspacesClientTypes.PartitionKey]? = nil,
            staticColumns: [KeyspacesClientTypes.StaticColumn]? = nil
        )
        {
            self.allColumns = allColumns
            self.clusteringKeys = clusteringKeys
            self.partitionKeys = partitionKeys
            self.staticColumns = staticColumns
        }
    }

}

extension KeyspacesClientTypes {

    public enum TimeToLiveStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeToLiveStatus] {
            return [
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// Enable custom Time to Live (TTL) settings for rows and columns without setting a TTL default for the specified table. For more information, see [Enabling TTL on tables](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_enabling) in the Amazon Keyspaces Developer Guide.
    public struct TimeToLive {
        /// Shows how to enable custom Time to Live (TTL) settings for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.TimeToLiveStatus?

        public init(
            status: KeyspacesClientTypes.TimeToLiveStatus? = nil
        )
        {
            self.status = status
        }
    }

}

public struct CreateTableInput {
    /// The optional auto scaling settings for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity automatically on your behalf. Auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide. By default, auto scaling is disabled for a table.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Specifies the read/write throughput capacity mode for the table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:
    ///
    /// * status: "enabled"
    ///
    ///
    /// Once client-side timestamps are enabled for a table, this setting cannot be disabled.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// This parameter allows to enter a description of the table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the table is going to be created in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Specifies if pointInTimeRecovery is enabled or disabled for the table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The optional Amazon Web Services Region specific settings of a multi-Region table. These settings overwrite the general settings of the table for the specified Region. For a multi-Region table in provisioned capacity mode, you can configure the table's read capacity differently for each Region's replica. The write capacity, however, remains synchronized between all replicas to ensure that there's enough capacity to replicate writes across all Regions. To define the read capacity for a table replica in a specific Region, you can do so by configuring the following parameters.
    ///
    /// * region: The Region where these settings are applied. (Required)
    ///
    /// * readCapacityUnits: The provisioned read capacity units. (Optional)
    ///
    /// * readCapacityAutoScaling: The read capacity auto scaling settings for the table. (Optional)
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The schemaDefinition consists of the following parameters. For each column to be created:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
    ///
    ///
    /// The primary key of the table consists of the following columns:
    ///
    /// * partitionKeys - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data.
    ///
    /// * name - The name of each partition key column.
    ///
    /// * clusteringKeys - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.
    ///
    /// * name - The name of the clustering column.
    ///
    /// * orderBy - Sets the ascendant (ASC) or descendant (DESC) order modifier. To define a column as static use staticColumns - Static columns store values that are shared by all rows in the same partition:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type.
    /// This member is required.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of key-value pair tags to be attached to the resource. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?
    /// Enables Time to Live custom settings for the table. The options are:
    ///
    /// * status:enabled
    ///
    /// * status:disabled
    ///
    ///
    /// The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        tableName: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.comment = comment
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.schemaDefinition = schemaDefinition
        self.tableName = tableName
        self.tags = tags
        self.ttl = ttl
    }
}

public struct CreateTableOutput {
    /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteKeyspaceInput {
    /// The name of the keyspace to be deleted.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

public struct DeleteKeyspaceOutput {

    public init() { }
}

public struct DeleteTableInput {
    /// The name of the keyspace of the to be deleted table.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

public struct DeleteTableOutput {

    public init() { }
}

public struct GetKeyspaceInput {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

public struct GetKeyspaceOutput {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// If the replicationStrategy of the keyspace is MULTI_REGION, a list of replication Regions is returned.
    public var replicationRegions: [Swift.String]?
    /// Returns the replication strategy of the keyspace. The options are SINGLE_REGION or MULTI_REGION.
    /// This member is required.
    public var replicationStrategy: KeyspacesClientTypes.Rs?
    /// Returns the ARN of the keyspace.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        replicationRegions: [Swift.String]? = nil,
        replicationStrategy: KeyspacesClientTypes.Rs? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.replicationRegions = replicationRegions
        self.replicationStrategy = replicationStrategy
        self.resourceArn = resourceArn
    }
}

public struct GetTableInput {
    /// The name of the keyspace that the table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

extension KeyspacesClientTypes {
    /// The point-in-time recovery status of the specified table.
    public struct PointInTimeRecoverySummary {
        /// Specifies the earliest possible restore point of the table in ISO 8601 format.
        public var earliestRestorableTimestamp: Foundation.Date?
        /// Shows if point-in-time recovery is enabled or disabled for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init(
            earliestRestorableTimestamp: Foundation.Date? = nil,
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.earliestRestorableTimestamp = earliestRestorableTimestamp
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {

    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case inaccessibleEncryptionCredentials
        case restoring
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .inaccessibleEncryptionCredentials,
                .restoring,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .inaccessibleEncryptionCredentials: return "INACCESSIBLE_ENCRYPTION_CREDENTIALS"
            case .restoring: return "RESTORING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KeyspacesClientTypes {
    /// The Region-specific settings of a multi-Region table in the specified Amazon Web Services Region. If the multi-Region table is using provisioned capacity and has optional auto scaling policies configured, note that the Region specific summary returns both read and write capacity settings. But only Region specific read capacity settings can be configured for a multi-Region table. In a multi-Region table, your write capacity units will be synced across all Amazon Web Services Regions to ensure that there is enough capacity to replicate write events across Regions.
    public struct ReplicaSpecificationSummary {
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED.
        ///
        ///
        /// For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        public var capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
        /// The Amazon Web Services Region.
        public var region: Swift.String?
        /// The status of the multi-Region table in the specified Amazon Web Services Region.
        public var status: KeyspacesClientTypes.TableStatus?

        public init(
            capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary? = nil,
            region: Swift.String? = nil,
            status: KeyspacesClientTypes.TableStatus? = nil
        )
        {
            self.capacitySpecification = capacitySpecification
            self.region = region
            self.status = status
        }
    }

}

public struct GetTableOutput {
    /// The read/write throughput capacity mode for a table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST
    ///
    /// * throughputMode:PROVISIONED
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
    /// The client-side timestamps setting of the table.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// The the description of the specified table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The creation timestamp of the specified table.
    public var creationTimestamp: Foundation.Date?
    /// The default Time to Live settings in seconds of the specified table.
    public var defaultTimeToLive: Swift.Int?
    /// The encryption settings of the specified table.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The point-in-time recovery status of the specified table.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary?
    /// Returns the Amazon Web Services Region specific settings of all Regions a multi-Region table is replicated in.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecificationSummary]?
    /// The Amazon Resource Name (ARN) of the specified table.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The schema definition of the specified table.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The current status of the specified table.
    public var status: KeyspacesClientTypes.TableStatus?
    /// The name of the specified table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The custom Time to Live settings of the specified table.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        creationTimestamp: Foundation.Date? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecificationSummary]? = nil,
        resourceArn: Swift.String? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        status: KeyspacesClientTypes.TableStatus? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.comment = comment
        self.creationTimestamp = creationTimestamp
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.resourceArn = resourceArn
        self.schemaDefinition = schemaDefinition
        self.status = status
        self.tableName = tableName
        self.ttl = ttl
    }
}

public struct GetTableAutoScalingSettingsInput {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

extension KeyspacesClientTypes {
    /// The auto scaling settings of a multi-Region table in the specified Amazon Web Services Region.
    public struct ReplicaAutoScalingSpecification {
        /// The auto scaling settings for a multi-Region table in the specified Amazon Web Services Region.
        public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
        /// The Amazon Web Services Region.
        public var region: Swift.String?

        public init(
            autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
            region: Swift.String? = nil
        )
        {
            self.autoScalingSpecification = autoScalingSpecification
            self.region = region
        }
    }

}

public struct GetTableAutoScalingSettingsOutput {
    /// The auto scaling settings of the table.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The Amazon Web Services Region specific settings of a multi-Region table. Returns the settings for all Regions the table is replicated in.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaAutoScalingSpecification]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaAutoScalingSpecification]? = nil,
        resourceArn: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.keyspaceName = keyspaceName
        self.replicaSpecifications = replicaSpecifications
        self.resourceArn = resourceArn
        self.tableName = tableName
    }
}

public struct ListKeyspacesInput {
    /// The total number of keyspaces to return in the output. If the total number of keyspaces available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension KeyspacesClientTypes {
    /// Represents the properties of a keyspace.
    public struct KeyspaceSummary {
        /// The name of the keyspace.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// If the replicationStrategy of the keyspace is MULTI_REGION, a list of replication Regions is returned.
        public var replicationRegions: [Swift.String]?
        /// This property specifies if a keyspace is a single Region keyspace or a multi-Region keyspace. The available values are SINGLE_REGION or MULTI_REGION.
        /// This member is required.
        public var replicationStrategy: KeyspacesClientTypes.Rs?
        /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            keyspaceName: Swift.String? = nil,
            replicationRegions: [Swift.String]? = nil,
            replicationStrategy: KeyspacesClientTypes.Rs? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.replicationRegions = replicationRegions
            self.replicationStrategy = replicationStrategy
            self.resourceArn = resourceArn
        }
    }

}

public struct ListKeyspacesOutput {
    /// A list of keyspaces.
    /// This member is required.
    public var keyspaces: [KeyspacesClientTypes.KeyspaceSummary]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        keyspaces: [KeyspacesClientTypes.KeyspaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaces = keyspaces
        self.nextToken = nextToken
    }
}

public struct ListTablesInput {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The total number of tables to return in the output. If the total number of tables available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension KeyspacesClientTypes {
    /// Returns the name of the specified table, the keyspace it is stored in, and the unique identifier in the format of an Amazon Resource Name (ARN).
    public struct TableSummary {
        /// The name of the keyspace that the table is stored in.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            keyspaceName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

public struct ListTablesOutput {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tables.
    public var tables: [KeyspacesClientTypes.TableSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [KeyspacesClientTypes.TableSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

public struct ListTagsForResourceInput {
    /// The total number of tags to return in the output. If the total number of tags available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tags.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct RestoreTableInput {
    /// The optional auto scaling settings for the restored table in provisioned capacity mode. Specifies if the service can manage throughput capacity of a provisioned table automatically on your behalf. Amazon Keyspaces auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Specifies the read/write throughput capacity mode for the target table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification?
    /// Specifies the encryption settings for the target table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification?
    /// Specifies the pointInTimeRecovery settings for the target table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery?
    /// The optional Region specific settings of a multi-Regional table.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The restore timestamp in ISO 8601 format.
    public var restoreTimestamp: Foundation.Date?
    /// The keyspace name of the source table.
    /// This member is required.
    public var sourceKeyspaceName: Swift.String?
    /// The name of the source table.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// A list of key-value pair tags to be attached to the restored table. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tagsOverride: [KeyspacesClientTypes.Tag]?
    /// The name of the target keyspace.
    /// This member is required.
    public var targetKeyspaceName: Swift.String?
    /// The name of the target table.
    /// This member is required.
    public var targetTableName: Swift.String?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification? = nil,
        encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification? = nil,
        pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        restoreTimestamp: Foundation.Date? = nil,
        sourceKeyspaceName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        tagsOverride: [KeyspacesClientTypes.Tag]? = nil,
        targetKeyspaceName: Swift.String? = nil,
        targetTableName: Swift.String? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecificationOverride = capacitySpecificationOverride
        self.encryptionSpecificationOverride = encryptionSpecificationOverride
        self.pointInTimeRecoveryOverride = pointInTimeRecoveryOverride
        self.replicaSpecifications = replicaSpecifications
        self.restoreTimestamp = restoreTimestamp
        self.sourceKeyspaceName = sourceKeyspaceName
        self.sourceTableName = sourceTableName
        self.tagsOverride = tagsOverride
        self.targetKeyspaceName = targetKeyspaceName
        self.targetTableName = targetTableName
    }
}

public struct RestoreTableOutput {
    /// The Amazon Resource Name (ARN) of the restored table.
    /// This member is required.
    public var restoredTableARN: Swift.String?

    public init(
        restoredTableARN: Swift.String? = nil
    )
    {
        self.restoredTableARN = restoredTableARN
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Keyspaces resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of existing tags to be removed from the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateTableInput {
    /// For each column to be added to the specified table:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
    public var addColumns: [KeyspacesClientTypes.ColumnDefinition]?
    /// The optional auto scaling settings to update for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity of a provisioned table automatically on your behalf. Amazon Keyspaces auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. If auto scaling is already enabled for the table, you can use UpdateTable to update the minimum and maximum values or the auto scaling policy settings independently. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Modifies the read/write throughput capacity mode for the table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:
    ///
    /// * status: "enabled"
    ///
    ///
    /// Once client-side timestamps are enabled for a table, this setting cannot be disabled.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Modifies the encryption settings of the table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Modifies the pointInTimeRecovery settings of the table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The Region specific settings of a multi-Regional table.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// Modifies Time to Live custom settings for the table. The options are:
    ///
    /// * status:enabled
    ///
    /// * status:disabled
    ///
    ///
    /// The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        addColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.addColumns = addColumns
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.tableName = tableName
        self.ttl = ttl
    }
}

public struct UpdateTableOutput {
    /// The Amazon Resource Name (ARN) of the modified table.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension CreateKeyspaceInput {

    static func urlPathProvider(_ value: CreateKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteKeyspaceInput {

    static func urlPathProvider(_ value: DeleteKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        return "/"
    }
}

extension GetKeyspaceInput {

    static func urlPathProvider(_ value: GetKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableAutoScalingSettingsInput {

    static func urlPathProvider(_ value: GetTableAutoScalingSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListKeyspacesInput {

    static func urlPathProvider(_ value: ListKeyspacesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreTableInput {

    static func urlPathProvider(_ value: RestoreTableInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTableInput {

    static func urlPathProvider(_ value: UpdateTableInput) -> Swift.String? {
        return "/"
    }
}

extension CreateKeyspaceInput {

    static func write(value: CreateKeyspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["replicationSpecification"].write(value.replicationSpecification, with: KeyspacesClientTypes.ReplicationSpecification.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: KeyspacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTableInput {

    static func write(value: CreateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingSpecification"].write(value.autoScalingSpecification, with: KeyspacesClientTypes.AutoScalingSpecification.write(value:to:))
        try writer["capacitySpecification"].write(value.capacitySpecification, with: KeyspacesClientTypes.CapacitySpecification.write(value:to:))
        try writer["clientSideTimestamps"].write(value.clientSideTimestamps, with: KeyspacesClientTypes.ClientSideTimestamps.write(value:to:))
        try writer["comment"].write(value.comment, with: KeyspacesClientTypes.Comment.write(value:to:))
        try writer["defaultTimeToLive"].write(value.defaultTimeToLive)
        try writer["encryptionSpecification"].write(value.encryptionSpecification, with: KeyspacesClientTypes.EncryptionSpecification.write(value:to:))
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["pointInTimeRecovery"].write(value.pointInTimeRecovery, with: KeyspacesClientTypes.PointInTimeRecovery.write(value:to:))
        try writer["replicaSpecifications"].writeList(value.replicaSpecifications, memberWritingClosure: KeyspacesClientTypes.ReplicaSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["schemaDefinition"].write(value.schemaDefinition, with: KeyspacesClientTypes.SchemaDefinition.write(value:to:))
        try writer["tableName"].write(value.tableName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: KeyspacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ttl"].write(value.ttl, with: KeyspacesClientTypes.TimeToLive.write(value:to:))
    }
}

extension DeleteKeyspaceInput {

    static func write(value: DeleteKeyspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
    }
}

extension DeleteTableInput {

    static func write(value: DeleteTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["tableName"].write(value.tableName)
    }
}

extension GetKeyspaceInput {

    static func write(value: GetKeyspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
    }
}

extension GetTableInput {

    static func write(value: GetTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["tableName"].write(value.tableName)
    }
}

extension GetTableAutoScalingSettingsInput {

    static func write(value: GetTableAutoScalingSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["tableName"].write(value.tableName)
    }
}

extension ListKeyspacesInput {

    static func write(value: ListKeyspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTablesInput {

    static func write(value: ListTablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RestoreTableInput {

    static func write(value: RestoreTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingSpecification"].write(value.autoScalingSpecification, with: KeyspacesClientTypes.AutoScalingSpecification.write(value:to:))
        try writer["capacitySpecificationOverride"].write(value.capacitySpecificationOverride, with: KeyspacesClientTypes.CapacitySpecification.write(value:to:))
        try writer["encryptionSpecificationOverride"].write(value.encryptionSpecificationOverride, with: KeyspacesClientTypes.EncryptionSpecification.write(value:to:))
        try writer["pointInTimeRecoveryOverride"].write(value.pointInTimeRecoveryOverride, with: KeyspacesClientTypes.PointInTimeRecovery.write(value:to:))
        try writer["replicaSpecifications"].writeList(value.replicaSpecifications, memberWritingClosure: KeyspacesClientTypes.ReplicaSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["restoreTimestamp"].writeTimestamp(value.restoreTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["sourceKeyspaceName"].write(value.sourceKeyspaceName)
        try writer["sourceTableName"].write(value.sourceTableName)
        try writer["tagsOverride"].writeList(value.tagsOverride, memberWritingClosure: KeyspacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetKeyspaceName"].write(value.targetKeyspaceName)
        try writer["targetTableName"].write(value.targetTableName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: KeyspacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: KeyspacesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTableInput {

    static func write(value: UpdateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addColumns"].writeList(value.addColumns, memberWritingClosure: KeyspacesClientTypes.ColumnDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["autoScalingSpecification"].write(value.autoScalingSpecification, with: KeyspacesClientTypes.AutoScalingSpecification.write(value:to:))
        try writer["capacitySpecification"].write(value.capacitySpecification, with: KeyspacesClientTypes.CapacitySpecification.write(value:to:))
        try writer["clientSideTimestamps"].write(value.clientSideTimestamps, with: KeyspacesClientTypes.ClientSideTimestamps.write(value:to:))
        try writer["defaultTimeToLive"].write(value.defaultTimeToLive)
        try writer["encryptionSpecification"].write(value.encryptionSpecification, with: KeyspacesClientTypes.EncryptionSpecification.write(value:to:))
        try writer["keyspaceName"].write(value.keyspaceName)
        try writer["pointInTimeRecovery"].write(value.pointInTimeRecovery, with: KeyspacesClientTypes.PointInTimeRecovery.write(value:to:))
        try writer["replicaSpecifications"].writeList(value.replicaSpecifications, memberWritingClosure: KeyspacesClientTypes.ReplicaSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tableName"].write(value.tableName)
        try writer["ttl"].write(value.ttl, with: KeyspacesClientTypes.TimeToLive.write(value:to:))
    }
}

extension CreateKeyspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKeyspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKeyspaceOutput()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableOutput()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteKeyspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKeyspaceOutput {
        return DeleteKeyspaceOutput()
    }
}

extension DeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOutput {
        return DeleteTableOutput()
    }
}

extension GetKeyspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKeyspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKeyspaceOutput()
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.replicationRegions = try reader["replicationRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicationStrategy = try reader["replicationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOutput()
        value.capacitySpecification = try reader["capacitySpecification"].readIfPresent(with: KeyspacesClientTypes.CapacitySpecificationSummary.read(from:))
        value.clientSideTimestamps = try reader["clientSideTimestamps"].readIfPresent(with: KeyspacesClientTypes.ClientSideTimestamps.read(from:))
        value.comment = try reader["comment"].readIfPresent(with: KeyspacesClientTypes.Comment.read(from:))
        value.creationTimestamp = try reader["creationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultTimeToLive = try reader["defaultTimeToLive"].readIfPresent()
        value.encryptionSpecification = try reader["encryptionSpecification"].readIfPresent(with: KeyspacesClientTypes.EncryptionSpecification.read(from:))
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.pointInTimeRecovery = try reader["pointInTimeRecovery"].readIfPresent(with: KeyspacesClientTypes.PointInTimeRecoverySummary.read(from:))
        value.replicaSpecifications = try reader["replicaSpecifications"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.ReplicaSpecificationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.schemaDefinition = try reader["schemaDefinition"].readIfPresent(with: KeyspacesClientTypes.SchemaDefinition.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.ttl = try reader["ttl"].readIfPresent(with: KeyspacesClientTypes.TimeToLive.read(from:))
        return value
    }
}

extension GetTableAutoScalingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableAutoScalingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableAutoScalingSettingsOutput()
        value.autoScalingSpecification = try reader["autoScalingSpecification"].readIfPresent(with: KeyspacesClientTypes.AutoScalingSpecification.read(from:))
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.replicaSpecifications = try reader["replicaSpecifications"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.ReplicaAutoScalingSpecification.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        return value
    }
}

extension ListKeyspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKeyspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeyspacesOutput()
        value.keyspaces = try reader["keyspaces"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.KeyspaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tables = try reader["tables"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.TableSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RestoreTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreTableOutput()
        value.restoredTableARN = try reader["restoredTableARN"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTableOutput()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

enum CreateKeyspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKeyspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKeyspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableAutoScalingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKeyspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KeyspacesClientTypes.SchemaDefinition {

    static func write(value: KeyspacesClientTypes.SchemaDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allColumns"].writeList(value.allColumns, memberWritingClosure: KeyspacesClientTypes.ColumnDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clusteringKeys"].writeList(value.clusteringKeys, memberWritingClosure: KeyspacesClientTypes.ClusteringKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["partitionKeys"].writeList(value.partitionKeys, memberWritingClosure: KeyspacesClientTypes.PartitionKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["staticColumns"].writeList(value.staticColumns, memberWritingClosure: KeyspacesClientTypes.StaticColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.SchemaDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.SchemaDefinition()
        value.allColumns = try reader["allColumns"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.ColumnDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["partitionKeys"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.PartitionKey.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.clusteringKeys = try reader["clusteringKeys"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.ClusteringKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.staticColumns = try reader["staticColumns"].readListIfPresent(memberReadingClosure: KeyspacesClientTypes.StaticColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KeyspacesClientTypes.StaticColumn {

    static func write(value: KeyspacesClientTypes.StaticColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.StaticColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.StaticColumn()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.ClusteringKey {

    static func write(value: KeyspacesClientTypes.ClusteringKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["orderBy"].write(value.orderBy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.ClusteringKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.ClusteringKey()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.orderBy = try reader["orderBy"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KeyspacesClientTypes.PartitionKey {

    static func write(value: KeyspacesClientTypes.PartitionKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.PartitionKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.PartitionKey()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.ColumnDefinition {

    static func write(value: KeyspacesClientTypes.ColumnDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.ColumnDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.ColumnDefinition()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.CapacitySpecificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.CapacitySpecificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.CapacitySpecificationSummary()
        value.throughputMode = try reader["throughputMode"].readIfPresent() ?? .sdkUnknown("")
        value.readCapacityUnits = try reader["readCapacityUnits"].readIfPresent()
        value.writeCapacityUnits = try reader["writeCapacityUnits"].readIfPresent()
        value.lastUpdateToPayPerRequestTimestamp = try reader["lastUpdateToPayPerRequestTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension KeyspacesClientTypes.EncryptionSpecification {

    static func write(value: KeyspacesClientTypes.EncryptionSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyIdentifier"].write(value.kmsKeyIdentifier)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.EncryptionSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.EncryptionSpecification()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyIdentifier = try reader["kmsKeyIdentifier"].readIfPresent()
        return value
    }
}

extension KeyspacesClientTypes.PointInTimeRecoverySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.PointInTimeRecoverySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.PointInTimeRecoverySummary()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.earliestRestorableTimestamp = try reader["earliestRestorableTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension KeyspacesClientTypes.TimeToLive {

    static func write(value: KeyspacesClientTypes.TimeToLive?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.TimeToLive {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.TimeToLive()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KeyspacesClientTypes.Comment {

    static func write(value: KeyspacesClientTypes.Comment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.Comment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.Comment()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.ClientSideTimestamps {

    static func write(value: KeyspacesClientTypes.ClientSideTimestamps?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.ClientSideTimestamps {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.ClientSideTimestamps()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KeyspacesClientTypes.ReplicaSpecificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.ReplicaSpecificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.ReplicaSpecificationSummary()
        value.region = try reader["region"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.capacitySpecification = try reader["capacitySpecification"].readIfPresent(with: KeyspacesClientTypes.CapacitySpecificationSummary.read(from:))
        return value
    }
}

extension KeyspacesClientTypes.AutoScalingSpecification {

    static func write(value: KeyspacesClientTypes.AutoScalingSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readCapacityAutoScaling"].write(value.readCapacityAutoScaling, with: KeyspacesClientTypes.AutoScalingSettings.write(value:to:))
        try writer["writeCapacityAutoScaling"].write(value.writeCapacityAutoScaling, with: KeyspacesClientTypes.AutoScalingSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.AutoScalingSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.AutoScalingSpecification()
        value.writeCapacityAutoScaling = try reader["writeCapacityAutoScaling"].readIfPresent(with: KeyspacesClientTypes.AutoScalingSettings.read(from:))
        value.readCapacityAutoScaling = try reader["readCapacityAutoScaling"].readIfPresent(with: KeyspacesClientTypes.AutoScalingSettings.read(from:))
        return value
    }
}

extension KeyspacesClientTypes.AutoScalingSettings {

    static func write(value: KeyspacesClientTypes.AutoScalingSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingDisabled"].write(value.autoScalingDisabled)
        try writer["maximumUnits"].write(value.maximumUnits)
        try writer["minimumUnits"].write(value.minimumUnits)
        try writer["scalingPolicy"].write(value.scalingPolicy, with: KeyspacesClientTypes.AutoScalingPolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.AutoScalingSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.AutoScalingSettings()
        value.autoScalingDisabled = try reader["autoScalingDisabled"].readIfPresent() ?? false
        value.minimumUnits = try reader["minimumUnits"].readIfPresent()
        value.maximumUnits = try reader["maximumUnits"].readIfPresent()
        value.scalingPolicy = try reader["scalingPolicy"].readIfPresent(with: KeyspacesClientTypes.AutoScalingPolicy.read(from:))
        return value
    }
}

extension KeyspacesClientTypes.AutoScalingPolicy {

    static func write(value: KeyspacesClientTypes.AutoScalingPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetTrackingScalingPolicyConfiguration"].write(value.targetTrackingScalingPolicyConfiguration, with: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.AutoScalingPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.AutoScalingPolicy()
        value.targetTrackingScalingPolicyConfiguration = try reader["targetTrackingScalingPolicyConfiguration"].readIfPresent(with: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration.read(from:))
        return value
    }
}

extension KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration {

    static func write(value: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["disableScaleIn"].write(value.disableScaleIn)
        try writer["scaleInCooldown"].write(value.scaleInCooldown)
        try writer["scaleOutCooldown"].write(value.scaleOutCooldown)
        try writer["targetValue"].write(value.targetValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration()
        value.disableScaleIn = try reader["disableScaleIn"].readIfPresent() ?? false
        value.scaleInCooldown = try reader["scaleInCooldown"].readIfPresent() ?? 0
        value.scaleOutCooldown = try reader["scaleOutCooldown"].readIfPresent() ?? 0
        value.targetValue = try reader["targetValue"].readIfPresent() ?? 0
        return value
    }
}

extension KeyspacesClientTypes.ReplicaAutoScalingSpecification {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.ReplicaAutoScalingSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.ReplicaAutoScalingSpecification()
        value.region = try reader["region"].readIfPresent()
        value.autoScalingSpecification = try reader["autoScalingSpecification"].readIfPresent(with: KeyspacesClientTypes.AutoScalingSpecification.read(from:))
        return value
    }
}

extension KeyspacesClientTypes.KeyspaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.KeyspaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.KeyspaceSummary()
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.replicationStrategy = try reader["replicationStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.replicationRegions = try reader["replicationRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KeyspacesClientTypes.TableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.TableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.TableSummary()
        value.keyspaceName = try reader["keyspaceName"].readIfPresent() ?? ""
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.Tag {

    static func write(value: KeyspacesClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KeyspacesClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KeyspacesClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension KeyspacesClientTypes.ReplicationSpecification {

    static func write(value: KeyspacesClientTypes.ReplicationSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["regionList"].writeList(value.regionList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["replicationStrategy"].write(value.replicationStrategy)
    }
}

extension KeyspacesClientTypes.CapacitySpecification {

    static func write(value: KeyspacesClientTypes.CapacitySpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readCapacityUnits"].write(value.readCapacityUnits)
        try writer["throughputMode"].write(value.throughputMode)
        try writer["writeCapacityUnits"].write(value.writeCapacityUnits)
    }
}

extension KeyspacesClientTypes.PointInTimeRecovery {

    static func write(value: KeyspacesClientTypes.PointInTimeRecovery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension KeyspacesClientTypes.ReplicaSpecification {

    static func write(value: KeyspacesClientTypes.ReplicaSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["readCapacityAutoScaling"].write(value.readCapacityAutoScaling, with: KeyspacesClientTypes.AutoScalingSettings.write(value:to:))
        try writer["readCapacityUnits"].write(value.readCapacityUnits)
        try writer["region"].write(value.region)
    }
}

public enum KeyspacesClientTypes {}
