// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient access permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes.AutoScalingPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetTrackingScalingPolicyConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetTrackingScalingPolicyConfiguration = self.targetTrackingScalingPolicyConfiguration {
            try encodeContainer.encode(targetTrackingScalingPolicyConfiguration, forKey: .targetTrackingScalingPolicyConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetTrackingScalingPolicyConfigurationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration.self, forKey: .targetTrackingScalingPolicyConfiguration)
        targetTrackingScalingPolicyConfiguration = targetTrackingScalingPolicyConfigurationDecoded
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces supports the target tracking auto scaling policy. With this policy, Amazon Keyspaces auto scaling ensures that the table's ratio of consumed to provisioned capacity stays at or near the target value that you specify. You define the target value as a percentage between 20 and 90.
    public struct AutoScalingPolicy: Swift.Equatable {
        /// Auto scaling scales up capacity automatically when traffic exceeds this target utilization rate, and then back down when it falls below the target. A double between 20 and 90.
        public var targetTrackingScalingPolicyConfiguration: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration?

        public init(
            targetTrackingScalingPolicyConfiguration: KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration? = nil
        )
        {
            self.targetTrackingScalingPolicyConfiguration = targetTrackingScalingPolicyConfiguration
        }
    }

}

extension KeyspacesClientTypes.AutoScalingSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingDisabled
        case maximumUnits
        case minimumUnits
        case scalingPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoScalingDisabled != false {
            try encodeContainer.encode(autoScalingDisabled, forKey: .autoScalingDisabled)
        }
        if let maximumUnits = self.maximumUnits {
            try encodeContainer.encode(maximumUnits, forKey: .maximumUnits)
        }
        if let minimumUnits = self.minimumUnits {
            try encodeContainer.encode(minimumUnits, forKey: .minimumUnits)
        }
        if let scalingPolicy = self.scalingPolicy {
            try encodeContainer.encode(scalingPolicy, forKey: .scalingPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoScalingDisabled) ?? false
        autoScalingDisabled = autoScalingDisabledDecoded
        let minimumUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumUnits)
        minimumUnits = minimumUnitsDecoded
        let maximumUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumUnits)
        maximumUnits = maximumUnitsDecoded
        let scalingPolicyDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingPolicy.self, forKey: .scalingPolicy)
        scalingPolicy = scalingPolicyDecoded
    }
}

extension KeyspacesClientTypes {
    /// The optional auto scaling settings for a table with provisioned throughput capacity. To turn on auto scaling for a table in throughputMode:PROVISIONED, you must specify the following parameters. Configure the minimum and maximum units for write and read capacity. The auto scaling policy ensures that capacity never goes below the minimum or above the maximum range.
    ///
    /// * minimumUnits: The minimum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
    ///
    /// * maximumUnits: The maximum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
    ///
    /// * scalingPolicy: Amazon Keyspaces supports the target tracking scaling policy. The auto scaling target is the provisioned read and write capacity of the table.
    ///
    /// * targetTrackingScalingPolicyConfiguration: To define the target tracking policy, you must define the target value.
    ///
    /// * targetValue: The target utilization rate of the table. Amazon Keyspaces auto scaling ensures that the ratio of consumed capacity to provisioned capacity stays at or near this value. You define targetValue as a percentage. A double between 20 and 90. (Required)
    ///
    /// * disableScaleIn: A boolean that specifies if scale-in is disabled or enabled for the table. This parameter is disabled by default. To turn on scale-in, set the boolean value to FALSE. This means that capacity for a table can be automatically scaled down on your behalf. (Optional)
    ///
    /// * scaleInCooldown: A cooldown period in seconds between scaling activities that lets the table stabilize before another scale in activity starts. If no value is provided, the default is 0. (Optional)
    ///
    /// * scaleOutCooldown: A cooldown period in seconds between scaling activities that lets the table stabilize before another scale out activity starts. If no value is provided, the default is 0. (Optional)
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public struct AutoScalingSettings: Swift.Equatable {
        /// This optional parameter enables auto scaling for the table if set to false.
        public var autoScalingDisabled: Swift.Bool
        /// Manage costs by specifying the maximum amount of throughput to provision. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
        public var maximumUnits: Swift.Int?
        /// The minimum level of throughput the table should always be ready to support. The value must be between 1 and the max throughput per second quota for your account (40,000 by default).
        public var minimumUnits: Swift.Int?
        /// Amazon Keyspaces supports the target tracking auto scaling policy. With this policy, Amazon Keyspaces auto scaling ensures that the table's ratio of consumed to provisioned capacity stays at or near the target value that you specify. You define the target value as a percentage between 20 and 90.
        public var scalingPolicy: KeyspacesClientTypes.AutoScalingPolicy?

        public init(
            autoScalingDisabled: Swift.Bool = false,
            maximumUnits: Swift.Int? = nil,
            minimumUnits: Swift.Int? = nil,
            scalingPolicy: KeyspacesClientTypes.AutoScalingPolicy? = nil
        )
        {
            self.autoScalingDisabled = autoScalingDisabled
            self.maximumUnits = maximumUnits
            self.minimumUnits = minimumUnits
            self.scalingPolicy = scalingPolicy
        }
    }

}

extension KeyspacesClientTypes.AutoScalingSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readCapacityAutoScaling
        case writeCapacityAutoScaling
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readCapacityAutoScaling = self.readCapacityAutoScaling {
            try encodeContainer.encode(readCapacityAutoScaling, forKey: .readCapacityAutoScaling)
        }
        if let writeCapacityAutoScaling = self.writeCapacityAutoScaling {
            try encodeContainer.encode(writeCapacityAutoScaling, forKey: .writeCapacityAutoScaling)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeCapacityAutoScalingDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSettings.self, forKey: .writeCapacityAutoScaling)
        writeCapacityAutoScaling = writeCapacityAutoScalingDecoded
        let readCapacityAutoScalingDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSettings.self, forKey: .readCapacityAutoScaling)
        readCapacityAutoScaling = readCapacityAutoScalingDecoded
    }
}

extension KeyspacesClientTypes {
    /// The optional auto scaling settings for read and write capacity of a table in provisioned capacity mode.
    public struct AutoScalingSpecification: Swift.Equatable {
        /// The auto scaling settings for the table's read capacity.
        public var readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?
        /// The auto scaling settings for the table's write capacity.
        public var writeCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?

        public init(
            readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil,
            writeCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil
        )
        {
            self.readCapacityAutoScaling = readCapacityAutoScaling
            self.writeCapacityAutoScaling = writeCapacityAutoScaling
        }
    }

}

extension KeyspacesClientTypes.CapacitySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readCapacityUnits
        case throughputMode
        case writeCapacityUnits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readCapacityUnits = self.readCapacityUnits {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
        if let writeCapacityUnits = self.writeCapacityUnits {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeCapacityUnits)
        writeCapacityUnits = writeCapacityUnitsDecoded
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces has two read/write capacity modes for processing reads and writes on your tables:
    ///
    /// * On-demand (default)
    ///
    /// * Provisioned
    ///
    ///
    /// The read/write capacity mode that you choose controls how you are charged for read and write throughput and how table throughput capacity is managed. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecification: Swift.Equatable {
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
        ///
        ///
        /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init(
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes.CapacitySpecificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdateToPayPerRequestTimestamp
        case readCapacityUnits
        case throughputMode
        case writeCapacityUnits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdateToPayPerRequestTimestamp = self.lastUpdateToPayPerRequestTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdateToPayPerRequestTimestamp, format: .epochSeconds, forKey: .lastUpdateToPayPerRequestTimestamp)
        }
        if let readCapacityUnits = self.readCapacityUnits {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
        if let writeCapacityUnits = self.writeCapacityUnits {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeCapacityUnits)
        writeCapacityUnits = writeCapacityUnitsDecoded
        let lastUpdateToPayPerRequestTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateToPayPerRequestTimestamp)
        lastUpdateToPayPerRequestTimestamp = lastUpdateToPayPerRequestTimestampDecoded
    }
}

extension KeyspacesClientTypes {
    /// The read/write throughput capacity mode for a table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED.
    ///
    ///
    /// For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecificationSummary: Swift.Equatable {
        /// The timestamp of the last operation that changed the provisioned throughput capacity of a table.
        public var lastUpdateToPayPerRequestTimestamp: ClientRuntime.Date?
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
        ///
        ///
        /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init(
            lastUpdateToPayPerRequestTimestamp: ClientRuntime.Date? = nil,
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.lastUpdateToPayPerRequestTimestamp = lastUpdateToPayPerRequestTimestamp
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes.ClientSideTimestamps: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ClientSideTimestampsStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KeyspacesClientTypes {
    /// The client-side timestamp setting of the table. For more information, see [How it works: Amazon Keyspaces client-side timestamps](https://docs.aws.amazon.com/keyspaces/latest/devguide/client-side-timestamps-how-it-works.html) in the Amazon Keyspaces Developer Guide.
    public struct ClientSideTimestamps: Swift.Equatable {
        /// Shows how to enable client-side timestamps settings for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.ClientSideTimestampsStatus?

        public init(
            status: KeyspacesClientTypes.ClientSideTimestampsStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    public enum ClientSideTimestampsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientSideTimestampsStatus] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientSideTimestampsStatus(rawValue: rawValue) ?? ClientSideTimestampsStatus.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.ClusteringKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SortOrder.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension KeyspacesClientTypes {
    /// The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.
    public struct ClusteringKey: Swift.Equatable {
        /// The name(s) of the clustering column(s).
        /// This member is required.
        public var name: Swift.String?
        /// Sets the ascendant (ASC) or descendant (DESC) order modifier.
        /// This member is required.
        public var orderBy: KeyspacesClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            orderBy: KeyspacesClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.orderBy = orderBy
        }
    }

}

extension KeyspacesClientTypes.ColumnDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension KeyspacesClientTypes {
    /// The names and data types of regular columns.
    public struct ColumnDefinition: Swift.Equatable {
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column. For a list of available data types, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension KeyspacesClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes {
    /// An optional comment that describes the table.
    public struct Comment: Swift.Equatable {
        /// An optional description of the table.
        /// This member is required.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Keyspaces couldn't complete the requested action. This error may occur if you try to perform an action and the same or a different action is already in progress, or if you try to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case replicationSpecification
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let replicationSpecification = self.replicationSpecification {
            try encodeContainer.encode(replicationSpecification, forKey: .replicationSpecification)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateKeyspaceInput {

    static func urlPathProvider(_ value: CreateKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace to be created.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The replication specification of the keyspace includes:
    ///
    /// * replicationStrategy - the required value is SINGLE_REGION or MULTI_REGION.
    ///
    /// * regionList - if the replicationStrategy is MULTI_REGION, the regionList requires the current Region and at least one additional Amazon Web Services Region where the keyspace is going to be replicated in. The maximum number of supported replication Regions including the current Region is six.
    public var replicationSpecification: KeyspacesClientTypes.ReplicationSpecification?
    /// A list of key-value pair tags to be attached to the keyspace. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        keyspaceName: Swift.String? = nil,
        replicationSpecification: KeyspacesClientTypes.ReplicationSpecification? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.replicationSpecification = replicationSpecification
        self.tags = tags
    }
}

struct CreateKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
    let replicationSpecification: KeyspacesClientTypes.ReplicationSpecification?
}

extension CreateKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case replicationSpecification
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let replicationSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ReplicationSpecification.self, forKey: .replicationSpecification)
        replicationSpecification = replicationSpecificationDecoded
    }
}

extension CreateKeyspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKeyspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct CreateKeyspaceOutput: Swift.Equatable {
    /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct CreateKeyspaceOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension CreateKeyspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum CreateKeyspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case capacitySpecification
        case clientSideTimestamps
        case comment
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case replicaSpecifications
        case schemaDefinition
        case tableName
        case tags
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSpecification = self.autoScalingSpecification {
            try encodeContainer.encode(autoScalingSpecification, forKey: .autoScalingSpecification)
        }
        if let capacitySpecification = self.capacitySpecification {
            try encodeContainer.encode(capacitySpecification, forKey: .capacitySpecification)
        }
        if let clientSideTimestamps = self.clientSideTimestamps {
            try encodeContainer.encode(clientSideTimestamps, forKey: .clientSideTimestamps)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let defaultTimeToLive = self.defaultTimeToLive {
            try encodeContainer.encode(defaultTimeToLive, forKey: .defaultTimeToLive)
        }
        if let encryptionSpecification = self.encryptionSpecification {
            try encodeContainer.encode(encryptionSpecification, forKey: .encryptionSpecification)
        }
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let pointInTimeRecovery = self.pointInTimeRecovery {
            try encodeContainer.encode(pointInTimeRecovery, forKey: .pointInTimeRecovery)
        }
        if let replicaSpecifications = replicaSpecifications {
            var replicaSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicaSpecifications)
            for replicaspecification0 in replicaSpecifications {
                try replicaSpecificationsContainer.encode(replicaspecification0)
            }
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateTableInput: Swift.Equatable {
    /// The optional auto scaling settings for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity automatically on your behalf. Auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide. By default, auto scaling is disabled for a table.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Specifies the read/write throughput capacity mode for the table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:
    ///
    /// * status: "enabled"
    ///
    ///
    /// Once client-side timestamps are enabled for a table, this setting cannot be disabled.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// This parameter allows to enter a description of the table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the table is going to be created in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Specifies if pointInTimeRecovery is enabled or disabled for the table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The optional Amazon Web Services Region specific settings of a multi-Region table. These settings overwrite the general settings of the table for the specified Region. For a multi-Region table in provisioned capacity mode, you can configure the table's read capacity differently for each Region's replica. The write capacity, however, remains synchronized between all replicas to ensure that there's enough capacity to replicate writes across all Regions. To define the read capacity for a table replica in a specific Region, you can do so by configuring the following parameters.
    ///
    /// * region: The Region where these settings are applied. (Required)
    ///
    /// * readCapacityUnits: The provisioned read capacity units. (Optional)
    ///
    /// * readCapacityAutoScaling: The read capacity auto scaling settings for the table. (Optional)
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The schemaDefinition consists of the following parameters. For each column to be created:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
    ///
    ///
    /// The primary key of the table consists of the following columns:
    ///
    /// * partitionKeys - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data.
    ///
    /// * name - The name of each partition key column.
    ///
    /// * clusteringKeys - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.
    ///
    /// * name - The name of the clustering column.
    ///
    /// * orderBy - Sets the ascendant (ASC) or descendant (DESC) order modifier. To define a column as static use staticColumns - Static columns store values that are shared by all rows in the same partition:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type.
    /// This member is required.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of key-value pair tags to be attached to the resource. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?
    /// Enables Time to Live custom settings for the table. The options are:
    ///
    /// * status:enabled
    ///
    /// * status:disabled
    ///
    ///
    /// The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        tableName: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.comment = comment
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.schemaDefinition = schemaDefinition
        self.tableName = tableName
        self.tags = tags
        self.ttl = ttl
    }
}

struct CreateTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    let comment: KeyspacesClientTypes.Comment?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
    let tags: [KeyspacesClientTypes.Tag]?
    let clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    let autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    let replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
}

extension CreateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case capacitySpecification
        case clientSideTimestamps
        case comment
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case replicaSpecifications
        case schemaDefinition
        case tableName
        case tags
        case ttl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientSideTimestampsDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ClientSideTimestamps.self, forKey: .clientSideTimestamps)
        clientSideTimestamps = clientSideTimestampsDecoded
        let autoScalingSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSpecification.self, forKey: .autoScalingSpecification)
        autoScalingSpecification = autoScalingSpecificationDecoded
        let replicaSpecificationsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ReplicaSpecification?].self, forKey: .replicaSpecifications)
        var replicaSpecificationsDecoded0:[KeyspacesClientTypes.ReplicaSpecification]? = nil
        if let replicaSpecificationsContainer = replicaSpecificationsContainer {
            replicaSpecificationsDecoded0 = [KeyspacesClientTypes.ReplicaSpecification]()
            for structure0 in replicaSpecificationsContainer {
                if let structure0 = structure0 {
                    replicaSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        replicaSpecifications = replicaSpecificationsDecoded0
    }
}

extension CreateTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct CreateTableOutput: Swift.Equatable {
    /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct CreateTableOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension CreateTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum CreateTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
    }
}

extension DeleteKeyspaceInput {

    static func urlPathProvider(_ value: DeleteKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace to be deleted.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

struct DeleteKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
}

extension DeleteKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension DeleteKeyspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteKeyspaceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteKeyspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteTableInput: Swift.Equatable {
    /// The name of the keyspace of the to be deleted table.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

struct DeleteTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
}

extension DeleteTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DeleteTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTableOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KeyspacesClientTypes.EncryptionSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyIdentifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces encrypts and decrypts the table data at rest transparently and integrates with Key Management Service for storing and managing the encryption key. You can choose one of the following KMS keys (KMS keys):
    ///
    /// * Amazon Web Services owned key - This is the default encryption type. The key is owned by Amazon Keyspaces (no additional charge).
    ///
    /// * Customer managed key - This key is stored in your account and is created, owned, and managed by you. You have full control over the customer managed key (KMS charges apply).
    ///
    ///
    /// For more information about encryption at rest in Amazon Keyspaces, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide. For more information about KMS, see [KMS management service concepts](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Key Management Service Developer Guide.
    public struct EncryptionSpecification: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the customer managed KMS key, for example kms_key_identifier:ARN.
        public var kmsKeyIdentifier: Swift.String?
        /// The encryption option specified for the table. You can choose one of the following KMS keys (KMS keys):
        ///
        /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
        ///
        /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
        ///
        ///
        /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: KeyspacesClientTypes.EncryptionType?

        public init(
            kmsKeyIdentifier: Swift.String? = nil,
            type: KeyspacesClientTypes.EncryptionType? = nil
        )
        {
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.type = type
        }
    }

}

extension KeyspacesClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKmsKey
        case customerManagedKmsKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .awsOwnedKmsKey,
                .customerManagedKmsKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKmsKey: return "AWS_OWNED_KMS_KEY"
            case .customerManagedKmsKey: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension GetKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
    }
}

extension GetKeyspaceInput {

    static func urlPathProvider(_ value: GetKeyspaceInput) -> Swift.String? {
        return "/"
    }
}

public struct GetKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

struct GetKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
}

extension GetKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension GetKeyspaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKeyspaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyspaceName = output.keyspaceName
            self.replicationRegions = output.replicationRegions
            self.replicationStrategy = output.replicationStrategy
            self.resourceArn = output.resourceArn
        } else {
            self.keyspaceName = nil
            self.replicationRegions = nil
            self.replicationStrategy = nil
            self.resourceArn = nil
        }
    }
}

public struct GetKeyspaceOutput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// If the replicationStrategy of the keyspace is MULTI_REGION, a list of replication Regions is returned.
    public var replicationRegions: [Swift.String]?
    /// Returns the replication strategy of the keyspace. The options are SINGLE_REGION or MULTI_REGION.
    /// This member is required.
    public var replicationStrategy: KeyspacesClientTypes.Rs?
    /// Returns the ARN of the keyspace.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        replicationRegions: [Swift.String]? = nil,
        replicationStrategy: KeyspacesClientTypes.Rs? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.replicationRegions = replicationRegions
        self.replicationStrategy = replicationStrategy
        self.resourceArn = resourceArn
    }
}

struct GetKeyspaceOutputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let resourceArn: Swift.String?
    let replicationStrategy: KeyspacesClientTypes.Rs?
    let replicationRegions: [Swift.String]?
}

extension GetKeyspaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case replicationRegions
        case replicationStrategy
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let replicationStrategyDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Rs.self, forKey: .replicationStrategy)
        replicationStrategy = replicationStrategyDecoded
        let replicationRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationRegions)
        var replicationRegionsDecoded0:[Swift.String]? = nil
        if let replicationRegionsContainer = replicationRegionsContainer {
            replicationRegionsDecoded0 = [Swift.String]()
            for string0 in replicationRegionsContainer {
                if let string0 = string0 {
                    replicationRegionsDecoded0?.append(string0)
                }
            }
        }
        replicationRegions = replicationRegionsDecoded0
    }
}

enum GetKeyspaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableAutoScalingSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableAutoScalingSettingsInput {

    static func urlPathProvider(_ value: GetTableAutoScalingSettingsInput) -> Swift.String? {
        return "/"
    }
}

public struct GetTableAutoScalingSettingsInput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

struct GetTableAutoScalingSettingsInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableAutoScalingSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableAutoScalingSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableAutoScalingSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingSpecification = output.autoScalingSpecification
            self.keyspaceName = output.keyspaceName
            self.replicaSpecifications = output.replicaSpecifications
            self.resourceArn = output.resourceArn
            self.tableName = output.tableName
        } else {
            self.autoScalingSpecification = nil
            self.keyspaceName = nil
            self.replicaSpecifications = nil
            self.resourceArn = nil
            self.tableName = nil
        }
    }
}

public struct GetTableAutoScalingSettingsOutput: Swift.Equatable {
    /// The auto scaling settings of the table.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The Amazon Web Services Region specific settings of a multi-Region table. Returns the settings for all Regions the table is replicated in.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaAutoScalingSpecification]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaAutoScalingSpecification]? = nil,
        resourceArn: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.keyspaceName = keyspaceName
        self.replicaSpecifications = replicaSpecifications
        self.resourceArn = resourceArn
        self.tableName = tableName
    }
}

struct GetTableAutoScalingSettingsOutputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let resourceArn: Swift.String?
    let autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    let replicaSpecifications: [KeyspacesClientTypes.ReplicaAutoScalingSpecification]?
}

extension GetTableAutoScalingSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case keyspaceName
        case replicaSpecifications
        case resourceArn
        case tableName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let autoScalingSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSpecification.self, forKey: .autoScalingSpecification)
        autoScalingSpecification = autoScalingSpecificationDecoded
        let replicaSpecificationsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ReplicaAutoScalingSpecification?].self, forKey: .replicaSpecifications)
        var replicaSpecificationsDecoded0:[KeyspacesClientTypes.ReplicaAutoScalingSpecification]? = nil
        if let replicaSpecificationsContainer = replicaSpecificationsContainer {
            replicaSpecificationsDecoded0 = [KeyspacesClientTypes.ReplicaAutoScalingSpecification]()
            for structure0 in replicaSpecificationsContainer {
                if let structure0 = structure0 {
                    replicaSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        replicaSpecifications = replicaSpecificationsDecoded0
    }
}

enum GetTableAutoScalingSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        return "/"
    }
}

public struct GetTableInput: Swift.Equatable {
    /// The name of the keyspace that the table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

struct GetTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.capacitySpecification = output.capacitySpecification
            self.clientSideTimestamps = output.clientSideTimestamps
            self.comment = output.comment
            self.creationTimestamp = output.creationTimestamp
            self.defaultTimeToLive = output.defaultTimeToLive
            self.encryptionSpecification = output.encryptionSpecification
            self.keyspaceName = output.keyspaceName
            self.pointInTimeRecovery = output.pointInTimeRecovery
            self.replicaSpecifications = output.replicaSpecifications
            self.resourceArn = output.resourceArn
            self.schemaDefinition = output.schemaDefinition
            self.status = output.status
            self.tableName = output.tableName
            self.ttl = output.ttl
        } else {
            self.capacitySpecification = nil
            self.clientSideTimestamps = nil
            self.comment = nil
            self.creationTimestamp = nil
            self.defaultTimeToLive = nil
            self.encryptionSpecification = nil
            self.keyspaceName = nil
            self.pointInTimeRecovery = nil
            self.replicaSpecifications = nil
            self.resourceArn = nil
            self.schemaDefinition = nil
            self.status = nil
            self.tableName = nil
            self.ttl = nil
        }
    }
}

public struct GetTableOutput: Swift.Equatable {
    /// The read/write throughput capacity mode for a table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST
    ///
    /// * throughputMode:PROVISIONED
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
    /// The client-side timestamps setting of the table.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// The the description of the specified table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The creation timestamp of the specified table.
    public var creationTimestamp: ClientRuntime.Date?
    /// The default Time to Live settings in seconds of the specified table.
    public var defaultTimeToLive: Swift.Int?
    /// The encryption settings of the specified table.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The point-in-time recovery status of the specified table.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary?
    /// Returns the Amazon Web Services Region specific settings of all Regions a multi-Region table is replicated in.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecificationSummary]?
    /// The Amazon Resource Name (ARN) of the specified table.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The schema definition of the specified table.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The current status of the specified table.
    public var status: KeyspacesClientTypes.TableStatus?
    /// The name of the specified table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The custom Time to Live settings of the specified table.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecificationSummary]? = nil,
        resourceArn: Swift.String? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        status: KeyspacesClientTypes.TableStatus? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.comment = comment
        self.creationTimestamp = creationTimestamp
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.resourceArn = resourceArn
        self.schemaDefinition = schemaDefinition
        self.status = status
        self.tableName = tableName
        self.ttl = ttl
    }
}

struct GetTableOutputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let resourceArn: Swift.String?
    let creationTimestamp: ClientRuntime.Date?
    let status: KeyspacesClientTypes.TableStatus?
    let schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
    let comment: KeyspacesClientTypes.Comment?
    let clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    let replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecificationSummary]?
}

extension GetTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecification
        case clientSideTimestamps
        case comment
        case creationTimestamp
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case replicaSpecifications
        case resourceArn
        case schemaDefinition
        case status
        case tableName
        case ttl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TableStatus.self, forKey: .status)
        status = statusDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecificationSummary.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoverySummary.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
        let commentDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
        let clientSideTimestampsDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ClientSideTimestamps.self, forKey: .clientSideTimestamps)
        clientSideTimestamps = clientSideTimestampsDecoded
        let replicaSpecificationsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ReplicaSpecificationSummary?].self, forKey: .replicaSpecifications)
        var replicaSpecificationsDecoded0:[KeyspacesClientTypes.ReplicaSpecificationSummary]? = nil
        if let replicaSpecificationsContainer = replicaSpecificationsContainer {
            replicaSpecificationsDecoded0 = [KeyspacesClientTypes.ReplicaSpecificationSummary]()
            for structure0 in replicaSpecificationsContainer {
                if let structure0 = structure0 {
                    replicaSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        replicaSpecifications = replicaSpecificationsDecoded0
    }
}

enum GetTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Keyspaces was unable to fully process this request because of an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes.KeyspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case replicationRegions
        case replicationStrategy
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let replicationRegions = replicationRegions {
            var replicationRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationRegions)
            for region0 in replicationRegions {
                try replicationRegionsContainer.encode(region0)
            }
        }
        if let replicationStrategy = self.replicationStrategy {
            try encodeContainer.encode(replicationStrategy.rawValue, forKey: .replicationStrategy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let replicationStrategyDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Rs.self, forKey: .replicationStrategy)
        replicationStrategy = replicationStrategyDecoded
        let replicationRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationRegions)
        var replicationRegionsDecoded0:[Swift.String]? = nil
        if let replicationRegionsContainer = replicationRegionsContainer {
            replicationRegionsDecoded0 = [Swift.String]()
            for string0 in replicationRegionsContainer {
                if let string0 = string0 {
                    replicationRegionsDecoded0?.append(string0)
                }
            }
        }
        replicationRegions = replicationRegionsDecoded0
    }
}

extension KeyspacesClientTypes {
    /// Represents the properties of a keyspace.
    public struct KeyspaceSummary: Swift.Equatable {
        /// The name of the keyspace.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// If the replicationStrategy of the keyspace is MULTI_REGION, a list of replication Regions is returned.
        public var replicationRegions: [Swift.String]?
        /// This property specifies if a keyspace is a single Region keyspace or a multi-Region keyspace. The available values are SINGLE_REGION or MULTI_REGION.
        /// This member is required.
        public var replicationStrategy: KeyspacesClientTypes.Rs?
        /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            keyspaceName: Swift.String? = nil,
            replicationRegions: [Swift.String]? = nil,
            replicationStrategy: KeyspacesClientTypes.Rs? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.replicationRegions = replicationRegions
            self.replicationStrategy = replicationStrategy
            self.resourceArn = resourceArn
        }
    }

}

extension ListKeyspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListKeyspacesInput {

    static func urlPathProvider(_ value: ListKeyspacesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListKeyspacesInput: Swift.Equatable {
    /// The total number of keyspaces to return in the output. If the total number of keyspaces available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKeyspacesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListKeyspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListKeyspacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKeyspacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyspaces = output.keyspaces
            self.nextToken = output.nextToken
        } else {
            self.keyspaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeyspacesOutput: Swift.Equatable {
    /// A list of keyspaces.
    /// This member is required.
    public var keyspaces: [KeyspacesClientTypes.KeyspaceSummary]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        keyspaces: [KeyspacesClientTypes.KeyspaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaces = keyspaces
        self.nextToken = nextToken
    }
}

struct ListKeyspacesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let keyspaces: [KeyspacesClientTypes.KeyspaceSummary]?
}

extension ListKeyspacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaces
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let keyspacesContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.KeyspaceSummary?].self, forKey: .keyspaces)
        var keyspacesDecoded0:[KeyspacesClientTypes.KeyspaceSummary]? = nil
        if let keyspacesContainer = keyspacesContainer {
            keyspacesDecoded0 = [KeyspacesClientTypes.KeyspaceSummary]()
            for structure0 in keyspacesContainer {
                if let structure0 = structure0 {
                    keyspacesDecoded0?.append(structure0)
                }
            }
        }
        keyspaces = keyspacesDecoded0
    }
}

enum ListKeyspacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The total number of tables to return in the output. If the total number of tables available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init(
        keyspaceName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let keyspaceName: Swift.String?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension ListTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutput: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tables.
    public var tables: [KeyspacesClientTypes.TableSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tables: [KeyspacesClientTypes.TableSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tables: [KeyspacesClientTypes.TableSummary]?
}

extension ListTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tablesContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.TableSummary?].self, forKey: .tables)
        var tablesDecoded0:[KeyspacesClientTypes.TableSummary]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [KeyspacesClientTypes.TableSummary]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
    }
}

enum ListTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The total number of tags to return in the output. If the total number of tags available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tags.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KeyspacesClientTypes.PartitionKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension KeyspacesClientTypes {
    /// The partition key portion of the primary key is required and determines how Amazon Keyspaces stores the data. The partition key can be a single column, or it can be a compound value composed of two or more columns.
    public struct PartitionKey: Swift.Equatable {
        /// The name(s) of the partition key column(s).
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes.PointInTimeRecovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoveryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KeyspacesClientTypes {
    /// Point-in-time recovery (PITR) helps protect your Amazon Keyspaces tables from accidental write or delete operations by providing you continuous backups of your table data. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public struct PointInTimeRecovery: Swift.Equatable {
        /// The options are:
        ///
        /// * status=ENABLED
        ///
        /// * status=DISABLED
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init(
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    public enum PointInTimeRecoveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PointInTimeRecoveryStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PointInTimeRecoveryStatus(rawValue: rawValue) ?? PointInTimeRecoveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.PointInTimeRecoverySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earliestRestorableTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earliestRestorableTimestamp = self.earliestRestorableTimestamp {
            try encodeContainer.encodeTimestamp(earliestRestorableTimestamp, format: .epochSeconds, forKey: .earliestRestorableTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoveryStatus.self, forKey: .status)
        status = statusDecoded
        let earliestRestorableTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .earliestRestorableTimestamp)
        earliestRestorableTimestamp = earliestRestorableTimestampDecoded
    }
}

extension KeyspacesClientTypes {
    /// The point-in-time recovery status of the specified table.
    public struct PointInTimeRecoverySummary: Swift.Equatable {
        /// Specifies the earliest possible restore point of the table in ISO 8601 format.
        public var earliestRestorableTimestamp: ClientRuntime.Date?
        /// Shows if point-in-time recovery is enabled or disabled for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init(
            earliestRestorableTimestamp: ClientRuntime.Date? = nil,
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.earliestRestorableTimestamp = earliestRestorableTimestamp
            self.status = status
        }
    }

}

extension KeyspacesClientTypes.ReplicaAutoScalingSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSpecification = self.autoScalingSpecification {
            try encodeContainer.encode(autoScalingSpecification, forKey: .autoScalingSpecification)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let autoScalingSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSpecification.self, forKey: .autoScalingSpecification)
        autoScalingSpecification = autoScalingSpecificationDecoded
    }
}

extension KeyspacesClientTypes {
    /// The auto scaling settings of a multi-Region table in the specified Amazon Web Services Region.
    public struct ReplicaAutoScalingSpecification: Swift.Equatable {
        /// The auto scaling settings for a multi-Region table in the specified Amazon Web Services Region.
        public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
        /// The Amazon Web Services Region.
        public var region: Swift.String?

        public init(
            autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
            region: Swift.String? = nil
        )
        {
            self.autoScalingSpecification = autoScalingSpecification
            self.region = region
        }
    }

}

extension KeyspacesClientTypes.ReplicaSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readCapacityAutoScaling
        case readCapacityUnits
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readCapacityAutoScaling = self.readCapacityAutoScaling {
            try encodeContainer.encode(readCapacityAutoScaling, forKey: .readCapacityAutoScaling)
        }
        if let readCapacityUnits = self.readCapacityUnits {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let readCapacityAutoScalingDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSettings.self, forKey: .readCapacityAutoScaling)
        readCapacityAutoScaling = readCapacityAutoScalingDecoded
    }
}

extension KeyspacesClientTypes {
    /// The Amazon Web Services Region specific settings of a multi-Region table. For a multi-Region table, you can configure the table's read capacity differently per Amazon Web Services Region. You can do this by configuring the following parameters.
    ///
    /// * region: The Region where these settings are applied. (Required)
    ///
    /// * readCapacityUnits: The provisioned read capacity units. (Optional)
    ///
    /// * readCapacityAutoScaling: The read capacity auto scaling settings for the table. (Optional)
    public struct ReplicaSpecification: Swift.Equatable {
        /// The read capacity auto scaling settings for the multi-Region table in the specified Amazon Web Services Region.
        public var readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings?
        /// The provisioned read capacity units for the multi-Region table in the specified Amazon Web Services Region.
        public var readCapacityUnits: Swift.Int?
        /// The Amazon Web Services Region.
        /// This member is required.
        public var region: Swift.String?

        public init(
            readCapacityAutoScaling: KeyspacesClientTypes.AutoScalingSettings? = nil,
            readCapacityUnits: Swift.Int? = nil,
            region: Swift.String? = nil
        )
        {
            self.readCapacityAutoScaling = readCapacityAutoScaling
            self.readCapacityUnits = readCapacityUnits
            self.region = region
        }
    }

}

extension KeyspacesClientTypes.ReplicaSpecificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecification
        case region
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacitySpecification = self.capacitySpecification {
            try encodeContainer.encode(capacitySpecification, forKey: .capacitySpecification)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TableStatus.self, forKey: .status)
        status = statusDecoded
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecificationSummary.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
    }
}

extension KeyspacesClientTypes {
    /// The Region-specific settings of a multi-Region table in the specified Amazon Web Services Region. If the multi-Region table is using provisioned capacity and has optional auto scaling policies configured, note that the Region specific summary returns both read and write capacity settings. But only Region specific read capacity settings can be configured for a multi-Region table. In a multi-Region table, your write capacity units will be synced across all Amazon Web Services Regions to ensure that there is enough capacity to replicate write events across Regions.
    public struct ReplicaSpecificationSummary: Swift.Equatable {
        /// The read/write throughput capacity mode for a table. The options are:
        ///
        /// * throughputMode:PAY_PER_REQUEST and
        ///
        /// * throughputMode:PROVISIONED.
        ///
        ///
        /// For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        public var capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
        /// The Amazon Web Services Region.
        public var region: Swift.String?
        /// The status of the multi-Region table in the specified Amazon Web Services Region.
        public var status: KeyspacesClientTypes.TableStatus?

        public init(
            capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary? = nil,
            region: Swift.String? = nil,
            status: KeyspacesClientTypes.TableStatus? = nil
        )
        {
            self.capacitySpecification = capacitySpecification
            self.region = region
            self.status = status
        }
    }

}

extension KeyspacesClientTypes.ReplicationSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionList
        case replicationStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionList = regionList {
            var regionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regionList)
            for region0 in regionList {
                try regionListContainer.encode(region0)
            }
        }
        if let replicationStrategy = self.replicationStrategy {
            try encodeContainer.encode(replicationStrategy.rawValue, forKey: .replicationStrategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationStrategyDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Rs.self, forKey: .replicationStrategy)
        replicationStrategy = replicationStrategyDecoded
        let regionListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regionList)
        var regionListDecoded0:[Swift.String]? = nil
        if let regionListContainer = regionListContainer {
            regionListDecoded0 = [Swift.String]()
            for string0 in regionListContainer {
                if let string0 = string0 {
                    regionListDecoded0?.append(string0)
                }
            }
        }
        regionList = regionListDecoded0
    }
}

extension KeyspacesClientTypes {
    /// The replication specification of the keyspace includes:
    ///
    /// * regionList - up to six Amazon Web Services Regions where the keyspace is replicated in.
    ///
    /// * replicationStrategy - the required value is SINGLE_REGION or MULTI_REGION.
    public struct ReplicationSpecification: Swift.Equatable {
        /// The regionList can contain up to six Amazon Web Services Regions where the keyspace is replicated in.
        public var regionList: [Swift.String]?
        /// The replicationStrategy of a keyspace, the required value is SINGLE_REGION or MULTI_REGION.
        /// This member is required.
        public var replicationStrategy: KeyspacesClientTypes.Rs?

        public init(
            regionList: [Swift.String]? = nil,
            replicationStrategy: KeyspacesClientTypes.Rs? = nil
        )
        {
            self.regionList = regionList
            self.replicationStrategy = replicationStrategy
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceArn = output.resourceArn
        } else {
            self.properties.message = nil
            self.properties.resourceArn = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation tried to access a keyspace or table that doesn't exist. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier in the format of Amazon Resource Name (ARN), for the resource not found.
        public internal(set) var resourceArn: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension RestoreTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case capacitySpecificationOverride
        case encryptionSpecificationOverride
        case pointInTimeRecoveryOverride
        case replicaSpecifications
        case restoreTimestamp
        case sourceKeyspaceName
        case sourceTableName
        case tagsOverride
        case targetKeyspaceName
        case targetTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingSpecification = self.autoScalingSpecification {
            try encodeContainer.encode(autoScalingSpecification, forKey: .autoScalingSpecification)
        }
        if let capacitySpecificationOverride = self.capacitySpecificationOverride {
            try encodeContainer.encode(capacitySpecificationOverride, forKey: .capacitySpecificationOverride)
        }
        if let encryptionSpecificationOverride = self.encryptionSpecificationOverride {
            try encodeContainer.encode(encryptionSpecificationOverride, forKey: .encryptionSpecificationOverride)
        }
        if let pointInTimeRecoveryOverride = self.pointInTimeRecoveryOverride {
            try encodeContainer.encode(pointInTimeRecoveryOverride, forKey: .pointInTimeRecoveryOverride)
        }
        if let replicaSpecifications = replicaSpecifications {
            var replicaSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicaSpecifications)
            for replicaspecification0 in replicaSpecifications {
                try replicaSpecificationsContainer.encode(replicaspecification0)
            }
        }
        if let restoreTimestamp = self.restoreTimestamp {
            try encodeContainer.encodeTimestamp(restoreTimestamp, format: .epochSeconds, forKey: .restoreTimestamp)
        }
        if let sourceKeyspaceName = self.sourceKeyspaceName {
            try encodeContainer.encode(sourceKeyspaceName, forKey: .sourceKeyspaceName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let tagsOverride = tagsOverride {
            var tagsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsOverride)
            for tag0 in tagsOverride {
                try tagsOverrideContainer.encode(tag0)
            }
        }
        if let targetKeyspaceName = self.targetKeyspaceName {
            try encodeContainer.encode(targetKeyspaceName, forKey: .targetKeyspaceName)
        }
        if let targetTableName = self.targetTableName {
            try encodeContainer.encode(targetTableName, forKey: .targetTableName)
        }
    }
}

extension RestoreTableInput {

    static func urlPathProvider(_ value: RestoreTableInput) -> Swift.String? {
        return "/"
    }
}

public struct RestoreTableInput: Swift.Equatable {
    /// The optional auto scaling settings for the restored table in provisioned capacity mode. Specifies if the service can manage throughput capacity of a provisioned table automatically on your behalf. Amazon Keyspaces auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Specifies the read/write throughput capacity mode for the target table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification?
    /// Specifies the encryption settings for the target table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification?
    /// Specifies the pointInTimeRecovery settings for the target table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery?
    /// The optional Region specific settings of a multi-Regional table.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The restore timestamp in ISO 8601 format.
    public var restoreTimestamp: ClientRuntime.Date?
    /// The keyspace name of the source table.
    /// This member is required.
    public var sourceKeyspaceName: Swift.String?
    /// The name of the source table.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// A list of key-value pair tags to be attached to the restored table. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tagsOverride: [KeyspacesClientTypes.Tag]?
    /// The name of the target keyspace.
    /// This member is required.
    public var targetKeyspaceName: Swift.String?
    /// The name of the target table.
    /// This member is required.
    public var targetTableName: Swift.String?

    public init(
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification? = nil,
        encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification? = nil,
        pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        restoreTimestamp: ClientRuntime.Date? = nil,
        sourceKeyspaceName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        tagsOverride: [KeyspacesClientTypes.Tag]? = nil,
        targetKeyspaceName: Swift.String? = nil,
        targetTableName: Swift.String? = nil
    )
    {
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecificationOverride = capacitySpecificationOverride
        self.encryptionSpecificationOverride = encryptionSpecificationOverride
        self.pointInTimeRecoveryOverride = pointInTimeRecoveryOverride
        self.replicaSpecifications = replicaSpecifications
        self.restoreTimestamp = restoreTimestamp
        self.sourceKeyspaceName = sourceKeyspaceName
        self.sourceTableName = sourceTableName
        self.tagsOverride = tagsOverride
        self.targetKeyspaceName = targetKeyspaceName
        self.targetTableName = targetTableName
    }
}

struct RestoreTableInputBody: Swift.Equatable {
    let sourceKeyspaceName: Swift.String?
    let sourceTableName: Swift.String?
    let targetKeyspaceName: Swift.String?
    let targetTableName: Swift.String?
    let restoreTimestamp: ClientRuntime.Date?
    let capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery?
    let tagsOverride: [KeyspacesClientTypes.Tag]?
    let autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    let replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
}

extension RestoreTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingSpecification
        case capacitySpecificationOverride
        case encryptionSpecificationOverride
        case pointInTimeRecoveryOverride
        case replicaSpecifications
        case restoreTimestamp
        case sourceKeyspaceName
        case sourceTableName
        case tagsOverride
        case targetKeyspaceName
        case targetTableName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceKeyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceKeyspaceName)
        sourceKeyspaceName = sourceKeyspaceNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetKeyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKeyspaceName)
        targetKeyspaceName = targetKeyspaceNameDecoded
        let targetTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetTableName)
        targetTableName = targetTableNameDecoded
        let restoreTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .restoreTimestamp)
        restoreTimestamp = restoreTimestampDecoded
        let capacitySpecificationOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecificationOverride)
        capacitySpecificationOverride = capacitySpecificationOverrideDecoded
        let encryptionSpecificationOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecificationOverride)
        encryptionSpecificationOverride = encryptionSpecificationOverrideDecoded
        let pointInTimeRecoveryOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecoveryOverride)
        pointInTimeRecoveryOverride = pointInTimeRecoveryOverrideDecoded
        let tagsOverrideContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tagsOverride)
        var tagsOverrideDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsOverrideContainer = tagsOverrideContainer {
            tagsOverrideDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsOverrideContainer {
                if let structure0 = structure0 {
                    tagsOverrideDecoded0?.append(structure0)
                }
            }
        }
        tagsOverride = tagsOverrideDecoded0
        let autoScalingSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSpecification.self, forKey: .autoScalingSpecification)
        autoScalingSpecification = autoScalingSpecificationDecoded
        let replicaSpecificationsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ReplicaSpecification?].self, forKey: .replicaSpecifications)
        var replicaSpecificationsDecoded0:[KeyspacesClientTypes.ReplicaSpecification]? = nil
        if let replicaSpecificationsContainer = replicaSpecificationsContainer {
            replicaSpecificationsDecoded0 = [KeyspacesClientTypes.ReplicaSpecification]()
            for structure0 in replicaSpecificationsContainer {
                if let structure0 = structure0 {
                    replicaSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        replicaSpecifications = replicaSpecificationsDecoded0
    }
}

extension RestoreTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.restoredTableARN = output.restoredTableARN
        } else {
            self.restoredTableARN = nil
        }
    }
}

public struct RestoreTableOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the restored table.
    /// This member is required.
    public var restoredTableARN: Swift.String?

    public init(
        restoredTableARN: Swift.String? = nil
    )
    {
        self.restoredTableARN = restoredTableARN
    }
}

struct RestoreTableOutputBody: Swift.Equatable {
    let restoredTableARN: Swift.String?
}

extension RestoreTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoredTableARN
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoredTableARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoredTableARN)
        restoredTableARN = restoredTableARNDecoded
    }
}

enum RestoreTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KeyspacesClientTypes {
    public enum Rs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiRegion
        case singleRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [Rs] {
            return [
                .multiRegion,
                .singleRegion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiRegion: return "MULTI_REGION"
            case .singleRegion: return "SINGLE_REGION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Rs(rawValue: rawValue) ?? Rs.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.SchemaDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allColumns
        case clusteringKeys
        case partitionKeys
        case staticColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allColumns = allColumns {
            var allColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allColumns)
            for columndefinition0 in allColumns {
                try allColumnsContainer.encode(columndefinition0)
            }
        }
        if let clusteringKeys = clusteringKeys {
            var clusteringKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusteringKeys)
            for clusteringkey0 in clusteringKeys {
                try clusteringKeysContainer.encode(clusteringkey0)
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for partitionkey0 in partitionKeys {
                try partitionKeysContainer.encode(partitionkey0)
            }
        }
        if let staticColumns = staticColumns {
            var staticColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticColumns)
            for staticcolumn0 in staticColumns {
                try staticColumnsContainer.encode(staticcolumn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ColumnDefinition?].self, forKey: .allColumns)
        var allColumnsDecoded0:[KeyspacesClientTypes.ColumnDefinition]? = nil
        if let allColumnsContainer = allColumnsContainer {
            allColumnsDecoded0 = [KeyspacesClientTypes.ColumnDefinition]()
            for structure0 in allColumnsContainer {
                if let structure0 = structure0 {
                    allColumnsDecoded0?.append(structure0)
                }
            }
        }
        allColumns = allColumnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.PartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[KeyspacesClientTypes.PartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [KeyspacesClientTypes.PartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let clusteringKeysContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ClusteringKey?].self, forKey: .clusteringKeys)
        var clusteringKeysDecoded0:[KeyspacesClientTypes.ClusteringKey]? = nil
        if let clusteringKeysContainer = clusteringKeysContainer {
            clusteringKeysDecoded0 = [KeyspacesClientTypes.ClusteringKey]()
            for structure0 in clusteringKeysContainer {
                if let structure0 = structure0 {
                    clusteringKeysDecoded0?.append(structure0)
                }
            }
        }
        clusteringKeys = clusteringKeysDecoded0
        let staticColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.StaticColumn?].self, forKey: .staticColumns)
        var staticColumnsDecoded0:[KeyspacesClientTypes.StaticColumn]? = nil
        if let staticColumnsContainer = staticColumnsContainer {
            staticColumnsDecoded0 = [KeyspacesClientTypes.StaticColumn]()
            for structure0 in staticColumnsContainer {
                if let structure0 = structure0 {
                    staticColumnsDecoded0?.append(structure0)
                }
            }
        }
        staticColumns = staticColumnsDecoded0
    }
}

extension KeyspacesClientTypes {
    /// Describes the schema of the table.
    public struct SchemaDefinition: Swift.Equatable {
        /// The regular columns of the table.
        /// This member is required.
        public var allColumns: [KeyspacesClientTypes.ColumnDefinition]?
        /// The columns that are part of the clustering key of the table.
        public var clusteringKeys: [KeyspacesClientTypes.ClusteringKey]?
        /// The columns that are part of the partition key of the table .
        /// This member is required.
        public var partitionKeys: [KeyspacesClientTypes.PartitionKey]?
        /// The columns that have been defined as STATIC. Static columns store values that are shared by all rows in the same partition.
        public var staticColumns: [KeyspacesClientTypes.StaticColumn]?

        public init(
            allColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
            clusteringKeys: [KeyspacesClientTypes.ClusteringKey]? = nil,
            partitionKeys: [KeyspacesClientTypes.PartitionKey]? = nil,
            staticColumns: [KeyspacesClientTypes.StaticColumn]? = nil
        )
        {
            self.allColumns = allColumns
            self.clusteringKeys = clusteringKeys
            self.partitionKeys = partitionKeys
            self.staticColumns = staticColumns
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation exceeded the service quota for this resource. For more information on service quotas, see [Quotas](https://docs.aws.amazon.com/keyspaces/latest/devguide/quotas.html) in the Amazon Keyspaces Developer Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.StaticColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension KeyspacesClientTypes {
    /// The static columns of the table. Static columns store values that are shared by all rows in the same partition.
    public struct StaticColumn: Swift.Equatable {
        /// The name of the static column.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes {
    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case inaccessibleEncryptionCredentials
        case restoring
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .inaccessibleEncryptionCredentials,
                .restoring,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .inaccessibleEncryptionCredentials: return "INACCESSIBLE_ENCRYPTION_CREDENTIALS"
            case .restoring: return "RESTORING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableStatus(rawValue: rawValue) ?? TableStatus.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.TableSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case resourceArn
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension KeyspacesClientTypes {
    /// Returns the name of the specified table, the keyspace it is stored in, and the unique identifier in the format of an Amazon Resource Name (ARN).
    public struct TableSummary: Swift.Equatable {
        /// The name of the keyspace that the table is stored in.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            keyspaceName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

extension KeyspacesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KeyspacesClientTypes {
    /// Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single Amazon Keyspaces resource. Amazon Web Services-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. Amazon Web Services-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user: in the Cost Allocation Report. You cannot backdate the application of a tag. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public struct Tag: Swift.Equatable {
        /// The key of the tag. Tag keys are case sensitive. Each Amazon Keyspaces resource can only have up to one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KeyspacesClientTypes.TargetTrackingScalingPolicyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableScaleIn
        case scaleInCooldown
        case scaleOutCooldown
        case targetValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disableScaleIn != false {
            try encodeContainer.encode(disableScaleIn, forKey: .disableScaleIn)
        }
        if scaleInCooldown != 0 {
            try encodeContainer.encode(scaleInCooldown, forKey: .scaleInCooldown)
        }
        if scaleOutCooldown != 0 {
            try encodeContainer.encode(scaleOutCooldown, forKey: .scaleOutCooldown)
        }
        if targetValue != 0.0 {
            try encodeContainer.encode(targetValue, forKey: .targetValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableScaleInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableScaleIn) ?? false
        disableScaleIn = disableScaleInDecoded
        let scaleInCooldownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scaleInCooldown) ?? 0
        scaleInCooldown = scaleInCooldownDecoded
        let scaleOutCooldownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scaleOutCooldown) ?? 0
        scaleOutCooldown = scaleOutCooldownDecoded
        let targetValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .targetValue) ?? 0.0
        targetValue = targetValueDecoded
    }
}

extension KeyspacesClientTypes {
    /// The auto scaling policy that scales a table based on the ratio of consumed to provisioned capacity.
    public struct TargetTrackingScalingPolicyConfiguration: Swift.Equatable {
        /// Specifies if scale-in is enabled. When auto scaling automatically decreases capacity for a table, the table scales in. When scaling policies are set, they can't scale in the table lower than its minimum capacity.
        public var disableScaleIn: Swift.Bool
        /// Specifies a scale-in cool down period. A cooldown period in seconds between scaling activities that lets the table stabilize before another scaling activity starts.
        public var scaleInCooldown: Swift.Int
        /// Specifies a scale out cool down period. A cooldown period in seconds between scaling activities that lets the table stabilize before another scaling activity starts.
        public var scaleOutCooldown: Swift.Int
        /// Specifies the target value for the target tracking auto scaling policy. Amazon Keyspaces auto scaling scales up capacity automatically when traffic exceeds this target utilization rate, and then back down when it falls below the target. This ensures that the ratio of consumed capacity to provisioned capacity stays at or near this value. You define targetValue as a percentage. A double between 20 and 90.
        /// This member is required.
        public var targetValue: Swift.Double

        public init(
            disableScaleIn: Swift.Bool = false,
            scaleInCooldown: Swift.Int = 0,
            scaleOutCooldown: Swift.Int = 0,
            targetValue: Swift.Double = 0.0
        )
        {
            self.disableScaleIn = disableScaleIn
            self.scaleInCooldown = scaleInCooldown
            self.scaleOutCooldown = scaleOutCooldown
            self.targetValue = targetValue
        }
    }

}

extension KeyspacesClientTypes {
    public enum ThroughputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case payPerRequest
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ThroughputMode] {
            return [
                .payPerRequest,
                .provisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .payPerRequest: return "PAY_PER_REQUEST"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThroughputMode(rawValue: rawValue) ?? ThroughputMode.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.TimeToLive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLiveStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KeyspacesClientTypes {
    /// Enable custom Time to Live (TTL) settings for rows and columns without setting a TTL default for the specified table. For more information, see [Enabling TTL on tables](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_enabling) in the Amazon Keyspaces Developer Guide.
    public struct TimeToLive: Swift.Equatable {
        /// Shows how to enable custom Time to Live (TTL) settings for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.TimeToLiveStatus?

        public init(
            status: KeyspacesClientTypes.TimeToLiveStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    public enum TimeToLiveStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeToLiveStatus] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeToLiveStatus(rawValue: rawValue) ?? TimeToLiveStatus.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Keyspaces resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of existing tags to be removed from the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumns
        case autoScalingSpecification
        case capacitySpecification
        case clientSideTimestamps
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case replicaSpecifications
        case tableName
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addColumns = addColumns {
            var addColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addColumns)
            for columndefinition0 in addColumns {
                try addColumnsContainer.encode(columndefinition0)
            }
        }
        if let autoScalingSpecification = self.autoScalingSpecification {
            try encodeContainer.encode(autoScalingSpecification, forKey: .autoScalingSpecification)
        }
        if let capacitySpecification = self.capacitySpecification {
            try encodeContainer.encode(capacitySpecification, forKey: .capacitySpecification)
        }
        if let clientSideTimestamps = self.clientSideTimestamps {
            try encodeContainer.encode(clientSideTimestamps, forKey: .clientSideTimestamps)
        }
        if let defaultTimeToLive = self.defaultTimeToLive {
            try encodeContainer.encode(defaultTimeToLive, forKey: .defaultTimeToLive)
        }
        if let encryptionSpecification = self.encryptionSpecification {
            try encodeContainer.encode(encryptionSpecification, forKey: .encryptionSpecification)
        }
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let pointInTimeRecovery = self.pointInTimeRecovery {
            try encodeContainer.encode(pointInTimeRecovery, forKey: .pointInTimeRecovery)
        }
        if let replicaSpecifications = replicaSpecifications {
            var replicaSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicaSpecifications)
            for replicaspecification0 in replicaSpecifications {
                try replicaSpecificationsContainer.encode(replicaspecification0)
            }
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension UpdateTableInput {

    static func urlPathProvider(_ value: UpdateTableInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateTableInput: Swift.Equatable {
    /// For each column to be added to the specified table:
    ///
    /// * name - The name of the column.
    ///
    /// * type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
    public var addColumns: [KeyspacesClientTypes.ColumnDefinition]?
    /// The optional auto scaling settings to update for a table in provisioned capacity mode. Specifies if the service can manage throughput capacity of a provisioned table automatically on your behalf. Amazon Keyspaces auto scaling helps you provision throughput capacity for variable workloads efficiently by increasing and decreasing your table's read and write capacity automatically in response to application traffic. If auto scaling is already enabled for the table, you can use UpdateTable to update the minimum and maximum values or the auto scaling policy settings independently. For more information, see [Managing throughput capacity automatically with Amazon Keyspaces auto scaling](https://docs.aws.amazon.com/keyspaces/latest/devguide/autoscaling.html) in the Amazon Keyspaces Developer Guide.
    public var autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    /// Modifies the read/write throughput capacity mode for the table. The options are:
    ///
    /// * throughputMode:PAY_PER_REQUEST and
    ///
    /// * throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input.
    ///
    ///
    /// The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// Enables client-side timestamps for the table. By default, the setting is disabled. You can enable client-side timestamps with the following option:
    ///
    /// * status: "enabled"
    ///
    ///
    /// Once client-side timestamps are enabled for a table, this setting cannot be disabled.
    public var clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Modifies the encryption settings of the table. You can choose one of the following KMS key (KMS key):
    ///
    /// * type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces.
    ///
    /// * type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input.
    ///
    ///
    /// The default is AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Modifies the pointInTimeRecovery settings of the table. The options are:
    ///
    /// * status=ENABLED
    ///
    /// * status=DISABLED
    ///
    ///
    /// If it's not specified, the default is status=DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The Region specific settings of a multi-Regional table.
    public var replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// Modifies Time to Live custom settings for the table. The options are:
    ///
    /// * status:enabled
    ///
    /// * status:disabled
    ///
    ///
    /// The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init(
        addColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
        autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification? = nil,
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.addColumns = addColumns
        self.autoScalingSpecification = autoScalingSpecification
        self.capacitySpecification = capacitySpecification
        self.clientSideTimestamps = clientSideTimestamps
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.replicaSpecifications = replicaSpecifications
        self.tableName = tableName
        self.ttl = ttl
    }
}

struct UpdateTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let addColumns: [KeyspacesClientTypes.ColumnDefinition]?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
    let clientSideTimestamps: KeyspacesClientTypes.ClientSideTimestamps?
    let autoScalingSpecification: KeyspacesClientTypes.AutoScalingSpecification?
    let replicaSpecifications: [KeyspacesClientTypes.ReplicaSpecification]?
}

extension UpdateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumns
        case autoScalingSpecification
        case capacitySpecification
        case clientSideTimestamps
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case replicaSpecifications
        case tableName
        case ttl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let addColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ColumnDefinition?].self, forKey: .addColumns)
        var addColumnsDecoded0:[KeyspacesClientTypes.ColumnDefinition]? = nil
        if let addColumnsContainer = addColumnsContainer {
            addColumnsDecoded0 = [KeyspacesClientTypes.ColumnDefinition]()
            for structure0 in addColumnsContainer {
                if let structure0 = structure0 {
                    addColumnsDecoded0?.append(structure0)
                }
            }
        }
        addColumns = addColumnsDecoded0
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
        let clientSideTimestampsDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ClientSideTimestamps.self, forKey: .clientSideTimestamps)
        clientSideTimestamps = clientSideTimestampsDecoded
        let autoScalingSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.AutoScalingSpecification.self, forKey: .autoScalingSpecification)
        autoScalingSpecification = autoScalingSpecificationDecoded
        let replicaSpecificationsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ReplicaSpecification?].self, forKey: .replicaSpecifications)
        var replicaSpecificationsDecoded0:[KeyspacesClientTypes.ReplicaSpecification]? = nil
        if let replicaSpecificationsContainer = replicaSpecificationsContainer {
            replicaSpecificationsDecoded0 = [KeyspacesClientTypes.ReplicaSpecification]()
            for structure0 in replicaSpecificationsContainer {
                if let structure0 = structure0 {
                    replicaSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        replicaSpecifications = replicaSpecificationsDecoded0
    }
}

extension UpdateTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct UpdateTableOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the modified table.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct UpdateTableOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension UpdateTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

enum UpdateTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed due to an invalid or malformed request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
