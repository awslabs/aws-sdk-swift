// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes.CapacitySpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readCapacityUnits
        case throughputMode
        case writeCapacityUnits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readCapacityUnits = self.readCapacityUnits {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
        if let writeCapacityUnits = self.writeCapacityUnits {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeCapacityUnits)
        writeCapacityUnits = writeCapacityUnitsDecoded
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces has two read/write capacity modes for processing reads and writes on your tables: • On-demand (default) • Provisioned The read/write capacity mode that you choose controls how you are charged for read and write throughput and how table throughput capacity is managed. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecification: Swift.Equatable {
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are: • throughputMode:PAY_PER_REQUEST and • throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input. The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init (
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes.CapacitySpecificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdateToPayPerRequestTimestamp
        case readCapacityUnits
        case throughputMode
        case writeCapacityUnits
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdateToPayPerRequestTimestamp = self.lastUpdateToPayPerRequestTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdateToPayPerRequestTimestamp, format: .epochSeconds, forKey: .lastUpdateToPayPerRequestTimestamp)
        }
        if let readCapacityUnits = self.readCapacityUnits {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
        if let writeCapacityUnits = self.writeCapacityUnits {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits)
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeCapacityUnits)
        writeCapacityUnits = writeCapacityUnitsDecoded
        let lastUpdateToPayPerRequestTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateToPayPerRequestTimestamp)
        lastUpdateToPayPerRequestTimestamp = lastUpdateToPayPerRequestTimestampDecoded
    }
}

extension KeyspacesClientTypes {
    /// The read/write throughput capacity mode for a table. The options are: • throughputMode:PAY_PER_REQUEST and • throughputMode:PROVISIONED. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public struct CapacitySpecificationSummary: Swift.Equatable {
        /// The timestamp of the last operation that changed the provisioned throughput capacity of a table.
        public var lastUpdateToPayPerRequestTimestamp: ClientRuntime.Date?
        /// The throughput capacity specified for read operations defined in read capacity units(RCUs).
        public var readCapacityUnits: Swift.Int?
        /// The read/write throughput capacity mode for a table. The options are: • throughputMode:PAY_PER_REQUEST and • throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input. The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var throughputMode: KeyspacesClientTypes.ThroughputMode?
        /// The throughput capacity specified for write operations defined in write capacity units(WCUs).
        public var writeCapacityUnits: Swift.Int?

        public init (
            lastUpdateToPayPerRequestTimestamp: ClientRuntime.Date? = nil,
            readCapacityUnits: Swift.Int? = nil,
            throughputMode: KeyspacesClientTypes.ThroughputMode? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.lastUpdateToPayPerRequestTimestamp = lastUpdateToPayPerRequestTimestamp
            self.readCapacityUnits = readCapacityUnits
            self.throughputMode = throughputMode
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension KeyspacesClientTypes.ClusteringKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SortOrder.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension KeyspacesClientTypes {
    /// The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition.
    public struct ClusteringKey: Swift.Equatable {
        /// The name(s) of the clustering column(s).
        /// This member is required.
        public var name: Swift.String?
        /// Sets the ascendant (ASC) or descendant (DESC) order modifier.
        /// This member is required.
        public var orderBy: KeyspacesClientTypes.SortOrder?

        public init (
            name: Swift.String? = nil,
            orderBy: KeyspacesClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.orderBy = orderBy
        }
    }

}

extension KeyspacesClientTypes.ColumnDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension KeyspacesClientTypes {
    /// The names and data types of regular columns.
    public struct ColumnDefinition: Swift.Equatable {
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the column. For a list of available data types, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension KeyspacesClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes {
    /// An optional comment that describes the table.
    public struct Comment: Swift.Equatable {
        /// An optional description of the table.
        /// This member is required.
        public var message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Keyspaces could not complete the requested action. This error may occur if you try to perform an action and the same or a different action is already in progress, or if you try to create a resource that already exists.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateKeyspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace to be created.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// A list of key-value pair tags to be attached to the keyspace. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init (
        keyspaceName: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tags = tags
    }
}

struct CreateKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension CreateKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKeyspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateKeyspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateKeyspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateKeyspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct CreateKeyspaceOutputResponse: Swift.Equatable {
    /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct CreateKeyspaceOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension CreateKeyspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension CreateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecification
        case comment
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case schemaDefinition
        case tableName
        case tags
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacitySpecification = self.capacitySpecification {
            try encodeContainer.encode(capacitySpecification, forKey: .capacitySpecification)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let defaultTimeToLive = self.defaultTimeToLive {
            try encodeContainer.encode(defaultTimeToLive, forKey: .defaultTimeToLive)
        }
        if let encryptionSpecification = self.encryptionSpecification {
            try encodeContainer.encode(encryptionSpecification, forKey: .encryptionSpecification)
        }
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let pointInTimeRecovery = self.pointInTimeRecovery {
            try encodeContainer.encode(pointInTimeRecovery, forKey: .pointInTimeRecovery)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension CreateTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTableInput: Swift.Equatable {
    /// Specifies the read/write throughput capacity mode for the table. The options are: • throughputMode:PAY_PER_REQUEST and • throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input. The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// This parameter allows to enter a description of the table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Specifies how the encryption key for encryption at rest is managed for the table. You can choose one of the following KMS key (KMS key): • type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces. • type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input. The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the table is going to be created in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Specifies if pointInTimeRecovery is enabled or disabled for the table. The options are: • ENABLED • DISABLED If it's not specified, the default is DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The schemaDefinition consists of the following parameters. For each column to be created: • name - The name of the column. • type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide. The primary key of the table consists of the following columns: • partitionKeys - The partition key can be a single column, or it can be a compound value composed of two or more columns. The partition key portion of the primary key is required and determines how Amazon Keyspaces stores your data. • name - The name of each partition key column. • clusteringKeys - The optional clustering column portion of your primary key determines how the data is clustered and sorted within each partition. • name - The name of the clustering column. • orderBy - Sets the ascendant (ASC) or descendant (DESC) order modifier. To define a column as static use staticColumns - Static columns store values that are shared by all rows in the same partition: • name - The name of the column. • type - An Amazon Keyspaces data type.
    /// This member is required.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// A list of key-value pair tags to be attached to the resource. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tags: [KeyspacesClientTypes.Tag]?
    /// Enables Time to Live custom settings for the table. The options are: • status:enabled • status:disabled The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init (
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        tableName: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.capacitySpecification = capacitySpecification
        self.comment = comment
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.schemaDefinition = schemaDefinition
        self.tableName = tableName
        self.tags = tags
        self.ttl = ttl
    }
}

struct CreateTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    let comment: KeyspacesClientTypes.Comment?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension CreateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecification
        case comment
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case schemaDefinition
        case tableName
        case tags
        case ttl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let commentDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct CreateTableOutputResponse: Swift.Equatable {
    /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct CreateTableOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension CreateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
    }
}

extension DeleteKeyspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace to be deleted.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

struct DeleteKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
}

extension DeleteKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension DeleteKeyspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteKeyspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteKeyspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKeyspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKeyspaceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension DeleteTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTableInput: Swift.Equatable {
    /// The name of the keyspace of the to be deleted table.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table to be deleted.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

struct DeleteTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
}

extension DeleteTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DeleteTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableOutputResponse: Swift.Equatable {

    public init () { }
}

extension KeyspacesClientTypes.EncryptionSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyIdentifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyIdentifier = self.kmsKeyIdentifier {
            try encodeContainer.encode(kmsKeyIdentifier, forKey: .kmsKeyIdentifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let kmsKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyIdentifier)
        kmsKeyIdentifier = kmsKeyIdentifierDecoded
    }
}

extension KeyspacesClientTypes {
    /// Amazon Keyspaces encrypts and decrypts the table data at rest transparently and integrates with Key Management Service for storing and managing the encryption key. You can choose one of the following KMS keys (KMS keys): • Amazon Web Services owned key - This is the default encryption type. The key is owned by Amazon Keyspaces (no additional charge). • Customer managed key - This key is stored in your account and is created, owned, and managed by you. You have full control over the customer managed key (KMS charges apply). For more information about encryption at rest in Amazon Keyspaces, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide. For more information about KMS, see [KMS management service concepts](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Key Management Service Developer Guide.
    public struct EncryptionSpecification: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the customer managed KMS key, for example kms_key_identifier:ARN.
        public var kmsKeyIdentifier: Swift.String?
        /// The encryption option specified for the table. You can choose one of the following KMS keys (KMS keys): • type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces. • type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input. The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
        /// This member is required.
        public var type: KeyspacesClientTypes.EncryptionType?

        public init (
            kmsKeyIdentifier: Swift.String? = nil,
            type: KeyspacesClientTypes.EncryptionType? = nil
        )
        {
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.type = type
        }
    }

}

extension KeyspacesClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKmsKey
        case customerManagedKmsKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .awsOwnedKmsKey,
                .customerManagedKmsKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKmsKey: return "AWS_OWNED_KMS_KEY"
            case .customerManagedKmsKey: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension GetKeyspaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
    }
}

extension GetKeyspaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetKeyspaceInput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
    }
}

struct GetKeyspaceInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
}

extension GetKeyspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension GetKeyspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKeyspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetKeyspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetKeyspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyspaceName = output.keyspaceName
            self.resourceArn = output.resourceArn
        } else {
            self.keyspaceName = nil
            self.resourceArn = nil
        }
    }
}

public struct GetKeyspaceOutputResponse: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The ARN of the keyspace.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.resourceArn = resourceArn
    }
}

struct GetKeyspaceOutputResponseBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let resourceArn: Swift.String?
}

extension GetKeyspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

extension GetTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTableInput: Swift.Equatable {
    /// The name of the keyspace that the table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.tableName = tableName
    }
}

struct GetTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
}

extension GetTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case tableName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capacitySpecification = output.capacitySpecification
            self.comment = output.comment
            self.creationTimestamp = output.creationTimestamp
            self.defaultTimeToLive = output.defaultTimeToLive
            self.encryptionSpecification = output.encryptionSpecification
            self.keyspaceName = output.keyspaceName
            self.pointInTimeRecovery = output.pointInTimeRecovery
            self.resourceArn = output.resourceArn
            self.schemaDefinition = output.schemaDefinition
            self.status = output.status
            self.tableName = output.tableName
            self.ttl = output.ttl
        } else {
            self.capacitySpecification = nil
            self.comment = nil
            self.creationTimestamp = nil
            self.defaultTimeToLive = nil
            self.encryptionSpecification = nil
            self.keyspaceName = nil
            self.pointInTimeRecovery = nil
            self.resourceArn = nil
            self.schemaDefinition = nil
            self.status = nil
            self.tableName = nil
            self.ttl = nil
        }
    }
}

public struct GetTableOutputResponse: Swift.Equatable {
    /// The read/write throughput capacity mode for a table. The options are: • throughputMode:PAY_PER_REQUEST • throughputMode:PROVISIONED
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
    /// The the description of the specified table.
    public var comment: KeyspacesClientTypes.Comment?
    /// The creation timestamp of the specified table.
    public var creationTimestamp: ClientRuntime.Date?
    /// The default Time to Live settings of the specified table.
    public var defaultTimeToLive: Swift.Int?
    /// The encryption settings of the specified table.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace that the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The point-in-time recovery status of the specified table.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary?
    /// The Amazon Resource Name (ARN) of the specified table.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The schema definition of the specified table.
    public var schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    /// The current status of the specified table.
    public var status: KeyspacesClientTypes.TableStatus?
    /// The name of the specified table.
    /// This member is required.
    public var tableName: Swift.String?
    /// The custom Time to Live settings of the specified table.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init (
        capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary? = nil,
        comment: KeyspacesClientTypes.Comment? = nil,
        creationTimestamp: ClientRuntime.Date? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary? = nil,
        resourceArn: Swift.String? = nil,
        schemaDefinition: KeyspacesClientTypes.SchemaDefinition? = nil,
        status: KeyspacesClientTypes.TableStatus? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.capacitySpecification = capacitySpecification
        self.comment = comment
        self.creationTimestamp = creationTimestamp
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.resourceArn = resourceArn
        self.schemaDefinition = schemaDefinition
        self.status = status
        self.tableName = tableName
        self.ttl = ttl
    }
}

struct GetTableOutputResponseBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let resourceArn: Swift.String?
    let creationTimestamp: ClientRuntime.Date?
    let status: KeyspacesClientTypes.TableStatus?
    let schemaDefinition: KeyspacesClientTypes.SchemaDefinition?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecificationSummary?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecoverySummary?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
    let comment: KeyspacesClientTypes.Comment?
}

extension GetTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecification
        case comment
        case creationTimestamp
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case resourceArn
        case schemaDefinition
        case status
        case tableName
        case ttl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TableStatus.self, forKey: .status)
        status = statusDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.SchemaDefinition.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecificationSummary.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoverySummary.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
        let commentDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Keyspaces was unable to fully process this request because of an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes.KeyspaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension KeyspacesClientTypes {
    /// Represents the properties of a keyspace.
    public struct KeyspaceSummary: Swift.Equatable {
        /// The name of the keyspace.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// The unique identifier of the keyspace in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?

        public init (
            keyspaceName: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.resourceArn = resourceArn
        }
    }

}

extension ListKeyspacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListKeyspacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListKeyspacesInput: Swift.Equatable {
    /// The total number of keyspaces to return in the output. If the total number of keyspaces available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKeyspacesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListKeyspacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListKeyspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeyspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListKeyspacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListKeyspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyspaces = output.keyspaces
            self.nextToken = output.nextToken
        } else {
            self.keyspaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeyspacesOutputResponse: Swift.Equatable {
    /// A list of keyspaces.
    /// This member is required.
    public var keyspaces: [KeyspacesClientTypes.KeyspaceSummary]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        keyspaces: [KeyspacesClientTypes.KeyspaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaces = keyspaces
        self.nextToken = nextToken
    }
}

struct ListKeyspacesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let keyspaces: [KeyspacesClientTypes.KeyspaceSummary]?
}

extension ListKeyspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaces
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let keyspacesContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.KeyspaceSummary?].self, forKey: .keyspaces)
        var keyspacesDecoded0:[KeyspacesClientTypes.KeyspaceSummary]? = nil
        if let keyspacesContainer = keyspacesContainer {
            keyspacesDecoded0 = [KeyspacesClientTypes.KeyspaceSummary]()
            for structure0 in keyspacesContainer {
                if let structure0 = structure0 {
                    keyspacesDecoded0?.append(structure0)
                }
            }
        }
        keyspaces = keyspacesDecoded0
    }
}

extension ListTablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The name of the keyspace.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// The total number of tables to return in the output. If the total number of tables available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var nextToken: Swift.String?

    public init (
        keyspaceName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyspaceName = keyspaceName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let keyspaceName: Swift.String?
}

extension ListTablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
    }
}

extension ListTablesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTablesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutputResponse: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tables.
    public var tables: [KeyspacesClientTypes.TableSummary]?

    public init (
        nextToken: Swift.String? = nil,
        tables: [KeyspacesClientTypes.TableSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tables: [KeyspacesClientTypes.TableSummary]?
}

extension ListTablesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tablesContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.TableSummary?].self, forKey: .tables)
        var tablesDecoded0:[KeyspacesClientTypes.TableSummary]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [KeyspacesClientTypes.TableSummary]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The total number of tags to return in the output. If the total number of tags available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as an argument of a subsequent API invocation.
    public var maxResults: Swift.Int?
    /// The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// A list of tags.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension KeyspacesClientTypes.PartitionKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension KeyspacesClientTypes {
    /// The partition key portion of the primary key is required and determines how Amazon Keyspaces stores the data. The partition key can be a single column, or it can be a compound value composed of two or more columns.
    public struct PartitionKey: Swift.Equatable {
        /// The name(s) of the partition key column(s).
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes.PointInTimeRecovery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoveryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KeyspacesClientTypes {
    /// Point-in-time recovery (PITR) helps protect your Amazon Keyspaces tables from accidental write or delete operations by providing you continuous backups of your table data. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public struct PointInTimeRecovery: Swift.Equatable {
        /// The options are: • ENABLED • DISABLED
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init (
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    public enum PointInTimeRecoveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PointInTimeRecoveryStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PointInTimeRecoveryStatus(rawValue: rawValue) ?? PointInTimeRecoveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.PointInTimeRecoverySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earliestRestorableTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let earliestRestorableTimestamp = self.earliestRestorableTimestamp {
            try encodeContainer.encodeTimestamp(earliestRestorableTimestamp, format: .epochSeconds, forKey: .earliestRestorableTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecoveryStatus.self, forKey: .status)
        status = statusDecoded
        let earliestRestorableTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .earliestRestorableTimestamp)
        earliestRestorableTimestamp = earliestRestorableTimestampDecoded
    }
}

extension KeyspacesClientTypes {
    /// The point-in-time recovery status of the specified table.
    public struct PointInTimeRecoverySummary: Swift.Equatable {
        /// Specifies the earliest possible restore point of the table in ISO 8601 format.
        public var earliestRestorableTimestamp: ClientRuntime.Date?
        /// Shows if point-in-time recovery is enabled or disabled for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.PointInTimeRecoveryStatus?

        public init (
            earliestRestorableTimestamp: ClientRuntime.Date? = nil,
            status: KeyspacesClientTypes.PointInTimeRecoveryStatus? = nil
        )
        {
            self.earliestRestorableTimestamp = earliestRestorableTimestamp
            self.status = status
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
        } else {
            self.message = nil
            self.resourceArn = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation tried to access a keyspace or table that doesn't exist. The resource might not be specified correctly, or its status might not be ACTIVE.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The unique identifier in the format of Amazon Resource Name (ARN), for the resource not found.
    public var resourceArn: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension RestoreTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecificationOverride
        case encryptionSpecificationOverride
        case pointInTimeRecoveryOverride
        case restoreTimestamp
        case sourceKeyspaceName
        case sourceTableName
        case tagsOverride
        case targetKeyspaceName
        case targetTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacitySpecificationOverride = self.capacitySpecificationOverride {
            try encodeContainer.encode(capacitySpecificationOverride, forKey: .capacitySpecificationOverride)
        }
        if let encryptionSpecificationOverride = self.encryptionSpecificationOverride {
            try encodeContainer.encode(encryptionSpecificationOverride, forKey: .encryptionSpecificationOverride)
        }
        if let pointInTimeRecoveryOverride = self.pointInTimeRecoveryOverride {
            try encodeContainer.encode(pointInTimeRecoveryOverride, forKey: .pointInTimeRecoveryOverride)
        }
        if let restoreTimestamp = self.restoreTimestamp {
            try encodeContainer.encodeTimestamp(restoreTimestamp, format: .epochSeconds, forKey: .restoreTimestamp)
        }
        if let sourceKeyspaceName = self.sourceKeyspaceName {
            try encodeContainer.encode(sourceKeyspaceName, forKey: .sourceKeyspaceName)
        }
        if let sourceTableName = self.sourceTableName {
            try encodeContainer.encode(sourceTableName, forKey: .sourceTableName)
        }
        if let tagsOverride = tagsOverride {
            var tagsOverrideContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsOverride)
            for tag0 in tagsOverride {
                try tagsOverrideContainer.encode(tag0)
            }
        }
        if let targetKeyspaceName = self.targetKeyspaceName {
            try encodeContainer.encode(targetKeyspaceName, forKey: .targetKeyspaceName)
        }
        if let targetTableName = self.targetTableName {
            try encodeContainer.encode(targetTableName, forKey: .targetTableName)
        }
    }
}

extension RestoreTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreTableInput: Swift.Equatable {
    /// Specifies the read/write throughput capacity mode for the target table. The options are: • throughputMode:PAY_PER_REQUEST • throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input. The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification?
    /// Specifies the encryption settings for the target table. You can choose one of the following KMS key (KMS key): • type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces. • type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input. The default is type:AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification?
    /// Specifies the pointInTimeRecovery settings for the target table. The options are: • ENABLED • DISABLED If it's not specified, the default is DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery?
    /// The restore timestamp in ISO 8601 format.
    public var restoreTimestamp: ClientRuntime.Date?
    /// The keyspace name of the source table.
    /// This member is required.
    public var sourceKeyspaceName: Swift.String?
    /// The name of the source table.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// A list of key-value pair tags to be attached to the restored table. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public var tagsOverride: [KeyspacesClientTypes.Tag]?
    /// The name of the target keyspace.
    /// This member is required.
    public var targetKeyspaceName: Swift.String?
    /// The name of the target table.
    /// This member is required.
    public var targetTableName: Swift.String?

    public init (
        capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification? = nil,
        encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification? = nil,
        pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        restoreTimestamp: ClientRuntime.Date? = nil,
        sourceKeyspaceName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        tagsOverride: [KeyspacesClientTypes.Tag]? = nil,
        targetKeyspaceName: Swift.String? = nil,
        targetTableName: Swift.String? = nil
    )
    {
        self.capacitySpecificationOverride = capacitySpecificationOverride
        self.encryptionSpecificationOverride = encryptionSpecificationOverride
        self.pointInTimeRecoveryOverride = pointInTimeRecoveryOverride
        self.restoreTimestamp = restoreTimestamp
        self.sourceKeyspaceName = sourceKeyspaceName
        self.sourceTableName = sourceTableName
        self.tagsOverride = tagsOverride
        self.targetKeyspaceName = targetKeyspaceName
        self.targetTableName = targetTableName
    }
}

struct RestoreTableInputBody: Swift.Equatable {
    let sourceKeyspaceName: Swift.String?
    let sourceTableName: Swift.String?
    let targetKeyspaceName: Swift.String?
    let targetTableName: Swift.String?
    let restoreTimestamp: ClientRuntime.Date?
    let capacitySpecificationOverride: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecificationOverride: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecoveryOverride: KeyspacesClientTypes.PointInTimeRecovery?
    let tagsOverride: [KeyspacesClientTypes.Tag]?
}

extension RestoreTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacitySpecificationOverride
        case encryptionSpecificationOverride
        case pointInTimeRecoveryOverride
        case restoreTimestamp
        case sourceKeyspaceName
        case sourceTableName
        case tagsOverride
        case targetKeyspaceName
        case targetTableName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceKeyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceKeyspaceName)
        sourceKeyspaceName = sourceKeyspaceNameDecoded
        let sourceTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableName)
        sourceTableName = sourceTableNameDecoded
        let targetKeyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKeyspaceName)
        targetKeyspaceName = targetKeyspaceNameDecoded
        let targetTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetTableName)
        targetTableName = targetTableNameDecoded
        let restoreTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .restoreTimestamp)
        restoreTimestamp = restoreTimestampDecoded
        let capacitySpecificationOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecificationOverride)
        capacitySpecificationOverride = capacitySpecificationOverrideDecoded
        let encryptionSpecificationOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecificationOverride)
        encryptionSpecificationOverride = encryptionSpecificationOverrideDecoded
        let pointInTimeRecoveryOverrideDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecoveryOverride)
        pointInTimeRecoveryOverride = pointInTimeRecoveryOverrideDecoded
        let tagsOverrideContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tagsOverride)
        var tagsOverrideDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsOverrideContainer = tagsOverrideContainer {
            tagsOverrideDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsOverrideContainer {
                if let structure0 = structure0 {
                    tagsOverrideDecoded0?.append(structure0)
                }
            }
        }
        tagsOverride = tagsOverrideDecoded0
    }
}

extension RestoreTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestoreTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestoreTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.restoredTableARN = output.restoredTableARN
        } else {
            self.restoredTableARN = nil
        }
    }
}

public struct RestoreTableOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the restored table.
    /// This member is required.
    public var restoredTableARN: Swift.String?

    public init (
        restoredTableARN: Swift.String? = nil
    )
    {
        self.restoredTableARN = restoredTableARN
    }
}

struct RestoreTableOutputResponseBody: Swift.Equatable {
    let restoredTableARN: Swift.String?
}

extension RestoreTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoredTableARN
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoredTableARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoredTableARN)
        restoredTableARN = restoredTableARNDecoded
    }
}

extension KeyspacesClientTypes.SchemaDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allColumns
        case clusteringKeys
        case partitionKeys
        case staticColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allColumns = allColumns {
            var allColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allColumns)
            for columndefinition0 in allColumns {
                try allColumnsContainer.encode(columndefinition0)
            }
        }
        if let clusteringKeys = clusteringKeys {
            var clusteringKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusteringKeys)
            for clusteringkey0 in clusteringKeys {
                try clusteringKeysContainer.encode(clusteringkey0)
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for partitionkey0 in partitionKeys {
                try partitionKeysContainer.encode(partitionkey0)
            }
        }
        if let staticColumns = staticColumns {
            var staticColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .staticColumns)
            for staticcolumn0 in staticColumns {
                try staticColumnsContainer.encode(staticcolumn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ColumnDefinition?].self, forKey: .allColumns)
        var allColumnsDecoded0:[KeyspacesClientTypes.ColumnDefinition]? = nil
        if let allColumnsContainer = allColumnsContainer {
            allColumnsDecoded0 = [KeyspacesClientTypes.ColumnDefinition]()
            for structure0 in allColumnsContainer {
                if let structure0 = structure0 {
                    allColumnsDecoded0?.append(structure0)
                }
            }
        }
        allColumns = allColumnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.PartitionKey?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[KeyspacesClientTypes.PartitionKey]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [KeyspacesClientTypes.PartitionKey]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let clusteringKeysContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ClusteringKey?].self, forKey: .clusteringKeys)
        var clusteringKeysDecoded0:[KeyspacesClientTypes.ClusteringKey]? = nil
        if let clusteringKeysContainer = clusteringKeysContainer {
            clusteringKeysDecoded0 = [KeyspacesClientTypes.ClusteringKey]()
            for structure0 in clusteringKeysContainer {
                if let structure0 = structure0 {
                    clusteringKeysDecoded0?.append(structure0)
                }
            }
        }
        clusteringKeys = clusteringKeysDecoded0
        let staticColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.StaticColumn?].self, forKey: .staticColumns)
        var staticColumnsDecoded0:[KeyspacesClientTypes.StaticColumn]? = nil
        if let staticColumnsContainer = staticColumnsContainer {
            staticColumnsDecoded0 = [KeyspacesClientTypes.StaticColumn]()
            for structure0 in staticColumnsContainer {
                if let structure0 = structure0 {
                    staticColumnsDecoded0?.append(structure0)
                }
            }
        }
        staticColumns = staticColumnsDecoded0
    }
}

extension KeyspacesClientTypes {
    /// Describes the schema of the table.
    public struct SchemaDefinition: Swift.Equatable {
        /// The regular columns of the table.
        /// This member is required.
        public var allColumns: [KeyspacesClientTypes.ColumnDefinition]?
        /// The columns that are part of the clustering key of the table.
        public var clusteringKeys: [KeyspacesClientTypes.ClusteringKey]?
        /// The columns that are part of the partition key of the table .
        /// This member is required.
        public var partitionKeys: [KeyspacesClientTypes.PartitionKey]?
        /// The columns that have been defined as STATIC. Static columns store values that are shared by all rows in the same partition.
        public var staticColumns: [KeyspacesClientTypes.StaticColumn]?

        public init (
            allColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
            clusteringKeys: [KeyspacesClientTypes.ClusteringKey]? = nil,
            partitionKeys: [KeyspacesClientTypes.PartitionKey]? = nil,
            staticColumns: [KeyspacesClientTypes.StaticColumn]? = nil
        )
        {
            self.allColumns = allColumns
            self.clusteringKeys = clusteringKeys
            self.partitionKeys = partitionKeys
            self.staticColumns = staticColumns
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation exceeded the service quota for this resource. For more information on service quotas, see [Quotas](https://docs.aws.amazon.com/keyspaces/latest/devguide/quotas.html) in the Amazon Keyspaces Developer Guide.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyspacesClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.StaticColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension KeyspacesClientTypes {
    /// The static columns of the table. Static columns store values that are shared by all rows in the same partition.
    public struct StaticColumn: Swift.Equatable {
        /// The name of the static column.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension KeyspacesClientTypes {
    public enum TableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case inaccessibleEncryptionCredentials
        case restoring
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [TableStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .inaccessibleEncryptionCredentials,
                .restoring,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .inaccessibleEncryptionCredentials: return "INACCESSIBLE_ENCRYPTION_CREDENTIALS"
            case .restoring: return "RESTORING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableStatus(rawValue: rawValue) ?? TableStatus.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.TableSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyspaceName
        case resourceArn
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension KeyspacesClientTypes {
    /// Returns the name of the specified table, the keyspace it is stored in, and the unique identifier in the format of an Amazon Resource Name (ARN).
    public struct TableSummary: Swift.Equatable {
        /// The name of the keyspace that the table is stored in.
        /// This member is required.
        public var keyspaceName: Swift.String?
        /// The unique identifier of the table in the format of an Amazon Resource Name (ARN).
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table.
        /// This member is required.
        public var tableName: Swift.String?

        public init (
            keyspaceName: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.keyspaceName = keyspaceName
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

extension KeyspacesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KeyspacesClientTypes {
    /// Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single Amazon Keyspaces resource. Amazon Web Services-assigned tag names and values are automatically assigned the aws: prefix, which the user cannot assign. Amazon Web Services-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix user: in the Cost Allocation Report. You cannot backdate the application of a tag. For more information, see [Adding tags and labels to Amazon Keyspaces resources](https://docs.aws.amazon.com/keyspaces/latest/devguide/tagging-keyspaces.html) in the Amazon Keyspaces Developer Guide.
    public struct Tag: Swift.Equatable {
        /// The key of the tag. Tag keys are case sensitive. Each Amazon Keyspaces resource can only have up to one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag. Tag values are case-sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon Keyspaces resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension KeyspacesClientTypes {
    public enum ThroughputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case payPerRequest
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ThroughputMode] {
            return [
                .payPerRequest,
                .provisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .payPerRequest: return "PAY_PER_REQUEST"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThroughputMode(rawValue: rawValue) ?? ThroughputMode.sdkUnknown(rawValue)
        }
    }
}

extension KeyspacesClientTypes.TimeToLive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLiveStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KeyspacesClientTypes {
    /// Enable custom Time to Live (TTL) settings for rows and columns without setting a TTL default for the specified table. For more information, see [Enabling TTL on tables](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_enabling) in the Amazon Keyspaces Developer Guide.
    public struct TimeToLive: Swift.Equatable {
        /// Shows how to enable custom Time to Live (TTL) settings for the specified table.
        /// This member is required.
        public var status: KeyspacesClientTypes.TimeToLiveStatus?

        public init (
            status: KeyspacesClientTypes.TimeToLiveStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension KeyspacesClientTypes {
    public enum TimeToLiveStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeToLiveStatus] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeToLiveStatus(rawValue: rawValue) ?? TimeToLiveStatus.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Keyspaces resource that the tags will be removed from. This value is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of existing tags to be removed from the Amazon Keyspaces resource.
    /// This member is required.
    public var tags: [KeyspacesClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [KeyspacesClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [KeyspacesClientTypes.Tag]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KeyspacesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KeyspacesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumns
        case capacitySpecification
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case tableName
        case ttl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addColumns = addColumns {
            var addColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addColumns)
            for columndefinition0 in addColumns {
                try addColumnsContainer.encode(columndefinition0)
            }
        }
        if let capacitySpecification = self.capacitySpecification {
            try encodeContainer.encode(capacitySpecification, forKey: .capacitySpecification)
        }
        if let defaultTimeToLive = self.defaultTimeToLive {
            try encodeContainer.encode(defaultTimeToLive, forKey: .defaultTimeToLive)
        }
        if let encryptionSpecification = self.encryptionSpecification {
            try encodeContainer.encode(encryptionSpecification, forKey: .encryptionSpecification)
        }
        if let keyspaceName = self.keyspaceName {
            try encodeContainer.encode(keyspaceName, forKey: .keyspaceName)
        }
        if let pointInTimeRecovery = self.pointInTimeRecovery {
            try encodeContainer.encode(pointInTimeRecovery, forKey: .pointInTimeRecovery)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let ttl = self.ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}

extension UpdateTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTableInput: Swift.Equatable {
    /// For each column to be added to the specified table: • name - The name of the column. • type - An Amazon Keyspaces data type. For more information, see [Data types](https://docs.aws.amazon.com/keyspaces/latest/devguide/cql.elements.html#cql.data-types) in the Amazon Keyspaces Developer Guide.
    public var addColumns: [KeyspacesClientTypes.ColumnDefinition]?
    /// Modifies the read/write throughput capacity mode for the table. The options are: • throughputMode:PAY_PER_REQUEST and • throughputMode:PROVISIONED - Provisioned capacity mode requires readCapacityUnits and writeCapacityUnits as input. The default is throughput_mode:PAY_PER_REQUEST. For more information, see [Read/write capacity modes](https://docs.aws.amazon.com/keyspaces/latest/devguide/ReadWriteCapacityMode.html) in the Amazon Keyspaces Developer Guide.
    public var capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    /// The default Time to Live setting in seconds for the table. For more information, see [Setting the default TTL value for a table](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL-how-it-works.html#ttl-howitworks_default_ttl) in the Amazon Keyspaces Developer Guide.
    public var defaultTimeToLive: Swift.Int?
    /// Modifies the encryption settings of the table. You can choose one of the following KMS key (KMS key): • type:AWS_OWNED_KMS_KEY - This key is owned by Amazon Keyspaces. • type:CUSTOMER_MANAGED_KMS_KEY - This key is stored in your account and is created, owned, and managed by you. This option requires the kms_key_identifier of the KMS key in Amazon Resource Name (ARN) format as input. The default is AWS_OWNED_KMS_KEY. For more information, see [Encryption at rest](https://docs.aws.amazon.com/keyspaces/latest/devguide/EncryptionAtRest.html) in the Amazon Keyspaces Developer Guide.
    public var encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    /// The name of the keyspace the specified table is stored in.
    /// This member is required.
    public var keyspaceName: Swift.String?
    /// Modifies the pointInTimeRecovery settings of the table. The options are: • ENABLED • DISABLED If it's not specified, the default is DISABLED. For more information, see [Point-in-time recovery](https://docs.aws.amazon.com/keyspaces/latest/devguide/PointInTimeRecovery.html) in the Amazon Keyspaces Developer Guide.
    public var pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    /// The name of the table.
    /// This member is required.
    public var tableName: Swift.String?
    /// Modifies Time to Live custom settings for the table. The options are: • status:enabled • status:disabled The default is status:disabled. After ttl is enabled, you can't disable it for the table. For more information, see [Expiring data by using Amazon Keyspaces Time to Live (TTL)](https://docs.aws.amazon.com/keyspaces/latest/devguide/TTL.html) in the Amazon Keyspaces Developer Guide.
    public var ttl: KeyspacesClientTypes.TimeToLive?

    public init (
        addColumns: [KeyspacesClientTypes.ColumnDefinition]? = nil,
        capacitySpecification: KeyspacesClientTypes.CapacitySpecification? = nil,
        defaultTimeToLive: Swift.Int? = nil,
        encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification? = nil,
        keyspaceName: Swift.String? = nil,
        pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery? = nil,
        tableName: Swift.String? = nil,
        ttl: KeyspacesClientTypes.TimeToLive? = nil
    )
    {
        self.addColumns = addColumns
        self.capacitySpecification = capacitySpecification
        self.defaultTimeToLive = defaultTimeToLive
        self.encryptionSpecification = encryptionSpecification
        self.keyspaceName = keyspaceName
        self.pointInTimeRecovery = pointInTimeRecovery
        self.tableName = tableName
        self.ttl = ttl
    }
}

struct UpdateTableInputBody: Swift.Equatable {
    let keyspaceName: Swift.String?
    let tableName: Swift.String?
    let addColumns: [KeyspacesClientTypes.ColumnDefinition]?
    let capacitySpecification: KeyspacesClientTypes.CapacitySpecification?
    let encryptionSpecification: KeyspacesClientTypes.EncryptionSpecification?
    let pointInTimeRecovery: KeyspacesClientTypes.PointInTimeRecovery?
    let ttl: KeyspacesClientTypes.TimeToLive?
    let defaultTimeToLive: Swift.Int?
}

extension UpdateTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumns
        case capacitySpecification
        case defaultTimeToLive
        case encryptionSpecification
        case keyspaceName
        case pointInTimeRecovery
        case tableName
        case ttl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyspaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyspaceName)
        keyspaceName = keyspaceNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let addColumnsContainer = try containerValues.decodeIfPresent([KeyspacesClientTypes.ColumnDefinition?].self, forKey: .addColumns)
        var addColumnsDecoded0:[KeyspacesClientTypes.ColumnDefinition]? = nil
        if let addColumnsContainer = addColumnsContainer {
            addColumnsDecoded0 = [KeyspacesClientTypes.ColumnDefinition]()
            for structure0 in addColumnsContainer {
                if let structure0 = structure0 {
                    addColumnsDecoded0?.append(structure0)
                }
            }
        }
        addColumns = addColumnsDecoded0
        let capacitySpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.CapacitySpecification.self, forKey: .capacitySpecification)
        capacitySpecification = capacitySpecificationDecoded
        let encryptionSpecificationDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.EncryptionSpecification.self, forKey: .encryptionSpecification)
        encryptionSpecification = encryptionSpecificationDecoded
        let pointInTimeRecoveryDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.PointInTimeRecovery.self, forKey: .pointInTimeRecovery)
        pointInTimeRecovery = pointInTimeRecoveryDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(KeyspacesClientTypes.TimeToLive.self, forKey: .ttl)
        ttl = ttlDecoded
        let defaultTimeToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTimeToLive)
        defaultTimeToLive = defaultTimeToLiveDecoded
    }
}

extension UpdateTableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateTableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
        } else {
            self.resourceArn = nil
        }
    }
}

public struct UpdateTableOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the modified table.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct UpdateTableOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension UpdateTableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed due to an invalid or malformed request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
