// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// (Discontinued) You do not have required permissions to access the requested resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Resource type that caused the exception
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AssociateMemberAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

extension AssociateMemberAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateMemberAccountInput: Swift.Equatable {
    /// (Discontinued) The ID of the Amazon Web Services account that you want to associate with Amazon Macie Classic as a member account.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init(
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct AssociateMemberAccountInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
}

extension AssociateMemberAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension AssociateMemberAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateMemberAccountOutput: Swift.Equatable {

    public init() { }
}

enum AssociateMemberAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateS3ResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3Resources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resourceclassification0 in s3Resources {
                try s3ResourcesContainer.encode(s3resourceclassification0)
            }
        }
    }
}

extension AssociateS3ResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateS3ResourcesInput: Swift.Equatable {
    /// (Discontinued) The ID of the Amazon Macie Classic member account whose resources you want to associate with Macie Classic.
    public var memberAccountId: Swift.String?
    /// (Discontinued) The S3 resources that you want to associate with Amazon Macie Classic for monitoring and data classification.
    /// This member is required.
    public var s3Resources: [MacieClientTypes.S3ResourceClassification]?

    public init(
        memberAccountId: Swift.String? = nil,
        s3Resources: [MacieClientTypes.S3ResourceClassification]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3Resources = s3Resources
    }
}

struct AssociateS3ResourcesInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
    let s3Resources: [MacieClientTypes.S3ResourceClassification]?
}

extension AssociateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3Resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[MacieClientTypes.S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [MacieClientTypes.S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
    }
}

extension AssociateS3ResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateS3ResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct AssociateS3ResourcesOutput: Swift.Equatable {
    /// (Discontinued) S3 resources that couldn't be associated with Amazon Macie Classic. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init(
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct AssociateS3ResourcesOutputBody: Swift.Equatable {
    let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension AssociateS3ResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

enum AssociateS3ResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MacieClientTypes.ClassificationType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = self.continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = self.oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) The classification type that Amazon Macie Classic applies to the associated S3 resources.
    public struct ClassificationType: Swift.Equatable {
        /// (Discontinued) A continuous classification of the objects that are added to a specified S3 bucket. Amazon Macie Classic begins performing continuous classification after a bucket is successfully associated with Macie Classic.
        /// This member is required.
        public var continuous: MacieClientTypes.S3ContinuousClassificationType?
        /// (Discontinued) A one-time classification of all of the existing objects in a specified S3 bucket.
        /// This member is required.
        public var oneTime: MacieClientTypes.S3OneTimeClassificationType?

        public init(
            continuous: MacieClientTypes.S3ContinuousClassificationType? = nil,
            oneTime: MacieClientTypes.S3OneTimeClassificationType? = nil
        )
        {
            self.continuous = continuous
            self.oneTime = oneTime
        }
    }

}

extension MacieClientTypes.ClassificationTypeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuous
        case oneTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuous = self.continuous {
            try encodeContainer.encode(continuous.rawValue, forKey: .continuous)
        }
        if let oneTime = self.oneTime {
            try encodeContainer.encode(oneTime.rawValue, forKey: .oneTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oneTimeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3OneTimeClassificationType.self, forKey: .oneTime)
        oneTime = oneTimeDecoded
        let continuousDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3ContinuousClassificationType.self, forKey: .continuous)
        continuous = continuousDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) The classification type that Amazon Macie Classic applies to the associated S3 resources. At least one of the classification types (oneTime or continuous) must be specified.
    public struct ClassificationTypeUpdate: Swift.Equatable {
        /// (Discontinued) A continuous classification of the objects that are added to a specified S3 bucket. Amazon Macie Classic begins performing continuous classification after a bucket is successfully associated with Macie Classic.
        public var continuous: MacieClientTypes.S3ContinuousClassificationType?
        /// (Discontinued) A one-time classification of all of the existing objects in a specified S3 bucket.
        public var oneTime: MacieClientTypes.S3OneTimeClassificationType?

        public init(
            continuous: MacieClientTypes.S3ContinuousClassificationType? = nil,
            oneTime: MacieClientTypes.S3OneTimeClassificationType? = nil
        )
        {
            self.continuous = continuous
            self.oneTime = oneTime
        }
    }

}

extension DisassociateMemberAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

extension DisassociateMemberAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateMemberAccountInput: Swift.Equatable {
    /// (Discontinued) The ID of the member account that you want to remove from Amazon Macie Classic.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init(
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateMemberAccountInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
}

extension DisassociateMemberAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension DisassociateMemberAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateMemberAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateMemberAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateS3ResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedS3Resources = associatedS3Resources {
            var associatedS3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedS3Resources)
            for s3resource0 in associatedS3Resources {
                try associatedS3ResourcesContainer.encode(s3resource0)
            }
        }
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

extension DisassociateS3ResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateS3ResourcesInput: Swift.Equatable {
    /// (Discontinued) The S3 resources (buckets or prefixes) that you want to remove from being monitored and classified by Amazon Macie Classic.
    /// This member is required.
    public var associatedS3Resources: [MacieClientTypes.S3Resource]?
    /// (Discontinued) The ID of the Amazon Macie Classic member account whose resources you want to remove from being monitored by Macie Classic.
    public var memberAccountId: Swift.String?

    public init(
        associatedS3Resources: [MacieClientTypes.S3Resource]? = nil,
        memberAccountId: Swift.String? = nil
    )
    {
        self.associatedS3Resources = associatedS3Resources
        self.memberAccountId = memberAccountId
    }
}

struct DisassociateS3ResourcesInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
    let associatedS3Resources: [MacieClientTypes.S3Resource]?
}

extension DisassociateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedS3Resources
        case memberAccountId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let associatedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3Resource?].self, forKey: .associatedS3Resources)
        var associatedS3ResourcesDecoded0:[MacieClientTypes.S3Resource]? = nil
        if let associatedS3ResourcesContainer = associatedS3ResourcesContainer {
            associatedS3ResourcesDecoded0 = [MacieClientTypes.S3Resource]()
            for structure0 in associatedS3ResourcesContainer {
                if let structure0 = structure0 {
                    associatedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        associatedS3Resources = associatedS3ResourcesDecoded0
    }
}

extension DisassociateS3ResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateS3ResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct DisassociateS3ResourcesOutput: Swift.Equatable {
    /// (Discontinued) S3 resources that couldn't be removed from being monitored and classified by Amazon Macie Classic. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init(
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct DisassociateS3ResourcesOutputBody: Swift.Equatable {
    let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension DisassociateS3ResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

enum DisassociateS3ResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MacieClientTypes.FailedS3Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case failedItem
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let failedItem = self.failedItem {
            try encodeContainer.encode(failedItem, forKey: .failedItem)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemDecoded = try containerValues.decodeIfPresent(MacieClientTypes.S3Resource.self, forKey: .failedItem)
        failedItem = failedItemDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) Includes details about the failed S3 resources.
    public struct FailedS3Resource: Swift.Equatable {
        /// (Discontinued) The status code of a failed item.
        public var errorCode: Swift.String?
        /// (Discontinued) The error message of a failed item.
        public var errorMessage: Swift.String?
        /// (Discontinued) The failed S3 resources.
        public var failedItem: MacieClientTypes.S3Resource?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            failedItem: MacieClientTypes.S3Resource? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.failedItem = failedItem
        }
    }

}

extension InternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// (Discontinued) Internal server error.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error code for the exception
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.fieldName = output.fieldName
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.fieldName = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// (Discontinued) The request was rejected because an invalid or out-of-range value was supplied for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error code for the exception
        public internal(set) var errorCode: Swift.String? = nil
        /// Field that has invalid input
        public internal(set) var fieldName: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        fieldName: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.fieldName = fieldName
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let fieldName: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case fieldName
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// (Discontinued) The request was rejected because it attempted to create resources beyond the current Amazon Web Services account quotas. The error code describes the quota exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error code for the exception
        public internal(set) var errorCode: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Resource type that caused the exception
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListMemberAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMemberAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMemberAccountsInput: Swift.Equatable {
    /// (Discontinued) Use this parameter to indicate the maximum number of items that you want in the response. The default value is 250.
    public var maxResults: Swift.Int?
    /// (Discontinued) Use this parameter when paginating results. Set the value of this parameter to null on your first call to the ListMemberAccounts action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMemberAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMemberAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMemberAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberAccounts = output.memberAccounts
            self.nextToken = output.nextToken
        } else {
            self.memberAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListMemberAccountsOutput: Swift.Equatable {
    /// (Discontinued) A list of the Amazon Macie Classic member accounts returned by the action. The current Macie Classic administrator account is also included in this list.
    public var memberAccounts: [MacieClientTypes.MemberAccount]?
    /// (Discontinued) When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?

    public init(
        memberAccounts: [MacieClientTypes.MemberAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

struct ListMemberAccountsOutputBody: Swift.Equatable {
    let memberAccounts: [MacieClientTypes.MemberAccount]?
    let nextToken: Swift.String?
}

extension ListMemberAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccounts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountsContainer = try containerValues.decodeIfPresent([MacieClientTypes.MemberAccount?].self, forKey: .memberAccounts)
        var memberAccountsDecoded0:[MacieClientTypes.MemberAccount]? = nil
        if let memberAccountsContainer = memberAccountsContainer {
            memberAccountsDecoded0 = [MacieClientTypes.MemberAccount]()
            for structure0 in memberAccountsContainer {
                if let structure0 = structure0 {
                    memberAccountsDecoded0?.append(structure0)
                }
            }
        }
        memberAccounts = memberAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMemberAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListS3ResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListS3ResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListS3ResourcesInput: Swift.Equatable {
    /// (Discontinued) Use this parameter to indicate the maximum number of items that you want in the response. The default value is 250.
    public var maxResults: Swift.Int?
    /// (Discontinued) The Amazon Macie Classic member account ID whose associated S3 resources you want to list.
    public var memberAccountId: Swift.String?
    /// (Discontinued) Use this parameter when paginating results. Set its value to null on your first call to the ListS3Resources action. Subsequent calls to the action fill nextToken in the request with the value of nextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memberAccountId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
    }
}

struct ListS3ResourcesInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case memberAccountId
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListS3ResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListS3ResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.s3Resources = output.s3Resources
        } else {
            self.nextToken = nil
            self.s3Resources = nil
        }
    }
}

public struct ListS3ResourcesOutput: Swift.Equatable {
    /// (Discontinued) When a response is generated, if there is more data to be listed, this parameter is present in the response and contains the value to use for the nextToken parameter in a subsequent pagination request. If there is no more data to be listed, this parameter is set to null.
    public var nextToken: Swift.String?
    /// (Discontinued) A list of the associated S3 resources returned by the action.
    public var s3Resources: [MacieClientTypes.S3ResourceClassification]?

    public init(
        nextToken: Swift.String? = nil,
        s3Resources: [MacieClientTypes.S3ResourceClassification]? = nil
    )
    {
        self.nextToken = nextToken
        self.s3Resources = s3Resources
    }
}

struct ListS3ResourcesOutputBody: Swift.Equatable {
    let s3Resources: [MacieClientTypes.S3ResourceClassification]?
    let nextToken: Swift.String?
}

extension ListS3ResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case s3Resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassification?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[MacieClientTypes.S3ResourceClassification]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [MacieClientTypes.S3ResourceClassification]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListS3ResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MacieClientTypes.MemberAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) Contains information about the Amazon Macie Classic member account.
    public struct MemberAccount: Swift.Equatable {
        /// (Discontinued) The Amazon Web Services account ID of the Amazon Macie Classic member account.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension MacieClientTypes {
    public enum S3ContinuousClassificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ContinuousClassificationType] {
            return [
                .full,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ContinuousClassificationType(rawValue: rawValue) ?? S3ContinuousClassificationType.sdkUnknown(rawValue)
        }
    }
}

extension MacieClientTypes {
    public enum S3OneTimeClassificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [S3OneTimeClassificationType] {
            return [
                .full,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3OneTimeClassificationType(rawValue: rawValue) ?? S3OneTimeClassificationType.sdkUnknown(rawValue)
        }
    }
}

extension MacieClientTypes.S3Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) Contains information about the S3 resource. This data type is used as a request parameter in the DisassociateS3Resources action and can be used as a response parameter in the AssociateS3Resources and UpdateS3Resources actions.
    public struct S3Resource: Swift.Equatable {
        /// (Discontinued) The name of the S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// (Discontinued) The prefix of the S3 bucket.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension MacieClientTypes.S3ResourceClassification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case classificationType
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationType = self.classificationType {
            try encodeContainer.encode(classificationType, forKey: .classificationType)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let classificationTypeDecoded = try containerValues.decodeIfPresent(MacieClientTypes.ClassificationType.self, forKey: .classificationType)
        classificationType = classificationTypeDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) The S3 resources that you want to associate with Amazon Macie Classic for monitoring and data classification. This data type is used as a request parameter in the AssociateS3Resources action and a response parameter in the ListS3Resources action.
    public struct S3ResourceClassification: Swift.Equatable {
        /// (Discontinued) The name of the S3 bucket that you want to associate with Amazon Macie Classic.
        /// This member is required.
        public var bucketName: Swift.String?
        /// (Discontinued) The classification type that you want to specify for the resource associated with Amazon Macie Classic.
        /// This member is required.
        public var classificationType: MacieClientTypes.ClassificationType?
        /// (Discontinued) The prefix of the S3 bucket that you want to associate with Amazon Macie Classic.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            classificationType: MacieClientTypes.ClassificationType? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.classificationType = classificationType
            self.`prefix` = `prefix`
        }
    }

}

extension MacieClientTypes.S3ResourceClassificationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case classificationTypeUpdate
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let classificationTypeUpdate = self.classificationTypeUpdate {
            try encodeContainer.encode(classificationTypeUpdate, forKey: .classificationTypeUpdate)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let classificationTypeUpdateDecoded = try containerValues.decodeIfPresent(MacieClientTypes.ClassificationTypeUpdate.self, forKey: .classificationTypeUpdate)
        classificationTypeUpdate = classificationTypeUpdateDecoded
    }
}

extension MacieClientTypes {
    /// (Discontinued) The S3 resources whose classification types you want to update. This data type is used as a request parameter in the UpdateS3Resources action.
    public struct S3ResourceClassificationUpdate: Swift.Equatable {
        /// (Discontinued) The name of the S3 bucket whose classification types you want to update.
        /// This member is required.
        public var bucketName: Swift.String?
        /// (Discontinued) The classification type that you want to update for the resource associated with Amazon Macie Classic.
        /// This member is required.
        public var classificationTypeUpdate: MacieClientTypes.ClassificationTypeUpdate?
        /// (Discontinued) The prefix of the S3 bucket whose classification types you want to update.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            classificationTypeUpdate: MacieClientTypes.ClassificationTypeUpdate? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.classificationTypeUpdate = classificationTypeUpdate
            self.`prefix` = `prefix`
        }
    }

}

extension UpdateS3ResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
        if let s3ResourcesUpdate = s3ResourcesUpdate {
            var s3ResourcesUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3ResourcesUpdate)
            for s3resourceclassificationupdate0 in s3ResourcesUpdate {
                try s3ResourcesUpdateContainer.encode(s3resourceclassificationupdate0)
            }
        }
    }
}

extension UpdateS3ResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateS3ResourcesInput: Swift.Equatable {
    /// (Discontinued) The Amazon Web Services account ID of the Amazon Macie Classic member account whose S3 resources' classification types you want to update.
    public var memberAccountId: Swift.String?
    /// (Discontinued) The S3 resources whose classification types you want to update.
    /// This member is required.
    public var s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]?

    public init(
        memberAccountId: Swift.String? = nil,
        s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]? = nil
    )
    {
        self.memberAccountId = memberAccountId
        self.s3ResourcesUpdate = s3ResourcesUpdate
    }
}

struct UpdateS3ResourcesInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
    let s3ResourcesUpdate: [MacieClientTypes.S3ResourceClassificationUpdate]?
}

extension UpdateS3ResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId
        case s3ResourcesUpdate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
        let s3ResourcesUpdateContainer = try containerValues.decodeIfPresent([MacieClientTypes.S3ResourceClassificationUpdate?].self, forKey: .s3ResourcesUpdate)
        var s3ResourcesUpdateDecoded0:[MacieClientTypes.S3ResourceClassificationUpdate]? = nil
        if let s3ResourcesUpdateContainer = s3ResourcesUpdateContainer {
            s3ResourcesUpdateDecoded0 = [MacieClientTypes.S3ResourceClassificationUpdate]()
            for structure0 in s3ResourcesUpdateContainer {
                if let structure0 = structure0 {
                    s3ResourcesUpdateDecoded0?.append(structure0)
                }
            }
        }
        s3ResourcesUpdate = s3ResourcesUpdateDecoded0
    }
}

extension UpdateS3ResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateS3ResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedS3Resources = output.failedS3Resources
        } else {
            self.failedS3Resources = nil
        }
    }
}

public struct UpdateS3ResourcesOutput: Swift.Equatable {
    /// (Discontinued) The S3 resources whose classification types can't be updated. An error code and an error message are provided for each failed item.
    public var failedS3Resources: [MacieClientTypes.FailedS3Resource]?

    public init(
        failedS3Resources: [MacieClientTypes.FailedS3Resource]? = nil
    )
    {
        self.failedS3Resources = failedS3Resources
    }
}

struct UpdateS3ResourcesOutputBody: Swift.Equatable {
    let failedS3Resources: [MacieClientTypes.FailedS3Resource]?
}

extension UpdateS3ResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedS3Resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedS3ResourcesContainer = try containerValues.decodeIfPresent([MacieClientTypes.FailedS3Resource?].self, forKey: .failedS3Resources)
        var failedS3ResourcesDecoded0:[MacieClientTypes.FailedS3Resource]? = nil
        if let failedS3ResourcesContainer = failedS3ResourcesContainer {
            failedS3ResourcesDecoded0 = [MacieClientTypes.FailedS3Resource]()
            for structure0 in failedS3ResourcesContainer {
                if let structure0 = structure0 {
                    failedS3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedS3Resources = failedS3ResourcesDecoded0
    }
}

enum UpdateS3ResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalException": return try await InternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
