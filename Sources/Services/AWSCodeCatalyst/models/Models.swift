// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because you don't have sufficient access to perform this action. Verify that you are a member of a role that allows this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCatalystClientTypes.AccessTokenSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresTime = self.expiresTime {
            try encodeContainer.encodeTimestamp(expiresTime, format: .dateTime, forKey: .expiresTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a specified personal access token (PAT).
    public struct AccessTokenSummary: Swift.Equatable {
        /// The date and time when the personal access token will expire, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        public var expiresTime: ClientRuntime.Date?
        /// The system-generated ID of the personal access token.
        /// This member is required.
        public var id: Swift.String?
        /// The friendly name of the personal access token.
        /// This member is required.
        public var name: Swift.String?

        public init(
            expiresTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.expiresTime = expiresTime
            self.id = id
            self.name = name
        }
    }

}

extension CodeCatalystClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension CodeCatalystClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case equals
        case greaterThan
        case greaterThanOrEquals
        case lessThan
        case lessThanOrEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .equals,
                .greaterThan,
                .greaterThanOrEquals,
                .lessThan,
                .lessThanOrEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .equals: return "EQ"
            case .greaterThan: return "GT"
            case .greaterThanOrEquals: return "GE"
            case .lessThan: return "LT"
            case .lessThanOrEquals: return "LE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because the requested operation would cause a conflict with the current state of a service resource associated with the request. Another user might have updated the resource. Reload, make sure you have the latest data, and then try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccessTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiresTime = self.expiresTime {
            try encodeContainer.encodeTimestamp(expiresTime, format: .dateTime, forKey: .expiresTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/accessTokens"
    }
}

public struct CreateAccessTokenInput: Swift.Equatable {
    /// The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    public var expiresTime: ClientRuntime.Date?
    /// The friendly name of the personal access token.
    /// This member is required.
    public var name: Swift.String?

    public init(
        expiresTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil
    )
    {
        self.expiresTime = expiresTime
        self.name = name
    }
}

struct CreateAccessTokenInputBody: Swift.Equatable {
    let name: Swift.String?
    let expiresTime: ClientRuntime.Date?
}

extension CreateAccessTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiresTime
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
    }
}

extension CreateAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessTokenOutput(accessTokenId: \(Swift.String(describing: accessTokenId)), expiresTime: \(Swift.String(describing: expiresTime)), name: \(Swift.String(describing: name)), secret: \"CONTENT_REDACTED\")"}
}

extension CreateAccessTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessTokenId = output.accessTokenId
            self.expiresTime = output.expiresTime
            self.name = output.name
            self.secret = output.secret
        } else {
            self.accessTokenId = nil
            self.expiresTime = nil
            self.name = nil
            self.secret = nil
        }
    }
}

public struct CreateAccessTokenOutput: Swift.Equatable {
    /// The system-generated unique ID of the access token.
    /// This member is required.
    public var accessTokenId: Swift.String?
    /// The date and time the personal access token expires, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6). If not specified, the default is one year from creation.
    /// This member is required.
    public var expiresTime: ClientRuntime.Date?
    /// The friendly name of the personal access token.
    /// This member is required.
    public var name: Swift.String?
    /// The secret value of the personal access token.
    /// This member is required.
    public var secret: Swift.String?

    public init(
        accessTokenId: Swift.String? = nil,
        expiresTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        secret: Swift.String? = nil
    )
    {
        self.accessTokenId = accessTokenId
        self.expiresTime = expiresTime
        self.name = name
        self.secret = secret
    }
}

struct CreateAccessTokenOutputBody: Swift.Equatable {
    let secret: Swift.String?
    let name: Swift.String?
    let expiresTime: ClientRuntime.Date?
    let accessTokenId: Swift.String?
}

extension CreateAccessTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessTokenId
        case expiresTime
        case name
        case secret
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secret)
        secret = secretDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiresTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresTime)
        expiresTime = expiresTimeDecoded
        let accessTokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessTokenId)
        accessTokenId = accessTokenIdDecoded
    }
}

enum CreateAccessTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case persistentStorage
        case repositories
        case vpcConnectionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let persistentStorage = self.persistentStorage {
            try encodeContainer.encode(persistentStorage, forKey: .persistentStorage)
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for repositoryinput0 in repositories {
                try repositoriesContainer.encode(repositoryinput0)
            }
        }
        if let vpcConnectionName = self.vpcConnectionName {
            try encodeContainer.encode(vpcConnectionName, forKey: .vpcConnectionName)
        }
    }
}

extension CreateDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments"
    }
}

public struct CreateDevEnvironmentInput: Swift.Equatable {
    /// The user-defined alias for a Dev Environment.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment. An IDE is required to create a Dev Environment. For Dev Environment creation, this field contains configuration information and must be provided.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    /// This member is required.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage when created from the Amazon CodeCatalyst console, but there is no default when programmatically creating a Dev Environment. Valid values for persistent storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
    /// This member is required.
    public var persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The source repository that contains the branch to clone into the Dev Environment.
    public var repositories: [CodeCatalystClientTypes.RepositoryInput]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The name of the connection to use connect to a Amazon VPC.
    public var vpcConnectionName: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration? = nil,
        projectName: Swift.String? = nil,
        repositories: [CodeCatalystClientTypes.RepositoryInput]? = nil,
        spaceName: Swift.String? = nil,
        vpcConnectionName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.persistentStorage = persistentStorage
        self.projectName = projectName
        self.repositories = repositories
        self.spaceName = spaceName
        self.vpcConnectionName = vpcConnectionName
    }
}

struct CreateDevEnvironmentInputBody: Swift.Equatable {
    let repositories: [CodeCatalystClientTypes.RepositoryInput]?
    let clientToken: Swift.String?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let persistentStorage: CodeCatalystClientTypes.PersistentStorageConfiguration?
    let vpcConnectionName: Swift.String?
}

extension CreateDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case persistentStorage
        case repositories
        case vpcConnectionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.RepositoryInput?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.RepositoryInput]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.RepositoryInput]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorageConfiguration.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
        let vpcConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionName)
        vpcConnectionName = vpcConnectionNameDecoded
    }
}

extension CreateDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.vpcConnectionName = output.vpcConnectionName
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.vpcConnectionName = nil
        }
    }
}

public struct CreateDevEnvironmentOutput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The name of the connection used to connect to Amazon VPC used when the Dev Environment was created, if any.
    public var vpcConnectionName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        vpcConnectionName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.vpcConnectionName = vpcConnectionName
    }
}

struct CreateDevEnvironmentOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let vpcConnectionName: Swift.String?
}

extension CreateDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case vpcConnectionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vpcConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionName)
        vpcConnectionName = vpcConnectionNameDecoded
    }
}

enum CreateDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// The description of the project. This description will be displayed to all users of the project. We recommend providing a brief description of the project and its intended purpose.
    public var description: Swift.String?
    /// The friendly name of the project that will be displayed to users.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.spaceName = spaceName
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The friendly name of the project.
    public var displayName: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSourceRepositoryBranchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headCommitId = self.headCommitId {
            try encodeContainer.encode(headCommitId, forKey: .headCommitId)
        }
    }
}

extension CreateSourceRepositoryBranchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/branches/\(name.urlPercentEncoding())"
    }
}

public struct CreateSourceRepositoryBranchInput: Swift.Equatable {
    /// The commit ID in an existing branch from which you want to create the new branch.
    public var headCommitId: Swift.String?
    /// The name for the branch you're creating.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the repository where you want to create a branch.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        headCommitId: Swift.String? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.headCommitId = headCommitId
        self.name = name
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct CreateSourceRepositoryBranchInputBody: Swift.Equatable {
    let headCommitId: Swift.String?
}

extension CreateSourceRepositoryBranchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

extension CreateSourceRepositoryBranchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSourceRepositoryBranchOutputBody = try responseDecoder.decode(responseBody: data)
            self.headCommitId = output.headCommitId
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.ref = output.ref
        } else {
            self.headCommitId = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.ref = nil
        }
    }
}

public struct CreateSourceRepositoryBranchOutput: Swift.Equatable {
    /// The commit ID of the tip of the newly created branch.
    public var headCommitId: Swift.String?
    /// The time the branch was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the newly created branch.
    public var name: Swift.String?
    /// The Git reference name of the branch.
    public var ref: Swift.String?

    public init(
        headCommitId: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        ref: Swift.String? = nil
    )
    {
        self.headCommitId = headCommitId
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.ref = ref
    }
}

struct CreateSourceRepositoryBranchOutputBody: Swift.Equatable {
    let ref: Swift.String?
    let name: Swift.String?
    let lastUpdatedTime: ClientRuntime.Date?
    let headCommitId: Swift.String?
}

extension CreateSourceRepositoryBranchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
        case lastUpdatedTime
        case name
        case ref
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ref)
        ref = refDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

enum CreateSourceRepositoryBranchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSourceRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension CreateSourceRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(name.urlPercentEncoding())"
    }
}

public struct CreateSourceRepositoryInput: Swift.Equatable {
    /// The description of the source repository.
    public var description: Swift.String?
    /// The name of the source repository. For more information about name requirements, see [Quotas for source repositories](https://docs.aws.amazon.com/codecatalyst/latest/userguide/source-quotas.html).
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct CreateSourceRepositoryInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension CreateSourceRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSourceRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSourceRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.name = output.name
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.name = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct CreateSourceRepositoryOutput: Swift.Equatable {
    /// The description of the source repository.
    public var description: Swift.String?
    /// The name of the source repository.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct CreateSourceRepositoryOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension CreateSourceRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case projectName
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum CreateSourceRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAccessTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/v1/accessTokens/\(id.urlPercentEncoding())"
    }
}

public struct DeleteAccessTokenInput: Swift.Equatable {
    /// The ID of the personal access token to delete. You can find the IDs of all PATs associated with your Amazon Web Services Builder ID in a space by calling [ListAccessTokens].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteAccessTokenInputBody: Swift.Equatable {
}

extension DeleteAccessTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessTokenOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment you want to delete. To retrieve a list of Dev Environment IDs, use [ListDevEnvironments].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteDevEnvironmentInputBody: Swift.Equatable {
}

extension DeleteDevEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct DeleteDevEnvironmentOutput: Swift.Equatable {
    /// The system-generated unique ID of the deleted Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteDevEnvironmentOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
}

extension DeleteDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum DeleteDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(name.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// The name of the project in the space. To retrieve a list of project names, use [ListProjects].
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.spaceName = spaceName
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct DeleteProjectOutput: Swift.Equatable {
    /// The friendly name displayed to users of the project in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct DeleteProjectOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
}

extension DeleteProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case name
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSourceRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(name.urlPercentEncoding())"
    }
}

public struct DeleteSourceRepositoryInput: Swift.Equatable {
    /// The name of the source repository.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteSourceRepositoryInputBody: Swift.Equatable {
}

extension DeleteSourceRepositoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSourceRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSourceRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.name = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct DeleteSourceRepositoryOutput: Swift.Equatable {
    /// The name of the repository.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct DeleteSourceRepositoryOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let name: Swift.String?
}

extension DeleteSourceRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectName
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum DeleteSourceRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSpaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(name.urlPercentEncoding())"
    }
}

public struct DeleteSpaceInput: Swift.Equatable {
    /// The name of the space. To retrieve a list of space names, use [ListSpaces].
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteSpaceInputBody: Swift.Equatable {
}

extension DeleteSpaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSpaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.name = output.name
        } else {
            self.displayName = nil
            self.name = nil
        }
    }
}

public struct DeleteSpaceOutput: Swift.Equatable {
    /// The friendly name of the space displayed to users of the space in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.name = name
    }
}

struct DeleteSpaceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
}

extension DeleteSpaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

enum DeleteSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCatalystClientTypes.DevEnvironmentAccessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamUrl
        case tokenValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamUrl = self.streamUrl {
            try encodeContainer.encode(streamUrl, forKey: .streamUrl)
        }
        if let tokenValue = self.tokenValue {
            try encodeContainer.encode(tokenValue, forKey: .tokenValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamUrl)
        streamUrl = streamUrlDecoded
        let tokenValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenValue)
        tokenValue = tokenValueDecoded
    }
}

extension CodeCatalystClientTypes.DevEnvironmentAccessDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CodeCatalystClientTypes {
    /// Information about connection details for a Dev Environment.
    public struct DevEnvironmentAccessDetails: Swift.Equatable {
        /// The URL used to send commands to and from the Dev Environment.
        /// This member is required.
        public var streamUrl: Swift.String?
        /// An encrypted token value that contains session and caller information used to authenticate the connection.
        /// This member is required.
        public var tokenValue: Swift.String?

        public init(
            streamUrl: Swift.String? = nil,
            tokenValue: Swift.String? = nil
        )
        {
            self.streamUrl = streamUrl
            self.tokenValue = tokenValue
        }
    }

}

extension CodeCatalystClientTypes.DevEnvironmentRepositorySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the source repsitory for a Dev Environment.
    public struct DevEnvironmentRepositorySummary: Swift.Equatable {
        /// The name of the branch in a source repository cloned into the Dev Environment.
        public var branchName: Swift.String?
        /// The name of the source repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }
    }

}

extension CodeCatalystClientTypes.DevEnvironmentSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executeCommandSessionConfiguration
        case sessionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executeCommandSessionConfiguration = self.executeCommandSessionConfiguration {
            try encodeContainer.encode(executeCommandSessionConfiguration, forKey: .executeCommandSessionConfiguration)
        }
        if let sessionType = self.sessionType {
            try encodeContainer.encode(sessionType.rawValue, forKey: .sessionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentSessionType.self, forKey: .sessionType)
        sessionType = sessionTypeDecoded
        let executeCommandSessionConfigurationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ExecuteCommandSessionConfiguration.self, forKey: .executeCommandSessionConfiguration)
        executeCommandSessionConfiguration = executeCommandSessionConfigurationDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of a Dev Environment session.
    public struct DevEnvironmentSessionConfiguration: Swift.Equatable {
        /// Information about optional commands that will be run on the Dev Environment when the SSH session begins.
        public var executeCommandSessionConfiguration: CodeCatalystClientTypes.ExecuteCommandSessionConfiguration?
        /// The type of the session.
        /// This member is required.
        public var sessionType: CodeCatalystClientTypes.DevEnvironmentSessionType?

        public init(
            executeCommandSessionConfiguration: CodeCatalystClientTypes.ExecuteCommandSessionConfiguration? = nil,
            sessionType: CodeCatalystClientTypes.DevEnvironmentSessionType? = nil
        )
        {
            self.executeCommandSessionConfiguration = executeCommandSessionConfiguration
            self.sessionType = sessionType
        }
    }

}

extension CodeCatalystClientTypes.DevEnvironmentSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devEnvironmentId
        case id
        case projectName
        case spaceName
        case startedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEnvironmentId = self.devEnvironmentId {
            try encodeContainer.encode(devEnvironmentId, forKey: .devEnvironmentId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let spaceName = self.spaceName {
            try encodeContainer.encode(spaceName, forKey: .spaceName)
        }
        if let startedTime = self.startedTime {
            try encodeContainer.encodeTimestamp(startedTime, format: .dateTime, forKey: .startedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let devEnvironmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devEnvironmentId)
        devEnvironmentId = devEnvironmentIdDecoded
        let startedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedTime)
        startedTime = startedTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about active sessions for a Dev Environment.
    public struct DevEnvironmentSessionSummary: Swift.Equatable {
        /// The system-generated unique ID of the Dev Environment.
        /// This member is required.
        public var devEnvironmentId: Swift.String?
        /// The system-generated unique ID of the Dev Environment session.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the project in the space.
        /// This member is required.
        public var projectName: Swift.String?
        /// The name of the space.
        /// This member is required.
        public var spaceName: Swift.String?
        /// The date and time the session started, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
        /// This member is required.
        public var startedTime: ClientRuntime.Date?

        public init(
            devEnvironmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            projectName: Swift.String? = nil,
            spaceName: Swift.String? = nil,
            startedTime: ClientRuntime.Date? = nil
        )
        {
            self.devEnvironmentId = devEnvironmentId
            self.id = id
            self.projectName = projectName
            self.spaceName = spaceName
            self.startedTime = startedTime
        }
    }

}

extension CodeCatalystClientTypes {
    public enum DevEnvironmentSessionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssh
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [DevEnvironmentSessionType] {
            return [
                .ssh,
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssh: return "SSH"
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevEnvironmentSessionType(rawValue: rawValue) ?? DevEnvironmentSessionType.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes {
    public enum DevEnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case deleting
        case failed
        case pending
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [DevEnvironmentStatus] {
            return [
                .deleted,
                .deleting,
                .failed,
                .pending,
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DevEnvironmentStatus(rawValue: rawValue) ?? DevEnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.DevEnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case creatorId
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case lastUpdatedTime
        case persistentStorage
        case projectName
        case repositories
        case spaceName
        case status
        case statusReason
        case vpcConnectionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let creatorId = self.creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ide0 in ides {
                try idesContainer.encode(ide0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let persistentStorage = self.persistentStorage {
            try encodeContainer.encode(persistentStorage, forKey: .persistentStorage)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for devenvironmentrepositorysummary0 in repositories {
                try repositoriesContainer.encode(devenvironmentrepositorysummary0)
            }
        }
        if let spaceName = self.spaceName {
            try encodeContainer.encode(spaceName, forKey: .spaceName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let vpcConnectionName = self.vpcConnectionName {
            try encodeContainer.encode(vpcConnectionName, forKey: .vpcConnectionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentRepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Ide?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.Ide]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.Ide]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorage.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
        let vpcConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionName)
        vpcConnectionName = vpcConnectionNameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a Dev Environment.
    public struct DevEnvironmentSummary: Swift.Equatable {
        /// The user-specified alias for the Dev Environment.
        public var alias: Swift.String?
        /// The system-generated unique ID of the user who created the Dev Environment.
        /// This member is required.
        public var creatorId: Swift.String?
        /// The system-generated unique ID for the Dev Environment.
        /// This member is required.
        public var id: Swift.String?
        /// Information about the integrated development environment (IDE) configured for a Dev Environment.
        public var ides: [CodeCatalystClientTypes.Ide]?
        /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Dev Environments consume compute minutes when running.
        /// This member is required.
        public var inactivityTimeoutMinutes: Swift.Int
        /// The Amazon EC2 instace type used for the Dev Environment.
        /// This member is required.
        public var instanceType: CodeCatalystClientTypes.InstanceType?
        /// The time when the Dev Environment was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Information about the configuration of persistent storage for the Dev Environment.
        /// This member is required.
        public var persistentStorage: CodeCatalystClientTypes.PersistentStorage?
        /// The name of the project in the space.
        public var projectName: Swift.String?
        /// Information about the repositories that will be cloned into the Dev Environment. If no rvalue is specified, no repository is cloned.
        /// This member is required.
        public var repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
        /// The name of the space.
        public var spaceName: Swift.String?
        /// The status of the Dev Environment.
        /// This member is required.
        public var status: CodeCatalystClientTypes.DevEnvironmentStatus?
        /// The reason for the status.
        public var statusReason: Swift.String?
        /// The name of the connection used to connect to Amazon VPC used when the Dev Environment was created, if any.
        public var vpcConnectionName: Swift.String?

        public init(
            alias: Swift.String? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            ides: [CodeCatalystClientTypes.Ide]? = nil,
            inactivityTimeoutMinutes: Swift.Int = 0,
            instanceType: CodeCatalystClientTypes.InstanceType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            persistentStorage: CodeCatalystClientTypes.PersistentStorage? = nil,
            projectName: Swift.String? = nil,
            repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil,
            spaceName: Swift.String? = nil,
            status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil,
            statusReason: Swift.String? = nil,
            vpcConnectionName: Swift.String? = nil
        )
        {
            self.alias = alias
            self.creatorId = creatorId
            self.id = id
            self.ides = ides
            self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
            self.instanceType = instanceType
            self.lastUpdatedTime = lastUpdatedTime
            self.persistentStorage = persistentStorage
            self.projectName = projectName
            self.repositories = repositories
            self.spaceName = spaceName
            self.status = status
            self.statusReason = statusReason
            self.vpcConnectionName = vpcConnectionName
        }
    }

}

extension CodeCatalystClientTypes.EmailAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case verified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let verified = self.verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verified)
        verified = verifiedDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an email address.
    public struct EmailAddress: Swift.Equatable {
        /// The email address.
        public var email: Swift.String?
        /// Whether the email address has been verified.
        public var verified: Swift.Bool?

        public init(
            email: Swift.String? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.email = email
            self.verified = verified
        }
    }

}

extension CodeCatalystClientTypes.EventLogEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case eventCategory
        case eventName
        case eventSource
        case eventTime
        case eventType
        case id
        case operationType
        case projectInformation
        case requestId
        case requestPayload
        case responsePayload
        case sourceIpAddress
        case userAgent
        case userIdentity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let eventCategory = self.eventCategory {
            try encodeContainer.encode(eventCategory, forKey: .eventCategory)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let operationType = self.operationType {
            try encodeContainer.encode(operationType.rawValue, forKey: .operationType)
        }
        if let projectInformation = self.projectInformation {
            try encodeContainer.encode(projectInformation, forKey: .projectInformation)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let requestPayload = self.requestPayload {
            try encodeContainer.encode(requestPayload, forKey: .requestPayload)
        }
        if let responsePayload = self.responsePayload {
            try encodeContainer.encode(responsePayload, forKey: .responsePayload)
        }
        if let sourceIpAddress = self.sourceIpAddress {
            try encodeContainer.encode(sourceIpAddress, forKey: .sourceIpAddress)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
        if let userIdentity = self.userIdentity {
            try encodeContainer.encode(userIdentity, forKey: .userIdentity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let operationTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.OperationType.self, forKey: .operationType)
        operationType = operationTypeDecoded
        let userIdentityDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.UserIdentity.self, forKey: .userIdentity)
        userIdentity = userIdentityDecoded
        let projectInformationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ProjectInformation.self, forKey: .projectInformation)
        projectInformation = projectInformationDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let requestPayloadDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EventPayload.self, forKey: .requestPayload)
        requestPayload = requestPayloadDecoded
        let responsePayloadDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EventPayload.self, forKey: .responsePayload)
        responsePayload = responsePayloadDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let sourceIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIpAddress)
        sourceIpAddress = sourceIpAddressDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an entry in an event log of Amazon CodeCatalyst activity.
    public struct EventLogEntry: Swift.Equatable {
        /// The code of the error, if any.
        public var errorCode: Swift.String?
        /// The category for the event.
        /// This member is required.
        public var eventCategory: Swift.String?
        /// The name of the event.
        /// This member is required.
        public var eventName: Swift.String?
        /// The source of the event.
        /// This member is required.
        public var eventSource: Swift.String?
        /// The time the event took place, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var eventTime: ClientRuntime.Date?
        /// The type of the event.
        /// This member is required.
        public var eventType: Swift.String?
        /// The system-generated unique ID of the event.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the event.
        /// This member is required.
        public var operationType: CodeCatalystClientTypes.OperationType?
        /// Information about the project where the event occurred.
        public var projectInformation: CodeCatalystClientTypes.ProjectInformation?
        /// The system-generated unique ID of the request.
        public var requestId: Swift.String?
        /// Information about the payload of the request.
        public var requestPayload: CodeCatalystClientTypes.EventPayload?
        /// Information about the payload of the response, if any.
        public var responsePayload: CodeCatalystClientTypes.EventPayload?
        /// The IP address of the user whose actions are recorded in the event.
        public var sourceIpAddress: Swift.String?
        /// The user agent whose actions are recorded in the event.
        public var userAgent: Swift.String?
        /// The system-generated unique ID of the user whose actions are recorded in the event.
        /// This member is required.
        public var userIdentity: CodeCatalystClientTypes.UserIdentity?

        public init(
            errorCode: Swift.String? = nil,
            eventCategory: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            eventType: Swift.String? = nil,
            id: Swift.String? = nil,
            operationType: CodeCatalystClientTypes.OperationType? = nil,
            projectInformation: CodeCatalystClientTypes.ProjectInformation? = nil,
            requestId: Swift.String? = nil,
            requestPayload: CodeCatalystClientTypes.EventPayload? = nil,
            responsePayload: CodeCatalystClientTypes.EventPayload? = nil,
            sourceIpAddress: Swift.String? = nil,
            userAgent: Swift.String? = nil,
            userIdentity: CodeCatalystClientTypes.UserIdentity? = nil
        )
        {
            self.errorCode = errorCode
            self.eventCategory = eventCategory
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.eventType = eventType
            self.id = id
            self.operationType = operationType
            self.projectInformation = projectInformation
            self.requestId = requestId
            self.requestPayload = requestPayload
            self.responsePayload = responsePayload
            self.sourceIpAddress = sourceIpAddress
            self.userAgent = userAgent
            self.userIdentity = userIdentity
        }
    }

}

extension CodeCatalystClientTypes.EventPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the payload of an event recording Amazon CodeCatalyst activity.
    public struct EventPayload: Swift.Equatable {
        /// The type of content in the event payload.
        public var contentType: Swift.String?
        /// The data included in the event payload.
        public var data: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            data: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.data = data
        }
    }

}

extension CodeCatalystClientTypes.ExecuteCommandSessionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments
        case command
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arguments)
            for string0 in arguments {
                try argumentsContainer.encode(string0)
            }
        }
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0:[Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String]()
            for string0 in argumentsContainer {
                if let string0 = string0 {
                    argumentsDecoded0?.append(string0)
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension CodeCatalystClientTypes {
    /// Information about the commands that will be run on a Dev Environment when an SSH session begins.
    public struct ExecuteCommandSessionConfiguration: Swift.Equatable {
        /// An array of arguments containing arguments and members.
        public var arguments: [Swift.String]?
        /// The command used at the beginning of the SSH session to a Dev Environment.
        /// This member is required.
        public var command: Swift.String?

        public init(
            arguments: [Swift.String]? = nil,
            command: Swift.String? = nil
        )
        {
            self.arguments = arguments
            self.command = command
        }
    }

}

extension CodeCatalystClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case key
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator, forKey: .comparisonOperator)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a filter used to limit results of a query.
    public struct Filter: Swift.Equatable {
        /// The operator used to compare the fields.
        public var comparisonOperator: Swift.String?
        /// A key that can be used to sort results.
        /// This member is required.
        public var key: Swift.String?
        /// The values of the key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            comparisonOperator: Swift.String? = nil,
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.key = key
            self.values = values
        }
    }

}

extension CodeCatalystClientTypes {
    public enum FilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hasAccessTo
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterKey] {
            return [
                .hasAccessTo,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hasAccessTo: return "hasAccessTo"
            case .name: return "name"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterKey(rawValue: rawValue) ?? FilterKey.sdkUnknown(rawValue)
        }
    }
}

extension GetDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct GetDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment for which you want to view information. To retrieve a list of Dev Environment IDs, use [ListDevEnvironments].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetDevEnvironmentInputBody: Swift.Equatable {
}

extension GetDevEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.creatorId = output.creatorId
            self.id = output.id
            self.ides = output.ides
            self.inactivityTimeoutMinutes = output.inactivityTimeoutMinutes
            self.instanceType = output.instanceType
            self.lastUpdatedTime = output.lastUpdatedTime
            self.persistentStorage = output.persistentStorage
            self.projectName = output.projectName
            self.repositories = output.repositories
            self.spaceName = output.spaceName
            self.status = output.status
            self.statusReason = output.statusReason
            self.vpcConnectionName = output.vpcConnectionName
        } else {
            self.alias = nil
            self.creatorId = nil
            self.id = nil
            self.ides = nil
            self.inactivityTimeoutMinutes = 0
            self.instanceType = nil
            self.lastUpdatedTime = nil
            self.persistentStorage = nil
            self.projectName = nil
            self.repositories = nil
            self.spaceName = nil
            self.status = nil
            self.statusReason = nil
            self.vpcConnectionName = nil
        }
    }
}

public struct GetDevEnvironmentOutput: Swift.Equatable {
    /// The user-specified alias for the Dev Environment.
    public var alias: Swift.String?
    /// The system-generated unique ID of the user who created the Dev Environment.
    /// This member is required.
    public var creatorId: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for the Dev Environment.
    public var ides: [CodeCatalystClientTypes.Ide]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes.
    /// This member is required.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    /// This member is required.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The time when the Dev Environment was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// Information about the amount of storage allocated to the Dev Environment. By default, a Dev Environment is configured to have 16GB of persistent storage.
    /// This member is required.
    public var persistentStorage: CodeCatalystClientTypes.PersistentStorage?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The source repository that contains the branch cloned into the Dev Environment.
    /// This member is required.
    public var repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The current status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?
    /// The reason for the status.
    public var statusReason: Swift.String?
    /// The name of the connection used to connect to Amazon VPC used when the Dev Environment was created, if any.
    public var vpcConnectionName: Swift.String?

    public init(
        alias: Swift.String? = nil,
        creatorId: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.Ide]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        persistentStorage: CodeCatalystClientTypes.PersistentStorage? = nil,
        projectName: Swift.String? = nil,
        repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil,
        statusReason: Swift.String? = nil,
        vpcConnectionName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.creatorId = creatorId
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.lastUpdatedTime = lastUpdatedTime
        self.persistentStorage = persistentStorage
        self.projectName = projectName
        self.repositories = repositories
        self.spaceName = spaceName
        self.status = status
        self.statusReason = statusReason
        self.vpcConnectionName = vpcConnectionName
    }
}

struct GetDevEnvironmentOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let lastUpdatedTime: ClientRuntime.Date?
    let creatorId: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
    let statusReason: Swift.String?
    let repositories: [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.Ide]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let persistentStorage: CodeCatalystClientTypes.PersistentStorage?
    let vpcConnectionName: Swift.String?
}

extension GetDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case creatorId
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case lastUpdatedTime
        case persistentStorage
        case projectName
        case repositories
        case spaceName
        case status
        case statusReason
        case vpcConnectionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentRepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeCatalystClientTypes.DevEnvironmentRepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeCatalystClientTypes.DevEnvironmentRepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Ide?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.Ide]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.Ide]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let persistentStorageDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.PersistentStorage.self, forKey: .persistentStorage)
        persistentStorage = persistentStorageDecoded
        let vpcConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectionName)
        vpcConnectionName = vpcConnectionNameDecoded
    }
}

enum GetDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(name.urlPercentEncoding())"
    }
}

public struct GetProjectInput: Swift.Equatable {
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.spaceName = spaceName
    }
}

struct GetProjectInputBody: Swift.Equatable {
}

extension GetProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct GetProjectOutput: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The friendly name of the project displayed to users in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct GetProjectOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension GetProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSourceRepositoryCloneUrlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/cloneUrls"
    }
}

public struct GetSourceRepositoryCloneUrlsInput: Swift.Equatable {
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the source repository.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct GetSourceRepositoryCloneUrlsInputBody: Swift.Equatable {
}

extension GetSourceRepositoryCloneUrlsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSourceRepositoryCloneUrlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSourceRepositoryCloneUrlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.https = output.https
        } else {
            self.https = nil
        }
    }
}

public struct GetSourceRepositoryCloneUrlsOutput: Swift.Equatable {
    /// The HTTPS URL to use when cloning the source repository.
    /// This member is required.
    public var https: Swift.String?

    public init(
        https: Swift.String? = nil
    )
    {
        self.https = https
    }
}

struct GetSourceRepositoryCloneUrlsOutputBody: Swift.Equatable {
    let https: Swift.String?
}

extension GetSourceRepositoryCloneUrlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case https
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .https)
        https = httpsDecoded
    }
}

enum GetSourceRepositoryCloneUrlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSourceRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(name.urlPercentEncoding())"
    }
}

public struct GetSourceRepositoryInput: Swift.Equatable {
    /// The name of the source repository.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetSourceRepositoryInputBody: Swift.Equatable {
}

extension GetSourceRepositoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSourceRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSourceRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.description = output.description
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.createdTime = nil
            self.description = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct GetSourceRepositoryOutput: Swift.Equatable {
    /// The time the source repository was created, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The description of the source repository.
    public var description: Swift.String?
    /// The time the source repository was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the source repository.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetSourceRepositoryOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let lastUpdatedTime: ClientRuntime.Date?
    let createdTime: ClientRuntime.Date?
}

extension GetSourceRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case description
        case lastUpdatedTime
        case name
        case projectName
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

enum GetSourceRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(name.urlPercentEncoding())"
    }
}

public struct GetSpaceInput: Swift.Equatable {
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetSpaceInputBody: Swift.Equatable {
}

extension GetSpaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.regionName = output.regionName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.regionName = nil
        }
    }
}

public struct GetSpaceOutput: Swift.Equatable {
    /// The description of the space.
    public var description: Swift.String?
    /// The friendly name of the space displayed to users.
    public var displayName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Web Services Region where the space exists.
    /// This member is required.
    public var regionName: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.regionName = regionName
    }
}

struct GetSpaceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let regionName: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension GetSpaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case regionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum GetSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/subscription"
    }
}

public struct GetSubscriptionInput: Swift.Equatable {
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        spaceName: Swift.String? = nil
    )
    {
        self.spaceName = spaceName
    }
}

struct GetSubscriptionInputBody: Swift.Equatable {
}

extension GetSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.awsAccountName = output.awsAccountName
            self.subscriptionType = output.subscriptionType
        } else {
            self.awsAccountName = nil
            self.subscriptionType = nil
        }
    }
}

public struct GetSubscriptionOutput: Swift.Equatable {
    /// The display name of the Amazon Web Services account used for billing for the space.
    public var awsAccountName: Swift.String?
    /// The type of the billing plan for the space.
    public var subscriptionType: Swift.String?

    public init(
        awsAccountName: Swift.String? = nil,
        subscriptionType: Swift.String? = nil
    )
    {
        self.awsAccountName = awsAccountName
        self.subscriptionType = subscriptionType
    }
}

struct GetSubscriptionOutputBody: Swift.Equatable {
    let subscriptionType: Swift.String?
    let awsAccountName: Swift.String?
}

extension GetSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountName
        case subscriptionType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let awsAccountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountName)
        awsAccountName = awsAccountNameDecoded
    }
}

enum GetSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserDetailsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let id = id {
                let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
                items.append(idQueryItem)
            }
            if let userName = userName {
                let userNameQueryItem = ClientRuntime.URLQueryItem(name: "userName".urlPercentEncoding(), value: Swift.String(userName).urlPercentEncoding())
                items.append(userNameQueryItem)
            }
            return items
        }
    }
}

extension GetUserDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/userDetails"
    }
}

public struct GetUserDetailsInput: Swift.Equatable {
    /// The system-generated unique ID of the user.
    public var id: Swift.String?
    /// The name of the user as displayed in Amazon CodeCatalyst.
    public var userName: Swift.String?

    public init(
        id: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.id = id
        self.userName = userName
    }
}

struct GetUserDetailsInputBody: Swift.Equatable {
}

extension GetUserDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.displayName = output.displayName
            self.primaryEmail = output.primaryEmail
            self.userId = output.userId
            self.userName = output.userName
            self.version = output.version
        } else {
            self.displayName = nil
            self.primaryEmail = nil
            self.userId = nil
            self.userName = nil
            self.version = nil
        }
    }
}

public struct GetUserDetailsOutput: Swift.Equatable {
    /// The friendly name displayed for the user in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The email address provided by the user when they signed up.
    public var primaryEmail: CodeCatalystClientTypes.EmailAddress?
    /// The system-generated unique ID of the user.
    public var userId: Swift.String?
    /// The name of the user as displayed in Amazon CodeCatalyst.
    public var userName: Swift.String?
    ///
    public var version: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        primaryEmail: CodeCatalystClientTypes.EmailAddress? = nil,
        userId: Swift.String? = nil,
        userName: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.primaryEmail = primaryEmail
        self.userId = userId
        self.userName = userName
        self.version = version
    }
}

struct GetUserDetailsOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let userName: Swift.String?
    let displayName: Swift.String?
    let primaryEmail: CodeCatalystClientTypes.EmailAddress?
    let version: Swift.String?
}

extension GetUserDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case primaryEmail
        case userId
        case userName
        case version
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let primaryEmailDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.EmailAddress.self, forKey: .primaryEmail)
        primaryEmail = primaryEmailDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetUserDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/workflows/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The ID of the workflow. To rerieve a list of workflow IDs, use [ListWorkflows].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.definition = output.definition
            self.id = output.id
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.projectName = output.projectName
            self.runMode = output.runMode
            self.sourceBranchName = output.sourceBranchName
            self.sourceRepositoryName = output.sourceRepositoryName
            self.spaceName = output.spaceName
            self.status = output.status
        } else {
            self.createdTime = nil
            self.definition = nil
            self.id = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.projectName = nil
            self.runMode = nil
            self.sourceBranchName = nil
            self.sourceRepositoryName = nil
            self.spaceName = nil
            self.status = nil
        }
    }
}

public struct GetWorkflowOutput: Swift.Equatable {
    /// The date and time the workflow was created, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// Information about the workflow definition file for the workflow.
    /// This member is required.
    public var definition: CodeCatalystClientTypes.WorkflowDefinition?
    /// The ID of the workflow.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time the workflow was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the workflow.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The behavior to use when multiple workflows occur at the same time. For more information, see [https://docs.aws.amazon.com/codecatalyst/latest/userguide/workflows-configure-runs.html](https://docs.aws.amazon.com/codecatalyst/latest/userguide/workflows-configure-runs.html) in the Amazon CodeCatalyst User Guide.
    /// This member is required.
    public var runMode: CodeCatalystClientTypes.WorkflowRunMode?
    /// The name of the branch that contains the workflow YAML.
    public var sourceBranchName: Swift.String?
    /// The name of the source repository where the workflow YAML is stored.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The status of the workflow.
    /// This member is required.
    public var status: CodeCatalystClientTypes.WorkflowStatus?

    public init(
        createdTime: ClientRuntime.Date? = nil,
        definition: CodeCatalystClientTypes.WorkflowDefinition? = nil,
        id: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        projectName: Swift.String? = nil,
        runMode: CodeCatalystClientTypes.WorkflowRunMode? = nil,
        sourceBranchName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.WorkflowStatus? = nil
    )
    {
        self.createdTime = createdTime
        self.definition = definition
        self.id = id
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.projectName = projectName
        self.runMode = runMode
        self.sourceBranchName = sourceBranchName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
        self.status = status
    }
}

struct GetWorkflowOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let sourceRepositoryName: Swift.String?
    let sourceBranchName: Swift.String?
    let definition: CodeCatalystClientTypes.WorkflowDefinition?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let runMode: CodeCatalystClientTypes.WorkflowRunMode?
    let status: CodeCatalystClientTypes.WorkflowStatus?
}

extension GetWorkflowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case definition
        case id
        case lastUpdatedTime
        case name
        case projectName
        case runMode
        case sourceBranchName
        case sourceRepositoryName
        case spaceName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceRepositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRepositoryName)
        sourceRepositoryName = sourceRepositoryNameDecoded
        let sourceBranchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBranchName)
        sourceBranchName = sourceBranchNameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let runModeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowRunMode.self, forKey: .runMode)
        runMode = runModeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetWorkflowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkflowRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/workflowRuns/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowRunInput: Swift.Equatable {
    /// The ID of the workflow run. To retrieve a list of workflow run IDs, use [ListWorkflowRuns].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct GetWorkflowRunInputBody: Swift.Equatable {
}

extension GetWorkflowRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkflowRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.id = output.id
            self.lastUpdatedTime = output.lastUpdatedTime
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.startTime = output.startTime
            self.status = output.status
            self.statusReasons = output.statusReasons
            self.workflowId = output.workflowId
        } else {
            self.endTime = nil
            self.id = nil
            self.lastUpdatedTime = nil
            self.projectName = nil
            self.spaceName = nil
            self.startTime = nil
            self.status = nil
            self.statusReasons = nil
            self.workflowId = nil
        }
    }
}

public struct GetWorkflowRunOutput: Swift.Equatable {
    /// The date and time the workflow run ended, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    public var endTime: ClientRuntime.Date?
    /// The ID of the workflow run.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time the workflow run status was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The date and time the workflow run began, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The status of the workflow run.
    /// This member is required.
    public var status: CodeCatalystClientTypes.WorkflowRunStatus?
    /// Information about the reasons for the status of the workflow run.
    public var statusReasons: [CodeCatalystClientTypes.WorkflowRunStatusReason]?
    /// The ID of the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        endTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: CodeCatalystClientTypes.WorkflowRunStatus? = nil,
        statusReasons: [CodeCatalystClientTypes.WorkflowRunStatusReason]? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.lastUpdatedTime = lastUpdatedTime
        self.projectName = projectName
        self.spaceName = spaceName
        self.startTime = startTime
        self.status = status
        self.statusReasons = statusReasons
        self.workflowId = workflowId
    }
}

struct GetWorkflowRunOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let workflowId: Swift.String?
    let status: CodeCatalystClientTypes.WorkflowRunStatus?
    let statusReasons: [CodeCatalystClientTypes.WorkflowRunStatusReason]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension GetWorkflowRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case id
        case lastUpdatedTime
        case projectName
        case spaceName
        case startTime
        case status
        case statusReasons
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowRunStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowRunStatusReason?].self, forKey: .statusReasons)
        var statusReasonsDecoded0:[CodeCatalystClientTypes.WorkflowRunStatusReason]? = nil
        if let statusReasonsContainer = statusReasonsContainer {
            statusReasonsDecoded0 = [CodeCatalystClientTypes.WorkflowRunStatusReason]()
            for structure0 in statusReasonsContainer {
                if let structure0 = structure0 {
                    statusReasonsDecoded0?.append(structure0)
                }
            }
        }
        statusReasons = statusReasonsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum GetWorkflowRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCatalystClientTypes.Ide: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an integrated development environment (IDE) used in a Dev Environment.
    public struct Ide: Swift.Equatable {
        /// The name of the IDE.
        public var name: Swift.String?
        /// A link to the IDE runtime image.
        public var runtime: Swift.String?

        public init(
            name: Swift.String? = nil,
            runtime: Swift.String? = nil
        )
        {
            self.name = name
            self.runtime = runtime
        }
    }

}

extension CodeCatalystClientTypes.IdeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case runtime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of an integrated development environment (IDE) for a Dev Environment.
    public struct IdeConfiguration: Swift.Equatable {
        /// The name of the IDE. Valid values include Cloud9, IntelliJ, PyCharm, GoLand, and VSCode.
        public var name: Swift.String?
        /// A link to the IDE runtime image. This parameter is not required for VSCode.
        public var runtime: Swift.String?

        public init(
            name: Swift.String? = nil,
            runtime: Swift.String? = nil
        )
        {
            self.name = name
            self.runtime = runtime
        }
    }

}

extension CodeCatalystClientTypes {
    public enum InstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case devStandard1Large
        case devStandard1Medium
        case devStandard1Small
        case devStandard1Xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .devStandard1Large,
                .devStandard1Medium,
                .devStandard1Small,
                .devStandard1Xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .devStandard1Large: return "dev.standard1.large"
            case .devStandard1Medium: return "dev.standard1.medium"
            case .devStandard1Small: return "dev.standard1.small"
            case .devStandard1Xlarge: return "dev.standard1.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceType(rawValue: rawValue) ?? InstanceType.sdkUnknown(rawValue)
        }
    }
}

extension ListAccessTokensInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccessTokensInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/accessTokens"
    }
}

public struct ListAccessTokensInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessTokensInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccessTokensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessTokensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessTokensOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessTokensOutput: Swift.Equatable {
    /// A list of personal access tokens (PATs) associated with the calling user identity.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.AccessTokenSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.AccessTokenSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccessTokensOutputBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.AccessTokenSummary]?
    let nextToken: Swift.String?
}

extension ListAccessTokensOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.AccessTokenSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.AccessTokenSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.AccessTokenSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessTokensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevEnvironmentSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevEnvironmentSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let devEnvironmentId = devEnvironmentId else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(devEnvironmentId.urlPercentEncoding())/sessions"
    }
}

public struct ListDevEnvironmentSessionsInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var devEnvironmentId: Swift.String?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        devEnvironmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.devEnvironmentId = devEnvironmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct ListDevEnvironmentSessionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevEnvironmentSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevEnvironmentSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevEnvironmentSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevEnvironmentSessionsOutput: Swift.Equatable {
    /// Information about each session retrieved in the list.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.DevEnvironmentSessionSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.DevEnvironmentSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDevEnvironmentSessionsOutputBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.DevEnvironmentSessionSummary]?
    let nextToken: Swift.String?
}

extension ListDevEnvironmentSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentSessionSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.DevEnvironmentSessionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.DevEnvironmentSessionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevEnvironmentSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevEnvironmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension ListDevEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/devEnvironments"
    }
}

public struct ListDevEnvironmentsInput: Swift.Equatable {
    /// Information about filters to apply to narrow the results returned in the list.
    public var filters: [CodeCatalystClientTypes.Filter]?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        filters: [CodeCatalystClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct ListDevEnvironmentsInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let filters: [CodeCatalystClientTypes.Filter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case projectName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[CodeCatalystClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodeCatalystClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevEnvironmentsOutput: Swift.Equatable {
    /// Information about the Dev Environments in a project.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.DevEnvironmentSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.DevEnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDevEnvironmentsOutputBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.DevEnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListDevEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.DevEnvironmentSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.DevEnvironmentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.DevEnvironmentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventLogsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case eventName
        case maxResults
        case nextToken
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
    }
}

extension ListEventLogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/eventLogs"
    }
}

public struct ListEventLogsInput: Swift.Equatable {
    /// The time after which you do not want any events retrieved, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The name of the event.
    public var eventName: Swift.String?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The date and time when you want to start retrieving events, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        eventName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventName = eventName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spaceName = spaceName
        self.startTime = startTime
    }
}

struct ListEventLogsInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventLogsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case eventName
        case maxResults
        case nextToken
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventLogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventLogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventLogsOutput: Swift.Equatable {
    /// Information about each event retrieved in the list.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.EventLogEntry]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.EventLogEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEventLogsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.EventLogEntry]?
}

extension ListEventLogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.EventLogEntry?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.EventLogEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.EventLogEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListEventLogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for projectlistfilter0 in filters {
                try filtersContainer.encode(projectlistfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// Information about filters to apply to narrow the results returned in the list.
    public var filters: [CodeCatalystClientTypes.ProjectListFilter]?
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        filters: [CodeCatalystClientTypes.ProjectListFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.spaceName = spaceName
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [CodeCatalystClientTypes.ProjectListFilter]?
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ProjectListFilter?].self, forKey: .filters)
        var filtersDecoded0:[CodeCatalystClientTypes.ProjectListFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodeCatalystClientTypes.ProjectListFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// Information about the projects.
    public var items: [CodeCatalystClientTypes.ProjectSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.ProjectSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.ProjectSummary]?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ProjectSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ProjectSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ProjectSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSourceRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSourceRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories"
    }
}

public struct ListSourceRepositoriesInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct ListSourceRepositoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSourceRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CodeCatalystClientTypes.ListSourceRepositoriesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case description
        case id
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .dateTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a source repository returned in a list of source repositories.
    public struct ListSourceRepositoriesItem: Swift.Equatable {
        /// The time the source repository was created, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The description of the repository, if any.
        public var description: Swift.String?
        /// The system-generated unique ID of the source repository.
        /// This member is required.
        public var id: Swift.String?
        /// The time the source repository was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the source repository.
        /// This member is required.
        public var name: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension ListSourceRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSourceRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceRepositoriesOutput: Swift.Equatable {
    /// Information about the source repositories.
    public var items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceRepositoriesOutputBody: Swift.Equatable {
    let items: [CodeCatalystClientTypes.ListSourceRepositoriesItem]?
    let nextToken: Swift.String?
}

extension ListSourceRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ListSourceRepositoriesItem?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ListSourceRepositoriesItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ListSourceRepositoriesItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSourceRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSourceRepositoryBranchesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSourceRepositoryBranchesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let sourceRepositoryName = sourceRepositoryName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/sourceRepositories/\(sourceRepositoryName.urlPercentEncoding())/branches"
    }
}

public struct ListSourceRepositoryBranchesInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the source repository.
    /// This member is required.
    public var sourceRepositoryName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sourceRepositoryName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRepositoryName = sourceRepositoryName
        self.spaceName = spaceName
    }
}

struct ListSourceRepositoryBranchesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSourceRepositoryBranchesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CodeCatalystClientTypes.ListSourceRepositoryBranchesItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headCommitId
        case lastUpdatedTime
        case name
        case ref
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headCommitId = self.headCommitId {
            try encodeContainer.encode(headCommitId, forKey: .headCommitId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ref = self.ref {
            try encodeContainer.encode(ref, forKey: .ref)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ref)
        ref = refDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let headCommitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headCommitId)
        headCommitId = headCommitIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a branch of a source repository returned in a list of branches.
    public struct ListSourceRepositoryBranchesItem: Swift.Equatable {
        /// The commit ID of the tip of the branch at the time of the request, also known as the head commit.
        public var headCommitId: Swift.String?
        /// The time the branch was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the branch.
        public var name: Swift.String?
        /// The Git reference name of the branch.
        public var ref: Swift.String?

        public init(
            headCommitId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            ref: Swift.String? = nil
        )
        {
            self.headCommitId = headCommitId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.ref = ref
        }
    }

}

extension ListSourceRepositoryBranchesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSourceRepositoryBranchesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceRepositoryBranchesOutput: Swift.Equatable {
    /// Information about the source branches.
    /// This member is required.
    public var items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceRepositoryBranchesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]?
}

extension ListSourceRepositoryBranchesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.ListSourceRepositoryBranchesItem?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.ListSourceRepositoryBranchesItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListSourceRepositoryBranchesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSpacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/spaces"
    }
}

public struct ListSpacesInput: Swift.Equatable {
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSpacesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSpacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSpacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpacesOutput: Swift.Equatable {
    /// Information about the spaces.
    public var items: [CodeCatalystClientTypes.SpaceSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.SpaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSpacesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.SpaceSummary]?
}

extension ListSpacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.SpaceSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.SpaceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.SpaceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListSpacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for workflowrunsortcriteria0 in sortBy {
                try sortByContainer.encode(workflowrunsortcriteria0)
            }
        }
    }
}

extension ListWorkflowRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let workflowId = workflowId {
                let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
                items.append(workflowIdQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/workflowRuns"
    }
}

public struct ListWorkflowRunsInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// Information used to sort the items in the returned list.
    public var sortBy: [CodeCatalystClientTypes.WorkflowRunSortCriteria]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The ID of the workflow. To retrieve a list of workflow IDs, use [ListWorkflows].
    public var workflowId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sortBy: [CodeCatalystClientTypes.WorkflowRunSortCriteria]? = nil,
        spaceName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortBy = sortBy
        self.spaceName = spaceName
        self.workflowId = workflowId
    }
}

struct ListWorkflowRunsInputBody: Swift.Equatable {
    let sortBy: [CodeCatalystClientTypes.WorkflowRunSortCriteria]?
}

extension ListWorkflowRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowRunSortCriteria?].self, forKey: .sortBy)
        var sortByDecoded0:[CodeCatalystClientTypes.WorkflowRunSortCriteria]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CodeCatalystClientTypes.WorkflowRunSortCriteria]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
    }
}

extension ListWorkflowRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowRunsOutput: Swift.Equatable {
    /// Information about the runs of a workflow.
    public var items: [CodeCatalystClientTypes.WorkflowRunSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.WorkflowRunSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWorkflowRunsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.WorkflowRunSummary]?
}

extension ListWorkflowRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowRunSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.WorkflowRunSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.WorkflowRunSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListWorkflowRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkflowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for workflowsortcriteria0 in sortBy {
                try sortByContainer.encode(workflowsortcriteria0)
            }
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/workflows"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The maximum number of results to show in a single call to this API. If the number of results is larger than the number you specified, the response will include a NextToken element, which you can use to obtain additional results.
    public var maxResults: Swift.Int?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// Information used to sort the items in the returned list.
    public var sortBy: [CodeCatalystClientTypes.WorkflowSortCriteria]?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sortBy: [CodeCatalystClientTypes.WorkflowSortCriteria]? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sortBy = sortBy
        self.spaceName = spaceName
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
    let sortBy: [CodeCatalystClientTypes.WorkflowSortCriteria]?
}

extension ListWorkflowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowSortCriteria?].self, forKey: .sortBy)
        var sortByDecoded0:[CodeCatalystClientTypes.WorkflowSortCriteria]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CodeCatalystClientTypes.WorkflowSortCriteria]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
    }
}

extension ListWorkflowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkflowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutput: Swift.Equatable {
    /// Information about the workflows in a project.
    public var items: [CodeCatalystClientTypes.WorkflowSummary]?
    /// A token returned from a call to this API to indicate the next batch of results to return, if any.
    public var nextToken: Swift.String?

    public init(
        items: [CodeCatalystClientTypes.WorkflowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CodeCatalystClientTypes.WorkflowSummary]?
}

extension ListWorkflowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowSummary?].self, forKey: .items)
        var itemsDecoded0:[CodeCatalystClientTypes.WorkflowSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CodeCatalystClientTypes.WorkflowSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListWorkflowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCatalystClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mutation
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .mutation,
                .readonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mutation: return "MUTATION"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.PersistentStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInGiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeInGiB = self.sizeInGiB {
            try encodeContainer.encode(sizeInGiB, forKey: .sizeInGiB)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInGiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInGiB)
        sizeInGiB = sizeInGiBDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the persistent storage for a Dev Environment.
    public struct PersistentStorage: Swift.Equatable {
        /// The size of the persistent storage in gigabytes (specifically GiB). Valid values for storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
        /// This member is required.
        public var sizeInGiB: Swift.Int?

        public init(
            sizeInGiB: Swift.Int? = nil
        )
        {
            self.sizeInGiB = sizeInGiB
        }
    }

}

extension CodeCatalystClientTypes.PersistentStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInGiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeInGiB = self.sizeInGiB {
            try encodeContainer.encode(sizeInGiB, forKey: .sizeInGiB)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInGiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInGiB)
        sizeInGiB = sizeInGiBDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about the configuration of persistent storage for a Dev Environment.
    public struct PersistentStorageConfiguration: Swift.Equatable {
        /// The size of the persistent storage in gigabytes (specifically GiB). Valid values for storage are based on memory sizes in 16GB increments. Valid values are 16, 32, and 64.
        /// This member is required.
        public var sizeInGiB: Swift.Int?

        public init(
            sizeInGiB: Swift.Int? = nil
        )
        {
            self.sizeInGiB = sizeInGiB
        }
    }

}

extension CodeCatalystClientTypes.ProjectInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a project in a space.
    public struct ProjectInformation: Swift.Equatable {
        /// The name of the project in the space.
        public var name: Swift.String?
        /// The system-generated unique ID of the project.
        public var projectId: Swift.String?

        public init(
            name: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.name = name
            self.projectId = projectId
        }
    }

}

extension CodeCatalystClientTypes.ProjectListFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator
        case key
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.FilterKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
    }
}

extension CodeCatalystClientTypes {
    /// nformation about the filter used to narrow the results returned in a list of projects.
    public struct ProjectListFilter: Swift.Equatable {
        /// The operator used to compare the fields.
        public var comparisonOperator: CodeCatalystClientTypes.ComparisonOperator?
        /// A key that can be used to sort results.
        /// This member is required.
        public var key: CodeCatalystClientTypes.FilterKey?
        /// The values of the key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            comparisonOperator: CodeCatalystClientTypes.ComparisonOperator? = nil,
            key: CodeCatalystClientTypes.FilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.key = key
            self.values = values
        }
    }

}

extension CodeCatalystClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a project.
    public struct ProjectSummary: Swift.Equatable {
        /// The description of the project.
        public var description: Swift.String?
        /// The friendly name displayed to users of the project in Amazon CodeCatalyst.
        public var displayName: Swift.String?
        /// The name of the project in the space.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.name = name
        }
    }

}

extension CodeCatalystClientTypes.RepositoryInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = self.branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a repository that will be cloned to a Dev Environment.
    public struct RepositoryInput: Swift.Equatable {
        /// The name of the branch in a source repository.
        public var branchName: Swift.String?
        /// The name of the source repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init(
            branchName: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.branchName = branchName
            self.repositoryName = repositoryName
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because the specified resource was not found. Verify that the spelling is correct and that you have access to the resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because one or more resources has reached its limits for the tier the space belongs to. Either reduce the number of resources, or change the tier if applicable.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeCatalystClientTypes.SpaceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case regionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about an space.
    public struct SpaceSummary: Swift.Equatable {
        /// The description of the space.
        public var description: Swift.String?
        /// The friendly name of the space displayed to users.
        public var displayName: Swift.String?
        /// The name of the space.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services Region where the space exists.
        /// This member is required.
        public var regionName: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil,
            regionName: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.name = name
            self.regionName = regionName
        }
    }

}

extension StartDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
    }
}

extension StartDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/start"
    }
}

public struct StartDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentInputBody: Swift.Equatable {
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
}

extension StartDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
    }
}

extension StartDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.status = output.status
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.status = nil
        }
    }
}

public struct StartDevEnvironmentOutput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.status = status
    }
}

struct StartDevEnvironmentOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
}

extension StartDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum StartDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartDevEnvironmentSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionConfiguration = self.sessionConfiguration {
            try encodeContainer.encode(sessionConfiguration, forKey: .sessionConfiguration)
        }
    }
}

extension StartDevEnvironmentSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/session"
    }
}

public struct StartDevEnvironmentSessionInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// Information about the configuration of a Dev Environment session.
    /// This member is required.
    public var sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.sessionConfiguration = sessionConfiguration
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentSessionInputBody: Swift.Equatable {
    let sessionConfiguration: CodeCatalystClientTypes.DevEnvironmentSessionConfiguration?
}

extension StartDevEnvironmentSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionConfigurationDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentSessionConfiguration.self, forKey: .sessionConfiguration)
        sessionConfiguration = sessionConfigurationDecoded
    }
}

extension StartDevEnvironmentSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDevEnvironmentSessionOutput(id: \(Swift.String(describing: id)), projectName: \(Swift.String(describing: projectName)), sessionId: \(Swift.String(describing: sessionId)), spaceName: \(Swift.String(describing: spaceName)), accessDetails: \"CONTENT_REDACTED\")"}
}

extension StartDevEnvironmentSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartDevEnvironmentSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessDetails = output.accessDetails
            self.id = output.id
            self.projectName = output.projectName
            self.sessionId = output.sessionId
            self.spaceName = output.spaceName
        } else {
            self.accessDetails = nil
            self.id = nil
            self.projectName = nil
            self.sessionId = nil
            self.spaceName = nil
        }
    }
}

public struct StartDevEnvironmentSessionOutput: Swift.Equatable {
    /// Information about connection details for a Dev Environment.
    /// This member is required.
    public var accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The system-generated unique ID of the Dev Environment session.
    public var sessionId: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails? = nil,
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.accessDetails = accessDetails
        self.id = id
        self.projectName = projectName
        self.sessionId = sessionId
        self.spaceName = spaceName
    }
}

struct StartDevEnvironmentSessionOutputBody: Swift.Equatable {
    let accessDetails: CodeCatalystClientTypes.DevEnvironmentAccessDetails?
    let sessionId: Swift.String?
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
}

extension StartDevEnvironmentSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessDetails
        case id
        case projectName
        case sessionId
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessDetailsDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentAccessDetails.self, forKey: .accessDetails)
        accessDetails = accessDetailsDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum StartDevEnvironmentSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartWorkflowRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension StartWorkflowRunInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let workflowId = workflowId else {
                let message = "Creating a URL Query Item failed. workflowId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let workflowIdQueryItem = ClientRuntime.URLQueryItem(name: "workflowId".urlPercentEncoding(), value: Swift.String(workflowId).urlPercentEncoding())
            items.append(workflowIdQueryItem)
            return items
        }
    }
}

extension StartWorkflowRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/workflowRuns"
    }
}

public struct StartWorkflowRunInput: Swift.Equatable {
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The system-generated unique ID of the workflow. To retrieve a list of workflow IDs, use [ListWorkflows].
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
        self.spaceName = spaceName
        self.workflowId = workflowId
    }
}

struct StartWorkflowRunInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension StartWorkflowRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartWorkflowRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartWorkflowRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.workflowId = output.workflowId
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.workflowId = nil
        }
    }
}

public struct StartWorkflowRunOutput: Swift.Equatable {
    /// The system-generated unique ID of the workflow run.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The system-generated unique ID of the workflow.
    /// This member is required.
    public var workflowId: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        workflowId: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.workflowId = workflowId
    }
}

struct StartWorkflowRunOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let workflowId: Swift.String?
}

extension StartWorkflowRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case workflowId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
    }
}

enum StartWorkflowRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/stop"
    }
}

public struct StopDevEnvironmentInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct StopDevEnvironmentInputBody: Swift.Equatable {
}

extension StopDevEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.spaceName = output.spaceName
            self.status = output.status
        } else {
            self.id = nil
            self.projectName = nil
            self.spaceName = nil
            self.status = nil
        }
    }
}

public struct StopDevEnvironmentOutput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?
    /// The status of the Dev Environment.
    /// This member is required.
    public var status: CodeCatalystClientTypes.DevEnvironmentStatus?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil,
        status: CodeCatalystClientTypes.DevEnvironmentStatus? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.spaceName = spaceName
        self.status = status
    }
}

struct StopDevEnvironmentOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let status: CodeCatalystClientTypes.DevEnvironmentStatus?
}

extension StopDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case spaceName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.DevEnvironmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum StopDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopDevEnvironmentSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())/session/\(sessionId.urlPercentEncoding())"
    }
}

public struct StopDevEnvironmentSessionInput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment. To obtain this ID, use [ListDevEnvironments].
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The system-generated unique ID of the Dev Environment session. This ID is returned by [StartDevEnvironmentSession].
    /// This member is required.
    public var sessionId: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.sessionId = sessionId
        self.spaceName = spaceName
    }
}

struct StopDevEnvironmentSessionInputBody: Swift.Equatable {
}

extension StopDevEnvironmentSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopDevEnvironmentSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopDevEnvironmentSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.projectName = output.projectName
            self.sessionId = output.sessionId
            self.spaceName = output.spaceName
        } else {
            self.id = nil
            self.projectName = nil
            self.sessionId = nil
            self.spaceName = nil
        }
    }
}

public struct StopDevEnvironmentSessionOutput: Swift.Equatable {
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The system-generated unique ID of the Dev Environment session.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        id: Swift.String? = nil,
        projectName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.id = id
        self.projectName = projectName
        self.sessionId = sessionId
        self.spaceName = spaceName
    }
}

struct StopDevEnvironmentSessionOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let id: Swift.String?
    let sessionId: Swift.String?
}

extension StopDevEnvironmentSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case projectName
        case sessionId
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

enum StopDevEnvironmentSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDevEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ides = ides {
            var idesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ides)
            for ideconfiguration0 in ides {
                try idesContainer.encode(ideconfiguration0)
            }
        }
        if inactivityTimeoutMinutes != 0 {
            try encodeContainer.encode(inactivityTimeoutMinutes, forKey: .inactivityTimeoutMinutes)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
    }
}

extension UpdateDevEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let projectName = projectName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(projectName.urlPercentEncoding())/devEnvironments/\(id.urlPercentEncoding())"
    }
}

public struct UpdateDevEnvironmentInput: Swift.Equatable {
    /// The user-specified alias for the Dev Environment. Changing this value will not cause a restart.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for a Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes. Only whole integers are allowed. Dev Environments consume compute minutes when running. Changing this value will cause a restart of the Dev Environment if it is running.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment. Changing this value will cause a restart of the Dev Environment if it is running.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct UpdateDevEnvironmentInputBody: Swift.Equatable {
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let clientToken: Swift.String?
}

extension UpdateDevEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case ides
        case inactivityTimeoutMinutes
        case instanceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDevEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDevEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.clientToken = output.clientToken
            self.id = output.id
            self.ides = output.ides
            self.inactivityTimeoutMinutes = output.inactivityTimeoutMinutes
            self.instanceType = output.instanceType
            self.projectName = output.projectName
            self.spaceName = output.spaceName
        } else {
            self.alias = nil
            self.clientToken = nil
            self.id = nil
            self.ides = nil
            self.inactivityTimeoutMinutes = 0
            self.instanceType = nil
            self.projectName = nil
            self.spaceName = nil
        }
    }
}

public struct UpdateDevEnvironmentOutput: Swift.Equatable {
    /// The user-specified alias for the Dev Environment.
    public var alias: Swift.String?
    /// A user-specified idempotency token. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries return the result from the original successful request and have no additional effect.
    public var clientToken: Swift.String?
    /// The system-generated unique ID of the Dev Environment.
    /// This member is required.
    public var id: Swift.String?
    /// Information about the integrated development environment (IDE) configured for the Dev Environment.
    public var ides: [CodeCatalystClientTypes.IdeConfiguration]?
    /// The amount of time the Dev Environment will run without any activity detected before stopping, in minutes.
    public var inactivityTimeoutMinutes: Swift.Int
    /// The Amazon EC2 instace type to use for the Dev Environment.
    public var instanceType: CodeCatalystClientTypes.InstanceType?
    /// The name of the project in the space.
    /// This member is required.
    public var projectName: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        ides: [CodeCatalystClientTypes.IdeConfiguration]? = nil,
        inactivityTimeoutMinutes: Swift.Int = 0,
        instanceType: CodeCatalystClientTypes.InstanceType? = nil,
        projectName: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.id = id
        self.ides = ides
        self.inactivityTimeoutMinutes = inactivityTimeoutMinutes
        self.instanceType = instanceType
        self.projectName = projectName
        self.spaceName = spaceName
    }
}

struct UpdateDevEnvironmentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let spaceName: Swift.String?
    let projectName: Swift.String?
    let alias: Swift.String?
    let ides: [CodeCatalystClientTypes.IdeConfiguration]?
    let instanceType: CodeCatalystClientTypes.InstanceType?
    let inactivityTimeoutMinutes: Swift.Int
    let clientToken: Swift.String?
}

extension UpdateDevEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case id
        case ides
        case inactivityTimeoutMinutes
        case instanceType
        case projectName
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let idesContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.IdeConfiguration?].self, forKey: .ides)
        var idesDecoded0:[CodeCatalystClientTypes.IdeConfiguration]? = nil
        if let idesContainer = idesContainer {
            idesDecoded0 = [CodeCatalystClientTypes.IdeConfiguration]()
            for structure0 in idesContainer {
                if let structure0 = structure0 {
                    idesDecoded0?.append(structure0)
                }
            }
        }
        ides = idesDecoded0
        let instanceTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let inactivityTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inactivityTimeoutMinutes) ?? 0
        inactivityTimeoutMinutes = inactivityTimeoutMinutesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

enum UpdateDevEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let spaceName = spaceName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(spaceName.urlPercentEncoding())/projects/\(name.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The name of the project.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.spaceName = spaceName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
            self.spaceName = output.spaceName
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
            self.spaceName = nil
        }
    }
}

public struct UpdateProjectOutput: Swift.Equatable {
    /// The description of the project.
    public var description: Swift.String?
    /// The friendly name of the project displayed to users in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the project.
    public var name: Swift.String?
    /// The name of the space.
    public var spaceName: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        spaceName: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.spaceName = spaceName
    }
}

struct UpdateProjectOutputBody: Swift.Equatable {
    let spaceName: Swift.String?
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension UpdateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
        case spaceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceName)
        spaceName = spaceNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSpaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateSpaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/v1/spaces/\(name.urlPercentEncoding())"
    }
}

public struct UpdateSpaceInput: Swift.Equatable {
    /// The description of the space.
    public var description: Swift.String?
    /// The name of the space.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateSpaceInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateSpaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSpaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.name = output.name
        } else {
            self.description = nil
            self.displayName = nil
            self.name = nil
        }
    }
}

public struct UpdateSpaceOutput: Swift.Equatable {
    /// The description of the space.
    public var description: Swift.String?
    /// The friendly name of the space displayed to users in Amazon CodeCatalyst.
    public var displayName: Swift.String?
    /// The name of the space.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

struct UpdateSpaceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension UpdateSpaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

enum UpdateSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCatalystClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case principalId
        case userName
        case userType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType.rawValue, forKey: .userType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userTypeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.UserType.self, forKey: .userType)
        userType = userTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a user whose activity is recorded in an event for a space.
    public struct UserIdentity: Swift.Equatable {
        /// The Amazon Web Services account number of the user in Amazon Web Services, if any.
        public var awsAccountId: Swift.String?
        /// The ID of the Amazon CodeCatalyst service principal.
        /// This member is required.
        public var principalId: Swift.String?
        /// The display name of the user in Amazon CodeCatalyst.
        public var userName: Swift.String?
        /// The role assigned to the user in a Amazon CodeCatalyst space or project when the event occurred.
        /// This member is required.
        public var userType: CodeCatalystClientTypes.UserType?

        public init(
            awsAccountId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: CodeCatalystClientTypes.UserType? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension CodeCatalystClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case unknown
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .awsAccount,
                .unknown,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .unknown: return "UNKNOWN"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied because an input failed to satisfy the constraints specified by the service. Check the spelling and input requirements, and then try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VerifySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/session"
    }
}

public struct VerifySessionInput: Swift.Equatable {

    public init() { }
}

struct VerifySessionInputBody: Swift.Equatable {
}

extension VerifySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension VerifySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VerifySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.identity = output.identity
        } else {
            self.identity = nil
        }
    }
}

public struct VerifySessionOutput: Swift.Equatable {
    /// The system-generated unique ID of the user in Amazon CodeCatalyst.
    public var identity: Swift.String?

    public init(
        identity: Swift.String? = nil
    )
    {
        self.identity = identity
    }
}

struct VerifySessionOutputBody: Swift.Equatable {
    let identity: Swift.String?
}

extension VerifySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identity)
        identity = identityDecoded
    }
}

enum VerifySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await CodeCatalystClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeCatalystClientTypes.WorkflowDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a workflow definition file.
    public struct WorkflowDefinition: Swift.Equatable {
        /// The path to the workflow definition file stored in the source repository for the project, including the file name.
        /// This member is required.
        public var path: Swift.String?

        public init(
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension CodeCatalystClientTypes.WorkflowDefinitionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a workflow definition.
    public struct WorkflowDefinitionSummary: Swift.Equatable {
        /// The path to the workflow definition file stored in the source repository for the project, including the file name.
        /// This member is required.
        public var path: Swift.String?

        public init(
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension CodeCatalystClientTypes {
    public enum WorkflowRunMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case parallel
        case queued
        case superseded
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowRunMode] {
            return [
                .parallel,
                .queued,
                .superseded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .parallel: return "PARALLEL"
            case .queued: return "QUEUED"
            case .superseded: return "SUPERSEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowRunMode(rawValue: rawValue) ?? WorkflowRunMode.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.WorkflowRunSortCriteria: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CodeCatalystClientTypes {
    /// Information used to sort workflow runs in the returned list.
    public struct WorkflowRunSortCriteria: Swift.Equatable {

        public init() { }
    }

}

extension CodeCatalystClientTypes {
    public enum WorkflowRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abandoned
        case cancelled
        case failed
        case inProgress
        case notRun
        case provisioning
        case stopped
        case stopping
        case succeeded
        case superseded
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowRunStatus] {
            return [
                .abandoned,
                .cancelled,
                .failed,
                .inProgress,
                .notRun,
                .provisioning,
                .stopped,
                .stopping,
                .succeeded,
                .superseded,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abandoned: return "ABANDONED"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notRun: return "NOT_RUN"
            case .provisioning: return "PROVISIONING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .succeeded: return "SUCCEEDED"
            case .superseded: return "SUPERSEDED"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowRunStatus(rawValue: rawValue) ?? WorkflowRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.WorkflowRunStatusReason: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CodeCatalystClientTypes {
    /// Information about the status of a workflow run.
    public struct WorkflowRunStatusReason: Swift.Equatable {

        public init() { }
    }

}

extension CodeCatalystClientTypes.WorkflowRunSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case id
        case lastUpdatedTime
        case startTime
        case status
        case statusReasons
        case workflowId
        case workflowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReasons = statusReasons {
            var statusReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusReasons)
            for workflowrunstatusreason0 in statusReasons {
                try statusReasonsContainer.encode(workflowrunstatusreason0)
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowName = self.workflowName {
            try encodeContainer.encode(workflowName, forKey: .workflowName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowName)
        workflowName = workflowNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowRunStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonsContainer = try containerValues.decodeIfPresent([CodeCatalystClientTypes.WorkflowRunStatusReason?].self, forKey: .statusReasons)
        var statusReasonsDecoded0:[CodeCatalystClientTypes.WorkflowRunStatusReason]? = nil
        if let statusReasonsContainer = statusReasonsContainer {
            statusReasonsDecoded0 = [CodeCatalystClientTypes.WorkflowRunStatusReason]()
            for structure0 in statusReasonsContainer {
                if let structure0 = structure0 {
                    statusReasonsDecoded0?.append(structure0)
                }
            }
        }
        statusReasons = statusReasonsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a workflow run.
    public struct WorkflowRunSummary: Swift.Equatable {
        /// The date and time the workflow run ended, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
        public var endTime: ClientRuntime.Date?
        /// The system-generated unique ID of the workflow run.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the workflow was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The date and time the workflow run began, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6).
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The status of the workflow run.
        /// This member is required.
        public var status: CodeCatalystClientTypes.WorkflowRunStatus?
        /// The reasons for the workflow run status.
        public var statusReasons: [CodeCatalystClientTypes.WorkflowRunStatusReason]?
        /// The system-generated unique ID of the workflow.
        /// This member is required.
        public var workflowId: Swift.String?
        /// The name of the workflow.
        /// This member is required.
        public var workflowName: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: CodeCatalystClientTypes.WorkflowRunStatus? = nil,
            statusReasons: [CodeCatalystClientTypes.WorkflowRunStatusReason]? = nil,
            workflowId: Swift.String? = nil,
            workflowName: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.startTime = startTime
            self.status = status
            self.statusReasons = statusReasons
            self.workflowId = workflowId
            self.workflowName = workflowName
        }
    }

}

extension CodeCatalystClientTypes.WorkflowSortCriteria: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CodeCatalystClientTypes {
    /// Information used to sort workflows in the returned list.
    public struct WorkflowSortCriteria: Swift.Equatable {

        public init() { }
    }

}

extension CodeCatalystClientTypes {
    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case invalid
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .active,
                .invalid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invalid: return "INVALID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStatus(rawValue: rawValue) ?? WorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeCatalystClientTypes.WorkflowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case definition
        case id
        case lastUpdatedTime
        case name
        case runMode
        case sourceBranchName
        case sourceRepositoryName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .dateTime, forKey: .createdTime)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .dateTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runMode = self.runMode {
            try encodeContainer.encode(runMode.rawValue, forKey: .runMode)
        }
        if let sourceBranchName = self.sourceBranchName {
            try encodeContainer.encode(sourceBranchName, forKey: .sourceBranchName)
        }
        if let sourceRepositoryName = self.sourceRepositoryName {
            try encodeContainer.encode(sourceRepositoryName, forKey: .sourceRepositoryName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceRepositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRepositoryName)
        sourceRepositoryName = sourceRepositoryNameDecoded
        let sourceBranchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBranchName)
        sourceBranchName = sourceBranchNameDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowDefinitionSummary.self, forKey: .definition)
        definition = definitionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let runModeDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowRunMode.self, forKey: .runMode)
        runMode = runModeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeCatalystClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeCatalystClientTypes {
    /// Information about a workflow.
    public struct WorkflowSummary: Swift.Equatable {
        /// The date and time the workflow was created, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// Information about the workflow definition file.
        /// This member is required.
        public var definition: CodeCatalystClientTypes.WorkflowDefinitionSummary?
        /// The system-generated unique ID of a workflow.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time the workflow was last updated, in coordinated universal time (UTC) timestamp format as specified in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339#section-5.6)
        /// This member is required.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the workflow.
        /// This member is required.
        public var name: Swift.String?
        /// The run mode of the workflow.
        /// This member is required.
        public var runMode: CodeCatalystClientTypes.WorkflowRunMode?
        /// The name of the branch of the source repository where the workflow definition file is stored.
        /// This member is required.
        public var sourceBranchName: Swift.String?
        /// The name of the source repository where the workflow definition file is stored.
        /// This member is required.
        public var sourceRepositoryName: Swift.String?
        /// The status of the workflow.
        /// This member is required.
        public var status: CodeCatalystClientTypes.WorkflowStatus?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            definition: CodeCatalystClientTypes.WorkflowDefinitionSummary? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            runMode: CodeCatalystClientTypes.WorkflowRunMode? = nil,
            sourceBranchName: Swift.String? = nil,
            sourceRepositoryName: Swift.String? = nil,
            status: CodeCatalystClientTypes.WorkflowStatus? = nil
        )
        {
            self.createdTime = createdTime
            self.definition = definition
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.runMode = runMode
            self.sourceBranchName = sourceBranchName
            self.sourceRepositoryName = sourceRepositoryName
            self.status = status
        }
    }

}
