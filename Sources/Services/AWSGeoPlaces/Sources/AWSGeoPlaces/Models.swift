//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoPlacesClientTypes {

    /// Position of the access point represented by longitude and latitude for a vehicle.
    public struct AccessPoint: Swift.Sendable {
        /// The position, in longitude and latitude.
        public var position: [Swift.Double]?

        public init(
            position: [Swift.Double]? = nil
        )
        {
            self.position = position
        }
    }
}

extension GeoPlacesClientTypes.AccessPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPoint(position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// Category of the Place returned.
    public struct Category: Swift.Sendable {
        /// The category ID.
        /// This member is required.
        public var id: Swift.String?
        /// Localized name of the category type.
        public var localizedName: Swift.String?
        /// The category name.
        /// This member is required.
        public var name: Swift.String?
        /// Boolean which indicates if this category is the primary offered by the place.
        public var primary: Swift.Bool?

        public init(
            id: Swift.String? = nil,
            localizedName: Swift.String? = nil,
            name: Swift.String? = nil,
            primary: Swift.Bool? = nil
        )
        {
            self.id = id
            self.localizedName = localizedName
            self.name = name
            self.primary = primary
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates if the access location is restricted. Index correlates to that of an access point and indicates if access through this point has some form of restriction.
    public struct AccessRestriction: Swift.Sendable {
        /// Categories of results that results must belong too.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// The restriction.
        public var restricted: Swift.Bool?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            restricted: Swift.Bool? = nil
        )
        {
            self.categories = categories
            self.restricted = restricted
        }
    }
}

extension GeoPlacesClientTypes {

    /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
    public struct Country: Swift.Sendable {
        /// Country, represented by its alpha 2-character code.
        public var code2: Swift.String?
        /// Country, represented by its alpha t-character code.
        public var code3: Swift.String?
        /// Name of the country.
        public var name: Swift.String?

        public init(
            code2: Swift.String? = nil,
            code3: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code2 = code2
            self.code3 = code3
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// The region or state results should be to be present in. Example: North Rhine-Westphalia.
    public struct Region: Swift.Sendable {
        /// Abbreviated code for a the state, province or region of the country. Example: BC.
        public var code: Swift.String?
        /// Name for a the state, province, or region of the country. Example: British Columbia.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public enum TypePlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterBaseName
        case beforeBaseName
        case sdkUnknown(Swift.String)

        public static var allCases: [TypePlacement] {
            return [
                .afterBaseName,
                .beforeBaseName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterBaseName: return "AfterBaseName"
            case .beforeBaseName: return "BeforeBaseName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// Components of a street.
    public struct StreetComponents: Swift.Sendable {
        /// Base name part of the street name. Example: Younge from the “Younge street".
        public var baseName: Swift.String?
        /// Indicates the official directional identifiers assigned to highways.
        public var direction: Swift.String?
        /// A [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public var language: Swift.String?
        /// A prefix is a directional identifier that precedes, but is not included in, the base name of a road. Example: E for East.
        public var `prefix`: Swift.String?
        /// A suffix is a directional identifier that follows, but is not included in, the base name of a road. Example W for West.
        public var suffix: Swift.String?
        /// Street type part of the street name. Example: “avenue".
        public var type: Swift.String?
        /// Defines if the street type is before or after the base name.
        public var typePlacement: GeoPlacesClientTypes.TypePlacement?
        /// What character(s) separates the string from its type.
        public var typeSeparator: Swift.String?

        public init(
            baseName: Swift.String? = nil,
            direction: Swift.String? = nil,
            language: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            suffix: Swift.String? = nil,
            type: Swift.String? = nil,
            typePlacement: GeoPlacesClientTypes.TypePlacement? = nil,
            typeSeparator: Swift.String? = nil
        )
        {
            self.baseName = baseName
            self.direction = direction
            self.language = language
            self.`prefix` = `prefix`
            self.suffix = suffix
            self.type = type
            self.typePlacement = typePlacement
            self.typeSeparator = typeSeparator
        }
    }
}

extension GeoPlacesClientTypes {

    /// The sub-region.
    public struct SubRegion: Swift.Sendable {
        /// Abbreviated code for the county or sub-region.
        public var code: Swift.String?
        /// Name for the county or sub-region.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// The place address.
    public struct Address: Swift.Sendable {
        /// The number that identifies an address within a street.
        public var addressNumber: Swift.String?
        /// Name of the block. Example: Sunny Mansion 203 block: 2 Chome
        public var block: Swift.String?
        /// The name of the building at the address.
        public var building: Swift.String?
        /// The country component of the address.
        public var country: GeoPlacesClientTypes.Country?
        /// The district or division of a locality associated with this address.
        public var district: Swift.String?
        /// Name of the streets in the intersection. Example: ["Friedrichstraße","Unter den Linden"]
        public var intersection: [Swift.String]?
        /// Assembled address value built out of the address components, according to the regional postal rules. This is the correctly formatted address.
        public var label: Swift.String?
        /// The locality or city of the address. Example: Vancouver.
        public var locality: Swift.String?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code, for which the result should posses.
        public var postalCode: Swift.String?
        /// The region or state results should be present in. Example: North Rhine-Westphalia.
        public var region: GeoPlacesClientTypes.Region?
        /// The name of the street results should be present in.
        public var street: Swift.String?
        /// Components of the street. Example: Younge from the "Younge street".
        public var streetComponents: [GeoPlacesClientTypes.StreetComponents]?
        /// Name of sub-block. Example: Sunny Mansion 203 sub-block: 4
        public var subBlock: Swift.String?
        /// A subdivision of a district. Example: Minden-Lübbecke.
        public var subDistrict: Swift.String?
        /// The sub-region or county for which results should be present in.
        public var subRegion: GeoPlacesClientTypes.SubRegion?

        public init(
            addressNumber: Swift.String? = nil,
            block: Swift.String? = nil,
            building: Swift.String? = nil,
            country: GeoPlacesClientTypes.Country? = nil,
            district: Swift.String? = nil,
            intersection: [Swift.String]? = nil,
            label: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: GeoPlacesClientTypes.Region? = nil,
            street: Swift.String? = nil,
            streetComponents: [GeoPlacesClientTypes.StreetComponents]? = nil,
            subBlock: Swift.String? = nil,
            subDistrict: Swift.String? = nil,
            subRegion: GeoPlacesClientTypes.SubRegion? = nil
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.streetComponents = streetComponents
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates how well the entire input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
    public struct AddressComponentMatchScores: Swift.Sendable {
        /// The house number or address results should have.
        public var addressNumber: Swift.Double
        /// Name of the block. Example: Sunny Mansion 203 block: 2 Chome
        public var block: Swift.Double
        /// The name of the building at the address.
        public var building: Swift.Double
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public var country: Swift.Double
        /// The district or division of a city the results should be present in.
        public var district: Swift.Double
        /// Name of the streets in the intersection. Example: ["Friedrichstraße","Unter den Linden"]
        public var intersection: [Swift.Double]?
        /// The city or locality results should be present in. Example: Vancouver.
        public var locality: Swift.Double
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code, for which the result should posses.
        public var postalCode: Swift.Double
        /// The region or state results should be to be present in. Example: North Rhine-Westphalia.
        public var region: Swift.Double
        /// Name of sub-block. Example: Sunny Mansion 203 sub-block: 4
        public var subBlock: Swift.Double
        /// A subdivision of a district. Example: Minden-Lübbecke
        public var subDistrict: Swift.Double
        /// The sub-region or county for which results should be present in.
        public var subRegion: Swift.Double

        public init(
            addressNumber: Swift.Double = 0.0,
            block: Swift.Double = 0.0,
            building: Swift.Double = 0.0,
            country: Swift.Double = 0.0,
            district: Swift.Double = 0.0,
            intersection: [Swift.Double]? = nil,
            locality: Swift.Double = 0.0,
            postalCode: Swift.Double = 0.0,
            region: Swift.Double = 0.0,
            subBlock: Swift.Double = 0.0,
            subDistrict: Swift.Double = 0.0,
            subRegion: Swift.Double = 0.0
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    /// How to pronounce the various components of the address or place.
    public struct PhonemeTranscription: Swift.Sendable {
        /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public var language: Swift.String?
        /// Boolean which indicates if it the preferred pronunciation.
        public var preferred: Swift.Bool?
        /// Value which indicates how to pronounce the value.
        public var value: Swift.String?

        public init(
            language: Swift.String? = nil,
            preferred: Swift.Bool? = nil,
            value: Swift.String? = nil
        )
        {
            self.language = language
            self.preferred = preferred
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    /// How to pronounce the various components of the address or place.
    public struct AddressComponentPhonemes: Swift.Sendable {
        /// How to pronounce the name of the block.
        public var block: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public var country: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the district or division of a city results should be present in.
        public var district: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the city or locality results should be present in. Example: Vancouver.
        public var locality: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the region or state results should be to be present in.
        public var region: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the name of the street results should be present in.
        public var street: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the name of the sub-block.
        public var subBlock: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the sub-district or division of a city results should be present in.
        public var subDistrict: [GeoPlacesClientTypes.PhonemeTranscription]?
        /// How to pronounce the sub-region or county for which results should be present in.
        public var subRegion: [GeoPlacesClientTypes.PhonemeTranscription]?

        public init(
            block: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            country: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            district: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            locality: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            region: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            street: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subBlock: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subDistrict: [GeoPlacesClientTypes.PhonemeTranscription]? = nil,
            subRegion: [GeoPlacesClientTypes.PhonemeTranscription]? = nil
        )
        {
            self.block = block
            self.country = country
            self.district = district
            self.locality = locality
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoPlacesClientTypes {

    /// The input fails to satisfy the constraints specified by the Amazon Location service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such field is supported.
        case unknownField
        /// No such operation is supported.
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .missing,
                .other,
                .unknownField,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownField: return "UnknownField"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Test stub for FieldList.
        /// This member is required.
        public internal(set) var fieldList: [GeoPlacesClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Test stub for reason
        /// This member is required.
        public internal(set) var reason: GeoPlacesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GeoPlacesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GeoPlacesClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension GeoPlacesClientTypes {

    public enum AutocompleteAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case core
        case sdkUnknown(Swift.String)

        public static var allCases: [AutocompleteAdditionalFeature] {
            return [
                .core
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .core: return "Core"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The Circle that all results must be in.
    public struct FilterCircle: Swift.Sendable {
        /// The center position, in longitude and latitude, of the FilterCircle.
        /// This member is required.
        public var center: [Swift.Double]?
        /// The radius, in meters, of the FilterCircle.
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Int? = 0
        )
        {
            self.center = center
            self.radius = radius
        }
    }
}

extension GeoPlacesClientTypes.FilterCircle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoPlacesClientTypes {

    public enum AutocompleteFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case locality
        case postalCode
        case sdkUnknown(Swift.String)

        public static var allCases: [AutocompleteFilterPlaceType] {
            return [
                .locality,
                .postalCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .locality: return "Locality"
            case .postalCode: return "PostalCode"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// Autocomplete structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public struct AutocompleteFilter: Swift.Sendable {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var boundingBox: [Swift.Double]?
        /// The Circle that all results must be in.
        public var circle: GeoPlacesClientTypes.FilterCircle?
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public var includeCountries: [Swift.String]?
        /// The included place types.
        public var includePlaceTypes: [GeoPlacesClientTypes.AutocompleteFilterPlaceType]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil,
            includePlaceTypes: [GeoPlacesClientTypes.AutocompleteFilterPlaceType]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

extension GeoPlacesClientTypes.AutocompleteFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutocompleteFilter(includeCountries: \(Swift.String(describing: includeCountries)), includePlaceTypes: \(Swift.String(describing: includePlaceTypes)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum AutocompleteIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        case sdkUnknown(Swift.String)

        public static var allCases: [AutocompleteIntendedUse] {
            return [
                .singleUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalCodeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enumerateSpannedLocalities
        case mergeAllSpannedLocalities
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalCodeMode] {
            return [
                .enumerateSpannedLocalities,
                .mergeAllSpannedLocalities
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enumerateSpannedLocalities: return "EnumerateSpannedLocalities"
            case .mergeAllSpannedLocalities: return "MergeAllSpannedLocalities"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AutocompleteInput: Swift.Sendable {
    /// A list of optional additional parameters that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.AutocompleteAdditionalFeature]?
    /// The position in longitude and latitude that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format. The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
    public var biasPosition: [Swift.Double]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.AutocompleteFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.AutocompleteIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The PostalCodeMode affects how postal code results are returned. If a postal code spans multiple localities and this value is empty, partial district or locality information may be returned under a single postal code result entry. If it's populated with the value cityLookup, all cities in that postal code are returned.
    public var postalCodeMode: GeoPlacesClientTypes.PostalCodeMode?
    /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
    /// This member is required.
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.AutocompleteAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.AutocompleteFilter? = nil,
        intendedUse: GeoPlacesClientTypes.AutocompleteIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        postalCodeMode: GeoPlacesClientTypes.PostalCodeMode? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.postalCodeMode = postalCodeMode
        self.queryText = queryText
    }
}

extension AutocompleteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutocompleteInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), postalCodeMode: \(Swift.String(describing: postalCodeMode)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// Describes how parts of the result response match the input query.
    public struct Highlight: Swift.Sendable {
        /// End index of the highlight.
        public var endIndex: Swift.Int?
        /// Start index of the highlight.
        public var startIndex: Swift.Int?
        /// The highlight's value.
        public var value: Swift.String?

        public init(
            endIndex: Swift.Int? = nil,
            startIndex: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.endIndex = endIndex
            self.startIndex = startIndex
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates the starting and ending index of the country in the text query that match the found title.
    public struct CountryHighlights: Swift.Sendable {
        /// Indicates the starting and ending index of the country code in the text query that match the found title.
        public var code: [GeoPlacesClientTypes.Highlight]?
        /// Indicates the starting and ending index of the country code in the text query that match the found title.
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates the starting and ending index of the region in the text query that match the found title.
    public struct RegionHighlights: Swift.Sendable {
        /// Indicates the starting and ending index of the region in the text query that match the found title.
        public var code: [GeoPlacesClientTypes.Highlight]?
        /// Indicates the starting and ending index of the region name in the text query that match the found title.
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates the starting and ending index of the sub-region in the text query that match the found title.
    public struct SubRegionHighlights: Swift.Sendable {
        /// Indicates the starting and ending index of the sub-region in the text query that match the found title.
        public var code: [GeoPlacesClientTypes.Highlight]?
        /// Indicates the starting and ending index of the name in the text query that match the found title.
        public var name: [GeoPlacesClientTypes.Highlight]?

        public init(
            code: [GeoPlacesClientTypes.Highlight]? = nil,
            name: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// Describes how the parts of the response element matched the input query by returning the sections of the response which matched to input query terms.
    public struct AutocompleteAddressHighlights: Swift.Sendable {
        /// The house number or address results should have.
        public var addressNumber: [GeoPlacesClientTypes.Highlight]?
        /// Name of the block. Example: Sunny Mansion 203 block: 2 Chome
        public var block: [GeoPlacesClientTypes.Highlight]?
        /// The name of the building at the address.
        public var building: [GeoPlacesClientTypes.Highlight]?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public var country: GeoPlacesClientTypes.CountryHighlights?
        /// The district or division of a city the results should be present in.
        public var district: [GeoPlacesClientTypes.Highlight]?
        /// Name of the streets in the intersection. For example: e.g. ["Friedrichstraße","Unter den Linden"]
        public var intersection: [[GeoPlacesClientTypes.Highlight]]?
        /// Indicates the starting and ending indexes for result items where they are identified to match the input query. This should be used to provide emphasis to output display to make selecting the correct result from a list easier for end users.
        public var label: [GeoPlacesClientTypes.Highlight]?
        /// The city or locality results should be present in. Example: Vancouver.
        public var locality: [GeoPlacesClientTypes.Highlight]?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public var postalCode: [GeoPlacesClientTypes.Highlight]?
        /// The region or state results should be to be present in. Example: North Rhine-Westphalia.
        public var region: GeoPlacesClientTypes.RegionHighlights?
        /// The name of the street results should be present in.
        public var street: [GeoPlacesClientTypes.Highlight]?
        /// Name of sub-block. Example Sunny Mansion 203 sub-block: 4
        public var subBlock: [GeoPlacesClientTypes.Highlight]?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public var subDistrict: [GeoPlacesClientTypes.Highlight]?
        /// The sub-region or county for which results should be present in.
        public var subRegion: GeoPlacesClientTypes.SubRegionHighlights?

        public init(
            addressNumber: [GeoPlacesClientTypes.Highlight]? = nil,
            block: [GeoPlacesClientTypes.Highlight]? = nil,
            building: [GeoPlacesClientTypes.Highlight]? = nil,
            country: GeoPlacesClientTypes.CountryHighlights? = nil,
            district: [GeoPlacesClientTypes.Highlight]? = nil,
            intersection: [[GeoPlacesClientTypes.Highlight]]? = nil,
            label: [GeoPlacesClientTypes.Highlight]? = nil,
            locality: [GeoPlacesClientTypes.Highlight]? = nil,
            postalCode: [GeoPlacesClientTypes.Highlight]? = nil,
            region: GeoPlacesClientTypes.RegionHighlights? = nil,
            street: [GeoPlacesClientTypes.Highlight]? = nil,
            subBlock: [GeoPlacesClientTypes.Highlight]? = nil,
            subDistrict: [GeoPlacesClientTypes.Highlight]? = nil,
            subRegion: GeoPlacesClientTypes.SubRegionHighlights? = nil
        )
        {
            self.addressNumber = addressNumber
            self.block = block
            self.building = building
            self.country = country
            self.district = district
            self.intersection = intersection
            self.label = label
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subBlock = subBlock
            self.subDistrict = subDistrict
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes {

    /// Describes how the parts of the response element matched the input query by returning the sections of the response which matched to input query terms.
    public struct AutocompleteHighlights: Swift.Sendable {
        /// Describes how part of the result address match the input query.
        public var address: GeoPlacesClientTypes.AutocompleteAddressHighlights?
        /// Indicates where the title field in the result matches the input query.
        public var title: [GeoPlacesClientTypes.Highlight]?

        public init(
            address: GeoPlacesClientTypes.AutocompleteAddressHighlights? = nil,
            title: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case country
        case district
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case pointOfInterest
        case postalCode
        case region
        case street
        case subBlock
        case subDistrict
        case subRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaceType] {
            return [
                .block,
                .country,
                .district,
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .pointOfInterest,
                .postalCode,
                .region,
                .street,
                .subBlock,
                .subDistrict,
                .subRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "Block"
            case .country: return "Country"
            case .district: return "District"
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .pointOfInterest: return "PointOfInterest"
            case .postalCode: return "PostalCode"
            case .region: return "Region"
            case .street: return "Street"
            case .subBlock: return "SubBlock"
            case .subDistrict: return "SubDistrict"
            case .subRegion: return "SubRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// A result matching the input query text.
    public struct AutocompleteResultItem: Swift.Sendable {
        /// The address associated with this result.
        public var address: GeoPlacesClientTypes.Address?
        /// The distance in meters between the center of the search area and this result. Useful to evaluate how far away from the original bias position the result is.
        public var distance: Swift.Int
        /// Indicates the starting and ending index of the place in the text query that match the found title.
        public var highlights: GeoPlacesClientTypes.AutocompleteHighlights?
        /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
        public var language: Swift.String?
        /// The PlaceId of the place associated with this result. This can be used to look up additional details about the result via GetPlace.
        /// This member is required.
        public var placeId: Swift.String?
        /// PlaceType describes the type of result entry returned.
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// A formatted string for display when presenting this result to an end user.
        /// This member is required.
        public var title: Swift.String?

        public init(
            address: GeoPlacesClientTypes.Address? = nil,
            distance: Swift.Int = 0,
            highlights: GeoPlacesClientTypes.AutocompleteHighlights? = nil,
            language: Swift.String? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.address = address
            self.distance = distance
            self.highlights = highlights
            self.language = language
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.title = title
        }
    }
}

public struct AutocompleteOutput: Swift.Sendable {
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.AutocompleteResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.AutocompleteResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    /// A businesschain is a chain of businesses that belong to the same brand. For example 7-11.
    public struct BusinessChain: Swift.Sendable {
        /// The Business Chain Id.
        public var id: Swift.String?
        /// The business chain name.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension GeoPlacesClientTypes {

    /// Indicates how well the input matches the returned element. It is equal to 1 if all input tokens are recognized and matched to the title in the result.
    public struct ComponentMatchScores: Swift.Sendable {
        /// The place's address.
        public var address: GeoPlacesClientTypes.AddressComponentMatchScores?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public var title: Swift.Double

        public init(
            address: GeoPlacesClientTypes.AddressComponentMatchScores? = nil,
            title: Swift.Double = 0.0
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    /// Details related to contacts.
    public struct ContactDetails: Swift.Sendable {
        /// Categories of results that results must belong too.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// The contact's label.
        public var label: Swift.String?
        /// The contact's value.
        public var value: Swift.String?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            label: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.categories = categories
            self.label = label
            self.value = value
        }
    }
}

extension GeoPlacesClientTypes {

    /// A list of potential contact methods for the result/place.
    public struct Contacts: Swift.Sendable {
        /// List of emails for contacts of the result.
        public var emails: [GeoPlacesClientTypes.ContactDetails]?
        /// List of fax addresses for the result contact.
        public var faxes: [GeoPlacesClientTypes.ContactDetails]?
        /// List of phone numbers for the results contact.
        public var phones: [GeoPlacesClientTypes.ContactDetails]?
        /// List of website URLs that belong to the result.
        public var websites: [GeoPlacesClientTypes.ContactDetails]?

        public init(
            emails: [GeoPlacesClientTypes.ContactDetails]? = nil,
            faxes: [GeoPlacesClientTypes.ContactDetails]? = nil,
            phones: [GeoPlacesClientTypes.ContactDetails]? = nil,
            websites: [GeoPlacesClientTypes.ContactDetails]? = nil
        )
        {
            self.emails = emails
            self.faxes = faxes
            self.phones = phones
            self.websites = websites
        }
    }
}

extension GeoPlacesClientTypes {

    /// List of Food types offered by this result.
    public struct FoodType: Swift.Sendable {
        /// The Food Type Id.
        public var id: Swift.String?
        /// Localized name of the food type.
        /// This member is required.
        public var localizedName: Swift.String?
        /// Boolean which indicates if this food type is the primary offered by the place. For example, if a location serves fast food, but also dessert, he primary would likely be fast food.
        public var primary: Swift.Bool?

        public init(
            id: Swift.String? = nil,
            localizedName: Swift.String? = nil,
            primary: Swift.Bool? = nil
        )
        {
            self.id = id
            self.localizedName = localizedName
            self.primary = primary
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GeocodeAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [GeocodeAdditionalFeature] {
            return [
                .access,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GeocodeFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case postalCode
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [GeocodeFilterPlaceType] {
            return [
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .postalCode,
                .street
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .postalCode: return "PostalCode"
            case .street: return "Street"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// Geocode structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public struct GeocodeFilter: Swift.Sendable {
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public var includeCountries: [Swift.String]?
        /// The included place types.
        public var includePlaceTypes: [GeoPlacesClientTypes.GeocodeFilterPlaceType]?

        public init(
            includeCountries: [Swift.String]? = nil,
            includePlaceTypes: [GeoPlacesClientTypes.GeocodeFilterPlaceType]? = nil
        )
        {
            self.includeCountries = includeCountries
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GeocodeIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [GeocodeIntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// A structured free text query allows you to search for places by the name or text representation of specific properties of the place.
    public struct GeocodeQueryComponents: Swift.Sendable {
        /// The house number or address results should have.
        public var addressNumber: Swift.String?
        /// The alpha-2 or alpha-3 character code for the country that the results will be present in.
        public var country: Swift.String?
        /// The district or division of a city the results should be present in.
        public var district: Swift.String?
        /// City or locality results should be present in. Example: Vancouver.
        public var locality: Swift.String?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public var postalCode: Swift.String?
        /// The region or state results should be to be present in. Example: North Rhine-Westphalia.
        public var region: Swift.String?
        /// The name of the street results should be present in.
        public var street: Swift.String?
        /// The sub-region or county for which results should be present in.
        public var subRegion: Swift.String?

        public init(
            addressNumber: Swift.String? = nil,
            country: Swift.String? = nil,
            district: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            region: Swift.String? = nil,
            street: Swift.String? = nil,
            subRegion: Swift.String? = nil
        )
        {
            self.addressNumber = addressNumber
            self.country = country
            self.district = district
            self.locality = locality
            self.postalCode = postalCode
            self.region = region
            self.street = street
            self.subRegion = subRegion
        }
    }
}

extension GeoPlacesClientTypes.GeocodeQueryComponents: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeQueryComponents(addressNumber: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", district: \"CONTENT_REDACTED\", locality: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", region: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", subRegion: \"CONTENT_REDACTED\")"}
}

public struct GeocodeInput: Swift.Sendable {
    /// A list of optional additional parameters, such as time zone, that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.GeocodeAdditionalFeature]?
    /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format. The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
    public var biasPosition: [Swift.Double]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.GeocodeFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.GeocodeIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// A structured free text query allows you to search for places by the name or text representation of specific properties of the place.
    public var queryComponents: GeoPlacesClientTypes.GeocodeQueryComponents?
    /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.GeocodeAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.GeocodeFilter? = nil,
        intendedUse: GeoPlacesClientTypes.GeocodeIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryComponents: GeoPlacesClientTypes.GeocodeQueryComponents? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryComponents = queryComponents
        self.queryText = queryText
    }
}

extension GeocodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), queryComponents: \(Swift.String(describing: queryComponents)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// Details related to the match score.
    public struct MatchScoreDetails: Swift.Sendable {
        /// Indicates how well the component input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public var components: GeoPlacesClientTypes.ComponentMatchScores?
        /// Indicates how well the entire input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public var overall: Swift.Double

        public init(
            components: GeoPlacesClientTypes.ComponentMatchScores? = nil,
            overall: Swift.Double = 0.0
        )
        {
            self.components = components
            self.overall = overall
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalAuthority: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usps
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalAuthority] {
            return [
                .usps
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usps: return "Usps"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum PostalCodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uspsZip
        case uspsZipPlus4
        case sdkUnknown(Swift.String)

        public static var allCases: [PostalCodeType] {
            return [
                .uspsZip,
                .uspsZipPlus4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uspsZip: return "UspsZip"
            case .uspsZipPlus4: return "UspsZipPlus4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ZipClassificationCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case military
        case postOfficeBoxes
        case unique
        case sdkUnknown(Swift.String)

        public static var allCases: [ZipClassificationCode] {
            return [
                .military,
                .postOfficeBoxes,
                .unique
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .military: return "Military"
            case .postOfficeBoxes: return "PostOfficeBoxes"
            case .unique: return "Unique"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The USPS zip code.
    public struct UspsZip: Swift.Sendable {
        /// The ZIP Classification Code, or in other words what type of postal code is it.
        public var zipClassificationCode: GeoPlacesClientTypes.ZipClassificationCode?

        public init(
            zipClassificationCode: GeoPlacesClientTypes.ZipClassificationCode? = nil
        )
        {
            self.zipClassificationCode = zipClassificationCode
        }
    }
}

extension GeoPlacesClientTypes {

    public enum RecordTypeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case firm
        case general
        case highRise
        case postOfficeBox
        case rural
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordTypeCode] {
            return [
                .firm,
                .general,
                .highRise,
                .postOfficeBox,
                .rural,
                .street
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .firm: return "Firm"
            case .general: return "General"
            case .highRise: return "HighRise"
            case .postOfficeBox: return "PostOfficeBox"
            case .rural: return "Rural"
            case .street: return "Street"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The USPS zip+4 code.
    public struct UspsZipPlus4: Swift.Sendable {
        /// The USPS ZIP+4 Record Type Code.
        public var recordTypeCode: GeoPlacesClientTypes.RecordTypeCode?

        public init(
            recordTypeCode: GeoPlacesClientTypes.RecordTypeCode? = nil
        )
        {
            self.recordTypeCode = recordTypeCode
        }
    }
}

extension GeoPlacesClientTypes {

    /// Contains details about the postal code of the place or result.
    public struct PostalCodeDetails: Swift.Sendable {
        /// The postal authority or entity. This could be a governmental authority, a regulatory authority, or a designated postal operator.
        public var postalAuthority: GeoPlacesClientTypes.PostalAuthority?
        /// An alphanumeric string included in a postal address to facilitate mail sorting, such as post code, postcode, or ZIP code for which the result should posses.
        public var postalCode: Swift.String?
        /// The postal code type.
        public var postalCodeType: GeoPlacesClientTypes.PostalCodeType?
        /// The ZIP Classification Code, or in other words what type of postal code is it.
        public var uspsZip: GeoPlacesClientTypes.UspsZip?
        /// The USPS ZIP+4 Record Type Code.
        public var uspsZipPlus4: GeoPlacesClientTypes.UspsZipPlus4?

        public init(
            postalAuthority: GeoPlacesClientTypes.PostalAuthority? = nil,
            postalCode: Swift.String? = nil,
            postalCodeType: GeoPlacesClientTypes.PostalCodeType? = nil,
            uspsZip: GeoPlacesClientTypes.UspsZip? = nil,
            uspsZipPlus4: GeoPlacesClientTypes.UspsZipPlus4? = nil
        )
        {
            self.postalAuthority = postalAuthority
            self.postalCode = postalCode
            self.postalCodeType = postalCodeType
            self.uspsZip = uspsZip
            self.uspsZipPlus4 = uspsZipPlus4
        }
    }
}

extension GeoPlacesClientTypes {

    /// The time zone in which the place is located.
    public struct TimeZone: Swift.Sendable {
        /// The time zone name.
        /// This member is required.
        public var name: Swift.String?
        /// Time zone offset of the timezone from UTC.
        public var offset: Swift.String?
        /// The offset of the time zone from UTC, in seconds.
        public var offsetSeconds: Swift.Int

        public init(
            name: Swift.String? = nil,
            offset: Swift.String? = nil,
            offsetSeconds: Swift.Int = 0
        )
        {
            self.name = name
            self.offset = offset
            self.offsetSeconds = offsetSeconds
        }
    }
}

extension GeoPlacesClientTypes {

    /// The Geocoded result.
    public struct GeocodeResultItem: Swift.Sendable {
        /// Position of the access point represent by longitude and latitude.
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        /// The place's address.
        public var address: GeoPlacesClientTypes.Address?
        /// Boolean indicating if the address provided has been corrected.
        public var addressNumberCorrected: Swift.Bool?
        /// Categories of results that results must belong to.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// The distance in meters from the QueryPosition.
        public var distance: Swift.Int
        /// List of food types offered by this result.
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var mapView: [Swift.Double]?
        /// Indicates how well the entire input matches the returned. It is equal to 1 if all input tokens are recognized and matched.
        public var matchScores: GeoPlacesClientTypes.MatchScoreDetails?
        /// The PlaceId of the place you wish to receive the information for.
        /// This member is required.
        public var placeId: Swift.String?
        /// A PlaceType is a category that the result place must belong to.
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// The position in longitude and latitude.
        public var position: [Swift.Double]?
        /// Contains details about the postal code of the place/result.
        public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
        /// The time zone in which the place is located.
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// The localized display name of this result item based on request parameter language.
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            matchScores: GeoPlacesClientTypes.MatchScoreDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.matchScores = matchScores
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.GeocodeResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeocodeResultItem(accessPoints: \(Swift.String(describing: accessPoints)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), matchScores: \(Swift.String(describing: matchScores)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct GeocodeOutput: Swift.Sendable {
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.GeocodeResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.GeocodeResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum GetPlaceAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case contact
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [GetPlaceAdditionalFeature] {
            return [
                .access,
                .contact,
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .contact: return "Contact"
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum GetPlaceIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [GetPlaceIntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPlaceInput: Swift.Sendable {
    /// A list of optional additional parameters such as time zone that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.GetPlaceAdditionalFeature]?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.GetPlaceIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// The PlaceId of the place you wish to receive the information for.
    /// This member is required.
    public var placeId: Swift.String?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.GetPlaceAdditionalFeature]? = nil,
        intendedUse: GeoPlacesClientTypes.GetPlaceIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        placeId: Swift.String? = nil,
        politicalView: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.placeId = placeId
        self.politicalView = politicalView
    }
}

extension GetPlaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), politicalView: \(Swift.String(describing: politicalView)), key: \"CONTENT_REDACTED\", placeId: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// Components of the opening hours object.
    public struct OpeningHoursComponents: Swift.Sendable {
        /// String which represents the duration of the opening period, such as "PT12H00M".
        public var openDuration: Swift.String?
        /// String which represents the opening hours, such as "T070000".
        public var openTime: Swift.String?
        /// Days or periods when the provided opening hours are in affect. Example: FREQ:DAILY;BYDAY:MO,TU,WE,TH,SU
        public var recurrence: Swift.String?

        public init(
            openDuration: Swift.String? = nil,
            openTime: Swift.String? = nil,
            recurrence: Swift.String? = nil
        )
        {
            self.openDuration = openDuration
            self.openTime = openTime
            self.recurrence = recurrence
        }
    }
}

extension GeoPlacesClientTypes {

    /// List of opening hours objects.
    public struct OpeningHours: Swift.Sendable {
        /// Categories of results that results must belong too.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// Components of the opening hours object.
        public var components: [GeoPlacesClientTypes.OpeningHoursComponents]?
        /// List of opening hours in the format they are displayed in. This can vary by result and in most cases represents how the result uniquely formats their opening hours.
        public var display: [Swift.String]?
        /// Boolean which indicates if the result/place is currently open.
        public var openNow: Swift.Bool?

        public init(
            categories: [GeoPlacesClientTypes.Category]? = nil,
            components: [GeoPlacesClientTypes.OpeningHoursComponents]? = nil,
            display: [Swift.String]? = nil,
            openNow: Swift.Bool? = nil
        )
        {
            self.categories = categories
            self.components = components
            self.display = display
            self.openNow = openNow
        }
    }
}

extension GeoPlacesClientTypes {

    /// The phoneme details.
    public struct PhonemeDetails: Swift.Sendable {
        /// How to pronounce the address.
        public var address: GeoPlacesClientTypes.AddressComponentPhonemes?
        /// List of PhonemeTranscription. See PhonemeTranscription for fields.
        public var title: [GeoPlacesClientTypes.PhonemeTranscription]?

        public init(
            address: GeoPlacesClientTypes.AddressComponentPhonemes? = nil,
            title: [GeoPlacesClientTypes.PhonemeTranscription]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

public struct GetPlaceOutput: Swift.Sendable {
    /// Position of the access point in (lng,lat).
    public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
    /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
    public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
    /// The place's address.
    public var address: GeoPlacesClientTypes.Address?
    /// Boolean indicating if the address provided has been corrected.
    public var addressNumberCorrected: Swift.Bool?
    /// The Business Chains associated with the place.
    public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
    /// Categories of results that results must belong to.
    public var categories: [GeoPlacesClientTypes.Category]?
    /// List of potential contact methods for the result/place.
    public var contacts: GeoPlacesClientTypes.Contacts?
    /// List of food types offered by this result.
    public var foodTypes: [GeoPlacesClientTypes.FoodType]?
    /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set of four coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
    public var mapView: [Swift.Double]?
    /// List of opening hours objects.
    public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
    /// How the various components of the result's address are pronounced in various languages.
    public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
    /// The PlaceId of the place you wish to receive the information for.
    /// This member is required.
    public var placeId: Swift.String?
    /// A PlaceType is a category that the result place must belong to.
    /// This member is required.
    public var placeType: GeoPlacesClientTypes.PlaceType?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The position, in longitude and latitude.
    public var position: [Swift.Double]?
    /// Contains details about the postal code of the place/result.
    public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The time zone in which the place is located.
    public var timeZone: GeoPlacesClientTypes.TimeZone?
    /// The localized display name of this result item based on request parameter language.
    /// This member is required.
    public var title: Swift.String?

    public init(
        accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
        accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
        address: GeoPlacesClientTypes.Address? = nil,
        addressNumberCorrected: Swift.Bool? = nil,
        businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
        categories: [GeoPlacesClientTypes.Category]? = nil,
        contacts: GeoPlacesClientTypes.Contacts? = nil,
        foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
        mapView: [Swift.Double]? = nil,
        openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
        phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
        placeId: Swift.String? = nil,
        placeType: GeoPlacesClientTypes.PlaceType? = nil,
        politicalView: Swift.String? = nil,
        position: [Swift.Double]? = nil,
        postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
        pricingBucket: Swift.String? = nil,
        timeZone: GeoPlacesClientTypes.TimeZone? = nil,
        title: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.accessRestrictions = accessRestrictions
        self.address = address
        self.addressNumberCorrected = addressNumberCorrected
        self.businessChains = businessChains
        self.categories = categories
        self.contacts = contacts
        self.foodTypes = foodTypes
        self.mapView = mapView
        self.openingHours = openingHours
        self.phonemes = phonemes
        self.placeId = placeId
        self.placeType = placeType
        self.politicalView = politicalView
        self.position = position
        self.postalCodeDetails = postalCodeDetails
        self.pricingBucket = pricingBucket
        self.timeZone = timeZone
        self.title = title
    }
}

extension GetPlaceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaceOutput(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), pricingBucket: \(Swift.String(describing: pricingBucket)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum ReverseGeocodeAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [ReverseGeocodeAdditionalFeature] {
            return [
                .access,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ReverseGeocodeFilterPlaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interpolatedAddress
        case intersection
        case locality
        case pointAddress
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [ReverseGeocodeFilterPlaceType] {
            return [
                .interpolatedAddress,
                .intersection,
                .locality,
                .pointAddress,
                .street
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interpolatedAddress: return "InterpolatedAddress"
            case .intersection: return "Intersection"
            case .locality: return "Locality"
            case .pointAddress: return "PointAddress"
            case .street: return "Street"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The included place types.
    public struct ReverseGeocodeFilter: Swift.Sendable {
        /// The included place types.
        public var includePlaceTypes: [GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType]?

        public init(
            includePlaceTypes: [GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType]? = nil
        )
        {
            self.includePlaceTypes = includePlaceTypes
        }
    }
}

extension GeoPlacesClientTypes {

    public enum ReverseGeocodeIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [ReverseGeocodeIntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ReverseGeocodeInput: Swift.Sendable {
    /// A list of optional additional parameters, such as time zone that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.ReverseGeocodeFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.ReverseGeocodeIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The position, in [lng, lat] for which you are querying nearby resultsfor. Results closer to the position will be ranked higher then results further away from the position
    /// This member is required.
    public var queryPosition: [Swift.Double]?
    /// The maximum distance in meters from the QueryPosition from which a result will be returned.
    public var queryRadius: Swift.Int?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature]? = nil,
        filter: GeoPlacesClientTypes.ReverseGeocodeFilter? = nil,
        intendedUse: GeoPlacesClientTypes.ReverseGeocodeIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryPosition: [Swift.Double]? = nil,
        queryRadius: Swift.Int? = 0
    )
    {
        self.additionalFeatures = additionalFeatures
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryPosition = queryPosition
        self.queryRadius = queryRadius
    }
}

extension ReverseGeocodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReverseGeocodeInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), queryRadius: \(Swift.String(describing: queryRadius)), key: \"CONTENT_REDACTED\", queryPosition: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// The returned location from the Reverse Geocode action.
    public struct ReverseGeocodeResultItem: Swift.Sendable {
        /// Position of the access point represent by longitude and latitude.
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        /// The place's address.
        public var address: GeoPlacesClientTypes.Address?
        /// Boolean indicating if the address provided has been corrected.
        public var addressNumberCorrected: Swift.Bool?
        /// Categories of results that results must belong to.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// The distance in meters from the QueryPosition.
        public var distance: Swift.Int
        /// List of food types offered by this result.
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var mapView: [Swift.Double]?
        /// The PlaceId of the place you wish to receive the information for.
        /// This member is required.
        public var placeId: Swift.String?
        /// A PlaceType is a category that the result place must belong to.
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// The position in longitude and latitude.
        public var position: [Swift.Double]?
        /// Contains details about the postal code of the place/result.
        public var postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]?
        /// The time zone in which the place is located.
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// The localized display name of this result item based on request parameter language.
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            postalCodeDetails: [GeoPlacesClientTypes.PostalCodeDetails]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.postalCodeDetails = postalCodeDetails
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReverseGeocodeResultItem(accessPoints: \(Swift.String(describing: accessPoints)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), postalCodeDetails: \(Swift.String(describing: postalCodeDetails)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct ReverseGeocodeOutput: Swift.Sendable {
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.ReverseGeocodeResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.ReverseGeocodeResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SearchNearbyAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case contact
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchNearbyAdditionalFeature] {
            return [
                .access,
                .contact,
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .contact: return "Contact"
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// SearchNearby structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public struct SearchNearbyFilter: Swift.Sendable {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var boundingBox: [Swift.Double]?
        /// The Business Chains associated with the place.
        public var excludeBusinessChains: [Swift.String]?
        /// Categories of results that results are excluded from.
        public var excludeCategories: [Swift.String]?
        /// Food types that results are excluded from.
        public var excludeFoodTypes: [Swift.String]?
        /// The Business Chains associated with the place.
        public var includeBusinessChains: [Swift.String]?
        /// Categories of results that results must belong too.
        public var includeCategories: [Swift.String]?
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public var includeCountries: [Swift.String]?
        /// Food types that results are included from.
        public var includeFoodTypes: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            excludeBusinessChains: [Swift.String]? = nil,
            excludeCategories: [Swift.String]? = nil,
            excludeFoodTypes: [Swift.String]? = nil,
            includeBusinessChains: [Swift.String]? = nil,
            includeCategories: [Swift.String]? = nil,
            includeCountries: [Swift.String]? = nil,
            includeFoodTypes: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.excludeBusinessChains = excludeBusinessChains
            self.excludeCategories = excludeCategories
            self.excludeFoodTypes = excludeFoodTypes
            self.includeBusinessChains = includeBusinessChains
            self.includeCategories = includeCategories
            self.includeCountries = includeCountries
            self.includeFoodTypes = includeFoodTypes
        }
    }
}

extension GeoPlacesClientTypes.SearchNearbyFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyFilter(excludeBusinessChains: \(Swift.String(describing: excludeBusinessChains)), excludeCategories: \(Swift.String(describing: excludeCategories)), excludeFoodTypes: \(Swift.String(describing: excludeFoodTypes)), includeBusinessChains: \(Swift.String(describing: includeBusinessChains)), includeCategories: \(Swift.String(describing: includeCategories)), includeCountries: \(Swift.String(describing: includeCountries)), includeFoodTypes: \(Swift.String(describing: includeFoodTypes)), boundingBox: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum SearchNearbyIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchNearbyIntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchNearbyInput: Swift.Sendable {
    /// A list of optional additional parameters, such as time zone, that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.SearchNearbyAdditionalFeature]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.SearchNearbyFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.SearchNearbyIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    public var nextToken: Swift.String?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The position, in [lng, lat] for which you are querying nearby resultsfor. Results closer to the position will be ranked higher then results further away from the position
    /// This member is required.
    public var queryPosition: [Swift.Double]?
    /// The maximum distance in meters from the QueryPosition from which a result will be returned.
    public var queryRadius: Swift.Int?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SearchNearbyAdditionalFeature]? = nil,
        filter: GeoPlacesClientTypes.SearchNearbyFilter? = nil,
        intendedUse: GeoPlacesClientTypes.SearchNearbyIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        politicalView: Swift.String? = nil,
        queryPosition: [Swift.Double]? = nil,
        queryRadius: Swift.Int? = 0
    )
    {
        self.additionalFeatures = additionalFeatures
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.politicalView = politicalView
        self.queryPosition = queryPosition
        self.queryRadius = queryRadius
    }
}

extension SearchNearbyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), politicalView: \(Swift.String(describing: politicalView)), queryRadius: \(Swift.String(describing: queryRadius)), key: \"CONTENT_REDACTED\", queryPosition: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// The search results of nearby places.
    public struct SearchNearbyResultItem: Swift.Sendable {
        /// Position of the access point represent by longitude and latitude.
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        /// The place's address.
        public var address: GeoPlacesClientTypes.Address?
        /// Boolean indicating if the address provided has been corrected.
        public var addressNumberCorrected: Swift.Bool?
        /// The Business Chains associated with the place.
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        /// Categories of results that results must belong to.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// List of potential contact methods for the result/place.
        public var contacts: GeoPlacesClientTypes.Contacts?
        /// The distance in meters from the QueryPosition.
        public var distance: Swift.Int
        /// List of food types offered by this result.
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var mapView: [Swift.Double]?
        /// List of opening hours objects.
        public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
        /// How the various components of the result's address are pronounced in various languages.
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        /// This member is required.
        public var placeId: Swift.String?
        /// A PlaceType is a category that the result place must belong to.
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// The position in longitude and latitude.
        public var position: [Swift.Double]?
        /// The time zone in which the place is located.
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// The item's title.
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            contacts: GeoPlacesClientTypes.Contacts? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.SearchNearbyResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchNearbyResultItem(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct SearchNearbyOutput: Swift.Sendable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    public var nextToken: Swift.String?
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.SearchNearbyResultItem]?

    public init(
        nextToken: Swift.String? = nil,
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.SearchNearbyResultItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SearchTextAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case contact
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchTextAdditionalFeature] {
            return [
                .access,
                .contact,
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .contact: return "Contact"
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// SearchText structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public struct SearchTextFilter: Swift.Sendable {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var boundingBox: [Swift.Double]?
        /// The Circle that all results must be in.
        public var circle: GeoPlacesClientTypes.FilterCircle?
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public var includeCountries: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }
    }
}

extension GeoPlacesClientTypes.SearchTextFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextFilter(includeCountries: \(Swift.String(describing: includeCountries)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum SearchTextIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        /// Indicates that results of the operation may be stored locally.
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchTextIntendedUse] {
            return [
                .singleUse,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchTextInput: Swift.Sendable {
    /// A list of optional additional parameters, such as time zone, that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.SearchTextAdditionalFeature]?
    /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format. The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
    public var biasPosition: [Swift.Double]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.SearchTextFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.SearchTextIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    public var nextToken: Swift.String?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The query Id.
    public var queryId: Swift.String?
    /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SearchTextAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.SearchTextFilter? = nil,
        intendedUse: GeoPlacesClientTypes.SearchTextIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        politicalView: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.politicalView = politicalView
        self.queryId = queryId
        self.queryText = queryText
    }
}

extension SearchTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), politicalView: \(Swift.String(describing: politicalView)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryId: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// The text search result.
    public struct SearchTextResultItem: Swift.Sendable {
        /// Position of the access point represent by longitude and latitude.
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        /// The place's address.
        public var address: GeoPlacesClientTypes.Address?
        /// Boolean indicating if the address provided has been corrected.
        public var addressNumberCorrected: Swift.Bool?
        /// The Business Chains associated with the place.
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        /// Categories of results that results must belong to.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// List of potential contact methods for the result/place.
        public var contacts: GeoPlacesClientTypes.Contacts?
        /// The distance in meters from the QueryPosition.
        public var distance: Swift.Int
        /// List of food types offered by this result.
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var mapView: [Swift.Double]?
        /// List of opening hours objects.
        public var openingHours: [GeoPlacesClientTypes.OpeningHours]?
        /// How the various components of the result's address are pronounced in various languages.
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        /// This member is required.
        public var placeId: Swift.String?
        /// A PlaceType is a category that the result place must belong to.
        /// This member is required.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// The position, in longitude and latitude.
        public var position: [Swift.Double]?
        /// The time zone in which the place is located.
        public var timeZone: GeoPlacesClientTypes.TimeZone?
        /// The item's title.
        /// This member is required.
        public var title: Swift.String?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            addressNumberCorrected: Swift.Bool? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            contacts: GeoPlacesClientTypes.Contacts? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            openingHours: [GeoPlacesClientTypes.OpeningHours]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil,
            title: Swift.String? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.addressNumberCorrected = addressNumberCorrected
            self.businessChains = businessChains
            self.categories = categories
            self.contacts = contacts
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.openingHours = openingHours
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes.SearchTextResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchTextResultItem(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), addressNumberCorrected: \(Swift.String(describing: addressNumberCorrected)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), contacts: \(Swift.String(describing: contacts)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), openingHours: \(Swift.String(describing: openingHours)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), title: \(Swift.String(describing: title)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

public struct SearchTextOutput: Swift.Sendable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    public var nextToken: Swift.String?
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.SearchTextResultItem]?

    public init(
        nextToken: Swift.String? = nil,
        pricingBucket: Swift.String? = nil,
        resultItems: [GeoPlacesClientTypes.SearchTextResultItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.pricingBucket = pricingBucket
        self.resultItems = resultItems
    }
}

extension GeoPlacesClientTypes {

    public enum SuggestAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case core
        case phonemes
        case timeZone
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggestAdditionalFeature] {
            return [
                .access,
                .core,
                .phonemes,
                .timeZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "Access"
            case .core: return "Core"
            case .phonemes: return "Phonemes"
            case .timeZone: return "TimeZone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// SuggestFilter structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public struct SuggestFilter: Swift.Sendable {
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var boundingBox: [Swift.Double]?
        /// The Circle that all results must be in.
        public var circle: GeoPlacesClientTypes.FilterCircle?
        /// A list of countries that all results must be in. Countries are represented by either their alpha-2 or alpha-3 character codes.
        public var includeCountries: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            circle: GeoPlacesClientTypes.FilterCircle? = nil,
            includeCountries: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.circle = circle
            self.includeCountries = includeCountries
        }
    }
}

extension GeoPlacesClientTypes.SuggestFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestFilter(includeCountries: \(Swift.String(describing: includeCountries)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum SuggestIntendedUse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
        case singleUse
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggestIntendedUse] {
            return [
                .singleUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .singleUse: return "SingleUse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SuggestInput: Swift.Sendable {
    /// A list of optional additional parameters, such as time zone, that can be requested for each result.
    public var additionalFeatures: [GeoPlacesClientTypes.SuggestAdditionalFeature]?
    /// The position, in longitude and latitude, that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in [lng, lat] and in the WSG84 format. The fields BiasPosition, FilterBoundingBox, and FilterCircle are mutually exclusive.
    public var biasPosition: [Swift.Double]?
    /// A structure which contains a set of inclusion/exclusion properties that results must posses in order to be returned as a result.
    public var filter: GeoPlacesClientTypes.SuggestFilter?
    /// Indicates if the results will be stored. Defaults to SingleUse, if left empty.
    public var intendedUse: GeoPlacesClientTypes.SuggestIntendedUse?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// A list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.
    public var language: Swift.String?
    /// Maximum number of query terms to be returned for use with a search text query.
    public var maxQueryRefinements: Swift.Int?
    /// An optional limit for the number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
    public var politicalView: Swift.String?
    /// The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.
    /// This member is required.
    public var queryText: Swift.String?

    public init(
        additionalFeatures: [GeoPlacesClientTypes.SuggestAdditionalFeature]? = nil,
        biasPosition: [Swift.Double]? = nil,
        filter: GeoPlacesClientTypes.SuggestFilter? = nil,
        intendedUse: GeoPlacesClientTypes.SuggestIntendedUse? = nil,
        key: Swift.String? = nil,
        language: Swift.String? = nil,
        maxQueryRefinements: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        politicalView: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalFeatures = additionalFeatures
        self.biasPosition = biasPosition
        self.filter = filter
        self.intendedUse = intendedUse
        self.key = key
        self.language = language
        self.maxQueryRefinements = maxQueryRefinements
        self.maxResults = maxResults
        self.politicalView = politicalView
        self.queryText = queryText
    }
}

extension SuggestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestInput(additionalFeatures: \(Swift.String(describing: additionalFeatures)), filter: \(Swift.String(describing: filter)), intendedUse: \(Swift.String(describing: intendedUse)), language: \(Swift.String(describing: language)), maxQueryRefinements: \(Swift.String(describing: maxQueryRefinements)), maxResults: \(Swift.String(describing: maxResults)), politicalView: \(Swift.String(describing: politicalView)), biasPosition: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    /// Suggestions for refining individual query terms. Suggestions are returned as objects which note the term, suggested replacement, and its index in the query.
    public struct QueryRefinement: Swift.Sendable {
        /// End index of the parsed query.
        /// This member is required.
        public var endIndex: Swift.Int?
        /// The sub-string of the original query that is replaced by this query term.
        /// This member is required.
        public var originalTerm: Swift.String?
        /// The term that will be suggested to the user.
        /// This member is required.
        public var refinedTerm: Swift.String?
        /// Start index of the parsed component.
        /// This member is required.
        public var startIndex: Swift.Int?

        public init(
            endIndex: Swift.Int? = nil,
            originalTerm: Swift.String? = nil,
            refinedTerm: Swift.String? = nil,
            startIndex: Swift.Int? = nil
        )
        {
            self.endIndex = endIndex
            self.originalTerm = originalTerm
            self.refinedTerm = refinedTerm
            self.startIndex = startIndex
        }
    }
}

extension GeoPlacesClientTypes {

    /// Describes how the parts of the textQuery matched the input query by returning the sections of the response which matched to textQuery terms.
    public struct SuggestAddressHighlights: Swift.Sendable {
        /// Indicates the starting and ending indexes of the places in the result which were identified to match the textQuery. This result is useful for providing emphasis to results where the user query directly matched to make selecting the correct result from a list easier for an end user.
        public var label: [GeoPlacesClientTypes.Highlight]?

        public init(
            label: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.label = label
        }
    }
}

extension GeoPlacesClientTypes {

    /// Describes how the parts of the textQuery matched the input query by returning the sections of the response which matched to textQuery terms.
    public struct SuggestHighlights: Swift.Sendable {
        /// The place's address.
        public var address: GeoPlacesClientTypes.SuggestAddressHighlights?
        /// Indicates the starting and ending index of the title in the text query that match the found title.
        public var title: [GeoPlacesClientTypes.Highlight]?

        public init(
            address: GeoPlacesClientTypes.SuggestAddressHighlights? = nil,
            title: [GeoPlacesClientTypes.Highlight]? = nil
        )
        {
            self.address = address
            self.title = title
        }
    }
}

extension GeoPlacesClientTypes {

    /// The suggested place results.
    public struct SuggestPlaceResult: Swift.Sendable {
        /// Position of the access point represent by longitude and latitude.
        public var accessPoints: [GeoPlacesClientTypes.AccessPoint]?
        /// Indicates known access restrictions on a vehicle access point. The index correlates to an access point and indicates if access through this point has some form of restriction.
        public var accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]?
        /// The place's address.
        public var address: GeoPlacesClientTypes.Address?
        /// The Business Chains associated with the place.
        public var businessChains: [GeoPlacesClientTypes.BusinessChain]?
        /// Categories of results that results must belong to.
        public var categories: [GeoPlacesClientTypes.Category]?
        /// The distance in meters from the QueryPosition.
        public var distance: Swift.Int
        /// List of food types offered by this result.
        public var foodTypes: [GeoPlacesClientTypes.FoodType]?
        /// The bounding box enclosing the geometric shape (area or line) that an individual result covers. The bounding box formed is defined as a set 4 coordinates: [{westward lng}, {southern lat}, {eastward lng}, {northern lat}]
        public var mapView: [Swift.Double]?
        /// How the various components of the result's address are pronounced in various languages.
        public var phonemes: GeoPlacesClientTypes.PhonemeDetails?
        /// The PlaceId of the place you wish to receive the information for.
        public var placeId: Swift.String?
        /// A PlaceType is a category that the result place must belong to.
        public var placeType: GeoPlacesClientTypes.PlaceType?
        /// The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.
        public var politicalView: Swift.String?
        /// The position, in longitude and latitude.
        public var position: [Swift.Double]?
        /// The time zone in which the place is located.
        public var timeZone: GeoPlacesClientTypes.TimeZone?

        public init(
            accessPoints: [GeoPlacesClientTypes.AccessPoint]? = nil,
            accessRestrictions: [GeoPlacesClientTypes.AccessRestriction]? = nil,
            address: GeoPlacesClientTypes.Address? = nil,
            businessChains: [GeoPlacesClientTypes.BusinessChain]? = nil,
            categories: [GeoPlacesClientTypes.Category]? = nil,
            distance: Swift.Int = 0,
            foodTypes: [GeoPlacesClientTypes.FoodType]? = nil,
            mapView: [Swift.Double]? = nil,
            phonemes: GeoPlacesClientTypes.PhonemeDetails? = nil,
            placeId: Swift.String? = nil,
            placeType: GeoPlacesClientTypes.PlaceType? = nil,
            politicalView: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            timeZone: GeoPlacesClientTypes.TimeZone? = nil
        )
        {
            self.accessPoints = accessPoints
            self.accessRestrictions = accessRestrictions
            self.address = address
            self.businessChains = businessChains
            self.categories = categories
            self.distance = distance
            self.foodTypes = foodTypes
            self.mapView = mapView
            self.phonemes = phonemes
            self.placeId = placeId
            self.placeType = placeType
            self.politicalView = politicalView
            self.position = position
            self.timeZone = timeZone
        }
    }
}

extension GeoPlacesClientTypes.SuggestPlaceResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuggestPlaceResult(accessPoints: \(Swift.String(describing: accessPoints)), accessRestrictions: \(Swift.String(describing: accessRestrictions)), address: \(Swift.String(describing: address)), businessChains: \(Swift.String(describing: businessChains)), categories: \(Swift.String(describing: categories)), distance: \(Swift.String(describing: distance)), foodTypes: \(Swift.String(describing: foodTypes)), phonemes: \(Swift.String(describing: phonemes)), placeId: \(Swift.String(describing: placeId)), placeType: \(Swift.String(describing: placeType)), politicalView: \(Swift.String(describing: politicalView)), timeZone: \(Swift.String(describing: timeZone)), mapView: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoPlacesClientTypes {

    public enum QueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessChain
        case category
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryType] {
            return [
                .businessChain,
                .category
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessChain: return "BusinessChain"
            case .category: return "Category"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The suggested query results.
    public struct SuggestQueryResult: Swift.Sendable {
        /// QueryId can be used to complete a follow up query through the SearchText API. The QueryId retains context from the original Suggest request such as filters, political view and language. See the SearchText API documentation for more details [SearchText API docs](https://docs.aws.amazon.com/latest/APIReference/API_geoplaces_SearchText.html).
        public var queryId: Swift.String?
        /// The query type. Category qeuries will search for places which have an entry matching the given category, for example "doctor office". BusinessChain queries will search for instances of a given business.
        public var queryType: GeoPlacesClientTypes.QueryType?

        public init(
            queryId: Swift.String? = nil,
            queryType: GeoPlacesClientTypes.QueryType? = nil
        )
        {
            self.queryId = queryId
            self.queryType = queryType
        }
    }
}

extension GeoPlacesClientTypes {

    public enum SuggestResultItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case place
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [SuggestResultItemType] {
            return [
                .place,
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .place: return "Place"
            case .query: return "Query"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoPlacesClientTypes {

    /// The resulting item from the suggested query.
    public struct SuggestResultItem: Swift.Sendable {
        /// Describes how the parts of the response element matched the input query by returning the sections of the response which matched to input query terms.
        public var highlights: GeoPlacesClientTypes.SuggestHighlights?
        /// The suggested place by its unique ID.
        public var place: GeoPlacesClientTypes.SuggestPlaceResult?
        /// The suggested query results.
        public var query: GeoPlacesClientTypes.SuggestQueryResult?
        /// The result type. Place results represent the final result for a point of interest, Query results represent a follow up query which can be completed through the SearchText operation.
        /// This member is required.
        public var suggestResultItemType: GeoPlacesClientTypes.SuggestResultItemType?
        /// The display title that should be used when presenting this option to the end user.
        /// This member is required.
        public var title: Swift.String?

        public init(
            highlights: GeoPlacesClientTypes.SuggestHighlights? = nil,
            place: GeoPlacesClientTypes.SuggestPlaceResult? = nil,
            query: GeoPlacesClientTypes.SuggestQueryResult? = nil,
            suggestResultItemType: GeoPlacesClientTypes.SuggestResultItemType? = nil,
            title: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.place = place
            self.query = query
            self.suggestResultItemType = suggestResultItemType
            self.title = title
        }
    }
}

public struct SuggestOutput: Swift.Sendable {
    /// The pricing bucket for which the query is charged at. For more inforamtion on pricing, please visit [Amazon Location Service Pricing](https://aws.amazon.com/location/pricing/).
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// Maximum number of query terms to be returned for use with a search text query.
    public var queryRefinements: [GeoPlacesClientTypes.QueryRefinement]?
    /// List of places or results returned for a query.
    public var resultItems: [GeoPlacesClientTypes.SuggestResultItem]?

    public init(
        pricingBucket: Swift.String? = nil,
        queryRefinements: [GeoPlacesClientTypes.QueryRefinement]? = nil,
        resultItems: [GeoPlacesClientTypes.SuggestResultItem]? = nil
    )
    {
        self.pricingBucket = pricingBucket
        self.queryRefinements = queryRefinements
        self.resultItems = resultItems
    }
}

extension AutocompleteInput {

    static func urlPathProvider(_ value: AutocompleteInput) -> Swift.String? {
        return "/autocomplete"
    }
}

extension AutocompleteInput {

    static func queryItemProvider(_ value: AutocompleteInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GeocodeInput {

    static func urlPathProvider(_ value: GeocodeInput) -> Swift.String? {
        return "/geocode"
    }
}

extension GeocodeInput {

    static func queryItemProvider(_ value: GeocodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetPlaceInput {

    static func urlPathProvider(_ value: GetPlaceInput) -> Swift.String? {
        guard let placeId = value.placeId else {
            return nil
        }
        return "/place/\(placeId.urlPercentEncoding())"
    }
}

extension GetPlaceInput {

    static func queryItemProvider(_ value: GetPlaceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let intendedUse = value.intendedUse {
            let intendedUseQueryItem = Smithy.URIQueryItem(name: "intended-use".urlPercentEncoding(), value: Swift.String(intendedUse.rawValue).urlPercentEncoding())
            items.append(intendedUseQueryItem)
        }
        if let additionalFeatures = value.additionalFeatures {
            additionalFeatures.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additional-features".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let language = value.language {
            let languageQueryItem = Smithy.URIQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language).urlPercentEncoding())
            items.append(languageQueryItem)
        }
        if let politicalView = value.politicalView {
            let politicalViewQueryItem = Smithy.URIQueryItem(name: "political-view".urlPercentEncoding(), value: Swift.String(politicalView).urlPercentEncoding())
            items.append(politicalViewQueryItem)
        }
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension ReverseGeocodeInput {

    static func urlPathProvider(_ value: ReverseGeocodeInput) -> Swift.String? {
        return "/reverse-geocode"
    }
}

extension ReverseGeocodeInput {

    static func queryItemProvider(_ value: ReverseGeocodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchNearbyInput {

    static func urlPathProvider(_ value: SearchNearbyInput) -> Swift.String? {
        return "/search-nearby"
    }
}

extension SearchNearbyInput {

    static func queryItemProvider(_ value: SearchNearbyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SearchTextInput {

    static func urlPathProvider(_ value: SearchTextInput) -> Swift.String? {
        return "/search-text"
    }
}

extension SearchTextInput {

    static func queryItemProvider(_ value: SearchTextInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SuggestInput {

    static func urlPathProvider(_ value: SuggestInput) -> Swift.String? {
        return "/suggest"
    }
}

extension SuggestInput {

    static func queryItemProvider(_ value: SuggestInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension AutocompleteInput {

    static func write(value: AutocompleteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.AutocompleteAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.AutocompleteFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["PostalCodeMode"].write(value.postalCodeMode)
        try writer["QueryText"].write(value.queryText)
    }
}

extension GeocodeInput {

    static func write(value: GeocodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.GeocodeAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.GeocodeFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryComponents"].write(value.queryComponents, with: GeoPlacesClientTypes.GeocodeQueryComponents.write(value:to:))
        try writer["QueryText"].write(value.queryText)
    }
}

extension ReverseGeocodeInput {

    static func write(value: ReverseGeocodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.ReverseGeocodeAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.ReverseGeocodeFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryPosition"].writeList(value.queryPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryRadius"].write(value.queryRadius)
    }
}

extension SearchNearbyInput {

    static func write(value: SearchNearbyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SearchNearbyAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SearchNearbyFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryPosition"].writeList(value.queryPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryRadius"].write(value.queryRadius)
    }
}

extension SearchTextInput {

    static func write(value: SearchTextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SearchTextAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SearchTextFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryId"].write(value.queryId)
        try writer["QueryText"].write(value.queryText)
    }
}

extension SuggestInput {

    static func write(value: SuggestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalFeatures"].writeList(value.additionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.SuggestAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BiasPosition"].writeList(value.biasPosition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: GeoPlacesClientTypes.SuggestFilter.write(value:to:))
        try writer["IntendedUse"].write(value.intendedUse)
        try writer["Language"].write(value.language)
        try writer["MaxQueryRefinements"].write(value.maxQueryRefinements)
        try writer["MaxResults"].write(value.maxResults)
        try writer["PoliticalView"].write(value.politicalView)
        try writer["QueryText"].write(value.queryText)
    }
}

extension AutocompleteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AutocompleteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AutocompleteOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AutocompleteResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeocodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GeocodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GeocodeOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.GeocodeResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPlaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaceOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.title = try reader["Title"].readIfPresent() ?? ""
        return value
    }
}

extension ReverseGeocodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReverseGeocodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReverseGeocodeOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ReverseGeocodeResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchNearbyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchNearbyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchNearbyOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SearchNearbyResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchTextOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTextOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SearchTextResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SuggestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SuggestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SuggestOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.queryRefinements = try reader["QueryRefinements"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.QueryRefinement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.SuggestResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

enum AutocompleteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GeocodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReverseGeocodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchNearbyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTextOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SuggestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.language = try reader["Language"].readIfPresent()
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.highlights = try reader["Highlights"].readIfPresent(with: GeoPlacesClientTypes.AutocompleteHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteHighlights()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AutocompleteAddressHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteAddressHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AutocompleteAddressHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AutocompleteAddressHighlights()
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.country = try reader["Country"].readIfPresent(with: GeoPlacesClientTypes.CountryHighlights.read(from:))
        value.region = try reader["Region"].readIfPresent(with: GeoPlacesClientTypes.RegionHighlights.read(from:))
        value.subRegion = try reader["SubRegion"].readIfPresent(with: GeoPlacesClientTypes.SubRegionHighlights.read(from:))
        value.locality = try reader["Locality"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.district = try reader["District"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subDistrict = try reader["SubDistrict"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.block = try reader["Block"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subBlock = try reader["SubBlock"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.postalCode = try reader["PostalCode"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.building = try reader["Building"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.Highlight {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Highlight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Highlight()
        value.startIndex = try reader["StartIndex"].readIfPresent()
        value.endIndex = try reader["EndIndex"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SubRegionHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SubRegionHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SubRegionHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.RegionHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.RegionHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.RegionHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.CountryHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.CountryHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.CountryHighlights()
        value.code = try reader["Code"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.Address {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Address()
        value.label = try reader["Label"].readIfPresent()
        value.country = try reader["Country"].readIfPresent(with: GeoPlacesClientTypes.Country.read(from:))
        value.region = try reader["Region"].readIfPresent(with: GeoPlacesClientTypes.Region.read(from:))
        value.subRegion = try reader["SubRegion"].readIfPresent(with: GeoPlacesClientTypes.SubRegion.read(from:))
        value.locality = try reader["Locality"].readIfPresent()
        value.district = try reader["District"].readIfPresent()
        value.subDistrict = try reader["SubDistrict"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.block = try reader["Block"].readIfPresent()
        value.subBlock = try reader["SubBlock"].readIfPresent()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readIfPresent()
        value.streetComponents = try reader["StreetComponents"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.StreetComponents.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readIfPresent()
        value.building = try reader["Building"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.StreetComponents {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.StreetComponents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.StreetComponents()
        value.baseName = try reader["BaseName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.typePlacement = try reader["TypePlacement"].readIfPresent()
        value.typeSeparator = try reader["TypeSeparator"].readIfPresent()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.direction = try reader["Direction"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SubRegion {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SubRegion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SubRegion()
        value.code = try reader["Code"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Region {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Region {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Region()
        value.code = try reader["Code"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Country {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Country {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Country()
        value.code2 = try reader["Code2"].readIfPresent()
        value.code3 = try reader["Code3"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.GeocodeResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.GeocodeResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.GeocodeResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.matchScores = try reader["MatchScores"].readIfPresent(with: GeoPlacesClientTypes.MatchScoreDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.MatchScoreDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.MatchScoreDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.MatchScoreDetails()
        value.overall = try reader["Overall"].readIfPresent() ?? 0
        value.components = try reader["Components"].readIfPresent(with: GeoPlacesClientTypes.ComponentMatchScores.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.ComponentMatchScores {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ComponentMatchScores {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ComponentMatchScores()
        value.title = try reader["Title"].readIfPresent() ?? 0
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AddressComponentMatchScores.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AddressComponentMatchScores {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AddressComponentMatchScores {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AddressComponentMatchScores()
        value.country = try reader["Country"].readIfPresent() ?? 0
        value.region = try reader["Region"].readIfPresent() ?? 0
        value.subRegion = try reader["SubRegion"].readIfPresent() ?? 0
        value.locality = try reader["Locality"].readIfPresent() ?? 0
        value.district = try reader["District"].readIfPresent() ?? 0
        value.subDistrict = try reader["SubDistrict"].readIfPresent() ?? 0
        value.postalCode = try reader["PostalCode"].readIfPresent() ?? 0
        value.block = try reader["Block"].readIfPresent() ?? 0
        value.subBlock = try reader["SubBlock"].readIfPresent() ?? 0
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.addressNumber = try reader["AddressNumber"].readIfPresent() ?? 0
        value.building = try reader["Building"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.TimeZone {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.TimeZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.TimeZone()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.offset = try reader["Offset"].readIfPresent()
        value.offsetSeconds = try reader["OffsetSeconds"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.AccessPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AccessPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AccessPoint()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.FoodType {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.FoodType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.FoodType()
        value.localizedName = try reader["LocalizedName"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent()
        value.primary = try reader["Primary"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Category {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Category {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Category()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.localizedName = try reader["LocalizedName"].readIfPresent()
        value.primary = try reader["Primary"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.PostalCodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PostalCodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PostalCodeDetails()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.postalAuthority = try reader["PostalAuthority"].readIfPresent()
        value.postalCodeType = try reader["PostalCodeType"].readIfPresent()
        value.uspsZip = try reader["UspsZip"].readIfPresent(with: GeoPlacesClientTypes.UspsZip.read(from:))
        value.uspsZipPlus4 = try reader["UspsZipPlus4"].readIfPresent(with: GeoPlacesClientTypes.UspsZipPlus4.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.UspsZipPlus4 {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.UspsZipPlus4 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.UspsZipPlus4()
        value.recordTypeCode = try reader["RecordTypeCode"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.UspsZip {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.UspsZip {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.UspsZip()
        value.zipClassificationCode = try reader["ZipClassificationCode"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.BusinessChain {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.BusinessChain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.BusinessChain()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.Contacts {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.Contacts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.Contacts()
        value.phones = try reader["Phones"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.faxes = try reader["Faxes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.websites = try reader["Websites"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.emails = try reader["Emails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.ContactDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.ContactDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ContactDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ContactDetails()
        value.label = try reader["Label"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.OpeningHours {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.OpeningHours {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.OpeningHours()
        value.display = try reader["Display"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.openNow = try reader["OpenNow"].readIfPresent()
        value.components = try reader["Components"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHoursComponents.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.OpeningHoursComponents {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.OpeningHoursComponents {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.OpeningHoursComponents()
        value.openTime = try reader["OpenTime"].readIfPresent()
        value.openDuration = try reader["OpenDuration"].readIfPresent()
        value.recurrence = try reader["Recurrence"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.AccessRestriction {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AccessRestriction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AccessRestriction()
        value.restricted = try reader["Restricted"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.PhonemeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PhonemeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PhonemeDetails()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.AddressComponentPhonemes.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.AddressComponentPhonemes {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.AddressComponentPhonemes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.AddressComponentPhonemes()
        value.country = try reader["Country"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subRegion = try reader["SubRegion"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.locality = try reader["Locality"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.district = try reader["District"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subDistrict = try reader["SubDistrict"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.block = try reader["Block"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subBlock = try reader["SubBlock"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.street = try reader["Street"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PhonemeTranscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.PhonemeTranscription {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.PhonemeTranscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.PhonemeTranscription()
        value.value = try reader["Value"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.preferred = try reader["Preferred"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ReverseGeocodeResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ReverseGeocodeResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.postalCodeDetails = try reader["PostalCodeDetails"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.PostalCodeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SearchNearbyResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SearchNearbyResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SearchNearbyResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SearchTextResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SearchTextResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SearchTextResultItem()
        value.placeId = try reader["PlaceId"].readIfPresent() ?? ""
        value.placeType = try reader["PlaceType"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.addressNumberCorrected = try reader["AddressNumberCorrected"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contacts = try reader["Contacts"].readIfPresent(with: GeoPlacesClientTypes.Contacts.read(from:))
        value.openingHours = try reader["OpeningHours"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.OpeningHours.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestResultItem()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.suggestResultItemType = try reader["SuggestResultItemType"].readIfPresent() ?? .sdkUnknown("")
        value.place = try reader["Place"].readIfPresent(with: GeoPlacesClientTypes.SuggestPlaceResult.read(from:))
        value.query = try reader["Query"].readIfPresent(with: GeoPlacesClientTypes.SuggestQueryResult.read(from:))
        value.highlights = try reader["Highlights"].readIfPresent(with: GeoPlacesClientTypes.SuggestHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestHighlights()
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.SuggestAddressHighlights.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.SuggestAddressHighlights {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestAddressHighlights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestAddressHighlights()
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Highlight.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoPlacesClientTypes.SuggestQueryResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestQueryResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestQueryResult()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryType = try reader["QueryType"].readIfPresent()
        return value
    }
}

extension GeoPlacesClientTypes.SuggestPlaceResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.SuggestPlaceResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.SuggestPlaceResult()
        value.placeId = try reader["PlaceId"].readIfPresent()
        value.placeType = try reader["PlaceType"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: GeoPlacesClientTypes.Address.read(from:))
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.mapView = try reader["MapView"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.Category.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.foodTypes = try reader["FoodTypes"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.FoodType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.businessChains = try reader["BusinessChains"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.BusinessChain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessPoints = try reader["AccessPoints"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.accessRestrictions = try reader["AccessRestrictions"].readListIfPresent(memberReadingClosure: GeoPlacesClientTypes.AccessRestriction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeZone = try reader["TimeZone"].readIfPresent(with: GeoPlacesClientTypes.TimeZone.read(from:))
        value.politicalView = try reader["PoliticalView"].readIfPresent()
        value.phonemes = try reader["Phonemes"].readIfPresent(with: GeoPlacesClientTypes.PhonemeDetails.read(from:))
        return value
    }
}

extension GeoPlacesClientTypes.QueryRefinement {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.QueryRefinement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.QueryRefinement()
        value.refinedTerm = try reader["RefinedTerm"].readIfPresent() ?? ""
        value.originalTerm = try reader["OriginalTerm"].readIfPresent() ?? ""
        value.startIndex = try reader["StartIndex"].readIfPresent() ?? 0
        value.endIndex = try reader["EndIndex"].readIfPresent() ?? 0
        return value
    }
}

extension GeoPlacesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoPlacesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoPlacesClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GeoPlacesClientTypes.AutocompleteFilter {

    static func write(value: GeoPlacesClientTypes.AutocompleteFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.AutocompleteFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.FilterCircle {

    static func write(value: GeoPlacesClientTypes.FilterCircle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Center"].writeList(value.center, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoPlacesClientTypes.GeocodeQueryComponents {

    static func write(value: GeoPlacesClientTypes.GeocodeQueryComponents?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressNumber"].write(value.addressNumber)
        try writer["Country"].write(value.country)
        try writer["District"].write(value.district)
        try writer["Locality"].write(value.locality)
        try writer["PostalCode"].write(value.postalCode)
        try writer["Region"].write(value.region)
        try writer["Street"].write(value.street)
        try writer["SubRegion"].write(value.subRegion)
    }
}

extension GeoPlacesClientTypes.GeocodeFilter {

    static func write(value: GeoPlacesClientTypes.GeocodeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.GeocodeFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.ReverseGeocodeFilter {

    static func write(value: GeoPlacesClientTypes.ReverseGeocodeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludePlaceTypes"].writeList(value.includePlaceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoPlacesClientTypes.ReverseGeocodeFilterPlaceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SearchNearbyFilter {

    static func write(value: GeoPlacesClientTypes.SearchNearbyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeBusinessChains"].writeList(value.excludeBusinessChains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeCategories"].writeList(value.excludeCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeFoodTypes"].writeList(value.excludeFoodTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeBusinessChains"].writeList(value.includeBusinessChains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeCategories"].writeList(value.includeCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeFoodTypes"].writeList(value.includeFoodTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SearchTextFilter {

    static func write(value: GeoPlacesClientTypes.SearchTextFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoPlacesClientTypes.SuggestFilter {

    static func write(value: GeoPlacesClientTypes.SuggestFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoPlacesClientTypes.FilterCircle.write(value:to:))
        try writer["IncludeCountries"].writeList(value.includeCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum GeoPlacesClientTypes {}
