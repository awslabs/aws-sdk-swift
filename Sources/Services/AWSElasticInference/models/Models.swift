// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ElasticInferenceClientTypes.AcceleratorType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypeName
        case memoryInfo
        case throughputInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorTypeName = self.acceleratorTypeName {
            try encodeContainer.encode(acceleratorTypeName, forKey: .acceleratorTypeName)
        }
        if let memoryInfo = self.memoryInfo {
            try encodeContainer.encode(memoryInfo, forKey: .memoryInfo)
        }
        if let throughputInfo = throughputInfo {
            var throughputInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .throughputInfo)
            for keyvaluepair0 in throughputInfo {
                try throughputInfoContainer.encode(keyvaluepair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorTypeName)
        acceleratorTypeName = acceleratorTypeNameDecoded
        let memoryInfoDecoded = try containerValues.decodeIfPresent(ElasticInferenceClientTypes.MemoryInfo.self, forKey: .memoryInfo)
        memoryInfo = memoryInfoDecoded
        let throughputInfoContainer = try containerValues.decodeIfPresent([ElasticInferenceClientTypes.KeyValuePair?].self, forKey: .throughputInfo)
        var throughputInfoDecoded0:[ElasticInferenceClientTypes.KeyValuePair]? = nil
        if let throughputInfoContainer = throughputInfoContainer {
            throughputInfoDecoded0 = [ElasticInferenceClientTypes.KeyValuePair]()
            for structure0 in throughputInfoContainer {
                if let structure0 = structure0 {
                    throughputInfoDecoded0?.append(structure0)
                }
            }
        }
        throughputInfo = throughputInfoDecoded0
    }
}

extension ElasticInferenceClientTypes {
    /// The details of an Elastic Inference Accelerator type.
    public struct AcceleratorType: Swift.Equatable {
        /// The name of the Elastic Inference Accelerator type.
        public var acceleratorTypeName: Swift.String?
        /// The memory information of the Elastic Inference Accelerator type.
        public var memoryInfo: ElasticInferenceClientTypes.MemoryInfo?
        /// The throughput information of the Elastic Inference Accelerator type.
        public var throughputInfo: [ElasticInferenceClientTypes.KeyValuePair]?

        public init(
            acceleratorTypeName: Swift.String? = nil,
            memoryInfo: ElasticInferenceClientTypes.MemoryInfo? = nil,
            throughputInfo: [ElasticInferenceClientTypes.KeyValuePair]? = nil
        )
        {
            self.acceleratorTypeName = acceleratorTypeName
            self.memoryInfo = memoryInfo
            self.throughputInfo = throughputInfo
        }
    }

}

extension ElasticInferenceClientTypes.AcceleratorTypeOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorType
        case location
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorType = self.acceleratorType {
            try encodeContainer.encode(acceleratorType, forKey: .acceleratorType)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let locationType = self.locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorType)
        acceleratorType = acceleratorTypeDecoded
        let locationTypeDecoded = try containerValues.decodeIfPresent(ElasticInferenceClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension ElasticInferenceClientTypes {
    /// The offering for an Elastic Inference Accelerator type.
    public struct AcceleratorTypeOffering: Swift.Equatable {
        /// The name of the Elastic Inference Accelerator type.
        public var acceleratorType: Swift.String?
        /// The location for the offering. It will return either the region, availability zone or availability zone id for the offering depending on the locationType value.
        public var location: Swift.String?
        /// The location type for the offering. It can assume the following values: region: defines that the offering is at the regional level. availability-zone: defines that the offering is at the availability zone level. availability-zone-id: defines that the offering is at the availability zone level, defined by the availability zone id.
        public var locationType: ElasticInferenceClientTypes.LocationType?

        public init(
            acceleratorType: Swift.String? = nil,
            location: Swift.String? = nil,
            locationType: ElasticInferenceClientTypes.LocationType? = nil
        )
        {
            self.acceleratorType = acceleratorType
            self.location = location
            self.locationType = locationType
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when a malformed input has been provided to the API.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAcceleratorOfferingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypes
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorTypes)
            for acceleratortypename0 in acceleratorTypes {
                try acceleratorTypesContainer.encode(acceleratortypename0)
            }
        }
        if let locationType = self.locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

extension DescribeAcceleratorOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-accelerator-offerings"
    }
}

public struct DescribeAcceleratorOfferingsInput: Swift.Equatable {
    /// The list of accelerator types to describe.
    public var acceleratorTypes: [Swift.String]?
    /// The location type that you want to describe accelerator type offerings for. It can assume the following values: region: will return the accelerator type offering at the regional level. availability-zone: will return the accelerator type offering at the availability zone level. availability-zone-id: will return the accelerator type offering at the availability zone level returning the availability zone id.
    /// This member is required.
    public var locationType: ElasticInferenceClientTypes.LocationType?

    public init(
        acceleratorTypes: [Swift.String]? = nil,
        locationType: ElasticInferenceClientTypes.LocationType? = nil
    )
    {
        self.acceleratorTypes = acceleratorTypes
        self.locationType = locationType
    }
}

struct DescribeAcceleratorOfferingsInputBody: Swift.Equatable {
    let locationType: ElasticInferenceClientTypes.LocationType?
    let acceleratorTypes: [Swift.String]?
}

extension DescribeAcceleratorOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypes
        case locationType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(ElasticInferenceClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[Swift.String]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [Swift.String]()
            for string0 in acceleratorTypesContainer {
                if let string0 = string0 {
                    acceleratorTypesDecoded0?.append(string0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
    }
}

extension DescribeAcceleratorOfferingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAcceleratorOfferingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorTypeOfferings = output.acceleratorTypeOfferings
        } else {
            self.acceleratorTypeOfferings = nil
        }
    }
}

public struct DescribeAcceleratorOfferingsOutput: Swift.Equatable {
    /// The list of accelerator type offerings for a specific location.
    public var acceleratorTypeOfferings: [ElasticInferenceClientTypes.AcceleratorTypeOffering]?

    public init(
        acceleratorTypeOfferings: [ElasticInferenceClientTypes.AcceleratorTypeOffering]? = nil
    )
    {
        self.acceleratorTypeOfferings = acceleratorTypeOfferings
    }
}

struct DescribeAcceleratorOfferingsOutputBody: Swift.Equatable {
    let acceleratorTypeOfferings: [ElasticInferenceClientTypes.AcceleratorTypeOffering]?
}

extension DescribeAcceleratorOfferingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypeOfferings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypeOfferingsContainer = try containerValues.decodeIfPresent([ElasticInferenceClientTypes.AcceleratorTypeOffering?].self, forKey: .acceleratorTypeOfferings)
        var acceleratorTypeOfferingsDecoded0:[ElasticInferenceClientTypes.AcceleratorTypeOffering]? = nil
        if let acceleratorTypeOfferingsContainer = acceleratorTypeOfferingsContainer {
            acceleratorTypeOfferingsDecoded0 = [ElasticInferenceClientTypes.AcceleratorTypeOffering]()
            for structure0 in acceleratorTypeOfferingsContainer {
                if let structure0 = structure0 {
                    acceleratorTypeOfferingsDecoded0?.append(structure0)
                }
            }
        }
        acceleratorTypeOfferings = acceleratorTypeOfferingsDecoded0
    }
}

enum DescribeAcceleratorOfferingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAcceleratorTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-accelerator-types"
    }
}

public struct DescribeAcceleratorTypesInput: Swift.Equatable {

    public init() { }
}

struct DescribeAcceleratorTypesInputBody: Swift.Equatable {
}

extension DescribeAcceleratorTypesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAcceleratorTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAcceleratorTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorTypes = output.acceleratorTypes
        } else {
            self.acceleratorTypes = nil
        }
    }
}

public struct DescribeAcceleratorTypesOutput: Swift.Equatable {
    /// The available accelerator types.
    public var acceleratorTypes: [ElasticInferenceClientTypes.AcceleratorType]?

    public init(
        acceleratorTypes: [ElasticInferenceClientTypes.AcceleratorType]? = nil
    )
    {
        self.acceleratorTypes = acceleratorTypes
    }
}

struct DescribeAcceleratorTypesOutputBody: Swift.Equatable {
    let acceleratorTypes: [ElasticInferenceClientTypes.AcceleratorType]?
}

extension DescribeAcceleratorTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([ElasticInferenceClientTypes.AcceleratorType?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[ElasticInferenceClientTypes.AcceleratorType]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [ElasticInferenceClientTypes.AcceleratorType]()
            for structure0 in acceleratorTypesContainer {
                if let structure0 = structure0 {
                    acceleratorTypesDecoded0?.append(structure0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
    }
}

enum DescribeAcceleratorTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAcceleratorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorIds = acceleratorIds {
            var acceleratorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorIds)
            for acceleratorid0 in acceleratorIds {
                try acceleratorIdsContainer.encode(acceleratorid0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAcceleratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-accelerators"
    }
}

public struct DescribeAcceleratorsInput: Swift.Equatable {
    /// The IDs of the accelerators to describe.
    public var acceleratorIds: [Swift.String]?
    /// One or more filters. Filter names and values are case-sensitive. Valid filter names are: accelerator-types: can provide a list of accelerator type names to filter for. instance-id: can provide a list of EC2 instance ids to filter for.
    public var filters: [ElasticInferenceClientTypes.Filter]?
    /// The total number of items to return in the command's output. If the total number of items available is more than the value specified, a NextToken is provided in the command's output. To resume pagination, provide the NextToken value in the starting-token argument of a subsequent command. Do not use the NextToken response element directly outside of the AWS CLI.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        acceleratorIds: [Swift.String]? = nil,
        filters: [ElasticInferenceClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorIds = acceleratorIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAcceleratorsInputBody: Swift.Equatable {
    let acceleratorIds: [Swift.String]?
    let filters: [ElasticInferenceClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAcceleratorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorIds
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorIds)
        var acceleratorIdsDecoded0:[Swift.String]? = nil
        if let acceleratorIdsContainer = acceleratorIdsContainer {
            acceleratorIdsDecoded0 = [Swift.String]()
            for string0 in acceleratorIdsContainer {
                if let string0 = string0 {
                    acceleratorIdsDecoded0?.append(string0)
                }
            }
        }
        acceleratorIds = acceleratorIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ElasticInferenceClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ElasticInferenceClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ElasticInferenceClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAcceleratorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAcceleratorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.acceleratorSet = output.acceleratorSet
            self.nextToken = output.nextToken
        } else {
            self.acceleratorSet = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAcceleratorsOutput: Swift.Equatable {
    /// The details of the Elastic Inference Accelerators.
    public var acceleratorSet: [ElasticInferenceClientTypes.ElasticInferenceAccelerator]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init(
        acceleratorSet: [ElasticInferenceClientTypes.ElasticInferenceAccelerator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.acceleratorSet = acceleratorSet
        self.nextToken = nextToken
    }
}

struct DescribeAcceleratorsOutputBody: Swift.Equatable {
    let acceleratorSet: [ElasticInferenceClientTypes.ElasticInferenceAccelerator]?
    let nextToken: Swift.String?
}

extension DescribeAcceleratorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorSet
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorSetContainer = try containerValues.decodeIfPresent([ElasticInferenceClientTypes.ElasticInferenceAccelerator?].self, forKey: .acceleratorSet)
        var acceleratorSetDecoded0:[ElasticInferenceClientTypes.ElasticInferenceAccelerator]? = nil
        if let acceleratorSetContainer = acceleratorSetContainer {
            acceleratorSetDecoded0 = [ElasticInferenceClientTypes.ElasticInferenceAccelerator]()
            for structure0 in acceleratorSetContainer {
                if let structure0 = structure0 {
                    acceleratorSetDecoded0?.append(structure0)
                }
            }
        }
        acceleratorSet = acceleratorSetDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAcceleratorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ElasticInferenceClientTypes.ElasticInferenceAccelerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorHealth
        case acceleratorId
        case acceleratorType
        case attachedResource
        case availabilityZone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorHealth = self.acceleratorHealth {
            try encodeContainer.encode(acceleratorHealth, forKey: .acceleratorHealth)
        }
        if let acceleratorId = self.acceleratorId {
            try encodeContainer.encode(acceleratorId, forKey: .acceleratorId)
        }
        if let acceleratorType = self.acceleratorType {
            try encodeContainer.encode(acceleratorType, forKey: .acceleratorType)
        }
        if let attachedResource = self.attachedResource {
            try encodeContainer.encode(attachedResource, forKey: .attachedResource)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorHealthDecoded = try containerValues.decodeIfPresent(ElasticInferenceClientTypes.ElasticInferenceAcceleratorHealth.self, forKey: .acceleratorHealth)
        acceleratorHealth = acceleratorHealthDecoded
        let acceleratorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorType)
        acceleratorType = acceleratorTypeDecoded
        let acceleratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceleratorId)
        acceleratorId = acceleratorIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let attachedResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedResource)
        attachedResource = attachedResourceDecoded
    }
}

extension ElasticInferenceClientTypes {
    /// The details of an Elastic Inference Accelerator.
    public struct ElasticInferenceAccelerator: Swift.Equatable {
        /// The health of the Elastic Inference Accelerator.
        public var acceleratorHealth: ElasticInferenceClientTypes.ElasticInferenceAcceleratorHealth?
        /// The ID of the Elastic Inference Accelerator.
        public var acceleratorId: Swift.String?
        /// The type of the Elastic Inference Accelerator.
        public var acceleratorType: Swift.String?
        /// The ARN of the resource that the Elastic Inference Accelerator is attached to.
        public var attachedResource: Swift.String?
        /// The availability zone where the Elastic Inference Accelerator is present.
        public var availabilityZone: Swift.String?

        public init(
            acceleratorHealth: ElasticInferenceClientTypes.ElasticInferenceAcceleratorHealth? = nil,
            acceleratorId: Swift.String? = nil,
            acceleratorType: Swift.String? = nil,
            attachedResource: Swift.String? = nil,
            availabilityZone: Swift.String? = nil
        )
        {
            self.acceleratorHealth = acceleratorHealth
            self.acceleratorId = acceleratorId
            self.acceleratorType = acceleratorType
            self.attachedResource = attachedResource
            self.availabilityZone = availabilityZone
        }
    }

}

extension ElasticInferenceClientTypes.ElasticInferenceAcceleratorHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ElasticInferenceClientTypes {
    /// The health details of an Elastic Inference Accelerator.
    public struct ElasticInferenceAcceleratorHealth: Swift.Equatable {
        /// The health status of the Elastic Inference Accelerator.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension ElasticInferenceClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ElasticInferenceClientTypes {
    /// A filter expression for the Elastic Inference Accelerator list.
    public struct Filter: Swift.Equatable {
        /// The filter name for the Elastic Inference Accelerator list. It can assume the following values: accelerator-type: the type of Elastic Inference Accelerator to filter for. instance-id: an EC2 instance id to filter for.
        public var name: Swift.String?
        /// The values for the filter of the Elastic Inference Accelerator list.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when an unexpected error occurred during request processing.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticInferenceClientTypes.KeyValuePair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
    }
}

extension ElasticInferenceClientTypes {
    /// A throughput entry for an Elastic Inference Accelerator type.
    public struct KeyValuePair: Swift.Equatable {
        /// The throughput value of the Elastic Inference Accelerator type. It can assume the following values: TFLOPS16bit: the throughput expressed in 16bit TeraFLOPS. TFLOPS32bit: the throughput expressed in 32bit TeraFLOPS.
        public var key: Swift.String?
        /// The throughput value of the Elastic Inference Accelerator type.
        public var value: Swift.Int

        public init(
            key: Swift.String? = nil,
            value: Swift.Int = 0
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the Elastic Inference Accelerator to list the tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags of the Elastic Inference Accelerator.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ElasticInferenceClientTypes {
    public enum LocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case availabilityZone
        case availabilityZoneId
        case region
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationType] {
            return [
                .availabilityZone,
                .availabilityZoneId,
                .region,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .availabilityZone: return "availability-zone"
            case .availabilityZoneId: return "availability-zone-id"
            case .region: return "region"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
        }
    }
}

extension ElasticInferenceClientTypes.MemoryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInMiB
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if sizeInMiB != 0 {
            try encodeContainer.encode(sizeInMiB, forKey: .sizeInMiB)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeInMiBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeInMiB) ?? 0
        sizeInMiB = sizeInMiBDecoded
    }
}

extension ElasticInferenceClientTypes {
    /// The memory information of an Elastic Inference Accelerator type.
    public struct MemoryInfo: Swift.Equatable {
        /// The size in mebibytes of the Elastic Inference Accelerator type.
        public var sizeInMiB: Swift.Int

        public init(
            sizeInMiB: Swift.Int = 0
        )
        {
            self.sizeInMiB = sizeInMiB
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Raised when the requested resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the Elastic Inference Accelerator to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the Elastic Inference Accelerator.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the Elastic Inference Accelerator to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to remove from the Elastic Inference Accelerator.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
