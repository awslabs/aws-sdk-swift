// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RedshiftClient {
    /// Paginate over `[DescribeClusterDbRevisionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterDbRevisionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterDbRevisionsOutputResponse`
    public func describeClusterDbRevisionsPaginated(input: DescribeClusterDbRevisionsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutputResponse>(input: input, inputKey: \DescribeClusterDbRevisionsInput.marker, outputKey: \DescribeClusterDbRevisionsOutputResponse.marker, paginationFunction: self.describeClusterDbRevisions(input:))
    }
}

extension DescribeClusterDbRevisionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterDbRevisionsInput {
        return DescribeClusterDbRevisionsInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where Input == DescribeClusterDbRevisionsInput, Output == DescribeClusterDbRevisionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterDbRevisionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterDbRevision]`
    /// - Returns: `[RedshiftClientTypes.ClusterDbRevision]`
    public func clusterDbRevisions() async throws -> [RedshiftClientTypes.ClusterDbRevision] {
        return try await self.asyncCompactMap { item in item.clusterDbRevisions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterParameterGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterParameterGroupsOutputResponse`
    public func describeClusterParameterGroupsPaginated(input: DescribeClusterParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutputResponse>(input: input, inputKey: \DescribeClusterParameterGroupsInput.marker, outputKey: \DescribeClusterParameterGroupsOutputResponse.marker, paginationFunction: self.describeClusterParameterGroups(input:))
    }
}

extension DescribeClusterParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterParameterGroupsInput {
        return DescribeClusterParameterGroupsInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeClusterParameterGroupsInput, Output == DescribeClusterParameterGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterParameterGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterParameterGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterParameterGroup]`
    public func parameterGroups() async throws -> [RedshiftClientTypes.ClusterParameterGroup] {
        return try await self.asyncCompactMap { item in item.parameterGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterParametersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterParametersOutputResponse`
    public func describeClusterParametersPaginated(input: DescribeClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeClusterParametersInput, DescribeClusterParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterParametersInput, DescribeClusterParametersOutputResponse>(input: input, inputKey: \DescribeClusterParametersInput.marker, outputKey: \DescribeClusterParametersOutputResponse.marker, paginationFunction: self.describeClusterParameters(input:))
    }
}

extension DescribeClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterParametersInput {
        return DescribeClusterParametersInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            source: self.source
        )}
}

extension PaginatorSequence where Input == DescribeClusterParametersInput, Output == DescribeClusterParametersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterParametersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Parameter]`
    /// - Returns: `[RedshiftClientTypes.Parameter]`
    public func parameters() async throws -> [RedshiftClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClustersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClustersOutputResponse`
    public func describeClustersPaginated(input: DescribeClustersInput) -> ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutputResponse>(input: input, inputKey: \DescribeClustersInput.marker, outputKey: \DescribeClustersOutputResponse.marker, paginationFunction: self.describeClusters(input:))
    }
}

extension DescribeClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClustersInput {
        return DescribeClustersInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeClustersInput, Output == DescribeClustersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClustersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Cluster]`
    /// - Returns: `[RedshiftClientTypes.Cluster]`
    public func clusters() async throws -> [RedshiftClientTypes.Cluster] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSecurityGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSecurityGroupsOutputResponse`
    public func describeClusterSecurityGroupsPaginated(input: DescribeClusterSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutputResponse>(input: input, inputKey: \DescribeClusterSecurityGroupsInput.marker, outputKey: \DescribeClusterSecurityGroupsOutputResponse.marker, paginationFunction: self.describeClusterSecurityGroups(input:))
    }
}

extension DescribeClusterSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSecurityGroupsInput {
        return DescribeClusterSecurityGroupsInput(
            clusterSecurityGroupName: self.clusterSecurityGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeClusterSecurityGroupsInput, Output == DescribeClusterSecurityGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSecurityGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterSecurityGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterSecurityGroup]`
    public func clusterSecurityGroups() async throws -> [RedshiftClientTypes.ClusterSecurityGroup] {
        return try await self.asyncCompactMap { item in item.clusterSecurityGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSnapshotsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSnapshotsOutputResponse`
    public func describeClusterSnapshotsPaginated(input: DescribeClusterSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutputResponse>(input: input, inputKey: \DescribeClusterSnapshotsInput.marker, outputKey: \DescribeClusterSnapshotsOutputResponse.marker, paginationFunction: self.describeClusterSnapshots(input:))
    }
}

extension DescribeClusterSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSnapshotsInput {
        return DescribeClusterSnapshotsInput(
            clusterExists: self.clusterExists,
            clusterIdentifier: self.clusterIdentifier,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotArn: self.snapshotArn,
            snapshotIdentifier: self.snapshotIdentifier,
            snapshotType: self.snapshotType,
            sortingEntities: self.sortingEntities,
            startTime: self.startTime,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeClusterSnapshotsInput, Output == DescribeClusterSnapshotsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSnapshotsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Snapshot]`
    /// - Returns: `[RedshiftClientTypes.Snapshot]`
    public func snapshots() async throws -> [RedshiftClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSubnetGroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSubnetGroupsOutputResponse`
    public func describeClusterSubnetGroupsPaginated(input: DescribeClusterSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutputResponse>(input: input, inputKey: \DescribeClusterSubnetGroupsInput.marker, outputKey: \DescribeClusterSubnetGroupsOutputResponse.marker, paginationFunction: self.describeClusterSubnetGroups(input:))
    }
}

extension DescribeClusterSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSubnetGroupsInput {
        return DescribeClusterSubnetGroupsInput(
            clusterSubnetGroupName: self.clusterSubnetGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeClusterSubnetGroupsInput, Output == DescribeClusterSubnetGroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSubnetGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterSubnetGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterSubnetGroup]`
    public func clusterSubnetGroups() async throws -> [RedshiftClientTypes.ClusterSubnetGroup] {
        return try await self.asyncCompactMap { item in item.clusterSubnetGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterTracksOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterTracksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterTracksOutputResponse`
    public func describeClusterTracksPaginated(input: DescribeClusterTracksInput) -> ClientRuntime.PaginatorSequence<DescribeClusterTracksInput, DescribeClusterTracksOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterTracksInput, DescribeClusterTracksOutputResponse>(input: input, inputKey: \DescribeClusterTracksInput.marker, outputKey: \DescribeClusterTracksOutputResponse.marker, paginationFunction: self.describeClusterTracks(input:))
    }
}

extension DescribeClusterTracksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterTracksInput {
        return DescribeClusterTracksInput(
            maintenanceTrackName: self.maintenanceTrackName,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where Input == DescribeClusterTracksInput, Output == DescribeClusterTracksOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterTracksPaginated`
    /// to access the nested member `[RedshiftClientTypes.MaintenanceTrack]`
    /// - Returns: `[RedshiftClientTypes.MaintenanceTrack]`
    public func maintenanceTracks() async throws -> [RedshiftClientTypes.MaintenanceTrack] {
        return try await self.asyncCompactMap { item in item.maintenanceTracks }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterVersionsOutputResponse`
    public func describeClusterVersionsPaginated(input: DescribeClusterVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterVersionsInput, DescribeClusterVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeClusterVersionsInput, DescribeClusterVersionsOutputResponse>(input: input, inputKey: \DescribeClusterVersionsInput.marker, outputKey: \DescribeClusterVersionsOutputResponse.marker, paginationFunction: self.describeClusterVersions(input:))
    }
}

extension DescribeClusterVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterVersionsInput {
        return DescribeClusterVersionsInput(
            clusterParameterGroupFamily: self.clusterParameterGroupFamily,
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where Input == DescribeClusterVersionsInput, Output == DescribeClusterVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterVersionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterVersion]`
    /// - Returns: `[RedshiftClientTypes.ClusterVersion]`
    public func clusterVersions() async throws -> [RedshiftClientTypes.ClusterVersion] {
        return try await self.asyncCompactMap { item in item.clusterVersions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesOutputResponse`
    public func describeDataSharesPaginated(input: DescribeDataSharesInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesInput, DescribeDataSharesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesInput, DescribeDataSharesOutputResponse>(input: input, inputKey: \DescribeDataSharesInput.marker, outputKey: \DescribeDataSharesOutputResponse.marker, paginationFunction: self.describeDataShares(input:))
    }
}

extension DescribeDataSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesInput {
        return DescribeDataSharesInput(
            dataShareArn: self.dataShareArn,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where Input == DescribeDataSharesInput, Output == DescribeDataSharesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesForConsumerOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesForConsumerInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesForConsumerOutputResponse`
    public func describeDataSharesForConsumerPaginated(input: DescribeDataSharesForConsumerInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesForConsumerInput, DescribeDataSharesForConsumerOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesForConsumerInput, DescribeDataSharesForConsumerOutputResponse>(input: input, inputKey: \DescribeDataSharesForConsumerInput.marker, outputKey: \DescribeDataSharesForConsumerOutputResponse.marker, paginationFunction: self.describeDataSharesForConsumer(input:))
    }
}

extension DescribeDataSharesForConsumerInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesForConsumerInput {
        return DescribeDataSharesForConsumerInput(
            consumerArn: self.consumerArn,
            marker: token,
            maxRecords: self.maxRecords,
            status: self.status
        )}
}

extension PaginatorSequence where Input == DescribeDataSharesForConsumerInput, Output == DescribeDataSharesForConsumerOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesForConsumerPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesForProducerOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesForProducerInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesForProducerOutputResponse`
    public func describeDataSharesForProducerPaginated(input: DescribeDataSharesForProducerInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesForProducerInput, DescribeDataSharesForProducerOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesForProducerInput, DescribeDataSharesForProducerOutputResponse>(input: input, inputKey: \DescribeDataSharesForProducerInput.marker, outputKey: \DescribeDataSharesForProducerOutputResponse.marker, paginationFunction: self.describeDataSharesForProducer(input:))
    }
}

extension DescribeDataSharesForProducerInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesForProducerInput {
        return DescribeDataSharesForProducerInput(
            marker: token,
            maxRecords: self.maxRecords,
            producerArn: self.producerArn,
            status: self.status
        )}
}

extension PaginatorSequence where Input == DescribeDataSharesForProducerInput, Output == DescribeDataSharesForProducerOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesForProducerPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDefaultClusterParametersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDefaultClusterParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDefaultClusterParametersOutputResponse`
    public func describeDefaultClusterParametersPaginated(input: DescribeDefaultClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutputResponse>(input: input, inputKey: \DescribeDefaultClusterParametersInput.marker, outputKey: \DescribeDefaultClusterParametersOutputResponse.defaultClusterParameters?.marker, paginationFunction: self.describeDefaultClusterParameters(input:))
    }
}

extension DescribeDefaultClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDefaultClusterParametersInput {
        return DescribeDefaultClusterParametersInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupFamily: self.parameterGroupFamily
        )}
}

extension PaginatorSequence where Input == DescribeDefaultClusterParametersInput, Output == DescribeDefaultClusterParametersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeDefaultClusterParametersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Parameter]`
    /// - Returns: `[RedshiftClientTypes.Parameter]`
    public func parameters() async throws -> [RedshiftClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.defaultClusterParameters?.parameters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEndpointAccessOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointAccessInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointAccessOutputResponse`
    public func describeEndpointAccessPaginated(input: DescribeEndpointAccessInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointAccessInput, DescribeEndpointAccessOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointAccessInput, DescribeEndpointAccessOutputResponse>(input: input, inputKey: \DescribeEndpointAccessInput.marker, outputKey: \DescribeEndpointAccessOutputResponse.marker, paginationFunction: self.describeEndpointAccess(input:))
    }
}

extension DescribeEndpointAccessInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointAccessInput {
        return DescribeEndpointAccessInput(
            clusterIdentifier: self.clusterIdentifier,
            endpointName: self.endpointName,
            marker: token,
            maxRecords: self.maxRecords,
            resourceOwner: self.resourceOwner,
            vpcId: self.vpcId
        )}
}

extension PaginatorSequence where Input == DescribeEndpointAccessInput, Output == DescribeEndpointAccessOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeEndpointAccessPaginated`
    /// to access the nested member `[RedshiftClientTypes.EndpointAccess]`
    /// - Returns: `[RedshiftClientTypes.EndpointAccess]`
    public func endpointAccessList() async throws -> [RedshiftClientTypes.EndpointAccess] {
        return try await self.asyncCompactMap { item in item.endpointAccessList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEndpointAuthorizationOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointAuthorizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointAuthorizationOutputResponse`
    public func describeEndpointAuthorizationPaginated(input: DescribeEndpointAuthorizationInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutputResponse>(input: input, inputKey: \DescribeEndpointAuthorizationInput.marker, outputKey: \DescribeEndpointAuthorizationOutputResponse.marker, paginationFunction: self.describeEndpointAuthorization(input:))
    }
}

extension DescribeEndpointAuthorizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointAuthorizationInput {
        return DescribeEndpointAuthorizationInput(
            account: self.account,
            clusterIdentifier: self.clusterIdentifier,
            grantee: self.grantee,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where Input == DescribeEndpointAuthorizationInput, Output == DescribeEndpointAuthorizationOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeEndpointAuthorizationPaginated`
    /// to access the nested member `[RedshiftClientTypes.EndpointAuthorization]`
    /// - Returns: `[RedshiftClientTypes.EndpointAuthorization]`
    public func endpointAuthorizationList() async throws -> [RedshiftClientTypes.EndpointAuthorization] {
        return try await self.asyncCompactMap { item in item.endpointAuthorizationList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEventsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutputResponse`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutputResponse>(input: input, inputKey: \DescribeEventsInput.marker, outputKey: \DescribeEventsOutputResponse.marker, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where Input == DescribeEventsInput, Output == DescribeEventsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Event]`
    /// - Returns: `[RedshiftClientTypes.Event]`
    public func events() async throws -> [RedshiftClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEventSubscriptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventSubscriptionsOutputResponse`
    public func describeEventSubscriptionsPaginated(input: DescribeEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutputResponse>(input: input, inputKey: \DescribeEventSubscriptionsInput.marker, outputKey: \DescribeEventSubscriptionsOutputResponse.marker, paginationFunction: self.describeEventSubscriptions(input:))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventSubscriptionsInput {
        return DescribeEventSubscriptionsInput(
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeEventSubscriptionsInput, Output == DescribeEventSubscriptionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventSubscriptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.EventSubscription]`
    /// - Returns: `[RedshiftClientTypes.EventSubscription]`
    public func eventSubscriptionsList() async throws -> [RedshiftClientTypes.EventSubscription] {
        return try await self.asyncCompactMap { item in item.eventSubscriptionsList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeHsmClientCertificatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeHsmClientCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeHsmClientCertificatesOutputResponse`
    public func describeHsmClientCertificatesPaginated(input: DescribeHsmClientCertificatesInput) -> ClientRuntime.PaginatorSequence<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutputResponse>(input: input, inputKey: \DescribeHsmClientCertificatesInput.marker, outputKey: \DescribeHsmClientCertificatesOutputResponse.marker, paginationFunction: self.describeHsmClientCertificates(input:))
    }
}

extension DescribeHsmClientCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHsmClientCertificatesInput {
        return DescribeHsmClientCertificatesInput(
            hsmClientCertificateIdentifier: self.hsmClientCertificateIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeHsmClientCertificatesInput, Output == DescribeHsmClientCertificatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeHsmClientCertificatesPaginated`
    /// to access the nested member `[RedshiftClientTypes.HsmClientCertificate]`
    /// - Returns: `[RedshiftClientTypes.HsmClientCertificate]`
    public func hsmClientCertificates() async throws -> [RedshiftClientTypes.HsmClientCertificate] {
        return try await self.asyncCompactMap { item in item.hsmClientCertificates }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeHsmConfigurationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeHsmConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeHsmConfigurationsOutputResponse`
    public func describeHsmConfigurationsPaginated(input: DescribeHsmConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutputResponse>(input: input, inputKey: \DescribeHsmConfigurationsInput.marker, outputKey: \DescribeHsmConfigurationsOutputResponse.marker, paginationFunction: self.describeHsmConfigurations(input:))
    }
}

extension DescribeHsmConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHsmConfigurationsInput {
        return DescribeHsmConfigurationsInput(
            hsmConfigurationIdentifier: self.hsmConfigurationIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeHsmConfigurationsInput, Output == DescribeHsmConfigurationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeHsmConfigurationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.HsmConfiguration]`
    /// - Returns: `[RedshiftClientTypes.HsmConfiguration]`
    public func hsmConfigurations() async throws -> [RedshiftClientTypes.HsmConfiguration] {
        return try await self.asyncCompactMap { item in item.hsmConfigurations }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeNodeConfigurationOptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeNodeConfigurationOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeNodeConfigurationOptionsOutputResponse`
    public func describeNodeConfigurationOptionsPaginated(input: DescribeNodeConfigurationOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutputResponse>(input: input, inputKey: \DescribeNodeConfigurationOptionsInput.marker, outputKey: \DescribeNodeConfigurationOptionsOutputResponse.marker, paginationFunction: self.describeNodeConfigurationOptions(input:))
    }
}

extension DescribeNodeConfigurationOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNodeConfigurationOptionsInput {
        return DescribeNodeConfigurationOptionsInput(
            actionType: self.actionType,
            clusterIdentifier: self.clusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotArn: self.snapshotArn,
            snapshotIdentifier: self.snapshotIdentifier
        )}
}

extension PaginatorSequence where Input == DescribeNodeConfigurationOptionsInput, Output == DescribeNodeConfigurationOptionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeNodeConfigurationOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.NodeConfigurationOption]`
    /// - Returns: `[RedshiftClientTypes.NodeConfigurationOption]`
    public func nodeConfigurationOptionList() async throws -> [RedshiftClientTypes.NodeConfigurationOption] {
        return try await self.asyncCompactMap { item in item.nodeConfigurationOptionList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeOrderableClusterOptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOrderableClusterOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOrderableClusterOptionsOutputResponse`
    public func describeOrderableClusterOptionsPaginated(input: DescribeOrderableClusterOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutputResponse>(input: input, inputKey: \DescribeOrderableClusterOptionsInput.marker, outputKey: \DescribeOrderableClusterOptionsOutputResponse.marker, paginationFunction: self.describeOrderableClusterOptions(input:))
    }
}

extension DescribeOrderableClusterOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrderableClusterOptionsInput {
        return DescribeOrderableClusterOptionsInput(
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords,
            nodeType: self.nodeType
        )}
}

extension PaginatorSequence where Input == DescribeOrderableClusterOptionsInput, Output == DescribeOrderableClusterOptionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeOrderableClusterOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.OrderableClusterOption]`
    /// - Returns: `[RedshiftClientTypes.OrderableClusterOption]`
    public func orderableClusterOptions() async throws -> [RedshiftClientTypes.OrderableClusterOption] {
        return try await self.asyncCompactMap { item in item.orderableClusterOptions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodeExchangeStatusOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodeExchangeStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodeExchangeStatusOutputResponse`
    public func describeReservedNodeExchangeStatusPaginated(input: DescribeReservedNodeExchangeStatusInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodeExchangeStatusInput, DescribeReservedNodeExchangeStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodeExchangeStatusInput, DescribeReservedNodeExchangeStatusOutputResponse>(input: input, inputKey: \DescribeReservedNodeExchangeStatusInput.marker, outputKey: \DescribeReservedNodeExchangeStatusOutputResponse.marker, paginationFunction: self.describeReservedNodeExchangeStatus(input:))
    }
}

extension DescribeReservedNodeExchangeStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodeExchangeStatusInput {
        return DescribeReservedNodeExchangeStatusInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeExchangeRequestId: self.reservedNodeExchangeRequestId,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where Input == DescribeReservedNodeExchangeStatusInput, Output == DescribeReservedNodeExchangeStatusOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodeExchangeStatusPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeExchangeStatus]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeExchangeStatus]`
    public func reservedNodeExchangeStatusDetails() async throws -> [RedshiftClientTypes.ReservedNodeExchangeStatus] {
        return try await self.asyncCompactMap { item in item.reservedNodeExchangeStatusDetails }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodeOfferingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodeOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodeOfferingsOutputResponse`
    public func describeReservedNodeOfferingsPaginated(input: DescribeReservedNodeOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutputResponse>(input: input, inputKey: \DescribeReservedNodeOfferingsInput.marker, outputKey: \DescribeReservedNodeOfferingsOutputResponse.marker, paginationFunction: self.describeReservedNodeOfferings(input:))
    }
}

extension DescribeReservedNodeOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodeOfferingsInput {
        return DescribeReservedNodeOfferingsInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeOfferingId: self.reservedNodeOfferingId
        )}
}

extension PaginatorSequence where Input == DescribeReservedNodeOfferingsInput, Output == DescribeReservedNodeOfferingsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodeOfferingsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeOffering]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeOffering]`
    public func reservedNodeOfferings() async throws -> [RedshiftClientTypes.ReservedNodeOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodeOfferings }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOutputResponse`
    public func describeReservedNodesPaginated(input: DescribeReservedNodesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutputResponse>(input: input, inputKey: \DescribeReservedNodesInput.marker, outputKey: \DescribeReservedNodesOutputResponse.marker, paginationFunction: self.describeReservedNodes(input:))
    }
}

extension DescribeReservedNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesInput {
        return DescribeReservedNodesInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where Input == DescribeReservedNodesInput, Output == DescribeReservedNodesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNode]`
    /// - Returns: `[RedshiftClientTypes.ReservedNode]`
    public func reservedNodes() async throws -> [RedshiftClientTypes.ReservedNode] {
        return try await self.asyncCompactMap { item in item.reservedNodes }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeScheduledActionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduledActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledActionsOutputResponse`
    public func describeScheduledActionsPaginated(input: DescribeScheduledActionsInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutputResponse>(input: input, inputKey: \DescribeScheduledActionsInput.marker, outputKey: \DescribeScheduledActionsOutputResponse.marker, paginationFunction: self.describeScheduledActions(input:))
    }
}

extension DescribeScheduledActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledActionsInput {
        return DescribeScheduledActionsInput(
            active: self.active,
            endTime: self.endTime,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            scheduledActionName: self.scheduledActionName,
            startTime: self.startTime,
            targetActionType: self.targetActionType
        )}
}

extension PaginatorSequence where Input == DescribeScheduledActionsInput, Output == DescribeScheduledActionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeScheduledActionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ScheduledAction]`
    /// - Returns: `[RedshiftClientTypes.ScheduledAction]`
    public func scheduledActions() async throws -> [RedshiftClientTypes.ScheduledAction] {
        return try await self.asyncCompactMap { item in item.scheduledActions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeSnapshotCopyGrantsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotCopyGrantsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotCopyGrantsOutputResponse`
    public func describeSnapshotCopyGrantsPaginated(input: DescribeSnapshotCopyGrantsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutputResponse>(input: input, inputKey: \DescribeSnapshotCopyGrantsInput.marker, outputKey: \DescribeSnapshotCopyGrantsOutputResponse.marker, paginationFunction: self.describeSnapshotCopyGrants(input:))
    }
}

extension DescribeSnapshotCopyGrantsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotCopyGrantsInput {
        return DescribeSnapshotCopyGrantsInput(
            marker: token,
            maxRecords: self.maxRecords,
            snapshotCopyGrantName: self.snapshotCopyGrantName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeSnapshotCopyGrantsInput, Output == DescribeSnapshotCopyGrantsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotCopyGrantsPaginated`
    /// to access the nested member `[RedshiftClientTypes.SnapshotCopyGrant]`
    /// - Returns: `[RedshiftClientTypes.SnapshotCopyGrant]`
    public func snapshotCopyGrants() async throws -> [RedshiftClientTypes.SnapshotCopyGrant] {
        return try await self.asyncCompactMap { item in item.snapshotCopyGrants }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeSnapshotSchedulesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotSchedulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotSchedulesOutputResponse`
    public func describeSnapshotSchedulesPaginated(input: DescribeSnapshotSchedulesInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutputResponse>(input: input, inputKey: \DescribeSnapshotSchedulesInput.marker, outputKey: \DescribeSnapshotSchedulesOutputResponse.marker, paginationFunction: self.describeSnapshotSchedules(input:))
    }
}

extension DescribeSnapshotSchedulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotSchedulesInput {
        return DescribeSnapshotSchedulesInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            scheduleIdentifier: self.scheduleIdentifier,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeSnapshotSchedulesInput, Output == DescribeSnapshotSchedulesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotSchedulesPaginated`
    /// to access the nested member `[RedshiftClientTypes.SnapshotSchedule]`
    /// - Returns: `[RedshiftClientTypes.SnapshotSchedule]`
    public func snapshotSchedules() async throws -> [RedshiftClientTypes.SnapshotSchedule] {
        return try await self.asyncCompactMap { item in item.snapshotSchedules }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeTableRestoreStatusOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTableRestoreStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTableRestoreStatusOutputResponse`
    public func describeTableRestoreStatusPaginated(input: DescribeTableRestoreStatusInput) -> ClientRuntime.PaginatorSequence<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutputResponse>(input: input, inputKey: \DescribeTableRestoreStatusInput.marker, outputKey: \DescribeTableRestoreStatusOutputResponse.marker, paginationFunction: self.describeTableRestoreStatus(input:))
    }
}

extension DescribeTableRestoreStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTableRestoreStatusInput {
        return DescribeTableRestoreStatusInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tableRestoreRequestId: self.tableRestoreRequestId
        )}
}

extension PaginatorSequence where Input == DescribeTableRestoreStatusInput, Output == DescribeTableRestoreStatusOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeTableRestoreStatusPaginated`
    /// to access the nested member `[RedshiftClientTypes.TableRestoreStatus]`
    /// - Returns: `[RedshiftClientTypes.TableRestoreStatus]`
    public func tableRestoreStatusDetails() async throws -> [RedshiftClientTypes.TableRestoreStatus] {
        return try await self.asyncCompactMap { item in item.tableRestoreStatusDetails }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeTagsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTagsOutputResponse`
    public func describeTagsPaginated(input: DescribeTagsInput) -> ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutputResponse>(input: input, inputKey: \DescribeTagsInput.marker, outputKey: \DescribeTagsOutputResponse.marker, paginationFunction: self.describeTags(input:))
    }
}

extension DescribeTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTagsInput {
        return DescribeTagsInput(
            marker: token,
            maxRecords: self.maxRecords,
            resourceName: self.resourceName,
            resourceType: self.resourceType,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where Input == DescribeTagsInput, Output == DescribeTagsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeTagsPaginated`
    /// to access the nested member `[RedshiftClientTypes.TaggedResource]`
    /// - Returns: `[RedshiftClientTypes.TaggedResource]`
    public func taggedResources() async throws -> [RedshiftClientTypes.TaggedResource] {
        return try await self.asyncCompactMap { item in item.taggedResources }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeUsageLimitsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeUsageLimitsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeUsageLimitsOutputResponse`
    public func describeUsageLimitsPaginated(input: DescribeUsageLimitsInput) -> ClientRuntime.PaginatorSequence<DescribeUsageLimitsInput, DescribeUsageLimitsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeUsageLimitsInput, DescribeUsageLimitsOutputResponse>(input: input, inputKey: \DescribeUsageLimitsInput.marker, outputKey: \DescribeUsageLimitsOutputResponse.marker, paginationFunction: self.describeUsageLimits(input:))
    }
}

extension DescribeUsageLimitsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeUsageLimitsInput {
        return DescribeUsageLimitsInput(
            clusterIdentifier: self.clusterIdentifier,
            featureType: self.featureType,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues,
            usageLimitId: self.usageLimitId
        )}
}

extension PaginatorSequence where Input == DescribeUsageLimitsInput, Output == DescribeUsageLimitsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeUsageLimitsPaginated`
    /// to access the nested member `[RedshiftClientTypes.UsageLimit]`
    /// - Returns: `[RedshiftClientTypes.UsageLimit]`
    public func usageLimits() async throws -> [RedshiftClientTypes.UsageLimit] {
        return try await self.asyncCompactMap { item in item.usageLimits }
    }
}
extension RedshiftClient {
    /// Paginate over `[GetReservedNodeExchangeConfigurationOptionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReservedNodeExchangeConfigurationOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReservedNodeExchangeConfigurationOptionsOutputResponse`
    public func getReservedNodeExchangeConfigurationOptionsPaginated(input: GetReservedNodeExchangeConfigurationOptionsInput) -> ClientRuntime.PaginatorSequence<GetReservedNodeExchangeConfigurationOptionsInput, GetReservedNodeExchangeConfigurationOptionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetReservedNodeExchangeConfigurationOptionsInput, GetReservedNodeExchangeConfigurationOptionsOutputResponse>(input: input, inputKey: \GetReservedNodeExchangeConfigurationOptionsInput.marker, outputKey: \GetReservedNodeExchangeConfigurationOptionsOutputResponse.marker, paginationFunction: self.getReservedNodeExchangeConfigurationOptions(input:))
    }
}

extension GetReservedNodeExchangeConfigurationOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReservedNodeExchangeConfigurationOptionsInput {
        return GetReservedNodeExchangeConfigurationOptionsInput(
            actionType: self.actionType,
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotIdentifier: self.snapshotIdentifier
        )}
}

extension PaginatorSequence where Input == GetReservedNodeExchangeConfigurationOptionsInput, Output == GetReservedNodeExchangeConfigurationOptionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `getReservedNodeExchangeConfigurationOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeConfigurationOption]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeConfigurationOption]`
    public func reservedNodeConfigurationOptionList() async throws -> [RedshiftClientTypes.ReservedNodeConfigurationOption] {
        return try await self.asyncCompactMap { item in item.reservedNodeConfigurationOptionList }
    }
}
extension RedshiftClient {
    /// Paginate over `[GetReservedNodeExchangeOfferingsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReservedNodeExchangeOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReservedNodeExchangeOfferingsOutputResponse`
    public func getReservedNodeExchangeOfferingsPaginated(input: GetReservedNodeExchangeOfferingsInput) -> ClientRuntime.PaginatorSequence<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutputResponse>(input: input, inputKey: \GetReservedNodeExchangeOfferingsInput.marker, outputKey: \GetReservedNodeExchangeOfferingsOutputResponse.marker, paginationFunction: self.getReservedNodeExchangeOfferings(input:))
    }
}

extension GetReservedNodeExchangeOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReservedNodeExchangeOfferingsInput {
        return GetReservedNodeExchangeOfferingsInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where Input == GetReservedNodeExchangeOfferingsInput, Output == GetReservedNodeExchangeOfferingsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `getReservedNodeExchangeOfferingsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeOffering]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeOffering]`
    public func reservedNodeOfferings() async throws -> [RedshiftClientTypes.ReservedNodeOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodeOfferings }
    }
}
