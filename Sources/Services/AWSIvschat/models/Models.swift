// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    public enum ChatTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteMessage
        case disconnectUser
        case sendMessage
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatTokenCapability] {
            return [
                .deleteMessage,
                .disconnectUser,
                .sendMessage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteMessage: return "DELETE_MESSAGE"
            case .disconnectUser: return "DISCONNECT_USER"
            case .sendMessage: return "SEND_MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatTokenCapability(rawValue: rawValue) ?? ChatTokenCapability.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.CloudWatchLogsDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies a CloudWatch Logs location where chat logs will be stored.
    public struct CloudWatchLogsDestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon Cloudwatch Logs destination where chat activity will be logged.
        /// This member is required.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateChatTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, chatTokenAttributes0) in attributes {
                try attributesContainer.encode(chatTokenAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for chattokencapability0 in capabilities {
                try capabilitiesContainer.encode(chattokencapability0.rawValue)
            }
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if sessionDurationInMinutes != 0 {
            try encodeContainer.encode(sessionDurationInMinutes, forKey: .sessionDurationInMinutes)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateChatTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateChatToken"
    }
}

public struct CreateChatTokenInput: Swift.Equatable {
    /// Application-provided attributes to encode into the token and attach to a chat session. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the room. Default: None (the capability to view messages is implicitly included in all requests).
    public var capabilities: [IvschatClientTypes.ChatTokenCapability]?
    /// Identifier of the room that the client is trying to access. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// Session duration (in minutes), after which the session expires. Default: 60 (1 hour).
    public var sessionDurationInMinutes: Swift.Int
    /// Application-provided ID that uniquely identifies the user associated with this token. This can be any UTF-8 encoded text.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        capabilities: [IvschatClientTypes.ChatTokenCapability]? = nil,
        roomIdentifier: Swift.String? = nil,
        sessionDurationInMinutes: Swift.Int = 0,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.roomIdentifier = roomIdentifier
        self.sessionDurationInMinutes = sessionDurationInMinutes
        self.userId = userId
    }
}

struct CreateChatTokenInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let capabilities: [IvschatClientTypes.ChatTokenCapability]?
    let sessionDurationInMinutes: Swift.Int
    let attributes: [Swift.String:Swift.String]?
}

extension CreateChatTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case capabilities
        case roomIdentifier
        case sessionDurationInMinutes
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ChatTokenCapability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[IvschatClientTypes.ChatTokenCapability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [IvschatClientTypes.ChatTokenCapability]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let sessionDurationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionDurationInMinutes) ?? 0
        sessionDurationInMinutes = sessionDurationInMinutesDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CreateChatTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChatTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.sessionExpirationTime = output.sessionExpirationTime
            self.token = output.token
            self.tokenExpirationTime = output.tokenExpirationTime
        } else {
            self.sessionExpirationTime = nil
            self.token = nil
            self.tokenExpirationTime = nil
        }
    }
}

public struct CreateChatTokenOutput: Swift.Equatable {
    /// Time after which an end user's session is no longer valid. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var sessionExpirationTime: ClientRuntime.Date?
    /// The issued client token, encrypted.
    public var token: Swift.String?
    /// Time after which the token is no longer valid and cannot be used to connect to a room. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var tokenExpirationTime: ClientRuntime.Date?

    public init(
        sessionExpirationTime: ClientRuntime.Date? = nil,
        token: Swift.String? = nil,
        tokenExpirationTime: ClientRuntime.Date? = nil
    )
    {
        self.sessionExpirationTime = sessionExpirationTime
        self.token = token
        self.tokenExpirationTime = tokenExpirationTime
    }
}

struct CreateChatTokenOutputBody: Swift.Equatable {
    let token: Swift.String?
    let tokenExpirationTime: ClientRuntime.Date?
    let sessionExpirationTime: ClientRuntime.Date?
}

extension CreateChatTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionExpirationTime
        case token
        case tokenExpirationTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let tokenExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .tokenExpirationTime)
        tokenExpirationTime = tokenExpirationTimeDecoded
        let sessionExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .sessionExpirationTime)
        sessionExpirationTime = sessionExpirationTimeDecoded
    }
}

enum CreateChatTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLoggingConfiguration"
    }
}

public struct CreateLoggingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.tags = tags
    }
}

struct CreateLoggingConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct CreateLoggingConfigurationOutput: Swift.Equatable {
    /// Logging-configuration ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.CreateLoggingConfigurationState?
    /// Tags attached to the resource, from the request (if specified). Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.CreateLoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct CreateLoggingConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.CreateLoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.CreateLoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvschatClientTypes {
    public enum CreateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [CreateLoggingConfigurationState] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreateLoggingConfigurationState(rawValue: rawValue) ?? CreateLoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateRoom"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension CreateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct CreateRoomOutput: Swift.Equatable {
    /// Room ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource, from the request (if specified).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct CreateRoomOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension CreateRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

enum CreateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLoggingConfiguration"
    }
}

public struct DeleteLoggingConfigurationInput: Swift.Equatable {
    /// Identifier of the logging configuration to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLoggingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension DeleteMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteMessage"
    }
}

public struct DeleteMessageInput: Swift.Equatable {
    /// ID of the message to be deleted. This is the Id field in the received message (see [ Message (Subscribe)](https://docs.aws.amazon.com/ivs/latest/chatmsgapireference/actions-message-subscribe.html) in the Chat Messaging API).
    /// This member is required.
    public var id: Swift.String?
    /// Reason for deleting the message.
    public var reason: Swift.String?
    /// Identifier of the room where the message should be deleted. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init(
        id: Swift.String? = nil,
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.id = id
        self.reason = reason
        self.roomIdentifier = roomIdentifier
    }
}

struct DeleteMessageInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let id: Swift.String?
    let reason: Swift.String?
}

extension DeleteMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case reason
        case roomIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DeleteMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteMessageOutput: Swift.Equatable {
    /// Operation identifier, generated by Amazon IVS Chat.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteMessageOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum DeleteMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRoom"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// Identifier of the room to be deleted. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension DeleteRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension DeleteRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRoomOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvschatClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudwatchlogs = "cloudWatchLogs"
        case firehose
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cloudwatchlogs(cloudwatchlogs):
                try container.encode(cloudwatchlogs, forKey: .cloudwatchlogs)
            case let .firehose(firehose):
                try container.encode(firehose, forKey: .firehose)
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(IvschatClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        let cloudwatchlogsDecoded = try values.decodeIfPresent(IvschatClientTypes.CloudWatchLogsDestinationConfiguration.self, forKey: .cloudwatchlogs)
        if let cloudwatchlogs = cloudwatchlogsDecoded {
            self = .cloudwatchlogs(cloudwatchlogs)
            return
        }
        let firehoseDecoded = try values.decodeIfPresent(IvschatClientTypes.FirehoseDestinationConfiguration.self, forKey: .firehose)
        if let firehose = firehoseDecoded {
            self = .firehose(firehose)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IvschatClientTypes {
    /// A complex type that describes a location where chat logs will be stored. Each member represents the configuration of one log destination. For logging, you define only one type of destination (for CloudWatch Logs, Kinesis Firehose, or S3).
    public enum DestinationConfiguration: Swift.Equatable {
        /// An Amazon S3 destination configuration where chat activity will be logged.
        case s3(IvschatClientTypes.S3DestinationConfiguration)
        /// An Amazon CloudWatch Logs destination configuration where chat activity will be logged.
        case cloudwatchlogs(IvschatClientTypes.CloudWatchLogsDestinationConfiguration)
        /// An Amazon Kinesis Data Firehose destination configuration where chat activity will be logged.
        case firehose(IvschatClientTypes.FirehoseDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension DisconnectUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DisconnectUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectUser"
    }
}

public struct DisconnectUserInput: Swift.Equatable {
    /// Reason for disconnecting the user.
    public var reason: Swift.String?
    /// Identifier of the room from which the user's clients should be disconnected. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// ID of the user (connection) to disconnect from the room.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.roomIdentifier = roomIdentifier
        self.userId = userId
    }
}

struct DisconnectUserInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let userId: Swift.String?
    let reason: Swift.String?
}

extension DisconnectUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case roomIdentifier
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisconnectUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisconnectUserOutput: Swift.Equatable {

    public init() { }
}

enum DisconnectUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvschatClientTypes {
    public enum FallbackResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackResult] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FallbackResult(rawValue: rawValue) ?? FallbackResult.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.FirehoseDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamName = self.deliveryStreamName {
            try encodeContainer.encode(deliveryStreamName, forKey: .deliveryStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamName)
        deliveryStreamName = deliveryStreamNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies a Kinesis Firehose location where chat logs will be stored.
    public struct FirehoseDestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
        /// This member is required.
        public var deliveryStreamName: Swift.String?

        public init(
            deliveryStreamName: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
        }
    }

}

extension GetLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLoggingConfiguration"
    }
}

public struct GetLoggingConfigurationInput: Swift.Equatable {
    /// Identifier of the logging configuration to be retrieved.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetLoggingConfigurationOutput: Swift.Equatable {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name. This value does not need to be unique.
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.LoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.LoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetLoggingConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.LoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension GetLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.LoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetRoom"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// Identifier of the room for which the configuration is to be retrieved. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
}

extension GetRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension GetRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetRoomOutput: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetRoomOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension GetRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

enum GetRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListLoggingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLoggingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLoggingConfigurations"
    }
}

public struct ListLoggingConfigurationsInput: Swift.Equatable {
    /// Maximum number of logging configurations to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first logging configurations to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggingConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListLoggingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListLoggingConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLoggingConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfigurations = output.loggingConfigurations
            self.nextToken = output.nextToken
        } else {
            self.loggingConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListLoggingConfigurationsOutput: Swift.Equatable {
    /// List of the matching logging configurations (summary information only). There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]?
    /// If there are more logging configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurations = loggingConfigurations
        self.nextToken = nextToken
    }
}

struct ListLoggingConfigurationsOutputBody: Swift.Equatable {
    let loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListLoggingConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationsContainer = try containerValues.decodeIfPresent([IvschatClientTypes.LoggingConfigurationSummary?].self, forKey: .loggingConfigurations)
        var loggingConfigurationsDecoded0:[IvschatClientTypes.LoggingConfigurationSummary]? = nil
        if let loggingConfigurationsContainer = loggingConfigurationsContainer {
            loggingConfigurationsDecoded0 = [IvschatClientTypes.LoggingConfigurationSummary]()
            for structure0 in loggingConfigurationsContainer {
                if let structure0 = structure0 {
                    loggingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loggingConfigurations = loggingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLoggingConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRoomsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifier
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfigurationIdentifier = self.loggingConfigurationIdentifier {
            try encodeContainer.encode(loggingConfigurationIdentifier, forKey: .loggingConfigurationIdentifier)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let messageReviewHandlerUri = self.messageReviewHandlerUri {
            try encodeContainer.encode(messageReviewHandlerUri, forKey: .messageReviewHandlerUri)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListRooms"
    }
}

public struct ListRoomsInput: Swift.Equatable {
    /// Logging-configuration identifier.
    public var loggingConfigurationIdentifier: Swift.String?
    /// Maximum number of rooms to return. Default: 50.
    public var maxResults: Swift.Int
    /// Filters the list to match the specified message review handler URI.
    public var messageReviewHandlerUri: Swift.String?
    /// Filters the list to match the specified room name.
    public var name: Swift.String?
    /// The first room to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        loggingConfigurationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        messageReviewHandlerUri: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurationIdentifier = loggingConfigurationIdentifier
        self.maxResults = maxResults
        self.messageReviewHandlerUri = messageReviewHandlerUri
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListRoomsInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let messageReviewHandlerUri: Swift.String?
    let loggingConfigurationIdentifier: Swift.String?
}

extension ListRoomsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfigurationIdentifier
        case maxResults
        case messageReviewHandlerUri
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let messageReviewHandlerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageReviewHandlerUri)
        messageReviewHandlerUri = messageReviewHandlerUriDecoded
        let loggingConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingConfigurationIdentifier)
        loggingConfigurationIdentifier = loggingConfigurationIdentifierDecoded
    }
}

extension ListRoomsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRoomsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
        } else {
            self.nextToken = nil
            self.rooms = nil
        }
    }
}

public struct ListRoomsOutput: Swift.Equatable {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching rooms (summary information only).
    /// This member is required.
    public var rooms: [IvschatClientTypes.RoomSummary]?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [IvschatClientTypes.RoomSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

struct ListRoomsOutputBody: Swift.Equatable {
    let rooms: [IvschatClientTypes.RoomSummary]?
    let nextToken: Swift.String?
}

extension ListRoomsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case rooms
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([IvschatClientTypes.RoomSummary?].self, forKey: .rooms)
        var roomsDecoded0:[IvschatClientTypes.RoomSummary]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [IvschatClientTypes.RoomSummary]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRoomsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvschatClientTypes {
    public enum LoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingConfigurationState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingConfigurationState(rawValue: rawValue) ?? LoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.LoggingConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.LoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvschatClientTypes {
    /// Summary information about a logging configuration.
    public struct LoggingConfigurationSummary: Swift.Equatable {
        /// Logging-configuration ARN.
        public var arn: Swift.String?
        /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: ClientRuntime.Date?
        /// A complex type that contains a destination configuration for where chat content will be logged.
        public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
        /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// Logging-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// The state of the logging configuration. When this is ACTIVE, the configuration is ready for logging chat content.
        public var state: IvschatClientTypes.LoggingConfigurationState?
        /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: IvschatClientTypes.LoggingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.destinationConfiguration = destinationConfiguration
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension IvschatClientTypes.MessageReviewHandler: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fallbackResult
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fallbackResult = self.fallbackResult {
            try encodeContainer.encode(fallbackResult.rawValue, forKey: .fallbackResult)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let fallbackResultDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.FallbackResult.self, forKey: .fallbackResult)
        fallbackResult = fallbackResultDecoded
    }
}

extension IvschatClientTypes {
    /// Configuration information for optional message review.
    public struct MessageReviewHandler: Swift.Equatable {
        /// Specifies the fallback behavior (whether the message is allowed or denied) if the handler does not return a valid response, encounters an error, or times out. (For the timeout period, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/userguide/service-quotas.html).) If allowed, the message is delivered with returned content to all users connected to the room. If denied, the message is not delivered to any user. Default: ALLOW.
        public var fallbackResult: IvschatClientTypes.FallbackResult?
        /// Identifier of the message review handler. Currently this must be an ARN of a lambda function.
        public var uri: Swift.String?

        public init(
            fallbackResult: IvschatClientTypes.FallbackResult? = nil,
            uri: Swift.String? = nil
        )
        {
            self.fallbackResult = fallbackResult
            self.uri = uri
        }
    }

}

extension PendingVerification {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let message: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IvschatClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IvschatClientTypes.RoomSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .dateTime, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension IvschatClientTypes {
    /// Summary information about a room.
    public struct RoomSummary: Swift.Equatable {
        /// Room ARN.
        public var arn: Swift.String?
        /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: ClientRuntime.Date?
        /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// List of logging-configuration identifiers attached to the room.
        public var loggingConfigurationIdentifiers: [Swift.String]?
        /// Configuration information for optional review of messages.
        public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
        /// Room name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            loggingConfigurationIdentifiers: [Swift.String]? = nil,
            messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
            self.messageReviewHandler = messageReviewHandler
            self.name = name
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

extension IvschatClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IvschatClientTypes {
    /// Specifies an S3 location where chat logs will be stored.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// Name of the Amazon S3 bucket where chat activity will be logged.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, eventAttributes0) in attributes {
                try attributesContainer.encode(eventAttributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let roomIdentifier = self.roomIdentifier {
            try encodeContainer.encode(roomIdentifier, forKey: .roomIdentifier)
        }
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/SendEvent"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// Application-defined metadata to attach to the event sent to clients. The maximum length of the metadata is 1 KB total.
    public var attributes: [Swift.String:Swift.String]?
    /// Application-defined name of the event to send to clients.
    /// This member is required.
    public var eventName: Swift.String?
    /// Identifier of the room to which the event will be sent. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        eventName: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.eventName = eventName
        self.roomIdentifier = roomIdentifier
    }
}

struct SendEventInputBody: Swift.Equatable {
    let roomIdentifier: Swift.String?
    let eventName: Swift.String?
    let attributes: [Swift.String:Swift.String]?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case eventName
        case roomIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomIdentifier)
        roomIdentifier = roomIdentifierDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?[key0] = string0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SendEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendEventOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct SendEventOutput: Swift.Equatable {
    /// An identifier generated by Amazon IVS Chat. This identifier must be used in subsequent operations for this message, such as DeleteMessage.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct SendEventOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension SendEventOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum SendEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limit = output.limit
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.limit = 0
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var limit: Swift.Int = 0
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limit = output.limit
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.limit = 0
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var limit: Swift.Int = 0
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: IvschatClientTypes.ResourceType?
    let limit: Swift.Int
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging AWS Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case identifier
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLoggingConfiguration"
    }
}

public struct UpdateLoggingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Identifier of the logging configuration to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?

    public init(
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.identifier = identifier
        self.name = name
    }
}

struct UpdateLoggingConfigurationInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
}

extension UpdateLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case identifier
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
    }
}

extension UpdateLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.destinationConfiguration = output.destinationConfiguration
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.destinationConfiguration = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateLoggingConfigurationOutput: Swift.Equatable {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.UpdateLoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.UpdateLoggingConfigurationState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct UpdateLoggingConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let name: Swift.String?
    let destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    let state: IvschatClientTypes.UpdateLoggingConfigurationState?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case destinationConfiguration
        case id
        case name
        case state
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.UpdateLoggingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvschatClientTypes {
    public enum UpdateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateLoggingConfigurationState] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateLoggingConfigurationState(rawValue: rawValue) ?? UpdateLoggingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let loggingConfigurationIdentifiers = loggingConfigurationIdentifiers {
            var loggingConfigurationIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggingConfigurationIdentifiers)
            for loggingconfigurationidentifier0 in loggingConfigurationIdentifiers {
                try loggingConfigurationIdentifiersContainer.encode(loggingconfigurationidentifier0)
            }
        }
        if maximumMessageLength != 0 {
            try encodeContainer.encode(maximumMessageLength, forKey: .maximumMessageLength)
        }
        if maximumMessageRatePerSecond != 0 {
            try encodeContainer.encode(maximumMessageRatePerSecond, forKey: .maximumMessageRatePerSecond)
        }
        if let messageReviewHandler = self.messageReviewHandler {
            try encodeContainer.encode(messageReviewHandler, forKey: .messageReviewHandler)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateRoom"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// Identifier of the room to be updated. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// The maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages. Specify an empty uri string to disassociate a message review handler from the specified room.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let identifier: Swift.String?
    let name: Swift.String?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

extension UpdateRoomOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRoomOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createTime = output.createTime
            self.id = output.id
            self.loggingConfigurationIdentifiers = output.loggingConfigurationIdentifiers
            self.maximumMessageLength = output.maximumMessageLength
            self.maximumMessageRatePerSecond = output.maximumMessageRatePerSecond
            self.messageReviewHandler = output.messageReviewHandler
            self.name = output.name
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.createTime = nil
            self.id = nil
            self.loggingConfigurationIdentifiers = nil
            self.maximumMessageLength = 0
            self.maximumMessageRatePerSecond = 0
            self.messageReviewHandler = nil
            self.name = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateRoomOutput: Swift.Equatable {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: ClientRuntime.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int = 0,
        maximumMessageRatePerSecond: Swift.Int = 0,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct UpdateRoomOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let createTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let maximumMessageRatePerSecond: Swift.Int
    let maximumMessageLength: Swift.Int
    let messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    let tags: [Swift.String:Swift.String]?
    let loggingConfigurationIdentifiers: [Swift.String]?
}

extension UpdateRoomOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case id
        case loggingConfigurationIdentifiers
        case maximumMessageLength
        case maximumMessageRatePerSecond
        case messageReviewHandler
        case name
        case tags
        case updateTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let maximumMessageRatePerSecondDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageRatePerSecond) ?? 0
        maximumMessageRatePerSecond = maximumMessageRatePerSecondDecoded
        let maximumMessageLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumMessageLength) ?? 0
        maximumMessageLength = maximumMessageLengthDecoded
        let messageReviewHandlerDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.MessageReviewHandler.self, forKey: .messageReviewHandler)
        messageReviewHandler = messageReviewHandlerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let loggingConfigurationIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loggingConfigurationIdentifiers)
        var loggingConfigurationIdentifiersDecoded0:[Swift.String]? = nil
        if let loggingConfigurationIdentifiersContainer = loggingConfigurationIdentifiersContainer {
            loggingConfigurationIdentifiersDecoded0 = [Swift.String]()
            for string0 in loggingConfigurationIdentifiersContainer {
                if let string0 = string0 {
                    loggingConfigurationIdentifiersDecoded0?.append(string0)
                }
            }
        }
        loggingConfigurationIdentifiers = loggingConfigurationIdentifiersDecoded0
    }
}

enum UpdateRoomOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var reason: IvschatClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IvschatClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: IvschatClientTypes.ValidationExceptionReason?
    let fieldList: [IvschatClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IvschatClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([IvschatClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[IvschatClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [IvschatClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension IvschatClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvschatClientTypes {
    /// This object is used in the ValidationException error.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Explanation of the reason for the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field which failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IvschatClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
