//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

public struct DeleteLoggingConfigurationOutput {

    public init() { }
}

public struct DeleteRoomOutput {

    public init() { }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IvschatClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .room
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension IvschatClientTypes {
    /// This object is used in the ValidationException error.
    public struct ValidationExceptionField {
        /// Explanation of the reason for the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field which failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IvschatClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        public internal(set) var fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var reason: IvschatClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [IvschatClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IvschatClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension IvschatClientTypes {

    public enum ChatTokenCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteMessage
        case disconnectUser
        case sendMessage
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatTokenCapability] {
            return [
                .deleteMessage,
                .disconnectUser,
                .sendMessage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteMessage: return "DELETE_MESSAGE"
            case .disconnectUser: return "DISCONNECT_USER"
            case .sendMessage: return "SEND_MESSAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateChatTokenInput {
    /// Application-provided attributes to encode into the token and attach to a chat session. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total.
    public var attributes: [Swift.String: Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the room. Default: None (the capability to view messages is implicitly included in all requests).
    public var capabilities: [IvschatClientTypes.ChatTokenCapability]?
    /// Identifier of the room that the client is trying to access. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// Session duration (in minutes), after which the session expires. Default: 60 (1 hour).
    public var sessionDurationInMinutes: Swift.Int?
    /// Application-provided ID that uniquely identifies the user associated with this token. This can be any UTF-8 encoded text.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        capabilities: [IvschatClientTypes.ChatTokenCapability]? = nil,
        roomIdentifier: Swift.String? = nil,
        sessionDurationInMinutes: Swift.Int? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.roomIdentifier = roomIdentifier
        self.sessionDurationInMinutes = sessionDurationInMinutes
        self.userId = userId
    }
}

extension CreateChatTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChatTokenInput(capabilities: \(Swift.String(describing: capabilities)), roomIdentifier: \(Swift.String(describing: roomIdentifier)), sessionDurationInMinutes: \(Swift.String(describing: sessionDurationInMinutes)), attributes: \"CONTENT_REDACTED\", userId: \"CONTENT_REDACTED\")"}
}

public struct CreateChatTokenOutput {
    /// Time after which an end user's session is no longer valid. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var sessionExpirationTime: Foundation.Date?
    /// The issued client token, encrypted.
    public var token: Swift.String?
    /// Time after which the token is no longer valid and cannot be used to connect to a room. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var tokenExpirationTime: Foundation.Date?

    public init(
        sessionExpirationTime: Foundation.Date? = nil,
        token: Swift.String? = nil,
        tokenExpirationTime: Foundation.Date? = nil
    )
    {
        self.sessionExpirationTime = sessionExpirationTime
        self.token = token
        self.tokenExpirationTime = tokenExpirationTime
    }
}

extension CreateChatTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChatTokenOutput(sessionExpirationTime: \(Swift.String(describing: sessionExpirationTime)), tokenExpirationTime: \(Swift.String(describing: tokenExpirationTime)), token: \"CONTENT_REDACTED\")"}
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var limit: Swift.Int = 0
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension IvschatClientTypes {
    /// Specifies a CloudWatch Logs location where chat logs will be stored.
    public struct CloudWatchLogsDestinationConfiguration {
        /// Name of the Amazon Cloudwatch Logs destination where chat activity will be logged.
        /// This member is required.
        public var logGroupName: Swift.String?

        public init(
            logGroupName: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
        }
    }

}

extension IvschatClientTypes {
    /// Specifies a Kinesis Firehose location where chat logs will be stored.
    public struct FirehoseDestinationConfiguration {
        /// Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
        /// This member is required.
        public var deliveryStreamName: Swift.String?

        public init(
            deliveryStreamName: Swift.String? = nil
        )
        {
            self.deliveryStreamName = deliveryStreamName
        }
    }

}

extension IvschatClientTypes {
    /// Specifies an S3 location where chat logs will be stored.
    public struct S3DestinationConfiguration {
        /// Name of the Amazon S3 bucket where chat activity will be logged.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension IvschatClientTypes {
    /// A complex type that describes a location where chat logs will be stored. Each member represents the configuration of one log destination. For logging, you define only one type of destination (for CloudWatch Logs, Kinesis Firehose, or S3).
    public enum DestinationConfiguration {
        /// An Amazon S3 destination configuration where chat activity will be logged.
        case s3(IvschatClientTypes.S3DestinationConfiguration)
        /// An Amazon CloudWatch Logs destination configuration where chat activity will be logged.
        case cloudwatchlogs(IvschatClientTypes.CloudWatchLogsDestinationConfiguration)
        /// An Amazon Kinesis Data Firehose destination configuration where chat activity will be logged.
        case firehose(IvschatClientTypes.FirehoseDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateLoggingConfigurationInput {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.tags = tags
    }
}

extension IvschatClientTypes {

    public enum CreateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [CreateLoggingConfigurationState] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLoggingConfigurationOutput {
    /// Logging-configuration ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.CreateLoggingConfigurationState?
    /// Tags attached to the resource, from the request (if specified). Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.CreateLoggingConfigurationState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

extension IvschatClientTypes {

    public enum FallbackResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackResult] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvschatClientTypes {
    /// Configuration information for optional message review.
    public struct MessageReviewHandler {
        /// Specifies the fallback behavior (whether the message is allowed or denied) if the handler does not return a valid response, encounters an error, or times out. (For the timeout period, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/userguide/service-quotas.html).) If allowed, the message is delivered with returned content to all users connected to the room. If denied, the message is not delivered to any user. Default: ALLOW.
        public var fallbackResult: IvschatClientTypes.FallbackResult?
        /// Identifier of the message review handler. Currently this must be an ARN of a lambda function.
        public var uri: Swift.String?

        public init(
            fallbackResult: IvschatClientTypes.FallbackResult? = nil,
            uri: Swift.String? = nil
        )
        {
            self.fallbackResult = fallbackResult
            self.uri = uri
        }
    }

}

public struct CreateRoomInput {
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int?
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int?
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int? = nil,
        maximumMessageRatePerSecond: Swift.Int? = nil,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
    }
}

public struct CreateRoomOutput {
    /// Room ARN, assigned by the system.
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int?
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int?
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource, from the request (if specified).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int? = nil,
        maximumMessageRatePerSecond: Swift.Int? = nil,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

public struct DeleteLoggingConfigurationInput {
    /// Identifier of the logging configuration to be deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        ///
        /// This member is required.
        public internal(set) var limit: Swift.Int = 0
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        ///
        /// This member is required.
        public internal(set) var resourceType: IvschatClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IvschatClientTypes.ResourceType? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct DeleteMessageInput {
    /// ID of the message to be deleted. This is the Id field in the received message (see [ Message (Subscribe)](https://docs.aws.amazon.com/ivs/latest/chatmsgapireference/actions-message-subscribe.html) in the Chat Messaging API).
    /// This member is required.
    public var id: Swift.String?
    /// Reason for deleting the message.
    public var reason: Swift.String?
    /// Identifier of the room where the message should be deleted. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init(
        id: Swift.String? = nil,
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.id = id
        self.reason = reason
        self.roomIdentifier = roomIdentifier
    }
}

public struct DeleteMessageOutput {
    /// Operation identifier, generated by Amazon IVS Chat.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteRoomInput {
    /// Identifier of the room to be deleted. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DisconnectUserInput {
    /// Reason for disconnecting the user.
    public var reason: Swift.String?
    /// Identifier of the room from which the user's clients should be disconnected. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?
    /// ID of the user (connection) to disconnect from the room.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        reason: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.reason = reason
        self.roomIdentifier = roomIdentifier
        self.userId = userId
    }
}

extension DisconnectUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectUserInput(reason: \(Swift.String(describing: reason)), roomIdentifier: \(Swift.String(describing: roomIdentifier)), userId: \"CONTENT_REDACTED\")"}
}

public struct DisconnectUserOutput {

    public init() { }
}

public struct GetLoggingConfigurationInput {
    /// Identifier of the logging configuration to be retrieved.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

extension IvschatClientTypes {

    public enum LoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingConfigurationState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetLoggingConfigurationOutput {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the logging configuration.
    public var id: Swift.String?
    /// Logging-configuration name. This value does not need to be unique.
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.LoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.LoggingConfigurationState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

public struct GetRoomInput {
    /// Identifier of the room for which the configuration is to be retrieved. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetRoomOutput {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int?
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int?
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int? = nil,
        maximumMessageRatePerSecond: Swift.Int? = nil,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

public struct ListLoggingConfigurationsInput {
    /// Maximum number of logging configurations to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first logging configurations to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvschatClientTypes {
    /// Summary information about a logging configuration.
    public struct LoggingConfigurationSummary {
        /// Logging-configuration ARN.
        public var arn: Swift.String?
        /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: Foundation.Date?
        /// A complex type that contains a destination configuration for where chat content will be logged.
        public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
        /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// Logging-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// The state of the logging configuration. When this is ACTIVE, the configuration is ready for logging chat content.
        public var state: IvschatClientTypes.LoggingConfigurationState?
        /// Tags to attach to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: IvschatClientTypes.LoggingConfigurationState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.destinationConfiguration = destinationConfiguration
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

public struct ListLoggingConfigurationsOutput {
    /// List of the matching logging configurations (summary information only). There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    /// This member is required.
    public var loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]?
    /// If there are more logging configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        loggingConfigurations: [IvschatClientTypes.LoggingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurations = loggingConfigurations
        self.nextToken = nextToken
    }
}

public struct ListRoomsInput {
    /// Logging-configuration identifier.
    public var loggingConfigurationIdentifier: Swift.String?
    /// Maximum number of rooms to return. Default: 50.
    public var maxResults: Swift.Int?
    /// Filters the list to match the specified message review handler URI.
    public var messageReviewHandlerUri: Swift.String?
    /// Filters the list to match the specified room name.
    public var name: Swift.String?
    /// The first room to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        loggingConfigurationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        messageReviewHandlerUri: Swift.String? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggingConfigurationIdentifier = loggingConfigurationIdentifier
        self.maxResults = maxResults
        self.messageReviewHandlerUri = messageReviewHandlerUri
        self.name = name
        self.nextToken = nextToken
    }
}

extension IvschatClientTypes {
    /// Summary information about a room.
    public struct RoomSummary {
        /// Room ARN.
        public var arn: Swift.String?
        /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var createTime: Foundation.Date?
        /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
        public var id: Swift.String?
        /// List of logging-configuration identifiers attached to the room.
        public var loggingConfigurationIdentifiers: [Swift.String]?
        /// Configuration information for optional review of messages.
        public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
        /// Room name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            loggingConfigurationIdentifiers: [Swift.String]? = nil,
            messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
            self.messageReviewHandler = messageReviewHandler
            self.name = name
            self.tags = tags
            self.updateTime = updateTime
        }
    }

}

public struct ListRoomsOutput {
    /// If there are more rooms than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching rooms (summary information only).
    /// This member is required.
    public var rooms: [IvschatClientTypes.RoomSummary]?

    public init(
        nextToken: Swift.String? = nil,
        rooms: [IvschatClientTypes.RoomSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct SendEventInput {
    /// Application-defined metadata to attach to the event sent to clients. The maximum length of the metadata is 1 KB total.
    public var attributes: [Swift.String: Swift.String]?
    /// Application-defined name of the event to send to clients.
    /// This member is required.
    public var eventName: Swift.String?
    /// Identifier of the room to which the event will be sent. Currently this must be an ARN.
    /// This member is required.
    public var roomIdentifier: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        eventName: Swift.String? = nil,
        roomIdentifier: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.eventName = eventName
        self.roomIdentifier = roomIdentifier
    }
}

public struct SendEventOutput {
    /// An identifier generated by Amazon IVS Chat. This identifier must be used in subsequent operations for this message, such as DeleteMessage.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct TagResourceInput {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS Chat has no constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateLoggingConfigurationInput {
    /// A complex type that contains a destination configuration for where chat content will be logged. There can be only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Identifier of the logging configuration to be updated.
    /// This member is required.
    public var identifier: Swift.String?
    /// Logging-configuration name. The value does not need to be unique.
    public var name: Swift.String?

    public init(
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.identifier = identifier
        self.name = name
    }
}

extension IvschatClientTypes {

    public enum UpdateLoggingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateLoggingConfigurationState] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateLoggingConfigurationOutput {
    /// Logging-configuration ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the logging configuration was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// A complex type that contains a destination configuration for where chat content will be logged, from the request. There is only one type of destination (cloudWatchLogs, firehose, or s3) in a destinationConfiguration.
    public var destinationConfiguration: IvschatClientTypes.DestinationConfiguration?
    /// Logging-configuration ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Logging-configuration name, from the request (if specified).
    public var name: Swift.String?
    /// The state of the logging configuration. When the state is ACTIVE, the configuration is ready to log chat content.
    public var state: IvschatClientTypes.UpdateLoggingConfigurationState?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the logging configuration’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        destinationConfiguration: IvschatClientTypes.DestinationConfiguration? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IvschatClientTypes.UpdateLoggingConfigurationState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.destinationConfiguration = destinationConfiguration
        self.id = id
        self.name = name
        self.state = state
        self.tags = tags
        self.updateTime = updateTime
    }
}

public struct UpdateRoomInput {
    /// Identifier of the room to be updated. Currently this must be an ARN.
    /// This member is required.
    public var identifier: Swift.String?
    /// Array of logging-configuration identifiers attached to the room.
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// The maximum number of characters in a single message. Messages are expected to be UTF-8 encoded and this limit applies specifically to rune/code-point count, not number of bytes. Default: 500.
    public var maximumMessageLength: Swift.Int?
    /// Maximum number of messages per second that can be sent to the room (by all clients). Default: 10.
    public var maximumMessageRatePerSecond: Swift.Int?
    /// Configuration information for optional review of messages. Specify an empty uri string to disassociate a message review handler from the specified room.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name. The value does not need to be unique.
    public var name: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int? = nil,
        maximumMessageRatePerSecond: Swift.Int? = nil,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
    }
}

public struct UpdateRoomOutput {
    /// Room ARN, from the request (if identifier was an ARN).
    public var arn: Swift.String?
    /// Time when the room was created. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var createTime: Foundation.Date?
    /// Room ID, generated by the system. This is a relative identifier, the part of the ARN that uniquely identifies the room.
    public var id: Swift.String?
    /// Array of logging configurations attached to the room, from the request (if specified).
    public var loggingConfigurationIdentifiers: [Swift.String]?
    /// Maximum number of characters in a single message, from the request (if specified).
    public var maximumMessageLength: Swift.Int?
    /// Maximum number of messages per second that can be sent to the room (by all clients), from the request (if specified).
    public var maximumMessageRatePerSecond: Swift.Int?
    /// Configuration information for optional review of messages.
    public var messageReviewHandler: IvschatClientTypes.MessageReviewHandler?
    /// Room name, from the request (if specified).
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    public var tags: [Swift.String: Swift.String]?
    /// Time of the room’s last update. This is an ISO 8601 timestamp; note that this is returned as a string.
    public var updateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createTime: Foundation.Date? = nil,
        id: Swift.String? = nil,
        loggingConfigurationIdentifiers: [Swift.String]? = nil,
        maximumMessageLength: Swift.Int? = nil,
        maximumMessageRatePerSecond: Swift.Int? = nil,
        messageReviewHandler: IvschatClientTypes.MessageReviewHandler? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createTime = createTime
        self.id = id
        self.loggingConfigurationIdentifiers = loggingConfigurationIdentifiers
        self.maximumMessageLength = maximumMessageLength
        self.maximumMessageRatePerSecond = maximumMessageRatePerSecond
        self.messageReviewHandler = messageReviewHandler
        self.name = name
        self.tags = tags
        self.updateTime = updateTime
    }
}

extension CreateChatTokenInput {

    static func urlPathProvider(_ value: CreateChatTokenInput) -> Swift.String? {
        return "/CreateChatToken"
    }
}

extension CreateLoggingConfigurationInput {

    static func urlPathProvider(_ value: CreateLoggingConfigurationInput) -> Swift.String? {
        return "/CreateLoggingConfiguration"
    }
}

extension CreateRoomInput {

    static func urlPathProvider(_ value: CreateRoomInput) -> Swift.String? {
        return "/CreateRoom"
    }
}

extension DeleteLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteLoggingConfigurationInput) -> Swift.String? {
        return "/DeleteLoggingConfiguration"
    }
}

extension DeleteMessageInput {

    static func urlPathProvider(_ value: DeleteMessageInput) -> Swift.String? {
        return "/DeleteMessage"
    }
}

extension DeleteRoomInput {

    static func urlPathProvider(_ value: DeleteRoomInput) -> Swift.String? {
        return "/DeleteRoom"
    }
}

extension DisconnectUserInput {

    static func urlPathProvider(_ value: DisconnectUserInput) -> Swift.String? {
        return "/DisconnectUser"
    }
}

extension GetLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetLoggingConfigurationInput) -> Swift.String? {
        return "/GetLoggingConfiguration"
    }
}

extension GetRoomInput {

    static func urlPathProvider(_ value: GetRoomInput) -> Swift.String? {
        return "/GetRoom"
    }
}

extension ListLoggingConfigurationsInput {

    static func urlPathProvider(_ value: ListLoggingConfigurationsInput) -> Swift.String? {
        return "/ListLoggingConfigurations"
    }
}

extension ListRoomsInput {

    static func urlPathProvider(_ value: ListRoomsInput) -> Swift.String? {
        return "/ListRooms"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension SendEventInput {

    static func urlPathProvider(_ value: SendEventInput) -> Swift.String? {
        return "/SendEvent"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLoggingConfigurationInput {

    static func urlPathProvider(_ value: UpdateLoggingConfigurationInput) -> Swift.String? {
        return "/UpdateLoggingConfiguration"
    }
}

extension UpdateRoomInput {

    static func urlPathProvider(_ value: UpdateRoomInput) -> Swift.String? {
        return "/UpdateRoom"
    }
}

extension CreateChatTokenInput {

    static func write(value: CreateChatTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IvschatClientTypes.ChatTokenCapability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roomIdentifier"].write(value.roomIdentifier)
        try writer["sessionDurationInMinutes"].write(value.sessionDurationInMinutes)
        try writer["userId"].write(value.userId)
    }
}

extension CreateLoggingConfigurationInput {

    static func write(value: CreateLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: IvschatClientTypes.DestinationConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRoomInput {

    static func write(value: CreateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfigurationIdentifiers"].writeList(value.loggingConfigurationIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maximumMessageLength"].write(value.maximumMessageLength)
        try writer["maximumMessageRatePerSecond"].write(value.maximumMessageRatePerSecond)
        try writer["messageReviewHandler"].write(value.messageReviewHandler, with: IvschatClientTypes.MessageReviewHandler.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteLoggingConfigurationInput {

    static func write(value: DeleteLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DeleteMessageInput {

    static func write(value: DeleteMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["reason"].write(value.reason)
        try writer["roomIdentifier"].write(value.roomIdentifier)
    }
}

extension DeleteRoomInput {

    static func write(value: DeleteRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DisconnectUserInput {

    static func write(value: DisconnectUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reason"].write(value.reason)
        try writer["roomIdentifier"].write(value.roomIdentifier)
        try writer["userId"].write(value.userId)
    }
}

extension GetLoggingConfigurationInput {

    static func write(value: GetLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension GetRoomInput {

    static func write(value: GetRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension ListLoggingConfigurationsInput {

    static func write(value: ListLoggingConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRoomsInput {

    static func write(value: ListRoomsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfigurationIdentifier"].write(value.loggingConfigurationIdentifier)
        try writer["maxResults"].write(value.maxResults)
        try writer["messageReviewHandlerUri"].write(value.messageReviewHandlerUri)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension SendEventInput {

    static func write(value: SendEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["eventName"].write(value.eventName)
        try writer["roomIdentifier"].write(value.roomIdentifier)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLoggingConfigurationInput {

    static func write(value: UpdateLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: IvschatClientTypes.DestinationConfiguration.write(value:to:))
        try writer["identifier"].write(value.identifier)
        try writer["name"].write(value.name)
    }
}

extension UpdateRoomInput {

    static func write(value: UpdateRoomInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
        try writer["loggingConfigurationIdentifiers"].writeList(value.loggingConfigurationIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maximumMessageLength"].write(value.maximumMessageLength)
        try writer["maximumMessageRatePerSecond"].write(value.maximumMessageRatePerSecond)
        try writer["messageReviewHandler"].write(value.messageReviewHandler, with: IvschatClientTypes.MessageReviewHandler.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateChatTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChatTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChatTokenOutput()
        value.sessionExpirationTime = try reader["sessionExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.token = try reader["token"].readIfPresent()
        value.tokenExpirationTime = try reader["tokenExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggingConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvschatClientTypes.DestinationConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoomOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.loggingConfigurationIdentifiers = try reader["loggingConfigurationIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maximumMessageLength = try reader["maximumMessageLength"].readIfPresent()
        value.maximumMessageRatePerSecond = try reader["maximumMessageRatePerSecond"].readIfPresent()
        value.messageReviewHandler = try reader["messageReviewHandler"].readIfPresent(with: IvschatClientTypes.MessageReviewHandler.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeleteLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoggingConfigurationOutput {
        return DeleteLoggingConfigurationOutput()
    }
}

extension DeleteMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMessageOutput()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DeleteRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoomOutput {
        return DeleteRoomOutput()
    }
}

extension DisconnectUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisconnectUserOutput {
        return DisconnectUserOutput()
    }
}

extension GetLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggingConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvschatClientTypes.DestinationConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRoomOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.loggingConfigurationIdentifiers = try reader["loggingConfigurationIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maximumMessageLength = try reader["maximumMessageLength"].readIfPresent()
        value.maximumMessageRatePerSecond = try reader["maximumMessageRatePerSecond"].readIfPresent()
        value.messageReviewHandler = try reader["messageReviewHandler"].readIfPresent(with: IvschatClientTypes.MessageReviewHandler.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ListLoggingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLoggingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoggingConfigurationsOutput()
        value.loggingConfigurations = try reader["loggingConfigurations"].readListIfPresent(memberReadingClosure: IvschatClientTypes.LoggingConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRoomsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoomsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoomsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.rooms = try reader["rooms"].readListIfPresent(memberReadingClosure: IvschatClientTypes.RoomSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension SendEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendEventOutput()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLoggingConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvschatClientTypes.DestinationConfiguration.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension UpdateRoomOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoomOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoomOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.loggingConfigurationIdentifiers = try reader["loggingConfigurationIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maximumMessageLength = try reader["maximumMessageLength"].readIfPresent()
        value.maximumMessageRatePerSecond = try reader["maximumMessageRatePerSecond"].readIfPresent()
        value.messageReviewHandler = try reader["messageReviewHandler"].readIfPresent(with: IvschatClientTypes.MessageReviewHandler.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

enum CreateChatTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisconnectUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLoggingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoomsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoomOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PendingVerification {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PendingVerification {
        let reader = baseError.errorBodyReader
        var value = PendingVerification()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: IvschatClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.limit = try reader["limit"].readIfPresent() ?? 0
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.limit = try reader["limit"].readIfPresent() ?? 0
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IvschatClientTypes.DestinationConfiguration {

    static func write(value: IvschatClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cloudwatchlogs(cloudwatchlogs):
                try writer["cloudWatchLogs"].write(cloudwatchlogs, with: IvschatClientTypes.CloudWatchLogsDestinationConfiguration.write(value:to:))
            case let .firehose(firehose):
                try writer["firehose"].write(firehose, with: IvschatClientTypes.FirehoseDestinationConfiguration.write(value:to:))
            case let .s3(s3):
                try writer["s3"].write(s3, with: IvschatClientTypes.S3DestinationConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: IvschatClientTypes.S3DestinationConfiguration.read(from:)))
            case "cloudWatchLogs":
                return .cloudwatchlogs(try reader["cloudWatchLogs"].read(with: IvschatClientTypes.CloudWatchLogsDestinationConfiguration.read(from:)))
            case "firehose":
                return .firehose(try reader["firehose"].read(with: IvschatClientTypes.FirehoseDestinationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IvschatClientTypes.FirehoseDestinationConfiguration {

    static func write(value: IvschatClientTypes.FirehoseDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryStreamName"].write(value.deliveryStreamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.FirehoseDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.FirehoseDestinationConfiguration()
        value.deliveryStreamName = try reader["deliveryStreamName"].readIfPresent() ?? ""
        return value
    }
}

extension IvschatClientTypes.CloudWatchLogsDestinationConfiguration {

    static func write(value: IvschatClientTypes.CloudWatchLogsDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupName"].write(value.logGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.CloudWatchLogsDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.CloudWatchLogsDestinationConfiguration()
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        return value
    }
}

extension IvschatClientTypes.S3DestinationConfiguration {

    static func write(value: IvschatClientTypes.S3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.S3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.S3DestinationConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        return value
    }
}

extension IvschatClientTypes.MessageReviewHandler {

    static func write(value: IvschatClientTypes.MessageReviewHandler?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fallbackResult"].write(value.fallbackResult)
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.MessageReviewHandler {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.MessageReviewHandler()
        value.uri = try reader["uri"].readIfPresent()
        value.fallbackResult = try reader["fallbackResult"].readIfPresent()
        return value
    }
}

extension IvschatClientTypes.LoggingConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.LoggingConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.LoggingConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvschatClientTypes.DestinationConfiguration.read(from:))
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvschatClientTypes.RoomSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.RoomSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.RoomSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.messageReviewHandler = try reader["messageReviewHandler"].readIfPresent(with: IvschatClientTypes.MessageReviewHandler.read(from:))
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.loggingConfigurationIdentifiers = try reader["loggingConfigurationIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IvschatClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> IvschatClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvschatClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum IvschatClientTypes {}
