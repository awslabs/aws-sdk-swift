// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSDKMeetingsClientTypes.Attendee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
        case capabilities = "Capabilities"
        case externalUserId = "ExternalUserId"
        case joinToken = "JoinToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = self.attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
        if let joinToken = self.joinToken {
            try encodeContainer.encode(joinToken, forKey: .joinToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
        let joinTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .joinToken)
        joinToken = joinTokenDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AttendeeCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), capabilities: \(Swift.String(describing: capabilities)), externalUserId: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// An Amazon Chime SDK meeting attendee. Includes a unique AttendeeId and JoinToken. The JoinToken allows a client to authenticate and join as the specified attendee. The JoinToken expires when the meeting ends, or when [DeleteAttendee] is called. After that, the attendee is unable to join the meeting. We recommend securely transferring each JoinToken from your server application to the client so that no other client has access to the token except for the one authorized to represent the attendee.
    public struct Attendee: Swift.Equatable {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The capabilities assigned to an attendee: audio, video, or content. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see . When using capabilities, be aware of these corner cases:
        ///
        /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
        ///
        /// * When you change an audio capability from None or Receive to Send or SendReceive , and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.
        ///
        /// * When you change a video or content capability from None or Receive to Send or SendReceive , and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
        public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.capabilities = capabilities
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension ChimeSDKMeetingsClientTypes.AttendeeCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case content = "Content"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio.rawValue, forKey: .audio)
        }
        if let content = self.content {
            try encodeContainer.encode(content.rawValue, forKey: .content)
        }
        if let video = self.video {
            try encodeContainer.encode(video.rawValue, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MediaCapabilities.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MediaCapabilities.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MediaCapabilities.self, forKey: .content)
        content = contentDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The media capabilities of an attendee: audio, video, or content. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see . When using capabilities, be aware of these corner cases:
    ///
    /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
    ///
    /// * When you change an audio capability from None or Receive to Send or SendReceive , and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.
    ///
    /// * When you change a video or content capability from None or Receive to Send or SendReceive , and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
    public struct AttendeeCapabilities: Swift.Equatable {
        /// The audio capability assigned to an attendee.
        /// This member is required.
        public var audio: ChimeSDKMeetingsClientTypes.MediaCapabilities?
        /// The content capability assigned to an attendee.
        /// This member is required.
        public var content: ChimeSDKMeetingsClientTypes.MediaCapabilities?
        /// The video capability assigned to an attendee.
        /// This member is required.
        public var video: ChimeSDKMeetingsClientTypes.MediaCapabilities?

        public init(
            audio: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil,
            content: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil,
            video: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil
        )
        {
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSDKMeetingsClientTypes.AttendeeIdItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeId = "AttendeeId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeId = self.attendeeId {
            try encodeContainer.encode(attendeeId, forKey: .attendeeId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attendeeId)
        attendeeId = attendeeIdDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// A structure that contains one or more attendee IDs.
    public struct AttendeeIdItem: Swift.Equatable {
        /// A list of one or more attendee IDs.
        /// This member is required.
        public var attendeeId: Swift.String?

        public init(
            attendeeId: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
        }
    }

}

extension ChimeSDKMeetingsClientTypes.AudioFeatures: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case echoReduction = "EchoReduction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let echoReduction = self.echoReduction {
            try encodeContainer.encode(echoReduction.rawValue, forKey: .echoReduction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let echoReductionDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MeetingFeatureStatus.self, forKey: .echoReduction)
        echoReduction = echoReductionDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// An optional category of meeting features that contains audio-specific configurations, such as operating parameters for Amazon Voice Focus.
    public struct AudioFeatures: Swift.Equatable {
        /// Makes echo reduction available to clients who connect to the meeting.
        public var echoReduction: ChimeSDKMeetingsClientTypes.MeetingFeatureStatus?

        public init(
            echoReduction: ChimeSDKMeetingsClientTypes.MeetingFeatureStatus? = nil
        )
        {
            self.echoReduction = echoReduction
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension BatchCreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitem0 in attendees {
                try attendeesContainer.encode(createattendeerequestitem0)
            }
        }
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
            return items
        }
    }
}

extension BatchCreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct BatchCreateAttendeeInput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK ID of the meeting to which you're adding attendees.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

struct BatchCreateAttendeeInputBody: Swift.Equatable {
    let attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
}

extension BatchCreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
    }
}

extension BatchCreateAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
        } else {
            self.attendees = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateAttendeeOutput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

struct BatchCreateAttendeeOutputBody: Swift.Equatable {
    let attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    let errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?
}

extension BatchCreateAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSDKMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSDKMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSDKMeetingsClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case excludedAttendeeIds = "ExcludedAttendeeIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let excludedAttendeeIds = excludedAttendeeIds {
            var excludedAttendeeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedAttendeeIds)
            for attendeeiditem0 in excludedAttendeeIds {
                try excludedAttendeeIdsContainer.encode(attendeeiditem0)
            }
        }
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-update-except"))
            return items
        }
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/capabilities"
    }
}

public struct BatchUpdateAttendeeCapabilitiesExceptInput: Swift.Equatable {
    /// The capabilities (audio, video, or content) that you want to update.
    /// This member is required.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The AttendeeIDs that you want to exclude from one or more capabilities.
    /// This member is required.
    public var excludedAttendeeIds: [ChimeSDKMeetingsClientTypes.AttendeeIdItem]?
    /// The ID of the meeting associated with the update request.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        excludedAttendeeIds: [ChimeSDKMeetingsClientTypes.AttendeeIdItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.excludedAttendeeIds = excludedAttendeeIds
        self.meetingId = meetingId
    }
}

struct BatchUpdateAttendeeCapabilitiesExceptInputBody: Swift.Equatable {
    let excludedAttendeeIds: [ChimeSDKMeetingsClientTypes.AttendeeIdItem]?
    let capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
}

extension BatchUpdateAttendeeCapabilitiesExceptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case excludedAttendeeIds = "ExcludedAttendeeIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedAttendeeIdsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.AttendeeIdItem?].self, forKey: .excludedAttendeeIds)
        var excludedAttendeeIdsDecoded0:[ChimeSDKMeetingsClientTypes.AttendeeIdItem]? = nil
        if let excludedAttendeeIdsContainer = excludedAttendeeIdsContainer {
            excludedAttendeeIdsDecoded0 = [ChimeSDKMeetingsClientTypes.AttendeeIdItem]()
            for structure0 in excludedAttendeeIdsContainer {
                if let structure0 = structure0 {
                    excludedAttendeeIdsDecoded0?.append(structure0)
                }
            }
        }
        excludedAttendeeIds = excludedAttendeeIdsDecoded0
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AttendeeCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct BatchUpdateAttendeeCapabilitiesExceptOutput: Swift.Equatable {

    public init() { }
}

enum BatchUpdateAttendeeCapabilitiesExceptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Multiple instances of the same request have been made simultaneously.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request involved in the conflict.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalUserId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

extension CreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeInput(capabilities: \(Swift.String(describing: capabilities)), meetingId: \(Swift.String(describing: meetingId)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension CreateAttendeeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }
}

extension CreateAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct CreateAttendeeInput: Swift.Equatable {
    /// The capabilities (audio, video, or content) that you want to grant an attendee. If you don't specify capabilities, all users have send and receive capabilities on all media channels by default. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see . When using capabilities, be aware of these corner cases:
    ///
    /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
    ///
    /// * When you change an audio capability from None or Receive to Send or SendReceive , and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.
    ///
    /// * When you change a video or content capability from None or Receive to Send or SendReceive , and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The unique ID of the meeting.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.externalUserId = externalUserId
        self.meetingId = meetingId
    }
}

struct CreateAttendeeInputBody: Swift.Equatable {
    let externalUserId: Swift.String?
    let capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
}

extension CreateAttendeeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case externalUserId = "ExternalUserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AttendeeCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
    }
}

extension CreateAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct CreateAttendeeOutput: Swift.Equatable {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct CreateAttendeeOutputBody: Swift.Equatable {
    let attendee: ChimeSDKMeetingsClientTypes.Attendee?
}

extension CreateAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

enum CreateAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case externalUserId = "ExternalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let externalUserId = self.externalUserId {
            try encodeContainer.encode(externalUserId, forKey: .externalUserId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalUserId)
        externalUserId = externalUserIdDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AttendeeCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeRequestItem(capabilities: \(Swift.String(describing: capabilities)), externalUserId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem: Swift.Equatable {
        /// A list of one or more capabilities.
        public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        /// This member is required.
        public var externalUserId: Swift.String?

        public init(
            capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.externalUserId = externalUserId
        }
    }

}

extension CreateMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingInput(mediaRegion: \(Swift.String(describing: mediaRegion)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tags: \(Swift.String(describing: tags)), tenantIds: \(Swift.String(describing: tenantIds)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension CreateMeetingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case primaryMeetingId = "PrimaryMeetingId"
        case tags = "Tags"
        case tenantIds = "TenantIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = self.meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = self.meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = self.notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let primaryMeetingId = self.primaryMeetingId {
            try encodeContainer.encode(primaryMeetingId, forKey: .primaryMeetingId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenantIds = tenantIds {
            var tenantIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tenantIds)
            for tenantid0 in tenantIds {
                try tenantIdsContainer.encode(tenantid0)
            }
        }
    }
}

extension CreateMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in AWS GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    /// When specified, replicates the media from the primary meeting to the new meeting.
    public var primaryMeetingId: Swift.String?
    /// Applies one or more tags to an Amazon Chime SDK meeting. Note the following:
    ///
    /// * Not all resources have tags. For a list of services with resources that support tagging using this operation, see [Services that support the Resource Groups Tagging API](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/supported-services.html). If the resource doesn't yet support this operation, the resource's service might support tagging using its own API operations. For more information, refer to the documentation for that service.
    ///
    /// * Each resource can have up to 50 tags. For other limits, see [Tag Naming and Usage Conventions](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions) in the AWS General Reference.
    ///
    /// * You can only tag resources that are located in the specified AWS Region for the AWS account.
    ///
    /// * To add tags to a resource, you need the necessary permissions for the service that the resource belongs to as well as permissions for adding tags. For more information, see the documentation for each service.
    ///
    ///
    /// Do not store personally identifiable information (PII) or other confidential or sensitive information in tags. We use tags to provide you with billing and administration services. Tags are not intended to be used for private or sensitive data. Minimum permissions In addition to the tag:TagResources permission required by this operation, you must also have the tagging permission defined by the service that created the resource. For example, to tag a ChimeSDKMeetings instance using the TagResources operation, you must have both of the following permissions: tag:TagResourcesChimeSDKMeetings:CreateTags Some services might have specific requirements for tagging some resources. For example, to tag an Amazon S3 bucket, you must also have the s3:GetBucketTagging permission. If the expected minimum permissions don't work, check the documentation for that service's tagging APIs for more information.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?
    /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
    public var tenantIds: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration? = nil,
        primaryMeetingId: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil,
        tenantIds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.primaryMeetingId = primaryMeetingId
        self.tags = tags
        self.tenantIds = tenantIds
    }
}

struct CreateMeetingInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let mediaRegion: Swift.String?
    let meetingHostId: Swift.String?
    let externalMeetingId: Swift.String?
    let notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    let meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    let primaryMeetingId: Swift.String?
    let tenantIds: [Swift.String]?
    let tags: [ChimeSDKMeetingsClientTypes.Tag]?
}

extension CreateMeetingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case primaryMeetingId = "PrimaryMeetingId"
        case tags = "Tags"
        case tenantIds = "TenantIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.NotificationsConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
        let primaryMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMeetingId)
        primaryMeetingId = primaryMeetingIdDecoded
        let tenantIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tenantIds)
        var tenantIdsDecoded0:[Swift.String]? = nil
        if let tenantIdsContainer = tenantIdsContainer {
            tenantIdsDecoded0 = [Swift.String]()
            for string0 in tenantIdsContainer {
                if let string0 = string0 {
                    tenantIdsDecoded0?.append(string0)
                }
            }
        }
        tenantIds = tenantIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMeetingsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMeetingsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMeetingOutputBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct CreateMeetingOutput: Swift.Equatable {
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct CreateMeetingOutputBody: Swift.Equatable {
    let meeting: ChimeSDKMeetingsClientTypes.Meeting?
}

extension CreateMeetingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

enum CreateMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMeetingWithAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesInput(attendees: \(Swift.String(describing: attendees)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tags: \(Swift.String(describing: tags)), tenantIds: \(Swift.String(describing: tenantIds)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension CreateMeetingWithAttendeesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case primaryMeetingId = "PrimaryMeetingId"
        case tags = "Tags"
        case tenantIds = "TenantIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendees = attendees {
            var attendeesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendees)
            for createattendeerequestitem0 in attendees {
                try attendeesContainer.encode(createattendeerequestitem0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingFeatures = self.meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = self.meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let notificationsConfiguration = self.notificationsConfiguration {
            try encodeContainer.encode(notificationsConfiguration, forKey: .notificationsConfiguration)
        }
        if let primaryMeetingId = self.primaryMeetingId {
            try encodeContainer.encode(primaryMeetingId, forKey: .primaryMeetingId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenantIds = tenantIds {
            var tenantIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tenantIds)
            for tenantid0 in tenantIds {
                try tenantIdsContainer.encode(tenantid0)
            }
        }
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "create-attendees"))
            return items
        }
    }
}

extension CreateMeetingWithAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/meetings"
    }
}

public struct CreateMeetingWithAttendeesInput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in AWS GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    /// When specified, replicates the media from the primary meeting to the new meeting.
    public var primaryMeetingId: Swift.String?
    /// The tags in the request.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?
    /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
    public var tenantIds: [Swift.String]?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration? = nil,
        primaryMeetingId: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil,
        tenantIds: [Swift.String]? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.primaryMeetingId = primaryMeetingId
        self.tags = tags
        self.tenantIds = tenantIds
    }
}

struct CreateMeetingWithAttendeesInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let mediaRegion: Swift.String?
    let meetingHostId: Swift.String?
    let externalMeetingId: Swift.String?
    let meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    let notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    let attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
    let primaryMeetingId: Swift.String?
    let tenantIds: [Swift.String]?
    let tags: [ChimeSDKMeetingsClientTypes.Tag]?
}

extension CreateMeetingWithAttendeesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case clientRequestToken = "ClientRequestToken"
        case externalMeetingId = "ExternalMeetingId"
        case mediaRegion = "MediaRegion"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case notificationsConfiguration = "NotificationsConfiguration"
        case primaryMeetingId = "PrimaryMeetingId"
        case tags = "Tags"
        case tenantIds = "TenantIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
        let notificationsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.NotificationsConfiguration.self, forKey: .notificationsConfiguration)
        notificationsConfiguration = notificationsConfigurationDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let primaryMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMeetingId)
        primaryMeetingId = primaryMeetingIdDecoded
        let tenantIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tenantIds)
        var tenantIdsDecoded0:[Swift.String]? = nil
        if let tenantIdsContainer = tenantIdsContainer {
            tenantIdsDecoded0 = [Swift.String]()
            for string0 in tenantIdsContainer {
                if let string0 = string0 {
                    tenantIdsDecoded0?.append(string0)
                }
            }
        }
        tenantIds = tenantIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMeetingsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMeetingsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMeetingWithAttendeesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMeetingWithAttendeesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.errors = output.errors
            self.meeting = output.meeting
        } else {
            self.attendees = nil
            self.errors = nil
            self.meeting = nil
        }
    }
}

public struct CreateMeetingWithAttendeesOutput: Swift.Equatable {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

struct CreateMeetingWithAttendeesOutputBody: Swift.Equatable {
    let meeting: ChimeSDKMeetingsClientTypes.Meeting?
    let attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    let errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?
}

extension CreateMeetingWithAttendeesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case errors = "Errors"
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSDKMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSDKMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.CreateAttendeeError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSDKMeetingsClientTypes.CreateAttendeeError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum CreateMeetingWithAttendeesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct DeleteAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct DeleteAttendeeInputBody: Swift.Equatable {
}

extension DeleteAttendeeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAttendeeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct DeleteMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct DeleteMeetingInputBody: Swift.Equatable {
}

extension DeleteMeetingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMeetingOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case languageCode = "LanguageCode"
        case region = "Region"
        case specialty = "Specialty"
        case type = "Type"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let specialty = self.specialty {
            try encodeContainer.encode(specialty.rawValue, forKey: .specialty)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeMedicalLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let specialtyDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeMedicalSpecialty.self, forKey: .specialty)
        specialty = specialtyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeMedicalType.self, forKey: .type)
        type = typeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeMedicalRegion.self, forKey: .region)
        region = regionDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeMedicalContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings: Swift.Equatable {
        /// Set this field to PHI to identify personal health information in the transcription output.
        public var contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeSDKMeetingsClientTypes.TranscribeMedicalLanguageCode?
        /// The AWS Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeSDKMeetingsClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeSDKMeetingsClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeSDKMeetingsClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeMedicalContentIdentificationType? = nil,
            languageCode: ChimeSDKMeetingsClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeSDKMeetingsClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeSDKMeetingsClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeSDKMeetingsClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeSDKMeetingsClientTypes.EngineTranscribeSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case contentRedactionType = "ContentRedactionType"
        case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
        case identifyLanguage = "IdentifyLanguage"
        case languageCode = "LanguageCode"
        case languageModelName = "LanguageModelName"
        case languageOptions = "LanguageOptions"
        case partialResultsStability = "PartialResultsStability"
        case piiEntityTypes = "PiiEntityTypes"
        case preferredLanguage = "PreferredLanguage"
        case region = "Region"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyFilterNames = "VocabularyFilterNames"
        case vocabularyName = "VocabularyName"
        case vocabularyNames = "VocabularyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let contentRedactionType = self.contentRedactionType {
            try encodeContainer.encode(contentRedactionType.rawValue, forKey: .contentRedactionType)
        }
        if enablePartialResultsStabilization != false {
            try encodeContainer.encode(enablePartialResultsStabilization, forKey: .enablePartialResultsStabilization)
        }
        if identifyLanguage != false {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let languageOptions = self.languageOptions {
            try encodeContainer.encode(languageOptions, forKey: .languageOptions)
        }
        if let partialResultsStability = self.partialResultsStability {
            try encodeContainer.encode(partialResultsStability.rawValue, forKey: .partialResultsStability)
        }
        if let piiEntityTypes = self.piiEntityTypes {
            try encodeContainer.encode(piiEntityTypes, forKey: .piiEntityTypes)
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage.rawValue, forKey: .preferredLanguage)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyFilterNames = self.vocabularyFilterNames {
            try encodeContainer.encode(vocabularyFilterNames, forKey: .vocabularyFilterNames)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
        if let vocabularyNames = self.vocabularyNames {
            try encodeContainer.encode(vocabularyNames, forKey: .vocabularyNames)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeVocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeRegion.self, forKey: .region)
        region = regionDecoded
        let enablePartialResultsStabilizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePartialResultsStabilization) ?? false
        enablePartialResultsStabilization = enablePartialResultsStabilizationDecoded
        let partialResultsStabilityDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribePartialResultsStability.self, forKey: .partialResultsStability)
        partialResultsStability = partialResultsStabilityDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeContentIdentificationType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let contentRedactionTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeContentRedactionType.self, forKey: .contentRedactionType)
        contentRedactionType = contentRedactionTypeDecoded
        let piiEntityTypesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .piiEntityTypes)
        piiEntityTypes = piiEntityTypesDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage) ?? false
        identifyLanguage = identifyLanguageDecoded
        let languageOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageOptions)
        languageOptions = languageOptionsDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscribeLanguageCode.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let vocabularyNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyNames)
        vocabularyNames = vocabularyNamesDecoded
        let vocabularyFilterNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterNames)
        vocabularyFilterNames = vocabularyFilterNamesDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// Settings specific for Amazon Transcribe as the live transcription engine. If you specify an invalid combination of parameters, a TranscriptFailed event will be sent with the contents of the BadRequestException generated by Amazon Transcribe. For more information on each parameter and which combinations are valid, refer to the [StartStreamTranscription](https://docs.aws.amazon.com/transcribe/latest/APIReference/API_streaming_StartStreamTranscription.html) API in the Amazon Transcribe Developer Guide.
    public struct EngineTranscribeSettings: Swift.Equatable {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You can’t set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeContentIdentificationType?
        /// Content redaction is performed at the segment level. If you don't include PiiEntityTypes, all PII is redacted. You can’t set ContentRedactionType and ContentIdentificationType.
        public var contentRedactionType: ChimeSDKMeetingsClientTypes.TranscribeContentRedactionType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.
        public var enablePartialResultsStabilization: Swift.Bool
        /// Enables automatic language identification for your transcription. If you include IdentifyLanguage, you can optionally use LanguageOptions to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy. You can also use PreferredLanguage to include a preferred language. Doing so can help Amazon Transcribe identify the language faster. You must include either LanguageCode or IdentifyLanguage. Language identification can't be combined with custom language models or redaction.
        public var identifyLanguage: Swift.Bool
        /// Specify the language code that represents the language spoken. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification.
        public var languageCode: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode?
        /// Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.
        public var languageModelName: Swift.String?
        /// Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. If you include LanguageOptions, you must also include IdentifyLanguage. You can only include one language dialect per language. For example, you cannot include en-US and en-AU.
        public var languageOptions: Swift.String?
        /// Specify the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.
        public var partialResultsStability: ChimeSDKMeetingsClientTypes.TranscribePartialResultsStability?
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRYCREDIT_DEBIT_NUMBER, EMAIL,NAME, PHONE, PIN, SSN, or ALL. Note that if you include PiiEntityTypes, you must also include ContentIdentificationType or ContentRedactionType. If you include ContentRedactionType or ContentIdentificationType, but do not include PiiEntityTypes, all PII is redacted or identified.
        public var piiEntityTypes: Swift.String?
        /// Specify a preferred language from the subset of languages codes you specified in LanguageOptions. You can only use this parameter if you include IdentifyLanguage and LanguageOptions.
        public var preferredLanguage: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode?
        /// The AWS Region in which to use Amazon Transcribe. If you don't specify a Region, then the [MediaRegion](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html) of the meeting is used. However, if Amazon Transcribe is not available in the MediaRegion, then a TranscriptFailed event is sent. Use auto to use Amazon Transcribe in a Region near the meeting’s MediaRegion. For more information, refer to [Choosing a transcription Region](https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region) in the Amazon Chime SDK Developer Guide.
        public var region: ChimeSDKMeetingsClientTypes.TranscribeRegion?
        /// Specify how you want your vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeSDKMeetingsClientTypes.TranscribeVocabularyFilterMethod?
        /// Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more vocabulary filters with your transcription, use the VocabularyFilterNames parameter instead.
        public var vocabularyFilterName: Swift.String?
        /// Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you're not including IdentifyLanguage and want to use a custom vocabulary filter with your transcription, use the VocabularyFilterName parameter instead.
        public var vocabularyFilterNames: Swift.String?
        /// Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more custom vocabularies with your transcription, use the VocabularyNames parameter instead.
        public var vocabularyName: Swift.String?
        /// Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you don't include IdentifyLanguage and want to use a custom vocabulary with your transcription, use the VocabularyName parameter instead.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeContentIdentificationType? = nil,
            contentRedactionType: ChimeSDKMeetingsClientTypes.TranscribeContentRedactionType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            identifyLanguage: Swift.Bool = false,
            languageCode: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeSDKMeetingsClientTypes.TranscribePartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode? = nil,
            region: ChimeSDKMeetingsClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeSDKMeetingsClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetAttendeeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

public struct GetAttendeeInput: Swift.Equatable {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

struct GetAttendeeInputBody: Swift.Equatable {
}

extension GetAttendeeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAttendeeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAttendeeOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct GetAttendeeOutput: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct GetAttendeeOutputBody: Swift.Equatable {
    let attendee: ChimeSDKMeetingsClientTypes.Attendee?
}

extension GetAttendeeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

enum GetAttendeeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMeetingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

public struct GetMeetingInput: Swift.Equatable {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct GetMeetingInputBody: Swift.Equatable {
}

extension GetMeetingInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMeetingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMeetingOutputBody = try responseDecoder.decode(responseBody: data)
            self.meeting = output.meeting
        } else {
            self.meeting = nil
        }
    }
}

public struct GetMeetingOutput: Swift.Equatable {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

struct GetMeetingOutputBody: Swift.Equatable {
    let meeting: ChimeSDKMeetingsClientTypes.Meeting?
}

extension GetMeetingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meeting = "Meeting"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Meeting.self, forKey: .meeting)
        meeting = meetingDecoded
    }
}

enum GetMeetingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ListAttendeesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAttendeesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

public struct ListAttendeesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

struct ListAttendeesInputBody: Swift.Equatable {
}

extension ListAttendeesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAttendeesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttendeesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendees = output.attendees
            self.nextToken = output.nextToken
        } else {
            self.attendees = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttendeesOutput: Swift.Equatable {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

struct ListAttendeesOutputBody: Swift.Equatable {
    let attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    let nextToken: Swift.String?
}

extension ListAttendeesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendees = "Attendees"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeesContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Attendee?].self, forKey: .attendees)
        var attendeesDecoded0:[ChimeSDKMeetingsClientTypes.Attendee]? = nil
        if let attendeesContainer = attendeesContainer {
            attendeesDecoded0 = [ChimeSDKMeetingsClientTypes.Attendee]()
            for structure0 in attendeesContainer {
                if let structure0 = structure0 {
                    attendeesDecoded0?.append(structure0)
                }
            }
        }
        attendees = attendeesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttendeesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags requested for the specified resource.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?

    public init(
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ChimeSDKMeetingsClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMeetingsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMeetingsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum MediaCapabilities: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case receive
        case send
        case sendReceive
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaCapabilities] {
            return [
                .none,
                .receive,
                .send,
                .sendReceive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .receive: return "Receive"
            case .send: return "Send"
            case .sendReceive: return "SendReceive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaCapabilities(rawValue: rawValue) ?? MediaCapabilities.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.MediaPlacement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioFallbackUrl = "AudioFallbackUrl"
        case audioHostUrl = "AudioHostUrl"
        case eventIngestionUrl = "EventIngestionUrl"
        case screenDataUrl = "ScreenDataUrl"
        case screenSharingUrl = "ScreenSharingUrl"
        case screenViewingUrl = "ScreenViewingUrl"
        case signalingUrl = "SignalingUrl"
        case turnControlUrl = "TurnControlUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioFallbackUrl = self.audioFallbackUrl {
            try encodeContainer.encode(audioFallbackUrl, forKey: .audioFallbackUrl)
        }
        if let audioHostUrl = self.audioHostUrl {
            try encodeContainer.encode(audioHostUrl, forKey: .audioHostUrl)
        }
        if let eventIngestionUrl = self.eventIngestionUrl {
            try encodeContainer.encode(eventIngestionUrl, forKey: .eventIngestionUrl)
        }
        if let screenDataUrl = self.screenDataUrl {
            try encodeContainer.encode(screenDataUrl, forKey: .screenDataUrl)
        }
        if let screenSharingUrl = self.screenSharingUrl {
            try encodeContainer.encode(screenSharingUrl, forKey: .screenSharingUrl)
        }
        if let screenViewingUrl = self.screenViewingUrl {
            try encodeContainer.encode(screenViewingUrl, forKey: .screenViewingUrl)
        }
        if let signalingUrl = self.signalingUrl {
            try encodeContainer.encode(signalingUrl, forKey: .signalingUrl)
        }
        if let turnControlUrl = self.turnControlUrl {
            try encodeContainer.encode(turnControlUrl, forKey: .turnControlUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioHostUrl)
        audioHostUrl = audioHostUrlDecoded
        let audioFallbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioFallbackUrl)
        audioFallbackUrl = audioFallbackUrlDecoded
        let signalingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalingUrl)
        signalingUrl = signalingUrlDecoded
        let turnControlUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .turnControlUrl)
        turnControlUrl = turnControlUrlDecoded
        let screenDataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenDataUrl)
        screenDataUrl = screenDataUrlDecoded
        let screenViewingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenViewingUrl)
        screenViewingUrl = screenViewingUrlDecoded
        let screenSharingUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenSharingUrl)
        screenSharingUrl = screenSharingUrlDecoded
        let eventIngestionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventIngestionUrl)
        eventIngestionUrl = eventIngestionUrlDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement: Swift.Equatable {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL.
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeSDKMeetingsClientTypes.Meeting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalMeetingId = "ExternalMeetingId"
        case mediaPlacement = "MediaPlacement"
        case mediaRegion = "MediaRegion"
        case meetingArn = "MeetingArn"
        case meetingFeatures = "MeetingFeatures"
        case meetingHostId = "MeetingHostId"
        case meetingId = "MeetingId"
        case primaryMeetingId = "PrimaryMeetingId"
        case tenantIds = "TenantIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalMeetingId = self.externalMeetingId {
            try encodeContainer.encode(externalMeetingId, forKey: .externalMeetingId)
        }
        if let mediaPlacement = self.mediaPlacement {
            try encodeContainer.encode(mediaPlacement, forKey: .mediaPlacement)
        }
        if let mediaRegion = self.mediaRegion {
            try encodeContainer.encode(mediaRegion, forKey: .mediaRegion)
        }
        if let meetingArn = self.meetingArn {
            try encodeContainer.encode(meetingArn, forKey: .meetingArn)
        }
        if let meetingFeatures = self.meetingFeatures {
            try encodeContainer.encode(meetingFeatures, forKey: .meetingFeatures)
        }
        if let meetingHostId = self.meetingHostId {
            try encodeContainer.encode(meetingHostId, forKey: .meetingHostId)
        }
        if let meetingId = self.meetingId {
            try encodeContainer.encode(meetingId, forKey: .meetingId)
        }
        if let primaryMeetingId = self.primaryMeetingId {
            try encodeContainer.encode(primaryMeetingId, forKey: .primaryMeetingId)
        }
        if let tenantIds = tenantIds {
            var tenantIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tenantIds)
            for tenantid0 in tenantIds {
                try tenantIdsContainer.encode(tenantid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingId)
        meetingId = meetingIdDecoded
        let meetingHostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingHostId)
        meetingHostId = meetingHostIdDecoded
        let externalMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalMeetingId)
        externalMeetingId = externalMeetingIdDecoded
        let mediaRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaRegion)
        mediaRegion = mediaRegionDecoded
        let mediaPlacementDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MediaPlacement.self, forKey: .mediaPlacement)
        mediaPlacement = mediaPlacementDecoded
        let meetingFeaturesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.self, forKey: .meetingFeatures)
        meetingFeatures = meetingFeaturesDecoded
        let primaryMeetingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryMeetingId)
        primaryMeetingId = primaryMeetingIdDecoded
        let tenantIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tenantIds)
        var tenantIdsDecoded0:[Swift.String]? = nil
        if let tenantIdsContainer = tenantIdsContainer {
            tenantIdsDecoded0 = [Swift.String]()
            for string0 in tenantIdsContainer {
                if let string0 = string0 {
                    tenantIdsDecoded0?.append(string0)
                }
            }
        }
        tenantIds = tenantIdsDecoded0
        let meetingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meetingArn)
        meetingArn = meetingArnDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.Meeting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Meeting(mediaPlacement: \(Swift.String(describing: mediaPlacement)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingArn: \(Swift.String(describing: meetingArn)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), meetingId: \(Swift.String(describing: meetingId)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tenantIds: \(Swift.String(describing: tenantIds)), externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting: Swift.Equatable {
        /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeSDKMeetingsClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in AWS GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
        public var mediaRegion: Swift.String?
        /// The ARN of the meeting.
        public var meetingArn: Swift.String?
        /// The features available to a meeting, such as echo reduction.
        public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
        /// Reserved.
        public var meetingHostId: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?
        /// When specified, replicates the media from the primary meeting to this meeting.
        public var primaryMeetingId: Swift.String?
        /// Array of strings.
        public var tenantIds: [Swift.String]?

        public init(
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeSDKMeetingsClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingArn: Swift.String? = nil,
            meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
            meetingHostId: Swift.String? = nil,
            meetingId: Swift.String? = nil,
            primaryMeetingId: Swift.String? = nil,
            tenantIds: [Swift.String]? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingArn = meetingArn
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.meetingId = meetingId
            self.primaryMeetingId = primaryMeetingId
            self.tenantIds = tenantIds
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    public enum MeetingFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MeetingFeatureStatus] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MeetingFeatureStatus(rawValue: rawValue) ?? MeetingFeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AudioFeatures.self, forKey: .audio)
        audio = audioDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration settings of the features available to a meeting.
    public struct MeetingFeaturesConfiguration: Swift.Equatable {
        /// The configuration settings for the audio features available to a meeting.
        public var audio: ChimeSDKMeetingsClientTypes.AudioFeatures?

        public init(
            audio: ChimeSDKMeetingsClientTypes.AudioFeatures? = nil
        )
        {
            self.audio = audio
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.NotificationsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn = "LambdaFunctionArn"
        case snsTopicArn = "SnsTopicArn"
        case sqsQueueArn = "SqsQueueArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = self.lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sqsQueueArn = self.sqsQueueArn {
            try encodeContainer.encode(sqsQueueArn, forKey: .sqsQueueArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sqsQueueArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsQueueArn)
        sqsQueueArn = sqsQueueArnDecoded
    }
}

extension ChimeSDKMeetingsClientTypes.NotificationsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationsConfiguration(lambdaFunctionArn: \"CONTENT_REDACTED\", snsTopicArn: \"CONTENT_REDACTED\", sqsQueueArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public struct NotificationsConfiguration: Swift.Equatable {
        /// The ARN of the AWS Lambda function in the notifications configuration.
        public var lambdaFunctionArn: Swift.String?
        /// The ARN of the SNS topic.
        public var snsTopicArn: Swift.String?
        /// The ARN of the SQS queue.
        public var sqsQueueArn: Swift.String?

        public init(
            lambdaFunctionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource that you want to tag couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that couldn't be found.
        public internal(set) var requestId: Swift.String? = nil
        /// The name of the resource that couldn't be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the failed request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension StartMeetingTranscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transcriptionConfiguration = self.transcriptionConfiguration {
            try encodeContainer.encode(transcriptionConfiguration, forKey: .transcriptionConfiguration)
        }
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
            return items
        }
    }
}

extension StartMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StartMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration?

    public init(
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

struct StartMeetingTranscriptionInputBody: Swift.Equatable {
    let transcriptionConfiguration: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration?
}

extension StartMeetingTranscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transcriptionConfiguration = "TranscriptionConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.TranscriptionConfiguration.self, forKey: .transcriptionConfiguration)
        transcriptionConfiguration = transcriptionConfigurationDecoded
    }
}

extension StartMeetingTranscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartMeetingTranscriptionOutput: Swift.Equatable {

    public init() { }
}

enum StartMeetingTranscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopMeetingTranscriptionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopMeetingTranscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

public struct StopMeetingTranscriptionInput: Swift.Equatable {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

struct StopMeetingTranscriptionInputBody: Swift.Equatable {
}

extension StopMeetingTranscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopMeetingTranscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopMeetingTranscriptionOutput: Swift.Equatable {

    public init() { }
}

enum StopMeetingTranscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// A key-value pair that you define.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Lists the requested tags.
    /// This member is required.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKMeetingsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMeetingsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMeetingsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMeetingsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of customer requests exceeds the request rate limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request that exceeded the throttling limit.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many tags were added to the specified resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request that contains too many tags.
        public internal(set) var requestId: Swift.String? = nil
        /// The name of the resource that received too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentIdentificationType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentIdentificationType(rawValue: rawValue) ?? TranscribeContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeContentRedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentRedactionType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeContentRedactionType(rawValue: rawValue) ?? TranscribeContentRedactionType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case hiIn
        case itIt
        case jaJp
        case koKr
        case ptBr
        case thTh
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .hiIn,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .thTh,
                .zhCn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .thTh: return "th-TH"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeLanguageCode(rawValue: rawValue) ?? TranscribeLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeMedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalContentIdentificationType] {
            return [
                .phi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalContentIdentificationType(rawValue: rawValue) ?? TranscribeMedicalContentIdentificationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalLanguageCode(rawValue: rawValue) ?? TranscribeMedicalLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalRegion(rawValue: rawValue) ?? TranscribeMedicalRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalSpecialty(rawValue: rawValue) ?? TranscribeMedicalSpecialty.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeMedicalType(rawValue: rawValue) ?? TranscribeMedicalType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribePartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribePartialResultsStability] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribePartialResultsStability(rawValue: rawValue) ?? TranscribePartialResultsStability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usGovWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usGovWest1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usGovWest1: return "us-gov-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeRegion(rawValue: rawValue) ?? TranscribeRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscribeVocabularyFilterMethod(rawValue: rawValue) ?? TranscribeVocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMeetingsClientTypes.TranscriptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineTranscribeMedicalSettings = "EngineTranscribeMedicalSettings"
        case engineTranscribeSettings = "EngineTranscribeSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineTranscribeMedicalSettings = self.engineTranscribeMedicalSettings {
            try encodeContainer.encode(engineTranscribeMedicalSettings, forKey: .engineTranscribeMedicalSettings)
        }
        if let engineTranscribeSettings = self.engineTranscribeSettings {
            try encodeContainer.encode(engineTranscribeSettings, forKey: .engineTranscribeSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTranscribeSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.EngineTranscribeSettings.self, forKey: .engineTranscribeSettings)
        engineTranscribeSettings = engineTranscribeSettingsDecoded
        let engineTranscribeMedicalSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings.self, forKey: .engineTranscribeMedicalSettings)
        engineTranscribeMedicalSettings = engineTranscribeMedicalSettingsDecoded
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration: Swift.Equatable {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings?

        public init(
            engineTranscribeMedicalSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user isn't authorized to request a resource.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource that you're removing tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys being removed from the resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAttendeeCapabilitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
    }
}

extension UpdateAttendeeCapabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let meetingId = meetingId else {
            return nil
        }
        guard let attendeeId = attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/capabilities"
    }
}

public struct UpdateAttendeeCapabilitiesInput: Swift.Equatable {
    /// The ID of the attendee associated with the update request.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The capabilities that you want to update.
    /// This member is required.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The ID of the meeting associated with the update request.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.capabilities = capabilities
        self.meetingId = meetingId
    }
}

struct UpdateAttendeeCapabilitiesInputBody: Swift.Equatable {
    let capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
}

extension UpdateAttendeeCapabilitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.AttendeeCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
    }
}

extension UpdateAttendeeCapabilitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAttendeeCapabilitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attendee = output.attendee
        } else {
            self.attendee = nil
        }
    }
}

public struct UpdateAttendeeCapabilitiesOutput: Swift.Equatable {
    /// The updated attendee data.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

struct UpdateAttendeeCapabilitiesOutputBody: Swift.Equatable {
    let attendee: ChimeSDKMeetingsClientTypes.Attendee?
}

extension UpdateAttendeeCapabilitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendee = "Attendee"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeDecoded = try containerValues.decodeIfPresent(ChimeSDKMeetingsClientTypes.Attendee.self, forKey: .attendee)
        attendee = attendeeDecoded
    }
}

enum UpdateAttendeeCapabilitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
