//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

public struct BatchUpdateAttendeeCapabilitiesExceptOutput {

    public init() { }
}

public struct DeleteAttendeeOutput {

    public init() { }
}

public struct DeleteMeetingOutput {

    public init() { }
}

public struct StartMeetingTranscriptionOutput {

    public init() { }
}

public struct StopMeetingTranscriptionOutput {

    public init() { }
}

extension ChimeSDKMeetingsClientTypes {

    public enum MediaCapabilities: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case receive
        case send
        case sendReceive
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaCapabilities] {
            return [
                .none,
                .receive,
                .send,
                .sendReceive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .receive: return "Receive"
            case .send: return "Send"
            case .sendReceive: return "SendReceive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The media capabilities of an attendee: audio, video, or content. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information, refer to and . When using capabilities, be aware of these corner cases:
    ///
    /// * If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.
    ///
    /// * If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.
    ///
    /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
    ///
    /// * When you change an audio capability from None or Receive to Send or SendReceive , and an attendee unmutes their microphone, audio flows from the attendee to the other meeting participants.
    ///
    /// * When you change a video or content capability from None or Receive to Send or SendReceive , and the attendee turns on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
    public struct AttendeeCapabilities {
        /// The audio capability assigned to an attendee.
        /// This member is required.
        public var audio: ChimeSDKMeetingsClientTypes.MediaCapabilities?
        /// The content capability assigned to an attendee.
        /// This member is required.
        public var content: ChimeSDKMeetingsClientTypes.MediaCapabilities?
        /// The video capability assigned to an attendee.
        /// This member is required.
        public var video: ChimeSDKMeetingsClientTypes.MediaCapabilities?

        public init(
            audio: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil,
            content: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil,
            video: ChimeSDKMeetingsClientTypes.MediaCapabilities? = nil
        )
        {
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// An Amazon Chime SDK meeting attendee. Includes a unique AttendeeId and JoinToken. The JoinToken allows a client to authenticate and join as the specified attendee. The JoinToken expires when the meeting ends, or when [DeleteAttendee] is called. After that, the attendee is unable to join the meeting. We recommend securely transferring each JoinToken from your server application to the client so that no other client has access to the token except for the one authorized to represent the attendee.
    public struct Attendee {
        /// The Amazon Chime SDK attendee ID.
        public var attendeeId: Swift.String?
        /// The capabilities assigned to an attendee: audio, video, or content. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see . When using capabilities, be aware of these corner cases:
        ///
        /// * If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.
        ///
        /// * If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.
        ///
        /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
        ///
        /// * When you change an audio capability from None or Receive to Send or SendReceive , and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.
        ///
        /// * When you change a video or content capability from None or Receive to Send or SendReceive , and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
        public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalUserId: Swift.String?
        /// The join token used by the Amazon Chime SDK attendee.
        public var joinToken: Swift.String?

        public init(
            attendeeId: Swift.String? = nil,
            capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
            externalUserId: Swift.String? = nil,
            joinToken: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
            self.capabilities = capabilities
            self.externalUserId = externalUserId
            self.joinToken = joinToken
        }
    }

}

extension ChimeSDKMeetingsClientTypes.Attendee: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attendee(attendeeId: \(Swift.String(describing: attendeeId)), capabilities: \(Swift.String(describing: capabilities)), externalUserId: \"CONTENT_REDACTED\", joinToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// Lists the maximum number of attendees allowed into the meeting. If you specify FHD for MeetingFeatures:Video:MaxResolution, or if you specify UHD for MeetingFeatures:Content:MaxResolution, the maximum number of attendees changes from the default of 250 to 25.
    public struct AttendeeFeatures {
        /// The maximum number of attendees allowed into the meeting.
        public var maxCount: Swift.Int?

        public init(
            maxCount: Swift.Int? = nil
        )
        {
            self.maxCount = maxCount
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// A structure that contains one or more attendee IDs.
    public struct AttendeeIdItem {
        /// A list of one or more attendee IDs.
        /// This member is required.
        public var attendeeId: Swift.String?

        public init(
            attendeeId: Swift.String? = nil
        )
        {
            self.attendeeId = attendeeId
        }
    }

}

extension ChimeSDKMeetingsClientTypes {

    public enum MeetingFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MeetingFeatureStatus] {
            return [
                .available,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// An optional category of meeting features that contains audio-specific configurations, such as operating parameters for Amazon Voice Focus.
    public struct AudioFeatures {
        /// Makes echo reduction available to clients who connect to the meeting.
        public var echoReduction: ChimeSDKMeetingsClientTypes.MeetingFeatureStatus?

        public init(
            echoReduction: ChimeSDKMeetingsClientTypes.MeetingFeatureStatus? = nil
        )
        {
            self.echoReduction = echoReduction
        }
    }

}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The request exceeds the resource limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the failed request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The number of customer requests exceeds the request rate limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request that exceeded the throttling limit.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The user isn't authorized to request a resource.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The request was well-formed but was unable to be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The Amazon Chime SDK attendee fields to create, used with the BatchCreateAttendee action.
    public struct CreateAttendeeRequestItem {
        /// A list of one or more capabilities.
        public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        /// This member is required.
        public var externalUserId: Swift.String?

        public init(
            capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.externalUserId = externalUserId
        }
    }

}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeRequestItem(capabilities: \(Swift.String(describing: capabilities)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateAttendeeInput {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The Amazon Chime SDK ID of the meeting to which you're adding attendees.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.meetingId = meetingId
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The list of errors returned when errors are encountered during the BatchCreateAttendee and CreateAttendee actions. This includes external user IDs, error codes, and error messages.
    public struct CreateAttendeeError {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalUserId: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            externalUserId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.externalUserId = externalUserId
        }
    }

}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct BatchCreateAttendeeOutput {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
    }
}

/// Multiple instances of the same request have been made simultaneously.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request involved in the conflict.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct BatchUpdateAttendeeCapabilitiesExceptInput {
    /// The capabilities (audio, video, or content) that you want to update.
    /// This member is required.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The AttendeeIDs that you want to exclude from one or more capabilities.
    /// This member is required.
    public var excludedAttendeeIds: [ChimeSDKMeetingsClientTypes.AttendeeIdItem]?
    /// The ID of the meeting associated with the update request.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        excludedAttendeeIds: [ChimeSDKMeetingsClientTypes.AttendeeIdItem]? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.excludedAttendeeIds = excludedAttendeeIds
        self.meetingId = meetingId
    }
}

public struct CreateAttendeeInput {
    /// The capabilities (audio, video, or content) that you want to grant an attendee. If you don't specify capabilities, all users have send and receive capabilities on all media channels by default. You use the capabilities with a set of values that control what the capabilities can do, such as SendReceive data. For more information about those values, see . When using capabilities, be aware of these corner cases:
    ///
    /// * If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.
    ///
    /// * If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.
    ///
    /// * You can't set content capabilities to SendReceive or Receive unless you also set video capabilities to SendReceive or Receive. If you don't set the video capability to receive, the response will contain an HTTP 400 Bad Request status code. However, you can set your video capability to receive and you set your content capability to not receive.
    ///
    /// * When you change an audio capability from None or Receive to Send or SendReceive , and if the attendee left their microphone unmuted, audio will flow from the attendee to the other meeting participants.
    ///
    /// * When you change a video or content capability from None or Receive to Send or SendReceive , and if the attendee turned on their video or content streams, remote attendees can receive those streams, but only after media renegotiation between the client and the Amazon Chime back-end server.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The Amazon Chime SDK external user ID. An idempotency token. Links the attendee to an identity managed by a builder application. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix.
    /// This member is required.
    public var externalUserId: Swift.String?
    /// The unique ID of the meeting.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        externalUserId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.externalUserId = externalUserId
        self.meetingId = meetingId
    }
}

extension CreateAttendeeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAttendeeInput(capabilities: \(Swift.String(describing: capabilities)), meetingId: \(Swift.String(describing: meetingId)), externalUserId: \"CONTENT_REDACTED\")"}
}

public struct CreateAttendeeOutput {
    /// The attendee information, including attendee ID and join token.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum ContentResolution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fhd
        case `none`
        case uhd
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentResolution] {
            return [
                .fhd,
                .none,
                .uhd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fhd: return "FHD"
            case .none: return "None"
            case .uhd: return "UHD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// Lists the content (screen share) features for the meeting. Applies to all attendees. If you specify MeetingFeatures:Content:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Content will be rejected with ValidationError 400.
    public struct ContentFeatures {
        /// The maximum resolution for the meeting content. Defaults to FHD. To use UHD, you must also provide a MeetingFeatures:Attendee:MaxCount value and override the default size limit of 250 attendees.
        public var maxResolution: ChimeSDKMeetingsClientTypes.ContentResolution?

        public init(
            maxResolution: ChimeSDKMeetingsClientTypes.ContentResolution? = nil
        )
        {
            self.maxResolution = maxResolution
        }
    }

}

extension ChimeSDKMeetingsClientTypes {

    public enum VideoResolution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fhd
        case hd
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoResolution] {
            return [
                .fhd,
                .hd,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fhd: return "FHD"
            case .hd: return "HD"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// The video features set for the meeting. Applies to all attendees. If you specify MeetingFeatures:Video:MaxResolution:None when you create a meeting, all API requests that include SendReceive, Send, or Receive for AttendeeCapabilities:Video will be rejected with ValidationError 400.
    public struct VideoFeatures {
        /// The maximum video resolution for the meeting. Applies to all attendees. Defaults to HD. To use FHD, you must also provide a MeetingFeatures:Attendee:MaxCount value and override the default size limit of 250 attendees.
        public var maxResolution: ChimeSDKMeetingsClientTypes.VideoResolution?

        public init(
            maxResolution: ChimeSDKMeetingsClientTypes.VideoResolution? = nil
        )
        {
            self.maxResolution = maxResolution
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration settings of the features available to a meeting.
    public struct MeetingFeaturesConfiguration {
        /// The configuration settings for the attendee features available to a meeting.
        public var attendee: ChimeSDKMeetingsClientTypes.AttendeeFeatures?
        /// The configuration settings for the audio features available to a meeting.
        public var audio: ChimeSDKMeetingsClientTypes.AudioFeatures?
        /// The configuration settings for the content features available to a meeting.
        public var content: ChimeSDKMeetingsClientTypes.ContentFeatures?
        /// The configuration settings for the video features available to a meeting.
        public var video: ChimeSDKMeetingsClientTypes.VideoFeatures?

        public init(
            attendee: ChimeSDKMeetingsClientTypes.AttendeeFeatures? = nil,
            audio: ChimeSDKMeetingsClientTypes.AudioFeatures? = nil,
            content: ChimeSDKMeetingsClientTypes.ContentFeatures? = nil,
            video: ChimeSDKMeetingsClientTypes.VideoFeatures? = nil
        )
        {
            self.attendee = attendee
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public struct NotificationsConfiguration {
        /// The ARN of the Amazon Web Services Lambda function in the notifications configuration.
        public var lambdaFunctionArn: Swift.String?
        /// The ARN of the SNS topic.
        public var snsTopicArn: Swift.String?
        /// The ARN of the SQS queue.
        public var sqsQueueArn: Swift.String?

        public init(
            lambdaFunctionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sqsQueueArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
            self.snsTopicArn = snsTopicArn
            self.sqsQueueArn = sqsQueueArn
        }
    }

}

extension ChimeSDKMeetingsClientTypes.NotificationsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationsConfiguration(lambdaFunctionArn: \"CONTENT_REDACTED\", snsTopicArn: \"CONTENT_REDACTED\", sqsQueueArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// A key-value pair that you define.
    public struct Tag {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateMeetingInput {
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    /// When specified, replicates the media from the primary meeting to the new meeting.
    public var primaryMeetingId: Swift.String?
    /// Applies one or more tags to an Amazon Chime SDK meeting. Note the following:
    ///
    /// * Not all resources have tags. For a list of services with resources that support tagging using this operation, see [Services that support the Resource Groups Tagging API](https://docs.aws.amazon.com/resourcegroupstagging/latest/APIReference/supported-services.html). If the resource doesn't yet support this operation, the resource's service might support tagging using its own API operations. For more information, refer to the documentation for that service.
    ///
    /// * Each resource can have up to 50 tags. For other limits, see [Tag Naming and Usage Conventions](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions) in the AWS General Reference.
    ///
    /// * You can only tag resources that are located in the specified Amazon Web Services Region for the Amazon Web Services account.
    ///
    /// * To add tags to a resource, you need the necessary permissions for the service that the resource belongs to as well as permissions for adding tags. For more information, see the documentation for each service.
    ///
    ///
    /// Do not store personally identifiable information (PII) or other confidential or sensitive information in tags. We use tags to provide you with billing and administration services. Tags are not intended to be used for private or sensitive data. Minimum permissions In addition to the tag:TagResources permission required by this operation, you must also have the tagging permission defined by the service that created the resource. For example, to tag a ChimeSDKMeetings instance using the TagResources operation, you must have both of the following permissions: tag:TagResourcesChimeSDKMeetings:CreateTags Some services might have specific requirements for tagging some resources. For example, to tag an Amazon S3 bucket, you must also have the s3:GetBucketTagging permission. If the expected minimum permissions don't work, check the documentation for that service's tagging APIs for more information.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?
    /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
    public var tenantIds: [Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration? = nil,
        primaryMeetingId: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil,
        tenantIds: [Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.primaryMeetingId = primaryMeetingId
        self.tags = tags
        self.tenantIds = tenantIds
    }
}

extension CreateMeetingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingInput(mediaRegion: \(Swift.String(describing: mediaRegion)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tags: \(Swift.String(describing: tags)), tenantIds: \(Swift.String(describing: tenantIds)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMeetingsClientTypes {
    /// A set of endpoints used by clients to connect to the media service group for an Amazon Chime SDK meeting.
    public struct MediaPlacement {
        /// The audio fallback URL.
        public var audioFallbackUrl: Swift.String?
        /// The audio host URL.
        public var audioHostUrl: Swift.String?
        /// The event ingestion URL.
        public var eventIngestionUrl: Swift.String?
        /// The screen data URL. This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public var screenDataUrl: Swift.String?
        /// The screen sharing URL. This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public var screenSharingUrl: Swift.String?
        /// The screen viewing URL. This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public var screenViewingUrl: Swift.String?
        /// The signaling URL.
        public var signalingUrl: Swift.String?
        /// The turn control URL. This parameter is deprecated and no longer used by the Amazon Chime SDK.
        public var turnControlUrl: Swift.String?

        public init(
            audioFallbackUrl: Swift.String? = nil,
            audioHostUrl: Swift.String? = nil,
            eventIngestionUrl: Swift.String? = nil,
            screenDataUrl: Swift.String? = nil,
            screenSharingUrl: Swift.String? = nil,
            screenViewingUrl: Swift.String? = nil,
            signalingUrl: Swift.String? = nil,
            turnControlUrl: Swift.String? = nil
        )
        {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.screenDataUrl = screenDataUrl
            self.screenSharingUrl = screenSharingUrl
            self.screenViewingUrl = screenViewingUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// A meeting created using the Amazon Chime SDK.
    public struct Meeting {
        /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
        public var externalMeetingId: Swift.String?
        /// The media placement for the meeting.
        public var mediaPlacement: ChimeSDKMeetingsClientTypes.MediaPlacement?
        /// The Region in which you create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
        public var mediaRegion: Swift.String?
        /// The ARN of the meeting.
        public var meetingArn: Swift.String?
        /// The features available to a meeting, such as echo reduction.
        public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
        /// Reserved.
        public var meetingHostId: Swift.String?
        /// The Amazon Chime SDK meeting ID.
        public var meetingId: Swift.String?
        /// When specified, replicates the media from the primary meeting to this meeting.
        public var primaryMeetingId: Swift.String?
        /// Array of strings.
        public var tenantIds: [Swift.String]?

        public init(
            externalMeetingId: Swift.String? = nil,
            mediaPlacement: ChimeSDKMeetingsClientTypes.MediaPlacement? = nil,
            mediaRegion: Swift.String? = nil,
            meetingArn: Swift.String? = nil,
            meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
            meetingHostId: Swift.String? = nil,
            meetingId: Swift.String? = nil,
            primaryMeetingId: Swift.String? = nil,
            tenantIds: [Swift.String]? = nil
        )
        {
            self.externalMeetingId = externalMeetingId
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingArn = meetingArn
            self.meetingFeatures = meetingFeatures
            self.meetingHostId = meetingHostId
            self.meetingId = meetingId
            self.primaryMeetingId = primaryMeetingId
            self.tenantIds = tenantIds
        }
    }

}

extension ChimeSDKMeetingsClientTypes.Meeting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Meeting(mediaPlacement: \(Swift.String(describing: mediaPlacement)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingArn: \(Swift.String(describing: meetingArn)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), meetingId: \(Swift.String(describing: meetingId)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tenantIds: \(Swift.String(describing: tenantIds)), externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingOutput {
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

public struct CreateMeetingWithAttendeesInput {
    /// The attendee information, including attendees' IDs and join tokens.
    /// This member is required.
    public var attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]?
    /// The unique identifier for the client request. Use a different token for different meetings.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The external meeting ID. Pattern: [-_&@+=,(){}\[\]\/«».:|'"#a-zA-Z0-9À-ÿ\s]* Values that begin with aws: are reserved. You can't configure a value that uses this prefix. Case insensitive.
    /// This member is required.
    public var externalMeetingId: Swift.String?
    /// The Region in which to create the meeting. Available values: af-south-1, ap-northeast-1, ap-northeast-2, ap-south-1, ap-southeast-1, ap-southeast-2, ca-central-1, eu-central-1, eu-north-1, eu-south-1, eu-west-1, eu-west-2, eu-west-3, sa-east-1, us-east-1, us-east-2, us-west-1, us-west-2. Available values in Amazon Web Services GovCloud (US) Regions: us-gov-east-1, us-gov-west-1.
    /// This member is required.
    public var mediaRegion: Swift.String?
    /// Lists the audio and video features enabled for a meeting, such as echo reduction.
    public var meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?
    /// Reserved.
    public var meetingHostId: Swift.String?
    /// The configuration for resource targets to receive notifications when meeting and attendee events occur.
    public var notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?
    /// When specified, replicates the media from the primary meeting to the new meeting.
    public var primaryMeetingId: Swift.String?
    /// The tags in the request.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?
    /// A consistent and opaque identifier, created and maintained by the builder to represent a segment of their users.
    public var tenantIds: [Swift.String]?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem]? = nil,
        clientRequestToken: Swift.String? = nil,
        externalMeetingId: Swift.String? = nil,
        mediaRegion: Swift.String? = nil,
        meetingFeatures: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration? = nil,
        meetingHostId: Swift.String? = nil,
        notificationsConfiguration: ChimeSDKMeetingsClientTypes.NotificationsConfiguration? = nil,
        primaryMeetingId: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil,
        tenantIds: [Swift.String]? = nil
    )
    {
        self.attendees = attendees
        self.clientRequestToken = clientRequestToken
        self.externalMeetingId = externalMeetingId
        self.mediaRegion = mediaRegion
        self.meetingFeatures = meetingFeatures
        self.meetingHostId = meetingHostId
        self.notificationsConfiguration = notificationsConfiguration
        self.primaryMeetingId = primaryMeetingId
        self.tags = tags
        self.tenantIds = tenantIds
    }
}

extension CreateMeetingWithAttendeesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMeetingWithAttendeesInput(attendees: \(Swift.String(describing: attendees)), mediaRegion: \(Swift.String(describing: mediaRegion)), meetingFeatures: \(Swift.String(describing: meetingFeatures)), notificationsConfiguration: \(Swift.String(describing: notificationsConfiguration)), primaryMeetingId: \(Swift.String(describing: primaryMeetingId)), tags: \(Swift.String(describing: tags)), tenantIds: \(Swift.String(describing: tenantIds)), clientRequestToken: \"CONTENT_REDACTED\", externalMeetingId: \"CONTENT_REDACTED\", meetingHostId: \"CONTENT_REDACTED\")"}
}

public struct CreateMeetingWithAttendeesOutput {
    /// The attendee information, including attendees' IDs and join tokens.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// If the action fails for one or more of the attendees in the request, a list of the attendees is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]?
    /// The meeting information, including the meeting ID and MediaPlacement.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        errors: [ChimeSDKMeetingsClientTypes.CreateAttendeeError]? = nil,
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.attendees = attendees
        self.errors = errors
        self.meeting = meeting
    }
}

public struct DeleteAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

public struct DeleteMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct GetAttendeeInput {
    /// The Amazon Chime SDK attendee ID.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.meetingId = meetingId
    }
}

public struct GetAttendeeOutput {
    /// The Amazon Chime SDK attendee information.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

public struct GetMeetingInput {
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

public struct GetMeetingOutput {
    /// The Amazon Chime SDK meeting information.
    public var meeting: ChimeSDKMeetingsClientTypes.Meeting?

    public init(
        meeting: ChimeSDKMeetingsClientTypes.Meeting? = nil
    )
    {
        self.meeting = meeting
    }
}

public struct ListAttendeesInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The Amazon Chime SDK meeting ID.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        meetingId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.meetingId = meetingId
        self.nextToken = nextToken
    }
}

public struct ListAttendeesOutput {
    /// The Amazon Chime SDK attendee information.
    public var attendees: [ChimeSDKMeetingsClientTypes.Attendee]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        attendees: [ChimeSDKMeetingsClientTypes.Attendee]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attendees = attendees
        self.nextToken = nextToken
    }
}

/// The resource that you want to tag couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that couldn't be found.
        public internal(set) var requestId: Swift.String? = nil
        /// The name of the resource that couldn't be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceName = resourceName
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The tags requested for the specified resource.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?

    public init(
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeMedicalContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phi
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalContentIdentificationType] {
            return [
                .phi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phi: return "PHI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeMedicalLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalLanguageCode] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeMedicalRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apSoutheast2
        case auto
        case caCentral1
        case euWest1
        case usEast1
        case usEast2
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalRegion] {
            return [
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euWest1,
                .usEast1,
                .usEast2,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euWest1: return "eu-west-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeMedicalSpecialty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cardiology
        case neurology
        case oncology
        case primarycare
        case radiology
        case urology
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalSpecialty] {
            return [
                .cardiology,
                .neurology,
                .oncology,
                .primarycare,
                .radiology,
                .urology
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cardiology: return "CARDIOLOGY"
            case .neurology: return "NEUROLOGY"
            case .oncology: return "ONCOLOGY"
            case .primarycare: return "PRIMARYCARE"
            case .radiology: return "RADIOLOGY"
            case .urology: return "UROLOGY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeMedicalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conversation
        case dictation
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeMedicalType] {
            return [
                .conversation,
                .dictation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conversation: return "CONVERSATION"
            case .dictation: return "DICTATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// Settings specific to the Amazon Transcribe Medical engine.
    public struct EngineTranscribeMedicalSettings {
        /// Set this field to PHI to identify personal health information in the transcription output.
        public var contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeMedicalContentIdentificationType?
        /// The language code specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var languageCode: ChimeSDKMeetingsClientTypes.TranscribeMedicalLanguageCode?
        /// The Amazon Web Services Region passed to Amazon Transcribe Medical. If you don't specify a Region, Amazon Chime uses the meeting's Region.
        public var region: ChimeSDKMeetingsClientTypes.TranscribeMedicalRegion?
        /// The specialty specified for the Amazon Transcribe Medical engine.
        /// This member is required.
        public var specialty: ChimeSDKMeetingsClientTypes.TranscribeMedicalSpecialty?
        /// The type of transcription.
        /// This member is required.
        public var type: ChimeSDKMeetingsClientTypes.TranscribeMedicalType?
        /// The name of the vocabulary passed to Amazon Transcribe Medical.
        public var vocabularyName: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeMedicalContentIdentificationType? = nil,
            languageCode: ChimeSDKMeetingsClientTypes.TranscribeMedicalLanguageCode? = nil,
            region: ChimeSDKMeetingsClientTypes.TranscribeMedicalRegion? = nil,
            specialty: ChimeSDKMeetingsClientTypes.TranscribeMedicalSpecialty? = nil,
            type: ChimeSDKMeetingsClientTypes.TranscribeMedicalType? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.languageCode = languageCode
            self.region = region
            self.specialty = specialty
            self.type = type
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeContentIdentificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentIdentificationType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeContentRedactionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeContentRedactionType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case hiIn
        case itIt
        case jaJp
        case koKr
        case ptBr
        case thTh
        case zhCn
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .hiIn,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .thTh,
                .zhCn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .hiIn: return "hi-IN"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptBr: return "pt-BR"
            case .thTh: return "th-TH"
            case .zhCn: return "zh-CN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribePartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribePartialResultsStability] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast2
        case auto
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case saEast1
        case usEast1
        case usEast2
        case usGovWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast2,
                .auto,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .saEast1,
                .usEast1,
                .usEast2,
                .usGovWest1,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast2: return "ap-southeast-2"
            case .auto: return "auto"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usGovWest1: return "us-gov-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {

    public enum TranscribeVocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscribeVocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMeetingsClientTypes {
    /// Settings specific for Amazon Transcribe as the live transcription engine. If you specify an invalid combination of parameters, a TranscriptFailed event will be sent with the contents of the BadRequestException generated by Amazon Transcribe. For more information on each parameter and which combinations are valid, refer to the [StartStreamTranscription](https://docs.aws.amazon.com/transcribe/latest/APIReference/API_streaming_StartStreamTranscription.html) API in the Amazon Transcribe Developer Guide.
    public struct EngineTranscribeSettings {
        /// Labels all personally identifiable information (PII) identified in your transcript. If you don't include PiiEntityTypes, all PII is identified. You can’t set ContentIdentificationType and ContentRedactionType.
        public var contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeContentIdentificationType?
        /// Content redaction is performed at the segment level. If you don't include PiiEntityTypes, all PII is redacted. You can’t set ContentRedactionType and ContentIdentificationType.
        public var contentRedactionType: ChimeSDKMeetingsClientTypes.TranscribeContentRedactionType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.
        public var enablePartialResultsStabilization: Swift.Bool
        /// Enables automatic language identification for your transcription. If you include IdentifyLanguage, you can optionally use LanguageOptions to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy. You can also use PreferredLanguage to include a preferred language. Doing so can help Amazon Transcribe identify the language faster. You must include either LanguageCode or IdentifyLanguage. Language identification can't be combined with custom language models or redaction.
        public var identifyLanguage: Swift.Bool
        /// Specify the language code that represents the language spoken. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification.
        public var languageCode: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode?
        /// Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.
        public var languageModelName: Swift.String?
        /// Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter. Including language options can improve the accuracy of language identification. If you include LanguageOptions, you must also include IdentifyLanguage. You can only include one language dialect per language. For example, you cannot include en-US and en-AU.
        public var languageOptions: Swift.String?
        /// Specify the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.
        public var partialResultsStability: ChimeSDKMeetingsClientTypes.TranscribePartialResultsStability?
        /// Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select ALL. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRYCREDIT_DEBIT_NUMBER, EMAIL,NAME, PHONE, PIN, SSN, or ALL. Note that if you include PiiEntityTypes, you must also include ContentIdentificationType or ContentRedactionType. If you include ContentRedactionType or ContentIdentificationType, but do not include PiiEntityTypes, all PII is redacted or identified.
        public var piiEntityTypes: Swift.String?
        /// Specify a preferred language from the subset of languages codes you specified in LanguageOptions. You can only use this parameter if you include IdentifyLanguage and LanguageOptions.
        public var preferredLanguage: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode?
        /// The Amazon Web Services Region in which to use Amazon Transcribe. If you don't specify a Region, then the [MediaRegion](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html) of the meeting is used. However, if Amazon Transcribe is not available in the MediaRegion, then a TranscriptFailed event is sent. Use auto to use Amazon Transcribe in a Region near the meeting’s MediaRegion. For more information, refer to [Choosing a transcription Region](https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region) in the Amazon Chime SDK Developer Guide.
        public var region: ChimeSDKMeetingsClientTypes.TranscribeRegion?
        /// Specify how you want your vocabulary filter applied to your transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeSDKMeetingsClientTypes.TranscribeVocabularyFilterMethod?
        /// Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more vocabulary filters with your transcription, use the VocabularyFilterNames parameter instead.
        public var vocabularyFilterName: Swift.String?
        /// Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region. If you're not including IdentifyLanguage and want to use a custom vocabulary filter with your transcription, use the VocabularyFilterName parameter instead.
        public var vocabularyFilterNames: Swift.String?
        /// Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you include IdentifyLanguage and want to use one or more custom vocabularies with your transcription, use the VocabularyNames parameter instead.
        public var vocabularyName: Swift.String?
        /// Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive. If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region. If you don't include IdentifyLanguage and want to use a custom vocabulary with your transcription, use the VocabularyName parameter instead.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMeetingsClientTypes.TranscribeContentIdentificationType? = nil,
            contentRedactionType: ChimeSDKMeetingsClientTypes.TranscribeContentRedactionType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            identifyLanguage: Swift.Bool = false,
            languageCode: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeSDKMeetingsClientTypes.TranscribePartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeSDKMeetingsClientTypes.TranscribeLanguageCode? = nil,
            region: ChimeSDKMeetingsClientTypes.TranscribeRegion? = nil,
            vocabularyFilterMethod: ChimeSDKMeetingsClientTypes.TranscribeVocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.region = region
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }

}

extension ChimeSDKMeetingsClientTypes {
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    public struct TranscriptionConfiguration {
        /// The transcription configuration settings passed to Amazon Transcribe Medical.
        public var engineTranscribeMedicalSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings?
        /// The transcription configuration settings passed to Amazon Transcribe.
        public var engineTranscribeSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings?

        public init(
            engineTranscribeMedicalSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings? = nil,
            engineTranscribeSettings: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings? = nil
        )
        {
            self.engineTranscribeMedicalSettings = engineTranscribeMedicalSettings
            self.engineTranscribeSettings = engineTranscribeSettings
        }
    }

}

public struct StartMeetingTranscriptionInput {
    /// The unique ID of the meeting being transcribed.
    /// This member is required.
    public var meetingId: Swift.String?
    /// The configuration for the current transcription operation. Must contain EngineTranscribeSettings or EngineTranscribeMedicalSettings.
    /// This member is required.
    public var transcriptionConfiguration: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration?

    public init(
        meetingId: Swift.String? = nil,
        transcriptionConfiguration: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration? = nil
    )
    {
        self.meetingId = meetingId
        self.transcriptionConfiguration = transcriptionConfiguration
    }
}

public struct StopMeetingTranscriptionInput {
    /// The unique ID of the meeting for which you stop transcription.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        meetingId: Swift.String? = nil
    )
    {
        self.meetingId = meetingId
    }
}

/// Too many tags were added to the specified resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the request that contains too many tags.
        public internal(set) var requestId: Swift.String? = nil
        /// The name of the resource that received too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Lists the requested tags.
    /// This member is required.
    public var tags: [ChimeSDKMeetingsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMeetingsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource that you're removing tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys being removed from the resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAttendeeCapabilitiesInput {
    /// The ID of the attendee associated with the update request.
    /// This member is required.
    public var attendeeId: Swift.String?
    /// The capabilities that you want to update.
    /// This member is required.
    public var capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?
    /// The ID of the meeting associated with the update request.
    /// This member is required.
    public var meetingId: Swift.String?

    public init(
        attendeeId: Swift.String? = nil,
        capabilities: ChimeSDKMeetingsClientTypes.AttendeeCapabilities? = nil,
        meetingId: Swift.String? = nil
    )
    {
        self.attendeeId = attendeeId
        self.capabilities = capabilities
        self.meetingId = meetingId
    }
}

public struct UpdateAttendeeCapabilitiesOutput {
    /// The updated attendee data.
    public var attendee: ChimeSDKMeetingsClientTypes.Attendee?

    public init(
        attendee: ChimeSDKMeetingsClientTypes.Attendee? = nil
    )
    {
        self.attendee = attendee
    }
}

extension BatchCreateAttendeeInput {

    static func urlPathProvider(_ value: BatchCreateAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension BatchCreateAttendeeInput {

    static func queryItemProvider(_ value: BatchCreateAttendeeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput {

    static func urlPathProvider(_ value: BatchUpdateAttendeeCapabilitiesExceptInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/capabilities"
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput {

    static func queryItemProvider(_ value: BatchUpdateAttendeeCapabilitiesExceptInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-update-except"))
        return items
    }
}

extension CreateAttendeeInput {

    static func urlPathProvider(_ value: CreateAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension CreateMeetingInput {

    static func urlPathProvider(_ value: CreateMeetingInput) -> Swift.String? {
        return "/meetings"
    }
}

extension CreateMeetingWithAttendeesInput {

    static func urlPathProvider(_ value: CreateMeetingWithAttendeesInput) -> Swift.String? {
        return "/meetings"
    }
}

extension CreateMeetingWithAttendeesInput {

    static func queryItemProvider(_ value: CreateMeetingWithAttendeesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "create-attendees"))
        return items
    }
}

extension DeleteAttendeeInput {

    static func urlPathProvider(_ value: DeleteAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

extension DeleteMeetingInput {

    static func urlPathProvider(_ value: DeleteMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

extension GetAttendeeInput {

    static func urlPathProvider(_ value: GetAttendeeInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())"
    }
}

extension GetMeetingInput {

    static func urlPathProvider(_ value: GetMeetingInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())"
    }
}

extension ListAttendeesInput {

    static func urlPathProvider(_ value: ListAttendeesInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees"
    }
}

extension ListAttendeesInput {

    static func queryItemProvider(_ value: ListAttendeesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension StartMeetingTranscriptionInput {

    static func urlPathProvider(_ value: StartMeetingTranscriptionInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

extension StartMeetingTranscriptionInput {

    static func queryItemProvider(_ value: StartMeetingTranscriptionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "start"))
        return items
    }
}

extension StopMeetingTranscriptionInput {

    static func urlPathProvider(_ value: StopMeetingTranscriptionInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/transcription"
    }
}

extension StopMeetingTranscriptionInput {

    static func queryItemProvider(_ value: StopMeetingTranscriptionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UpdateAttendeeCapabilitiesInput {

    static func urlPathProvider(_ value: UpdateAttendeeCapabilitiesInput) -> Swift.String? {
        guard let meetingId = value.meetingId else {
            return nil
        }
        guard let attendeeId = value.attendeeId else {
            return nil
        }
        return "/meetings/\(meetingId.urlPercentEncoding())/attendees/\(attendeeId.urlPercentEncoding())/capabilities"
    }
}

extension BatchCreateAttendeeInput {

    static func write(value: BatchCreateAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attendees"].writeList(value.attendees, memberWritingClosure: ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptInput {

    static func write(value: BatchUpdateAttendeeCapabilitiesExceptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].write(value.capabilities, with: ChimeSDKMeetingsClientTypes.AttendeeCapabilities.write(value:to:))
        try writer["ExcludedAttendeeIds"].writeList(value.excludedAttendeeIds, memberWritingClosure: ChimeSDKMeetingsClientTypes.AttendeeIdItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAttendeeInput {

    static func write(value: CreateAttendeeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].write(value.capabilities, with: ChimeSDKMeetingsClientTypes.AttendeeCapabilities.write(value:to:))
        try writer["ExternalUserId"].write(value.externalUserId)
    }
}

extension CreateMeetingInput {

    static func write(value: CreateMeetingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ExternalMeetingId"].write(value.externalMeetingId)
        try writer["MediaRegion"].write(value.mediaRegion)
        try writer["MeetingFeatures"].write(value.meetingFeatures, with: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.write(value:to:))
        try writer["MeetingHostId"].write(value.meetingHostId)
        try writer["NotificationsConfiguration"].write(value.notificationsConfiguration, with: ChimeSDKMeetingsClientTypes.NotificationsConfiguration.write(value:to:))
        try writer["PrimaryMeetingId"].write(value.primaryMeetingId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMeetingsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TenantIds"].writeList(value.tenantIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMeetingWithAttendeesInput {

    static func write(value: CreateMeetingWithAttendeesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attendees"].writeList(value.attendees, memberWritingClosure: ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ExternalMeetingId"].write(value.externalMeetingId)
        try writer["MediaRegion"].write(value.mediaRegion)
        try writer["MeetingFeatures"].write(value.meetingFeatures, with: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.write(value:to:))
        try writer["MeetingHostId"].write(value.meetingHostId)
        try writer["NotificationsConfiguration"].write(value.notificationsConfiguration, with: ChimeSDKMeetingsClientTypes.NotificationsConfiguration.write(value:to:))
        try writer["PrimaryMeetingId"].write(value.primaryMeetingId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMeetingsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TenantIds"].writeList(value.tenantIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartMeetingTranscriptionInput {

    static func write(value: StartMeetingTranscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TranscriptionConfiguration"].write(value.transcriptionConfiguration, with: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMeetingsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAttendeeCapabilitiesInput {

    static func write(value: UpdateAttendeeCapabilitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].write(value.capabilities, with: ChimeSDKMeetingsClientTypes.AttendeeCapabilities.write(value:to:))
    }
}

extension BatchCreateAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateAttendeeOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.CreateAttendeeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateAttendeeCapabilitiesExceptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateAttendeeCapabilitiesExceptOutput {
        return BatchUpdateAttendeeCapabilitiesExceptOutput()
    }
}

extension CreateAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAttendeeOutput()
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Attendee.read(from:))
        return value
    }
}

extension CreateMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeetingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeetingOutput()
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Meeting.read(from:))
        return value
    }
}

extension CreateMeetingWithAttendeesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMeetingWithAttendeesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMeetingWithAttendeesOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.CreateAttendeeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Meeting.read(from:))
        return value
    }
}

extension DeleteAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAttendeeOutput {
        return DeleteAttendeeOutput()
    }
}

extension DeleteMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMeetingOutput {
        return DeleteMeetingOutput()
    }
}

extension GetAttendeeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAttendeeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAttendeeOutput()
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Attendee.read(from:))
        return value
    }
}

extension GetMeetingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMeetingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMeetingOutput()
        value.meeting = try reader["Meeting"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Meeting.read(from:))
        return value
    }
}

extension ListAttendeesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttendeesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttendeesOutput()
        value.attendees = try reader["Attendees"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.Attendee.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeSDKMeetingsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartMeetingTranscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMeetingTranscriptionOutput {
        return StartMeetingTranscriptionOutput()
    }
}

extension StopMeetingTranscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopMeetingTranscriptionOutput {
        return StopMeetingTranscriptionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAttendeeCapabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAttendeeCapabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAttendeeCapabilitiesOutput()
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeSDKMeetingsClientTypes.Attendee.read(from:))
        return value
    }
}

enum BatchCreateAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateAttendeeCapabilitiesExceptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMeetingWithAttendeesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAttendeeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMeetingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttendeesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMeetingTranscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopMeetingTranscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAttendeeCapabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ServiceUnavailableException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnprocessableEntityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnprocessableEntityException {
        let reader = baseError.errorBodyReader
        var value = UnprocessableEntityException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.Attendee {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.Attendee {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.Attendee()
        value.externalUserId = try reader["ExternalUserId"].readIfPresent()
        value.attendeeId = try reader["AttendeeId"].readIfPresent()
        value.joinToken = try reader["JoinToken"].readIfPresent()
        value.capabilities = try reader["Capabilities"].readIfPresent(with: ChimeSDKMeetingsClientTypes.AttendeeCapabilities.read(from:))
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.AttendeeCapabilities {

    static func write(value: ChimeSDKMeetingsClientTypes.AttendeeCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audio"].write(value.audio)
        try writer["Content"].write(value.content)
        try writer["Video"].write(value.video)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.AttendeeCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.AttendeeCapabilities()
        value.audio = try reader["Audio"].readIfPresent() ?? .sdkUnknown("")
        value.video = try reader["Video"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["Content"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.CreateAttendeeError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.CreateAttendeeError()
        value.externalUserId = try reader["ExternalUserId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.Meeting {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.Meeting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.Meeting()
        value.meetingId = try reader["MeetingId"].readIfPresent()
        value.meetingHostId = try reader["MeetingHostId"].readIfPresent()
        value.externalMeetingId = try reader["ExternalMeetingId"].readIfPresent()
        value.mediaRegion = try reader["MediaRegion"].readIfPresent()
        value.mediaPlacement = try reader["MediaPlacement"].readIfPresent(with: ChimeSDKMeetingsClientTypes.MediaPlacement.read(from:))
        value.meetingFeatures = try reader["MeetingFeatures"].readIfPresent(with: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration.read(from:))
        value.primaryMeetingId = try reader["PrimaryMeetingId"].readIfPresent()
        value.tenantIds = try reader["TenantIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.meetingArn = try reader["MeetingArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration {

    static func write(value: ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attendee"].write(value.attendee, with: ChimeSDKMeetingsClientTypes.AttendeeFeatures.write(value:to:))
        try writer["Audio"].write(value.audio, with: ChimeSDKMeetingsClientTypes.AudioFeatures.write(value:to:))
        try writer["Content"].write(value.content, with: ChimeSDKMeetingsClientTypes.ContentFeatures.write(value:to:))
        try writer["Video"].write(value.video, with: ChimeSDKMeetingsClientTypes.VideoFeatures.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.MeetingFeaturesConfiguration()
        value.audio = try reader["Audio"].readIfPresent(with: ChimeSDKMeetingsClientTypes.AudioFeatures.read(from:))
        value.video = try reader["Video"].readIfPresent(with: ChimeSDKMeetingsClientTypes.VideoFeatures.read(from:))
        value.content = try reader["Content"].readIfPresent(with: ChimeSDKMeetingsClientTypes.ContentFeatures.read(from:))
        value.attendee = try reader["Attendee"].readIfPresent(with: ChimeSDKMeetingsClientTypes.AttendeeFeatures.read(from:))
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.AttendeeFeatures {

    static func write(value: ChimeSDKMeetingsClientTypes.AttendeeFeatures?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxCount"].write(value.maxCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.AttendeeFeatures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.AttendeeFeatures()
        value.maxCount = try reader["MaxCount"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.ContentFeatures {

    static func write(value: ChimeSDKMeetingsClientTypes.ContentFeatures?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResolution"].write(value.maxResolution)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.ContentFeatures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.ContentFeatures()
        value.maxResolution = try reader["MaxResolution"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.VideoFeatures {

    static func write(value: ChimeSDKMeetingsClientTypes.VideoFeatures?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResolution"].write(value.maxResolution)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.VideoFeatures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.VideoFeatures()
        value.maxResolution = try reader["MaxResolution"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.AudioFeatures {

    static func write(value: ChimeSDKMeetingsClientTypes.AudioFeatures?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EchoReduction"].write(value.echoReduction)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.AudioFeatures {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.AudioFeatures()
        value.echoReduction = try reader["EchoReduction"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.MediaPlacement {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.MediaPlacement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.MediaPlacement()
        value.audioHostUrl = try reader["AudioHostUrl"].readIfPresent()
        value.audioFallbackUrl = try reader["AudioFallbackUrl"].readIfPresent()
        value.signalingUrl = try reader["SignalingUrl"].readIfPresent()
        value.turnControlUrl = try reader["TurnControlUrl"].readIfPresent()
        value.screenDataUrl = try reader["ScreenDataUrl"].readIfPresent()
        value.screenViewingUrl = try reader["ScreenViewingUrl"].readIfPresent()
        value.screenSharingUrl = try reader["ScreenSharingUrl"].readIfPresent()
        value.eventIngestionUrl = try reader["EventIngestionUrl"].readIfPresent()
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.Tag {

    static func write(value: ChimeSDKMeetingsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMeetingsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMeetingsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem {

    static func write(value: ChimeSDKMeetingsClientTypes.CreateAttendeeRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].write(value.capabilities, with: ChimeSDKMeetingsClientTypes.AttendeeCapabilities.write(value:to:))
        try writer["ExternalUserId"].write(value.externalUserId)
    }
}

extension ChimeSDKMeetingsClientTypes.AttendeeIdItem {

    static func write(value: ChimeSDKMeetingsClientTypes.AttendeeIdItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttendeeId"].write(value.attendeeId)
    }
}

extension ChimeSDKMeetingsClientTypes.NotificationsConfiguration {

    static func write(value: ChimeSDKMeetingsClientTypes.NotificationsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaFunctionArn"].write(value.lambdaFunctionArn)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SqsQueueArn"].write(value.sqsQueueArn)
    }
}

extension ChimeSDKMeetingsClientTypes.TranscriptionConfiguration {

    static func write(value: ChimeSDKMeetingsClientTypes.TranscriptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineTranscribeMedicalSettings"].write(value.engineTranscribeMedicalSettings, with: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings.write(value:to:))
        try writer["EngineTranscribeSettings"].write(value.engineTranscribeSettings, with: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings.write(value:to:))
    }
}

extension ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings {

    static func write(value: ChimeSDKMeetingsClientTypes.EngineTranscribeMedicalSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["Region"].write(value.region)
        try writer["Specialty"].write(value.specialty)
        try writer["Type"].write(value.type)
        try writer["VocabularyName"].write(value.vocabularyName)
    }
}

extension ChimeSDKMeetingsClientTypes.EngineTranscribeSettings {

    static func write(value: ChimeSDKMeetingsClientTypes.EngineTranscribeSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["ContentRedactionType"].write(value.contentRedactionType)
        try writer["EnablePartialResultsStabilization"].write(value.enablePartialResultsStabilization)
        try writer["IdentifyLanguage"].write(value.identifyLanguage)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["LanguageOptions"].write(value.languageOptions)
        try writer["PartialResultsStability"].write(value.partialResultsStability)
        try writer["PiiEntityTypes"].write(value.piiEntityTypes)
        try writer["PreferredLanguage"].write(value.preferredLanguage)
        try writer["Region"].write(value.region)
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyFilterNames"].write(value.vocabularyFilterNames)
        try writer["VocabularyName"].write(value.vocabularyName)
        try writer["VocabularyNames"].write(value.vocabularyNames)
    }
}

public enum ChimeSDKMeetingsClientTypes {}
