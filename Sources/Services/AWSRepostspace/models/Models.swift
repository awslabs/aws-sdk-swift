// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepostspaceClientTypes {
    public enum ConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configured
        case unconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationStatus] {
            return [
                .configured,
                .unconfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .unconfigured: return "UNCONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationStatus(rawValue: rawValue) ?? ConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateSpaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSpaceInput(roleArn: \(Swift.String(describing: roleArn)), subdomain: \(Swift.String(describing: subdomain)), tier: \(Swift.String(describing: tier)), userKMSKey: \(Swift.String(describing: userKMSKey)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateSpaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case roleArn
        case subdomain
        case tags
        case tier
        case userKMSKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let subdomain = self.subdomain {
            try encodeContainer.encode(subdomain, forKey: .subdomain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let userKMSKey = self.userKMSKey {
            try encodeContainer.encode(userKMSKey, forKey: .userKMSKey)
        }
    }
}

extension CreateSpaceInput {

    static func urlPathProvider(_ value: CreateSpaceInput) -> Swift.String? {
        return "/spaces"
    }
}

public struct CreateSpaceInput {
    /// A description for the private re:Post. This is used only to help you identify this private re:Post.
    public var description: Swift.String?
    /// The name for the private re:Post. This must be unique in your account.
    /// This member is required.
    public var name: Swift.String?
    /// The IAM role that grants permissions to the private re:Post to convert unanswered questions into AWS support tickets.
    public var roleArn: Swift.String?
    /// The subdomain that you use to access your AWS re:Post Private private re:Post. All custom subdomains must be approved by AWS before use. In addition to your custom subdomain, all private re:Posts are issued an AWS generated subdomain for immediate use.
    /// This member is required.
    public var subdomain: Swift.String?
    /// The list of tags associated with the private re:Post.
    public var tags: [Swift.String:Swift.String]?
    /// The pricing tier for the private re:Post.
    /// This member is required.
    public var tier: RepostspaceClientTypes.TierLevel?
    /// The AWS KMS key ARN that’s used for the AWS KMS encryption. If you don't provide a key, your data is encrypted by default with a key that AWS owns and manages for you.
    public var userKMSKey: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: RepostspaceClientTypes.TierLevel? = nil,
        userKMSKey: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.subdomain = subdomain
        self.tags = tags
        self.tier = tier
        self.userKMSKey = userKMSKey
    }
}

struct CreateSpaceInputBody {
    let name: Swift.String?
    let subdomain: Swift.String?
    let tier: RepostspaceClientTypes.TierLevel?
    let description: Swift.String?
    let userKMSKey: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let roleArn: Swift.String?
}

extension CreateSpaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case roleArn
        case subdomain
        case tags
        case tier
        case userKMSKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let tierDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.TierLevel.self, forKey: .tier)
        tier = tierDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userKMSKey)
        userKMSKey = userKMSKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSpaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.spaceId = output.spaceId
        } else {
            self.spaceId = nil
        }
    }
}

public struct CreateSpaceOutput {
    /// The unique ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?

    public init(
        spaceId: Swift.String? = nil
    )
    {
        self.spaceId = spaceId
    }
}

struct CreateSpaceOutputBody {
    let spaceId: Swift.String?
}

extension CreateSpaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spaceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceId)
        spaceId = spaceIdDecoded
    }
}

enum CreateSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSpaceInput {

    static func urlPathProvider(_ value: DeleteSpaceInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())"
    }
}

public struct DeleteSpaceInput {
    /// The unique ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?

    public init(
        spaceId: Swift.String? = nil
    )
    {
        self.spaceId = spaceId
    }
}

struct DeleteSpaceInputBody {
}

extension DeleteSpaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSpaceOutput {

    public init() { }
}

enum DeleteSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterAdminInput {

    static func urlPathProvider(_ value: DeregisterAdminInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        guard let adminId = value.adminId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())/admins/\(adminId.urlPercentEncoding())"
    }
}

public struct DeregisterAdminInput {
    /// The ID of the admin to remove.
    /// This member is required.
    public var adminId: Swift.String?
    /// The ID of the private re:Post to remove the admin from.
    /// This member is required.
    public var spaceId: Swift.String?

    public init(
        adminId: Swift.String? = nil,
        spaceId: Swift.String? = nil
    )
    {
        self.adminId = adminId
        self.spaceId = spaceId
    }
}

struct DeregisterAdminInputBody {
}

extension DeregisterAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterAdminOutput {

    public init() { }
}

enum DeregisterAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpaceInput {

    static func urlPathProvider(_ value: GetSpaceInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())"
    }
}

public struct GetSpaceInput {
    /// The ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?

    public init(
        spaceId: Swift.String? = nil
    )
    {
        self.spaceId = spaceId
    }
}

struct GetSpaceInputBody {
}

extension GetSpaceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSpaceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSpaceOutput(arn: \(Swift.String(describing: arn)), clientId: \(Swift.String(describing: clientId)), configurationStatus: \(Swift.String(describing: configurationStatus)), contentSize: \(Swift.String(describing: contentSize)), createDateTime: \(Swift.String(describing: createDateTime)), customerRoleArn: \(Swift.String(describing: customerRoleArn)), deleteDateTime: \(Swift.String(describing: deleteDateTime)), groupAdmins: \(Swift.String(describing: groupAdmins)), randomDomain: \(Swift.String(describing: randomDomain)), spaceId: \(Swift.String(describing: spaceId)), status: \(Swift.String(describing: status)), storageLimit: \(Swift.String(describing: storageLimit)), tier: \(Swift.String(describing: tier)), userAdmins: \(Swift.String(describing: userAdmins)), userCount: \(Swift.String(describing: userCount)), userKMSKey: \(Swift.String(describing: userKMSKey)), vanityDomain: \(Swift.String(describing: vanityDomain)), vanityDomainStatus: \(Swift.String(describing: vanityDomainStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension GetSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpaceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientId = output.clientId
            self.configurationStatus = output.configurationStatus
            self.contentSize = output.contentSize
            self.createDateTime = output.createDateTime
            self.customerRoleArn = output.customerRoleArn
            self.deleteDateTime = output.deleteDateTime
            self.description = output.description
            self.groupAdmins = output.groupAdmins
            self.name = output.name
            self.randomDomain = output.randomDomain
            self.spaceId = output.spaceId
            self.status = output.status
            self.storageLimit = output.storageLimit
            self.tier = output.tier
            self.userAdmins = output.userAdmins
            self.userCount = output.userCount
            self.userKMSKey = output.userKMSKey
            self.vanityDomain = output.vanityDomain
            self.vanityDomainStatus = output.vanityDomainStatus
        } else {
            self.arn = nil
            self.clientId = nil
            self.configurationStatus = nil
            self.contentSize = nil
            self.createDateTime = nil
            self.customerRoleArn = nil
            self.deleteDateTime = nil
            self.description = nil
            self.groupAdmins = nil
            self.name = nil
            self.randomDomain = nil
            self.spaceId = nil
            self.status = nil
            self.storageLimit = nil
            self.tier = nil
            self.userAdmins = nil
            self.userCount = nil
            self.userKMSKey = nil
            self.vanityDomain = nil
            self.vanityDomainStatus = nil
        }
    }
}

public struct GetSpaceOutput {
    /// The ARN of the private re:Post.
    /// This member is required.
    public var arn: Swift.String?
    /// The Identity Center identifier for the Application Instance.
    /// This member is required.
    public var clientId: Swift.String?
    /// The configuration status of the private re:Post.
    /// This member is required.
    public var configurationStatus: RepostspaceClientTypes.ConfigurationStatus?
    /// The content size of the private re:Post.
    public var contentSize: Swift.Int?
    /// The date when the private re:Post was created.
    /// This member is required.
    public var createDateTime: ClientRuntime.Date?
    /// The IAM role that grants permissions to the private re:Post to convert unanswered questions into AWS support tickets.
    public var customerRoleArn: Swift.String?
    /// The date when the private re:Post was deleted.
    public var deleteDateTime: ClientRuntime.Date?
    /// The description of the private re:Post.
    public var description: Swift.String?
    /// The list of groups that are administrators of the private re:Post.
    public var groupAdmins: [Swift.String]?
    /// The name of the private re:Post.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS generated subdomain of the private re:Post
    /// This member is required.
    public var randomDomain: Swift.String?
    /// The unique ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?
    /// The creation or deletion status of the private re:Post.
    /// This member is required.
    public var status: Swift.String?
    /// The storage limit of the private re:Post.
    /// This member is required.
    public var storageLimit: Swift.Int?
    /// The pricing tier of the private re:Post.
    /// This member is required.
    public var tier: RepostspaceClientTypes.TierLevel?
    /// The list of users that are administrators of the private re:Post.
    public var userAdmins: [Swift.String]?
    /// The number of users that have onboarded to the private re:Post.
    public var userCount: Swift.Int?
    /// The custom AWS KMS key ARN that’s used for the AWS KMS encryption.
    public var userKMSKey: Swift.String?
    /// The custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.
    /// This member is required.
    public var vanityDomain: Swift.String?
    /// The approval status of the custom subdomain.
    /// This member is required.
    public var vanityDomainStatus: RepostspaceClientTypes.VanityDomainStatus?

    public init(
        arn: Swift.String? = nil,
        clientId: Swift.String? = nil,
        configurationStatus: RepostspaceClientTypes.ConfigurationStatus? = nil,
        contentSize: Swift.Int? = nil,
        createDateTime: ClientRuntime.Date? = nil,
        customerRoleArn: Swift.String? = nil,
        deleteDateTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        groupAdmins: [Swift.String]? = nil,
        name: Swift.String? = nil,
        randomDomain: Swift.String? = nil,
        spaceId: Swift.String? = nil,
        status: Swift.String? = nil,
        storageLimit: Swift.Int? = nil,
        tier: RepostspaceClientTypes.TierLevel? = nil,
        userAdmins: [Swift.String]? = nil,
        userCount: Swift.Int? = nil,
        userKMSKey: Swift.String? = nil,
        vanityDomain: Swift.String? = nil,
        vanityDomainStatus: RepostspaceClientTypes.VanityDomainStatus? = nil
    )
    {
        self.arn = arn
        self.clientId = clientId
        self.configurationStatus = configurationStatus
        self.contentSize = contentSize
        self.createDateTime = createDateTime
        self.customerRoleArn = customerRoleArn
        self.deleteDateTime = deleteDateTime
        self.description = description
        self.groupAdmins = groupAdmins
        self.name = name
        self.randomDomain = randomDomain
        self.spaceId = spaceId
        self.status = status
        self.storageLimit = storageLimit
        self.tier = tier
        self.userAdmins = userAdmins
        self.userCount = userCount
        self.userKMSKey = userKMSKey
        self.vanityDomain = vanityDomain
        self.vanityDomainStatus = vanityDomainStatus
    }
}

struct GetSpaceOutputBody {
    let spaceId: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let status: Swift.String?
    let configurationStatus: RepostspaceClientTypes.ConfigurationStatus?
    let clientId: Swift.String?
    let description: Swift.String?
    let vanityDomainStatus: RepostspaceClientTypes.VanityDomainStatus?
    let vanityDomain: Swift.String?
    let randomDomain: Swift.String?
    let customerRoleArn: Swift.String?
    let createDateTime: ClientRuntime.Date?
    let deleteDateTime: ClientRuntime.Date?
    let tier: RepostspaceClientTypes.TierLevel?
    let storageLimit: Swift.Int?
    let userAdmins: [Swift.String]?
    let groupAdmins: [Swift.String]?
    let userKMSKey: Swift.String?
    let userCount: Swift.Int?
    let contentSize: Swift.Int?
}

extension GetSpaceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientId
        case configurationStatus
        case contentSize
        case createDateTime
        case customerRoleArn
        case deleteDateTime
        case description
        case groupAdmins
        case name
        case randomDomain
        case spaceId
        case status
        case storageLimit
        case tier
        case userAdmins
        case userCount
        case userKMSKey
        case vanityDomain
        case vanityDomainStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceId)
        spaceId = spaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vanityDomainStatusDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.VanityDomainStatus.self, forKey: .vanityDomainStatus)
        vanityDomainStatus = vanityDomainStatusDecoded
        let vanityDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vanityDomain)
        vanityDomain = vanityDomainDecoded
        let randomDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomDomain)
        randomDomain = randomDomainDecoded
        let customerRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerRoleArn)
        customerRoleArn = customerRoleArnDecoded
        let createDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDateTime)
        createDateTime = createDateTimeDecoded
        let deleteDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deleteDateTime)
        deleteDateTime = deleteDateTimeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.TierLevel.self, forKey: .tier)
        tier = tierDecoded
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit)
        storageLimit = storageLimitDecoded
        let userAdminsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userAdmins)
        var userAdminsDecoded0:[Swift.String]? = nil
        if let userAdminsContainer = userAdminsContainer {
            userAdminsDecoded0 = [Swift.String]()
            for string0 in userAdminsContainer {
                if let string0 = string0 {
                    userAdminsDecoded0?.append(string0)
                }
            }
        }
        userAdmins = userAdminsDecoded0
        let groupAdminsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupAdmins)
        var groupAdminsDecoded0:[Swift.String]? = nil
        if let groupAdminsContainer = groupAdminsContainer {
            groupAdminsDecoded0 = [Swift.String]()
            for string0 in groupAdminsContainer {
                if let string0 = string0 {
                    groupAdminsDecoded0?.append(string0)
                }
            }
        }
        groupAdmins = groupAdminsDecoded0
        let userKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userKMSKey)
        userKMSKey = userKMSKeyDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
        let contentSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentSize)
        contentSize = contentSizeDecoded
    }
}

enum GetSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSpacesInput {

    static func queryItemProvider(_ value: ListSpacesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSpacesInput {

    static func urlPathProvider(_ value: ListSpacesInput) -> Swift.String? {
        return "/spaces"
    }
}

public struct ListSpacesInput {
    /// The maximum number of private re:Posts to include in the results.
    public var maxResults: Swift.Int?
    /// The token for the next set of private re:Posts to return. You receive this token from a previous ListSpaces operation.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpacesInputBody {
}

extension ListSpacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSpacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSpacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.spaces = output.spaces
        } else {
            self.nextToken = nil
            self.spaces = nil
        }
    }
}

public struct ListSpacesOutput {
    /// The token that you use when you request the next set of private re:Posts.
    public var nextToken: Swift.String?
    /// An array of structures that contain some information about the private re:Posts in the account.
    /// This member is required.
    public var spaces: [RepostspaceClientTypes.SpaceData]?

    public init(
        nextToken: Swift.String? = nil,
        spaces: [RepostspaceClientTypes.SpaceData]? = nil
    )
    {
        self.nextToken = nextToken
        self.spaces = spaces
    }
}

struct ListSpacesOutputBody {
    let spaces: [RepostspaceClientTypes.SpaceData]?
    let nextToken: Swift.String?
}

extension ListSpacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case spaces
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spacesContainer = try containerValues.decodeIfPresent([RepostspaceClientTypes.SpaceData?].self, forKey: .spaces)
        var spacesDecoded0:[RepostspaceClientTypes.SpaceData]? = nil
        if let spacesContainer = spacesContainer {
            spacesDecoded0 = [RepostspaceClientTypes.SpaceData]()
            for structure0 in spacesContainer {
                if let structure0 = structure0 {
                    spacesDecoded0?.append(structure0)
                }
            }
        }
        spaces = spacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSpacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource that the tags are associated with.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// The list of tags that are associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterAdminInput {

    static func urlPathProvider(_ value: RegisterAdminInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        guard let adminId = value.adminId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())/admins/\(adminId.urlPercentEncoding())"
    }
}

public struct RegisterAdminInput {
    /// The ID of the administrator.
    /// This member is required.
    public var adminId: Swift.String?
    /// The ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?

    public init(
        adminId: Swift.String? = nil,
        spaceId: Swift.String? = nil
    )
    {
        self.adminId = adminId
        self.spaceId = spaceId
    }
}

struct RegisterAdminInputBody {
}

extension RegisterAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RegisterAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterAdminOutput {

    public init() { }
}

enum RegisterAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum RepostspaceClientTypes {}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SendInvitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendInvitesInput(accessorIds: \(Swift.String(describing: accessorIds)), spaceId: \(Swift.String(describing: spaceId)), body: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension SendInvitesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessorIds
        case body
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessorIds = accessorIds {
            var accessorIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessorIds)
            for accessorid0 in accessorIds {
                try accessorIdsContainer.encode(accessorid0)
            }
        }
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension SendInvitesInput {

    static func urlPathProvider(_ value: SendInvitesInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())/invite"
    }
}

public struct SendInvitesInput {
    /// The array of identifiers for the users and groups.
    /// This member is required.
    public var accessorIds: [Swift.String]?
    /// The body of the invite.
    /// This member is required.
    public var body: Swift.String?
    /// The ID of the private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?
    /// The title of the invite.
    /// This member is required.
    public var title: Swift.String?

    public init(
        accessorIds: [Swift.String]? = nil,
        body: Swift.String? = nil,
        spaceId: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.accessorIds = accessorIds
        self.body = body
        self.spaceId = spaceId
        self.title = title
    }
}

struct SendInvitesInputBody {
    let accessorIds: [Swift.String]?
    let title: Swift.String?
    let body: Swift.String?
}

extension SendInvitesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessorIds
        case body
        case title
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accessorIds)
        var accessorIdsDecoded0:[Swift.String]? = nil
        if let accessorIdsContainer = accessorIdsContainer {
            accessorIdsDecoded0 = [Swift.String]()
            for string0 in accessorIdsContainer {
                if let string0 = string0 {
                    accessorIdsDecoded0?.append(string0)
                }
            }
        }
        accessorIds = accessorIdsDecoded0
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
    }
}

extension SendInvitesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendInvitesOutput {

    public init() { }
}

enum SendInvitesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code to identify the quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The id of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code to identify the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension RepostspaceClientTypes.SpaceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configurationStatus
        case contentSize
        case createDateTime
        case deleteDateTime
        case description
        case name
        case randomDomain
        case spaceId
        case status
        case storageLimit
        case tier
        case userCount
        case userKMSKey
        case vanityDomain
        case vanityDomainStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configurationStatus = self.configurationStatus {
            try encodeContainer.encode(configurationStatus.rawValue, forKey: .configurationStatus)
        }
        if let contentSize = self.contentSize {
            try encodeContainer.encode(contentSize, forKey: .contentSize)
        }
        if let createDateTime = self.createDateTime {
            try encodeContainer.encodeTimestamp(createDateTime, format: .dateTime, forKey: .createDateTime)
        }
        if let deleteDateTime = self.deleteDateTime {
            try encodeContainer.encodeTimestamp(deleteDateTime, format: .dateTime, forKey: .deleteDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let randomDomain = self.randomDomain {
            try encodeContainer.encode(randomDomain, forKey: .randomDomain)
        }
        if let spaceId = self.spaceId {
            try encodeContainer.encode(spaceId, forKey: .spaceId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let storageLimit = self.storageLimit {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
        if let userCount = self.userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
        if let userKMSKey = self.userKMSKey {
            try encodeContainer.encode(userKMSKey, forKey: .userKMSKey)
        }
        if let vanityDomain = self.vanityDomain {
            try encodeContainer.encode(vanityDomain, forKey: .vanityDomain)
        }
        if let vanityDomainStatus = self.vanityDomainStatus {
            try encodeContainer.encode(vanityDomainStatus.rawValue, forKey: .vanityDomainStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spaceId)
        spaceId = spaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
        let vanityDomainStatusDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.VanityDomainStatus.self, forKey: .vanityDomainStatus)
        vanityDomainStatus = vanityDomainStatusDecoded
        let vanityDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vanityDomain)
        vanityDomain = vanityDomainDecoded
        let randomDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .randomDomain)
        randomDomain = randomDomainDecoded
        let tierDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.TierLevel.self, forKey: .tier)
        tier = tierDecoded
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit)
        storageLimit = storageLimitDecoded
        let createDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createDateTime)
        createDateTime = createDateTimeDecoded
        let deleteDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deleteDateTime)
        deleteDateTime = deleteDateTimeDecoded
        let userKMSKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userKMSKey)
        userKMSKey = userKMSKeyDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userCount)
        userCount = userCountDecoded
        let contentSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentSize)
        contentSize = contentSizeDecoded
    }
}

extension RepostspaceClientTypes.SpaceData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpaceData(arn: \(Swift.String(describing: arn)), configurationStatus: \(Swift.String(describing: configurationStatus)), contentSize: \(Swift.String(describing: contentSize)), createDateTime: \(Swift.String(describing: createDateTime)), deleteDateTime: \(Swift.String(describing: deleteDateTime)), randomDomain: \(Swift.String(describing: randomDomain)), spaceId: \(Swift.String(describing: spaceId)), status: \(Swift.String(describing: status)), storageLimit: \(Swift.String(describing: storageLimit)), tier: \(Swift.String(describing: tier)), userCount: \(Swift.String(describing: userCount)), userKMSKey: \(Swift.String(describing: userKMSKey)), vanityDomain: \(Swift.String(describing: vanityDomain)), vanityDomainStatus: \(Swift.String(describing: vanityDomainStatus)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension RepostspaceClientTypes {
    /// A structure that contains some information about a private re:Post in the account.
    public struct SpaceData {
        /// The ARN of the private re:Post.
        /// This member is required.
        public var arn: Swift.String?
        /// The configuration status of the private re:Post.
        /// This member is required.
        public var configurationStatus: RepostspaceClientTypes.ConfigurationStatus?
        /// The content size of the private re:Post.
        public var contentSize: Swift.Int?
        /// The date when the private re:Post was created.
        /// This member is required.
        public var createDateTime: ClientRuntime.Date?
        /// The date when the private re:Post was deleted.
        public var deleteDateTime: ClientRuntime.Date?
        /// The description for the private re:Post. This is used only to help you identify this private re:Post.
        public var description: Swift.String?
        /// The name for the private re:Post.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS generated subdomain of the private re:Post.
        /// This member is required.
        public var randomDomain: Swift.String?
        /// The unique ID of the private re:Post.
        /// This member is required.
        public var spaceId: Swift.String?
        /// The creation/deletion status of the private re:Post.
        /// This member is required.
        public var status: Swift.String?
        /// The storage limit of the private re:Post.
        /// This member is required.
        public var storageLimit: Swift.Int?
        /// The pricing tier of the private re:Post.
        /// This member is required.
        public var tier: RepostspaceClientTypes.TierLevel?
        /// The number of onboarded users to the private re:Post.
        public var userCount: Swift.Int?
        /// The custom AWS KMS key ARN that’s used for the AWS KMS encryption.
        public var userKMSKey: Swift.String?
        /// This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.
        /// This member is required.
        public var vanityDomain: Swift.String?
        /// This approval status of the custom subdomain.
        /// This member is required.
        public var vanityDomainStatus: RepostspaceClientTypes.VanityDomainStatus?

        public init(
            arn: Swift.String? = nil,
            configurationStatus: RepostspaceClientTypes.ConfigurationStatus? = nil,
            contentSize: Swift.Int? = nil,
            createDateTime: ClientRuntime.Date? = nil,
            deleteDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            randomDomain: Swift.String? = nil,
            spaceId: Swift.String? = nil,
            status: Swift.String? = nil,
            storageLimit: Swift.Int? = nil,
            tier: RepostspaceClientTypes.TierLevel? = nil,
            userCount: Swift.Int? = nil,
            userKMSKey: Swift.String? = nil,
            vanityDomain: Swift.String? = nil,
            vanityDomainStatus: RepostspaceClientTypes.VanityDomainStatus? = nil
        )
        {
            self.arn = arn
            self.configurationStatus = configurationStatus
            self.contentSize = contentSize
            self.createDateTime = createDateTime
            self.deleteDateTime = deleteDateTime
            self.description = description
            self.name = name
            self.randomDomain = randomDomain
            self.spaceId = spaceId
            self.status = status
            self.storageLimit = storageLimit
            self.tier = tier
            self.userCount = userCount
            self.userKMSKey = userKMSKey
            self.vanityDomain = vanityDomain
            self.vanityDomainStatus = vanityDomainStatus
        }
    }

}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// The ARN of the resource that the tag is associated with.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys and values that must be associated with the resource. You can associate tag keys only, tags (key and values) only, or a combination of tag keys and tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code to identify the quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code to identify the service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension RepostspaceClientTypes {
    public enum TierLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [TierLevel] {
            return [
                .basic,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TierLevel(rawValue: rawValue) ?? TierLevel.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key values of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSpaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSpaceInput(roleArn: \(Swift.String(describing: roleArn)), spaceId: \(Swift.String(describing: spaceId)), tier: \(Swift.String(describing: tier)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateSpaceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case roleArn
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension UpdateSpaceInput {

    static func urlPathProvider(_ value: UpdateSpaceInput) -> Swift.String? {
        guard let spaceId = value.spaceId else {
            return nil
        }
        return "/spaces/\(spaceId.urlPercentEncoding())"
    }
}

public struct UpdateSpaceInput {
    /// A description for the private re:Post. This is used only to help you identify this private re:Post.
    public var description: Swift.String?
    /// The IAM role that grants permissions to the private re:Post to convert unanswered questions into AWS support tickets.
    public var roleArn: Swift.String?
    /// The unique ID of this private re:Post.
    /// This member is required.
    public var spaceId: Swift.String?
    /// The pricing tier of this private re:Post.
    public var tier: RepostspaceClientTypes.TierLevel?

    public init(
        description: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        spaceId: Swift.String? = nil,
        tier: RepostspaceClientTypes.TierLevel? = nil
    )
    {
        self.description = description
        self.roleArn = roleArn
        self.spaceId = spaceId
        self.tier = tier
    }
}

struct UpdateSpaceInputBody {
    let description: Swift.String?
    let tier: RepostspaceClientTypes.TierLevel?
    let roleArn: Swift.String?
}

extension UpdateSpaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case roleArn
        case tier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tierDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.TierLevel.self, forKey: .tier)
        tier = tierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateSpaceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSpaceOutput {

    public init() { }
}

enum UpdateSpaceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [RepostspaceClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why the request failed validation.
        /// This member is required.
        public internal(set) var reason: RepostspaceClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [RepostspaceClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: RepostspaceClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let reason: RepostspaceClientTypes.ValidationExceptionReason?
    let fieldList: [RepostspaceClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RepostspaceClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([RepostspaceClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[RepostspaceClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [RepostspaceClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension RepostspaceClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepostspaceClientTypes {
    /// Stores information about a field that’s passed inside a request that resulted in an exception.
    public struct ValidationExceptionField {
        /// The name of the field.
        /// This member is required.
        public var message: Swift.String?
        /// Message describing why the field failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension RepostspaceClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension RepostspaceClientTypes {
    public enum VanityDomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case unapproved
        case sdkUnknown(Swift.String)

        public static var allCases: [VanityDomainStatus] {
            return [
                .approved,
                .pending,
                .unapproved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .unapproved: return "UNAPPROVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VanityDomainStatus(rawValue: rawValue) ?? VanityDomainStatus.sdkUnknown(rawValue)
        }
    }
}
