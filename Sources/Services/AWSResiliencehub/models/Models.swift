// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddDraftAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let resourceMappings = resourceMappings {
            var resourceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceMappings)
            for resourcemapping0 in resourceMappings {
                try resourceMappingsContainer.encode(resourcemapping0)
            }
        }
    }
}

extension AddDraftAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/add-draft-app-version-resource-mappings"
    }
}

public struct AddDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init(
        appArn: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case resourceMappings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

extension AddDraftAppVersionResourceMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddDraftAppVersionResourceMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resourceMappings = output.resourceMappings
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resourceMappings = nil
        }
    }
}

public struct AddDraftAppVersionResourceMappingsOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// List of sources that are used to map a logical resource from the template to a physical resource. You can use sources such as CloudFormation, Terraform state files, AppRegistry applications, or Amazon EKS.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resourceMappings = resourceMappings
    }
}

struct AddDraftAppVersionResourceMappingsOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
}

extension AddDraftAppVersionResourceMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resourceMappings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
    }
}

enum AddDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes.AlarmRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case appComponentNames
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let appComponentNames = appComponentNames {
            var appComponentNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponentNames)
            for string2550 in appComponentNames {
                try appComponentNamesContainer.encode(string2550)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitem0 in items {
                try itemsContainer.encode(recommendationitem0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = self.prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AlarmType.self, forKey: .type)
        type = typeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
        let appComponentNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appComponentNames)
        var appComponentNamesDecoded0:[Swift.String]? = nil
        if let appComponentNamesContainer = appComponentNamesContainer {
            appComponentNamesDecoded0 = [Swift.String]()
            for string0 in appComponentNamesContainer {
                if let string0 = string0 {
                    appComponentNamesDecoded0?.append(string0)
                }
            }
        }
        appComponentNames = appComponentNamesDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation for a CloudWatch alarm.
    public struct AlarmRecommendation: Swift.Equatable {
        /// Application Component name for the CloudWatch alarm recommendation. This name is saved as the first item in the appComponentNames list.
        @available(*, deprecated, message: "An alarm recommendation can be attached to multiple Application Components, hence this property will be replaced by the new property 'appComponentNames'.")
        public var appComponentName: Swift.String?
        /// List of Application Component names for the CloudWatch alarm recommendation.
        public var appComponentNames: [Swift.String]?
        /// Description of the alarm recommendation.
        public var description: Swift.String?
        /// List of CloudWatch alarm recommendations.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// Name of the alarm recommendation.
        /// This member is required.
        public var name: Swift.String?
        /// The prerequisite for the alarm recommendation.
        public var prerequisite: Swift.String?
        /// Identifier of the alarm recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// Reference identifier of the alarm recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Type of alarm recommendation.
        /// This member is required.
        public var type: ResiliencehubClientTypes.AlarmType?

        public init(
            appComponentName: Swift.String? = nil,
            appComponentNames: [Swift.String]? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            type: ResiliencehubClientTypes.AlarmType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.appComponentNames = appComponentNames
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AlarmType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canary
        case composite
        case event
        case logs
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmType] {
            return [
                .canary,
                .composite,
                .event,
                .logs,
                .metric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canary: return "Canary"
            case .composite: return "Composite"
            case .event: return "Event"
            case .logs: return "Logs"
            case .metric: return "Metric"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmType(rawValue: rawValue) ?? AlarmType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.App: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentSchedule
        case complianceStatus
        case creationTime
        case description
        case driftStatus
        case eventSubscriptions
        case lastAppComplianceEvaluationTime
        case lastDriftEvaluationTime
        case lastResiliencyScoreEvaluationTime
        case name
        case permissionModel
        case policyArn
        case resiliencyScore
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentSchedule = self.assessmentSchedule {
            try encodeContainer.encode(assessmentSchedule.rawValue, forKey: .assessmentSchedule)
        }
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscription0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscription0)
            }
        }
        if let lastAppComplianceEvaluationTime = self.lastAppComplianceEvaluationTime {
            try encodeContainer.encodeTimestamp(lastAppComplianceEvaluationTime, format: .epochSeconds, forKey: .lastAppComplianceEvaluationTime)
        }
        if let lastDriftEvaluationTime = self.lastDriftEvaluationTime {
            try encodeContainer.encodeTimestamp(lastDriftEvaluationTime, format: .epochSeconds, forKey: .lastDriftEvaluationTime)
        }
        if let lastResiliencyScoreEvaluationTime = self.lastResiliencyScoreEvaluationTime {
            try encodeContainer.encodeTimestamp(lastResiliencyScoreEvaluationTime, format: .epochSeconds, forKey: .lastResiliencyScoreEvaluationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionModel = self.permissionModel {
            try encodeContainer.encode(permissionModel, forKey: .permissionModel)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppStatusType.self, forKey: .status)
        status = statusDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let lastAppComplianceEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAppComplianceEvaluationTime)
        lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTimeDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .resiliencyScore) ?? 0.0
        resiliencyScore = resiliencyScoreDecoded
        let lastResiliencyScoreEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastResiliencyScoreEvaluationTime)
        lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let assessmentScheduleDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessmentScheduleType.self, forKey: .assessmentSchedule)
        assessmentSchedule = assessmentScheduleDecoded
        let permissionModelDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PermissionModel.self, forKey: .permissionModel)
        permissionModel = permissionModelDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[ResiliencehubClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [ResiliencehubClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
        let driftStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppDriftStatusType.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
        let lastDriftEvaluationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastDriftEvaluationTime)
        lastDriftEvaluationTime = lastDriftEvaluationTimeDecoded
    }
}

extension ResiliencehubClientTypes.App: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "App(appArn: \(Swift.String(describing: appArn)), assessmentSchedule: \(Swift.String(describing: assessmentSchedule)), complianceStatus: \(Swift.String(describing: complianceStatus)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), driftStatus: \(Swift.String(describing: driftStatus)), eventSubscriptions: \(Swift.String(describing: eventSubscriptions)), lastAppComplianceEvaluationTime: \(Swift.String(describing: lastAppComplianceEvaluationTime)), lastDriftEvaluationTime: \(Swift.String(describing: lastDriftEvaluationTime)), lastResiliencyScoreEvaluationTime: \(Swift.String(describing: lastResiliencyScoreEvaluationTime)), name: \(Swift.String(describing: name)), permissionModel: \(Swift.String(describing: permissionModel)), policyArn: \(Swift.String(describing: policyArn)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), status: \(Swift.String(describing: status)), tags: \"CONTENT_REDACTED\")"}
}

extension ResiliencehubClientTypes {
    /// Defines an Resilience Hub application.
    public struct App: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var appArn: Swift.String?
        /// Assessment execution schedule with 'Daily' or 'Disabled' values.
        public var assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
        /// Current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// Timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// Optional description for an application.
        public var description: Swift.String?
        /// Indicates if compliance drifts (deviations) were detected while running an assessment for your application.
        public var driftStatus: ResiliencehubClientTypes.AppDriftStatusType?
        /// The list of events you would like to subscribe and get notification for. Currently, Resilience Hub supports notifications only for Drift detected and Scheduled assessment failure events.
        public var eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]?
        /// Timestamp for the most recent compliance evaluation.
        public var lastAppComplianceEvaluationTime: ClientRuntime.Date?
        /// Indicates the last time that a drift was evaluated.
        public var lastDriftEvaluationTime: ClientRuntime.Date?
        /// Timestamp for the most recent resiliency score evaluation.
        public var lastResiliencyScoreEvaluationTime: ClientRuntime.Date?
        /// Name for the application.
        /// This member is required.
        public var name: Swift.String?
        /// Defines the roles and credentials that Resilience Hub would use while creating the application, importing its resources, and running an assessment.
        public var permissionModel: ResiliencehubClientTypes.PermissionModel?
        /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var policyArn: Swift.String?
        /// Current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// Status of the application.
        public var status: ResiliencehubClientTypes.AppStatusType?
        /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?

        public init(
            appArn: Swift.String? = nil,
            assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            driftStatus: ResiliencehubClientTypes.AppDriftStatusType? = nil,
            eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]? = nil,
            lastAppComplianceEvaluationTime: ClientRuntime.Date? = nil,
            lastDriftEvaluationTime: ClientRuntime.Date? = nil,
            lastResiliencyScoreEvaluationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permissionModel: ResiliencehubClientTypes.PermissionModel? = nil,
            policyArn: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            status: ResiliencehubClientTypes.AppStatusType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appArn = appArn
            self.assessmentSchedule = assessmentSchedule
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.driftStatus = driftStatus
            self.eventSubscriptions = eventSubscriptions
            self.lastAppComplianceEvaluationTime = lastAppComplianceEvaluationTime
            self.lastDriftEvaluationTime = lastDriftEvaluationTime
            self.lastResiliencyScoreEvaluationTime = lastResiliencyScoreEvaluationTime
            self.name = name
            self.permissionModel = permissionModel
            self.policyArn = policyArn
            self.resiliencyScore = resiliencyScore
            self.status = status
            self.tags = tags
        }
    }

}

extension ResiliencehubClientTypes.AppAssessment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case compliance
        case complianceStatus
        case cost
        case driftStatus
        case endTime
        case invoker
        case message
        case policy
        case resiliencyScore
        case resourceErrorsDetails
        case startTime
        case tags
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = self.assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentCompliance0) in compliance {
                try complianceContainer.encode(assessmentCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let invoker = self.invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resiliencyScore = self.resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let resourceErrorsDetails = self.resourceErrorsDetails {
            try encodeContainer.encode(resourceErrorsDetails, forKey: .resourceErrorsDetails)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let resourceErrorsDetailsDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceErrorsDetails.self, forKey: .resourceErrorsDetails)
        resourceErrorsDetails = resourceErrorsDetailsDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ResiliencehubClientTypes.AppAssessment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppAssessment(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), assessmentArn: \(Swift.String(describing: assessmentArn)), assessmentName: \(Swift.String(describing: assessmentName)), assessmentStatus: \(Swift.String(describing: assessmentStatus)), compliance: \(Swift.String(describing: compliance)), complianceStatus: \(Swift.String(describing: complianceStatus)), cost: \(Swift.String(describing: cost)), driftStatus: \(Swift.String(describing: driftStatus)), endTime: \(Swift.String(describing: endTime)), invoker: \(Swift.String(describing: invoker)), message: \(Swift.String(describing: message)), policy: \(Swift.String(describing: policy)), resiliencyScore: \(Swift.String(describing: resiliencyScore)), resourceErrorsDetails: \(Swift.String(describing: resourceErrorsDetails)), startTime: \(Swift.String(describing: startTime)), versionName: \(Swift.String(describing: versionName)), tags: \"CONTENT_REDACTED\")"}
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment.
    public struct AppAssessment: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var appArn: Swift.String?
        /// Version of an application.
        public var appVersion: Swift.String?
        /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// Name of the assessment.
        public var assessmentName: Swift.String?
        /// Current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// Application compliance against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// Current status of the compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// Cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// Indicates if compliance drifts (deviations) were detected while running an assessment for your application.
        public var driftStatus: ResiliencehubClientTypes.DriftStatus?
        /// End time for the action.
        public var endTime: ClientRuntime.Date?
        /// The entity that invoked the assessment.
        /// This member is required.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// Error or warning message from the assessment execution
        public var message: Swift.String?
        /// Resiliency policy of an application.
        public var policy: ResiliencehubClientTypes.ResiliencyPolicy?
        /// Current resiliency score for an application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// A resource error object containing a list of errors retrieving an application's resources.
        public var resourceErrorsDetails: ResiliencehubClientTypes.ResourceErrorsDetails?
        /// Starting time for the action.
        public var startTime: ClientRuntime.Date?
        /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// Version name of the published application.
        public var versionName: Swift.String?

        public init(
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            driftStatus: ResiliencehubClientTypes.DriftStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            resourceErrorsDetails: ResiliencehubClientTypes.ResourceErrorsDetails? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.compliance = compliance
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.driftStatus = driftStatus
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.policy = policy
            self.resiliencyScore = resiliencyScore
            self.resourceErrorsDetails = resourceErrorsDetails
            self.startTime = startTime
            self.tags = tags
            self.versionName = versionName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppAssessmentScheduleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAssessmentScheduleType] {
            return [
                .daily,
                .disabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "Daily"
            case .disabled: return "Disabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppAssessmentScheduleType(rawValue: rawValue) ?? AppAssessmentScheduleType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppAssessmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentArn
        case assessmentName
        case assessmentStatus
        case complianceStatus
        case cost
        case driftStatus
        case endTime
        case invoker
        case message
        case resiliencyScore
        case startTime
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentStatus = self.assessmentStatus {
            try encodeContainer.encode(assessmentStatus.rawValue, forKey: .assessmentStatus)
        }
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let invoker = self.invoker {
            try encodeContainer.encode(invoker.rawValue, forKey: .invoker)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
        let invokerDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentInvoker.self, forKey: .invoker)
        invoker = invokerDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .resiliencyScore) ?? 0.0
        resiliencyScore = resiliencyScoreDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DriftStatus.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application assessment summary.
    public struct AppAssessmentSummary: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var appArn: Swift.String?
        /// Version of an application.
        public var appVersion: Swift.String?
        /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// Name of the assessment.
        public var assessmentName: Swift.String?
        /// Current status of the assessment for the resiliency policy.
        /// This member is required.
        public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
        /// TCurrent status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// Cost for an application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// Indicates if compliance drifts (deviations) were detected while running an assessment for your application.
        public var driftStatus: ResiliencehubClientTypes.DriftStatus?
        /// End time for the action.
        public var endTime: ClientRuntime.Date?
        /// Entity that invoked the assessment.
        public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
        /// Message from the assessment run.
        public var message: Swift.String?
        /// Current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// Starting time for the action.
        public var startTime: ClientRuntime.Date?
        /// Name of an application version.
        public var versionName: Swift.String?

        public init(
            appArn: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            assessmentName: Swift.String? = nil,
            assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            driftStatus: ResiliencehubClientTypes.DriftStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
            message: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            startTime: ClientRuntime.Date? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.appArn = appArn
            self.appVersion = appVersion
            self.assessmentArn = assessmentArn
            self.assessmentName = assessmentName
            self.assessmentStatus = assessmentStatus
            self.complianceStatus = complianceStatus
            self.cost = cost
            self.driftStatus = driftStatus
            self.endTime = endTime
            self.invoker = invoker
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.startTime = startTime
            self.versionName = versionName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppComplianceStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changesDetected
        case notAssessed
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [AppComplianceStatusType] {
            return [
                .changesDetected,
                .notAssessed,
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changesDetected: return "ChangesDetected"
            case .notAssessed: return "NotAssessed"
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppComplianceStatusType(rawValue: rawValue) ?? AppComplianceStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines an Application Component.
    public struct AppComponent: Swift.Equatable {
        /// Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
        public var additionalInfo: [Swift.String:[Swift.String]]?
        /// Identifier of the Application Component.
        public var id: Swift.String?
        /// Name of the Application Component.
        /// This member is required.
        public var name: Swift.String?
        /// The type of Application Component.
        /// This member is required.
        public var type: Swift.String?

        public init(
            additionalInfo: [Swift.String:[Swift.String]]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes.AppComponentCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case message
        case resiliencyScore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentCompliance0) in compliance {
                try complianceContainer.encode(assessmentCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resiliencyScore = self.resiliencyScore {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyScore.self, forKey: .resiliencyScore)
        resiliencyScore = resiliencyScoreDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the compliance of an Application Component against the resiliency policy.
    public struct AppComponentCompliance: Swift.Equatable {
        /// Name of the Application Component.
        public var appComponentName: Swift.String?
        /// The compliance of the Application Component against the resiliency policy.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The compliance message.
        public var message: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: ResiliencehubClientTypes.ResiliencyScore?
        /// Status of the action.
        public var status: ResiliencehubClientTypes.ComplianceStatus?

        public init(
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            message: Swift.String? = nil,
            resiliencyScore: ResiliencehubClientTypes.ResiliencyScore? = nil,
            status: ResiliencehubClientTypes.ComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.message = message
            self.resiliencyScore = resiliencyScore
            self.status = status
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppDriftStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detected
        case notChecked
        case notDetected
        case sdkUnknown(Swift.String)

        public static var allCases: [AppDriftStatusType] {
            return [
                .detected,
                .notChecked,
                .notDetected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detected: return "Detected"
            case .notChecked: return "NotChecked"
            case .notDetected: return "NotDetected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppDriftStatusType(rawValue: rawValue) ?? AppDriftStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppInputSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksSourceClusterNamespace
        case importType
        case resourceCount
        case sourceArn
        case sourceName
        case terraformSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksSourceClusterNamespace = self.eksSourceClusterNamespace {
            try encodeContainer.encode(eksSourceClusterNamespace, forKey: .eksSourceClusterNamespace)
        }
        if let importType = self.importType {
            try encodeContainer.encode(importType.rawValue, forKey: .importType)
        }
        if resourceCount != 0 {
            try encodeContainer.encode(resourceCount, forKey: .resourceCount)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceName = self.sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let terraformSource = self.terraformSource {
            try encodeContainer.encode(terraformSource, forKey: .terraformSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let importTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceMappingType.self, forKey: .importType)
        importType = importTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let terraformSourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TerraformSource.self, forKey: .terraformSource)
        terraformSource = terraformSourceDecoded
        let resourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resourceCount) ?? 0
        resourceCount = resourceCountDecoded
        let eksSourceClusterNamespaceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EksSourceClusterNamespace.self, forKey: .eksSourceClusterNamespace)
        eksSourceClusterNamespace = eksSourceClusterNamespaceDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The list of Resilience Hub application input sources.
    public struct AppInputSource: Swift.Equatable {
        /// The namespace on your Amazon Elastic Kubernetes Service cluster.
        public var eksSourceClusterNamespace: ResiliencehubClientTypes.EksSourceClusterNamespace?
        /// The resource type of the input source.
        /// This member is required.
        public var importType: ResiliencehubClientTypes.ResourceMappingType?
        /// The number of resources.
        public var resourceCount: Swift.Int
        /// The Amazon Resource Name (ARN) of the input source. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var sourceArn: Swift.String?
        /// The name of the input source.
        public var sourceName: Swift.String?
        /// The name of the Terraform s3 state le.
        public var terraformSource: ResiliencehubClientTypes.TerraformSource?

        public init(
            eksSourceClusterNamespace: ResiliencehubClientTypes.EksSourceClusterNamespace? = nil,
            importType: ResiliencehubClientTypes.ResourceMappingType? = nil,
            resourceCount: Swift.Int = 0,
            sourceArn: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            terraformSource: ResiliencehubClientTypes.TerraformSource? = nil
        )
        {
            self.eksSourceClusterNamespace = eksSourceClusterNamespace
            self.importType = importType
            self.resourceCount = resourceCount
            self.sourceArn = sourceArn
            self.sourceName = sourceName
            self.terraformSource = terraformSource
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AppStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatusType] {
            return [
                .active,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleting: return "Deleting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppStatusType(rawValue: rawValue) ?? AppStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.AppSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentSchedule
        case complianceStatus
        case creationTime
        case description
        case driftStatus
        case name
        case resiliencyScore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentSchedule = self.assessmentSchedule {
            try encodeContainer.encode(assessmentSchedule.rawValue, forKey: .assessmentSchedule)
        }
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let driftStatus = self.driftStatus {
            try encodeContainer.encode(driftStatus.rawValue, forKey: .driftStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if resiliencyScore != 0.0 {
            try encodeContainer.encode(resiliencyScore, forKey: .resiliencyScore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComplianceStatusType.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let resiliencyScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .resiliencyScore) ?? 0.0
        resiliencyScore = resiliencyScoreDecoded
        let assessmentScheduleDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessmentScheduleType.self, forKey: .assessmentSchedule)
        assessmentSchedule = assessmentScheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppStatusType.self, forKey: .status)
        status = statusDecoded
        let driftStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppDriftStatusType.self, forKey: .driftStatus)
        driftStatus = driftStatusDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines an application summary.
    public struct AppSummary: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var appArn: Swift.String?
        /// Assessment execution schedule with 'Daily' or 'Disabled' values.
        public var assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
        /// The current status of compliance for the resiliency policy.
        public var complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType?
        /// The timestamp for when the app was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The optional description for an app.
        public var description: Swift.String?
        /// Indicates if compliance drifts (deviations) were detected while running an assessment for your application.
        public var driftStatus: ResiliencehubClientTypes.AppDriftStatusType?
        /// The name of the application.
        /// This member is required.
        public var name: Swift.String?
        /// The current resiliency score for the application.
        public var resiliencyScore: Swift.Double
        /// Status of the application.
        public var status: ResiliencehubClientTypes.AppStatusType?

        public init(
            appArn: Swift.String? = nil,
            assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType? = nil,
            complianceStatus: ResiliencehubClientTypes.AppComplianceStatusType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            driftStatus: ResiliencehubClientTypes.AppDriftStatusType? = nil,
            name: Swift.String? = nil,
            resiliencyScore: Swift.Double = 0.0,
            status: ResiliencehubClientTypes.AppStatusType? = nil
        )
        {
            self.appArn = appArn
            self.assessmentSchedule = assessmentSchedule
            self.complianceStatus = complianceStatus
            self.creationTime = creationTime
            self.description = description
            self.driftStatus = driftStatus
            self.name = name
            self.resiliencyScore = resiliencyScore
            self.status = status
        }
    }

}

extension ResiliencehubClientTypes.AppVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersion
        case creationTime
        case identifier
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .identifier)
        identifier = identifierDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Version of an application.
    public struct AppVersionSummary: Swift.Equatable {
        /// Version of an application.
        /// This member is required.
        public var appVersion: Swift.String?
        /// Creation time of the application version.
        public var creationTime: ClientRuntime.Date?
        /// Identifier of the application version.
        public var identifier: Swift.Int?
        /// Name of the application version.
        public var versionName: Swift.String?

        public init(
            appVersion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            identifier: Swift.Int? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.appVersion = appVersion
            self.creationTime = creationTime
            self.identifier = identifier
            self.versionName = versionName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum AssessmentInvoker: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case system
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentInvoker] {
            return [
                .system,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .system: return "System"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentInvoker(rawValue: rawValue) ?? AssessmentInvoker.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .failed,
                .inprogress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ResiliencehubClientTypes {
    /// List of operational recommendations that did not get included or excluded.
    public struct BatchUpdateRecommendationStatusFailedEntry: Swift.Equatable {
        /// An identifier of an entry in this batch that is used to communicate the result. The entryIds of a batch request need to be unique within a request.
        /// This member is required.
        public var entryId: Swift.String?
        /// Indicates the error that occurred while excluding an operational recommendation.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorMessage = errorMessage
        }
    }

}

extension BatchUpdateRecommendationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case requestEntries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let requestEntries = requestEntries {
            var requestEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requestEntries)
            for updaterecommendationstatusrequestentry0 in requestEntries {
                try requestEntriesContainer.encode(updaterecommendationstatusrequestentry0)
            }
        }
    }
}

extension BatchUpdateRecommendationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-update-recommendation-status"
    }
}

public struct BatchUpdateRecommendationStatusInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Defines the list of operational recommendations that need to be included or excluded.
    /// This member is required.
    public var requestEntries: [ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry]?

    public init(
        appArn: Swift.String? = nil,
        requestEntries: [ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry]? = nil
    )
    {
        self.appArn = appArn
        self.requestEntries = requestEntries
    }
}

struct BatchUpdateRecommendationStatusInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let requestEntries: [ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry]?
}

extension BatchUpdateRecommendationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case requestEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let requestEntriesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry?].self, forKey: .requestEntries)
        var requestEntriesDecoded0:[ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry]? = nil
        if let requestEntriesContainer = requestEntriesContainer {
            requestEntriesDecoded0 = [ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry]()
            for structure0 in requestEntriesContainer {
                if let structure0 = structure0 {
                    requestEntriesDecoded0?.append(structure0)
                }
            }
        }
        requestEntries = requestEntriesDecoded0
    }
}

extension BatchUpdateRecommendationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateRecommendationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.failedEntries = output.failedEntries
            self.successfulEntries = output.successfulEntries
        } else {
            self.appArn = nil
            self.failedEntries = nil
            self.successfulEntries = nil
        }
    }
}

public struct BatchUpdateRecommendationStatusOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// A list of items with error details about each item, which could not be included or excluded.
    /// This member is required.
    public var failedEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry]?
    /// A list of items that were included or excluded.
    /// This member is required.
    public var successfulEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry]?

    public init(
        appArn: Swift.String? = nil,
        failedEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry]? = nil,
        successfulEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry]? = nil
    )
    {
        self.appArn = appArn
        self.failedEntries = failedEntries
        self.successfulEntries = successfulEntries
    }
}

struct BatchUpdateRecommendationStatusOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let successfulEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry]?
    let failedEntries: [ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry]?
}

extension BatchUpdateRecommendationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case failedEntries
        case successfulEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let successfulEntriesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry?].self, forKey: .successfulEntries)
        var successfulEntriesDecoded0:[ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry]? = nil
        if let successfulEntriesContainer = successfulEntriesContainer {
            successfulEntriesDecoded0 = [ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry]()
            for structure0 in successfulEntriesContainer {
                if let structure0 = structure0 {
                    successfulEntriesDecoded0?.append(structure0)
                }
            }
        }
        successfulEntries = successfulEntriesDecoded0
        let failedEntriesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [ResiliencehubClientTypes.BatchUpdateRecommendationStatusFailedEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

enum BatchUpdateRecommendationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes.BatchUpdateRecommendationStatusSuccessfulEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case excludeReason
        case excluded
        case item
        case referenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let excludeReason = self.excludeReason {
            try encodeContainer.encode(excludeReason.rawValue, forKey: .excludeReason)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let item = self.item {
            try encodeContainer.encode(item, forKey: .item)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let itemDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.UpdateRecommendationStatusItem.self, forKey: .item)
        item = itemDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let excludeReasonDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ExcludeRecommendationReason.self, forKey: .excludeReason)
        excludeReason = excludeReasonDecoded
    }
}

extension ResiliencehubClientTypes {
    /// List of operational recommendations that were successfully included or excluded.
    public struct BatchUpdateRecommendationStatusSuccessfulEntry: Swift.Equatable {
        /// An identifier for an entry in this batch that is used to communicate the result. The entryIds of a batch request need to be unique within a request.
        /// This member is required.
        public var entryId: Swift.String?
        /// Indicates the reason for excluding an operational recommendation.
        public var excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason?
        /// Indicates if the operational recommendation was successfully excluded.
        /// This member is required.
        public var excluded: Swift.Bool?
        /// The operational recommendation item.
        /// This member is required.
        public var item: ResiliencehubClientTypes.UpdateRecommendationStatusItem?
        /// Reference identifier of the operational recommendation.
        /// This member is required.
        public var referenceId: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason? = nil,
            excluded: Swift.Bool? = nil,
            item: ResiliencehubClientTypes.UpdateRecommendationStatusItem? = nil,
            referenceId: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.excludeReason = excludeReason
            self.excluded = excluded
            self.item = item
            self.referenceId = referenceId
        }
    }

}

extension ResiliencehubClientTypes.ComplianceDrift: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualReferenceId
        case actualValue
        case appId
        case appVersion
        case diffType
        case driftType
        case entityId
        case entityType
        case expectedReferenceId
        case expectedValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualReferenceId = self.actualReferenceId {
            try encodeContainer.encode(actualReferenceId, forKey: .actualReferenceId)
        }
        if let actualValue = actualValue {
            var actualValueContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actualValue)
            for (dictKey0, assessmentCompliance0) in actualValue {
                try actualValueContainer.encode(assessmentCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let diffType = self.diffType {
            try encodeContainer.encode(diffType.rawValue, forKey: .diffType)
        }
        if let driftType = self.driftType {
            try encodeContainer.encode(driftType.rawValue, forKey: .driftType)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let expectedReferenceId = self.expectedReferenceId {
            try encodeContainer.encode(expectedReferenceId, forKey: .expectedReferenceId)
        }
        if let expectedValue = expectedValue {
            var expectedValueContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .expectedValue)
            for (dictKey0, assessmentCompliance0) in expectedValue {
                try expectedValueContainer.encode(assessmentCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let driftTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DriftType.self, forKey: .driftType)
        driftType = driftTypeDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let expectedReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedReferenceId)
        expectedReferenceId = expectedReferenceIdDecoded
        let expectedValueContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .expectedValue)
        var expectedValueDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let expectedValueContainer = expectedValueContainer {
            expectedValueDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in expectedValueContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    expectedValueDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        expectedValue = expectedValueDecoded0
        let actualReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actualReferenceId)
        actualReferenceId = actualReferenceIdDecoded
        let actualValueContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .actualValue)
        var actualValueDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let actualValueContainer = actualValueContainer {
            actualValueDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in actualValueContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    actualValueDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        actualValue = actualValueDecoded0
        let diffTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DifferenceType.self, forKey: .diffType)
        diffType = diffTypeDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Indicates the compliance drifts (recovery time objective (RTO) and recovery point objective (RPO)) that were detected for an assessed entity.
    public struct ComplianceDrift: Swift.Equatable {
        /// Assessment identifier that is associated with this drift item.
        public var actualReferenceId: Swift.String?
        /// Actual compliance value of the entity.
        public var actualValue: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// Identifier of your application.
        public var appId: Swift.String?
        /// Published version of your application on which drift was detected.
        public var appVersion: Swift.String?
        /// Difference type between actual and expected recovery point objective (RPO) and recovery time objective (RTO) values. Currently, Resilience Hub supports only NotEqual difference type.
        public var diffType: ResiliencehubClientTypes.DifferenceType?
        /// The type of drift detected. Currently, Resilience Hub supports only ApplicationCompliance drift type.
        public var driftType: ResiliencehubClientTypes.DriftType?
        /// Identifier of an entity in which drift was detected. For compliance drift, the entity ID can be either application ID or the AppComponent ID.
        public var entityId: Swift.String?
        /// The type of entity in which drift was detected. For compliance drifts, Resilience Hub supports AWS::ResilienceHub::AppComponent and AWS::ResilienceHub::Application.
        public var entityType: Swift.String?
        /// Assessment identifier of a previous assessment of the same application version. Resilience Hub uses the previous assessment (associated with the reference identifier) to compare the compliance with the current assessment to identify drifts.
        public var expectedReferenceId: Swift.String?
        /// The expected compliance value of an entity.
        public var expectedValue: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?

        public init(
            actualReferenceId: Swift.String? = nil,
            actualValue: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            appId: Swift.String? = nil,
            appVersion: Swift.String? = nil,
            diffType: ResiliencehubClientTypes.DifferenceType? = nil,
            driftType: ResiliencehubClientTypes.DriftType? = nil,
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil,
            expectedReferenceId: Swift.String? = nil,
            expectedValue: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        )
        {
            self.actualReferenceId = actualReferenceId
            self.actualValue = actualValue
            self.appId = appId
            self.appVersion = appVersion
            self.diffType = diffType
            self.driftType = driftType
            self.entityId = entityId
            self.entityType = entityType
            self.expectedReferenceId = expectedReferenceId
            self.expectedValue = expectedValue
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyBreached
        case policyMet
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .policyBreached,
                .policyMet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyBreached: return "PolicyBreached"
            case .policyMet: return "PolicyMet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ComponentRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case configRecommendations
        case recommendationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let configRecommendations = configRecommendations {
            var configRecommendationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configRecommendations)
            for configrecommendation0 in configRecommendations {
                try configRecommendationsContainer.encode(configrecommendation0)
            }
        }
        if let recommendationStatus = self.recommendationStatus {
            try encodeContainer.encode(recommendationStatus.rawValue, forKey: .recommendationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let recommendationStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationComplianceStatus.self, forKey: .recommendationStatus)
        recommendationStatus = recommendationStatusDecoded
        let configRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ConfigRecommendation?].self, forKey: .configRecommendations)
        var configRecommendationsDecoded0:[ResiliencehubClientTypes.ConfigRecommendation]? = nil
        if let configRecommendationsContainer = configRecommendationsContainer {
            configRecommendationsDecoded0 = [ResiliencehubClientTypes.ConfigRecommendation]()
            for structure0 in configRecommendationsContainer {
                if let structure0 = structure0 {
                    configRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        configRecommendations = configRecommendationsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines recommendations for an Resilience Hub Application Component, returned as an object. This object contains component names, configuration recommendations, and recommendation statuses.
    public struct ComponentRecommendation: Swift.Equatable {
        /// Name of the Application Component.
        /// This member is required.
        public var appComponentName: Swift.String?
        /// List of recommendations.
        /// This member is required.
        public var configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]?
        /// Status of the recommendation.
        /// This member is required.
        public var recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus?

        public init(
            appComponentName: Swift.String? = nil,
            configRecommendations: [ResiliencehubClientTypes.ConfigRecommendation]? = nil,
            recommendationStatus: ResiliencehubClientTypes.RecommendationComplianceStatus? = nil
        )
        {
            self.appComponentName = appComponentName
            self.configRecommendations = configRecommendations
            self.recommendationStatus = recommendationStatus
        }
    }

}

extension ResiliencehubClientTypes.ConfigRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case compliance
        case cost
        case description
        case haArchitecture
        case name
        case optimizationType
        case recommendationCompliance
        case referenceId
        case suggestedChanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let compliance = compliance {
            var complianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .compliance)
            for (dictKey0, assessmentCompliance0) in compliance {
                try complianceContainer.encode(assessmentCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let cost = self.cost {
            try encodeContainer.encode(cost, forKey: .cost)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let haArchitecture = self.haArchitecture {
            try encodeContainer.encode(haArchitecture.rawValue, forKey: .haArchitecture)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let optimizationType = self.optimizationType {
            try encodeContainer.encode(optimizationType.rawValue, forKey: .optimizationType)
        }
        if let recommendationCompliance = recommendationCompliance {
            var recommendationComplianceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recommendationCompliance)
            for (dictKey0, recommendationCompliance0) in recommendationCompliance {
                try recommendationComplianceContainer.encode(recommendationCompliance0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let suggestedChanges = suggestedChanges {
            var suggestedChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suggestedChanges)
            for entitydescription0 in suggestedChanges {
                try suggestedChangesContainer.encode(entitydescription0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.Cost.self, forKey: .cost)
        cost = costDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let complianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.DisruptionCompliance?].self, forKey: .compliance)
        var complianceDecoded0: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil
        if let complianceContainer = complianceContainer {
            complianceDecoded0 = [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]()
            for (key0, disruptioncompliance0) in complianceContainer {
                if let disruptioncompliance0 = disruptioncompliance0 {
                    complianceDecoded0?[key0] = disruptioncompliance0
                }
            }
        }
        compliance = complianceDecoded0
        let recommendationComplianceContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.RecommendationDisruptionCompliance?].self, forKey: .recommendationCompliance)
        var recommendationComplianceDecoded0: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil
        if let recommendationComplianceContainer = recommendationComplianceContainer {
            recommendationComplianceDecoded0 = [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]()
            for (key0, recommendationdisruptioncompliance0) in recommendationComplianceContainer {
                if let recommendationdisruptioncompliance0 = recommendationdisruptioncompliance0 {
                    recommendationComplianceDecoded0?[key0] = recommendationdisruptioncompliance0
                }
            }
        }
        recommendationCompliance = recommendationComplianceDecoded0
        let optimizationTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ConfigRecommendationOptimizationType.self, forKey: .optimizationType)
        optimizationType = optimizationTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let suggestedChangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .suggestedChanges)
        var suggestedChangesDecoded0:[Swift.String]? = nil
        if let suggestedChangesContainer = suggestedChangesContainer {
            suggestedChangesDecoded0 = [Swift.String]()
            for string0 in suggestedChangesContainer {
                if let string0 = string0 {
                    suggestedChangesDecoded0?.append(string0)
                }
            }
        }
        suggestedChanges = suggestedChangesDecoded0
        let haArchitectureDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.HaArchitecture.self, forKey: .haArchitecture)
        haArchitecture = haArchitectureDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation configuration.
    public struct ConfigRecommendation: Swift.Equatable {
        /// Name of the Application Component.
        public var appComponentName: Swift.String?
        /// The current compliance against the resiliency policy before applying the configuration change.
        public var compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]?
        /// The cost for the application.
        public var cost: ResiliencehubClientTypes.Cost?
        /// The optional description for an app.
        public var description: Swift.String?
        /// The architecture type.
        public var haArchitecture: ResiliencehubClientTypes.HaArchitecture?
        /// The name of the recommendation configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The type of optimization.
        /// This member is required.
        public var optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType?
        /// The expected compliance against the resiliency policy after applying the configuration change.
        public var recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]?
        /// Reference identifier for the recommendation configuration.
        /// This member is required.
        public var referenceId: Swift.String?
        /// List of the suggested configuration changes.
        public var suggestedChanges: [Swift.String]?

        public init(
            appComponentName: Swift.String? = nil,
            compliance: [Swift.String:ResiliencehubClientTypes.DisruptionCompliance]? = nil,
            cost: ResiliencehubClientTypes.Cost? = nil,
            description: Swift.String? = nil,
            haArchitecture: ResiliencehubClientTypes.HaArchitecture? = nil,
            name: Swift.String? = nil,
            optimizationType: ResiliencehubClientTypes.ConfigRecommendationOptimizationType? = nil,
            recommendationCompliance: [Swift.String:ResiliencehubClientTypes.RecommendationDisruptionCompliance]? = nil,
            referenceId: Swift.String? = nil,
            suggestedChanges: [Swift.String]? = nil
        )
        {
            self.appComponentName = appComponentName
            self.compliance = compliance
            self.cost = cost
            self.description = description
            self.haArchitecture = haArchitecture
            self.name = name
            self.optimizationType = optimizationType
            self.recommendationCompliance = recommendationCompliance
            self.referenceId = referenceId
            self.suggestedChanges = suggestedChanges
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ConfigRecommendationOptimizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bestAttainable
        case bestAzRecovery
        case bestRegionRecovery
        case leastChange
        case leastCost
        case leastErrors
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRecommendationOptimizationType] {
            return [
                .bestAttainable,
                .bestAzRecovery,
                .bestRegionRecovery,
                .leastChange,
                .leastCost,
                .leastErrors,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bestAttainable: return "BestAttainable"
            case .bestAzRecovery: return "BestAZRecovery"
            case .bestRegionRecovery: return "BestRegionRecovery"
            case .leastChange: return "LeastChange"
            case .leastCost: return "LeastCost"
            case .leastErrors: return "LeastErrors"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigRecommendationOptimizationType(rawValue: rawValue) ?? ConfigRecommendationOptimizationType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that the exception applies to.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that the exception applies to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes.Cost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount
        case currency
        case frequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amount != 0.0 {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let currency = self.currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .amount) ?? 0.0
        amount = amountDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.CostFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a cost object.
    public struct Cost: Swift.Equatable {
        /// The cost amount.
        /// This member is required.
        public var amount: Swift.Double
        /// The cost currency, for example USD.
        /// This member is required.
        public var currency: Swift.String?
        /// The cost frequency.
        /// This member is required.
        public var frequency: ResiliencehubClientTypes.CostFrequency?

        public init(
            amount: Swift.Double = 0.0,
            currency: Swift.String? = nil,
            frequency: ResiliencehubClientTypes.CostFrequency? = nil
        )
        {
            self.amount = amount
            self.currency = currency
            self.frequency = frequency
        }
    }

}

extension ResiliencehubClientTypes {
    public enum CostFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case yearly
        case sdkUnknown(Swift.String)

        public static var allCases: [CostFrequency] {
            return [
                .daily,
                .hourly,
                .monthly,
                .yearly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "Daily"
            case .hourly: return "Hourly"
            case .monthly: return "Monthly"
            case .yearly: return "Yearly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostFrequency(rawValue: rawValue) ?? CostFrequency.sdkUnknown(rawValue)
        }
    }
}

extension CreateAppInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInput(assessmentSchedule: \(Swift.String(describing: assessmentSchedule)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), eventSubscriptions: \(Swift.String(describing: eventSubscriptions)), name: \(Swift.String(describing: name)), permissionModel: \(Swift.String(describing: permissionModel)), policyArn: \(Swift.String(describing: policyArn)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSchedule
        case clientToken
        case description
        case eventSubscriptions
        case name
        case permissionModel
        case policyArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentSchedule = self.assessmentSchedule {
            try encodeContainer.encode(assessmentSchedule.rawValue, forKey: .assessmentSchedule)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscription0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscription0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionModel = self.permissionModel {
            try encodeContainer.encode(permissionModel, forKey: .permissionModel)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-app"
    }
}

public struct CreateAppInput: Swift.Equatable {
    /// Assessment execution schedule with 'Daily' or 'Disabled' values.
    public var assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The list of events you would like to subscribe and get notification for. Currently, Resilience Hub supports only Drift detected and Scheduled assessment failure events notification.
    public var eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]?
    /// Name of the application.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the roles and credentials that Resilience Hub would use while creating the application, importing its resources, and running an assessment.
    public var permissionModel: ResiliencehubClientTypes.PermissionModel?
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var policyArn: Swift.String?
    /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]? = nil,
        name: Swift.String? = nil,
        permissionModel: ResiliencehubClientTypes.PermissionModel? = nil,
        policyArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentSchedule = assessmentSchedule
        self.clientToken = clientToken
        self.description = description
        self.eventSubscriptions = eventSubscriptions
        self.name = name
        self.permissionModel = permissionModel
        self.policyArn = policyArn
        self.tags = tags
    }
}

struct CreateAppInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let policyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
    let assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
    let permissionModel: ResiliencehubClientTypes.PermissionModel?
    let eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSchedule
        case clientToken
        case description
        case eventSubscriptions
        case name
        case permissionModel
        case policyArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let assessmentScheduleDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessmentScheduleType.self, forKey: .assessmentSchedule)
        assessmentSchedule = assessmentScheduleDecoded
        let permissionModelDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PermissionModel.self, forKey: .permissionModel)
        permissionModel = permissionModelDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[ResiliencehubClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [ResiliencehubClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
    }
}

extension CreateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct CreateAppOutput: Swift.Equatable {
    /// The created application returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init(
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct CreateAppOutputBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension CreateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum CreateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppVersionAppComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case clientToken
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateAppVersionAppComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-app-version-app-component"
    }
}

public struct CreateAppVersionAppComponentInput: Swift.Equatable {
    /// Currently, there is no supported additional information for Application Components.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Identifier of the Application Component.
    public var id: Swift.String?
    /// Name of the Application Component.
    /// This member is required.
    public var name: Swift.String?
    /// Type of Application Component. For more information about the types of Application Component, see [Grouping resources in an AppComponent](https://docs.aws.amazon.com/resilience-hub/latest/userguide/AppComponent.grouping.html).
    /// This member is required.
    public var type: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.clientToken = clientToken
        self.id = id
        self.name = name
        self.type = type
    }
}

struct CreateAppVersionAppComponentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let type: Swift.String?
    let additionalInfo: [Swift.String:[Swift.String]]?
    let clientToken: Swift.String?
}

extension CreateAppVersionAppComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case clientToken
        case id
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAppVersionAppComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppVersionAppComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appComponent = output.appComponent
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appComponent = nil
            self.appVersion = nil
        }
    }
}

public struct CreateAppVersionAppComponentOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that belong to this resource.
    public var appComponent: ResiliencehubClientTypes.AppComponent?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appComponent: ResiliencehubClientTypes.AppComponent? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appComponent = appComponent
        self.appVersion = appVersion
    }
}

struct CreateAppVersionAppComponentOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appComponent: ResiliencehubClientTypes.AppComponent?
}

extension CreateAppVersionAppComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appComponent
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appComponentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComponent.self, forKey: .appComponent)
        appComponent = appComponentDecoded
    }
}

enum CreateAppVersionAppComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppVersionResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appComponents
        case awsAccountId
        case awsRegion
        case clientToken
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appComponents = appComponents {
            var appComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponents)
            for string2550 in appComponents {
                try appComponentsContainer.encode(string2550)
            }
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension CreateAppVersionResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-app-version-resource"
    }
}

public struct CreateAppVersionResourceInput: Swift.Equatable {
    /// Currently, there is no supported additional information for resources.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that this resource belongs to. If an Application Component is not part of the Resilience Hub application, it will be added.
    /// This member is required.
    public var appComponents: [Swift.String]?
    /// Amazon Web Services account that owns the physical resource.
    public var awsAccountId: Swift.String?
    /// Amazon Web Services region that owns the physical resource.
    public var awsRegion: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Logical identifier of the resource.
    /// This member is required.
    public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    /// Physical identifier of the resource.
    /// This member is required.
    public var physicalResourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?
    /// Type of resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        appComponents: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
        physicalResourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.appComponents = appComponents
        self.awsAccountId = awsAccountId
        self.awsRegion = awsRegion
        self.clientToken = clientToken
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct CreateAppVersionResourceInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceName: Swift.String?
    let logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    let physicalResourceId: Swift.String?
    let awsRegion: Swift.String?
    let awsAccountId: Swift.String?
    let resourceType: Swift.String?
    let appComponents: [Swift.String]?
    let additionalInfo: [Swift.String:[Swift.String]]?
    let clientToken: Swift.String?
}

extension CreateAppVersionResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appComponents
        case awsAccountId
        case awsRegion
        case clientToken
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appComponents)
        var appComponentsDecoded0:[Swift.String]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [Swift.String]()
            for string0 in appComponentsContainer {
                if let string0 = string0 {
                    appComponentsDecoded0?.append(string0)
                }
            }
        }
        appComponents = appComponentsDecoded0
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAppVersionResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppVersionResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.physicalResource = output.physicalResource
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.physicalResource = nil
        }
    }
}

public struct CreateAppVersionResourceOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public var physicalResource: ResiliencehubClientTypes.PhysicalResource?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        physicalResource: ResiliencehubClientTypes.PhysicalResource? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.physicalResource = physicalResource
    }
}

struct CreateAppVersionResourceOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let physicalResource: ResiliencehubClientTypes.PhysicalResource?
}

extension CreateAppVersionResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case physicalResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let physicalResourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResource.self, forKey: .physicalResource)
        physicalResource = physicalResourceDecoded
    }
}

enum CreateAppVersionResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecommendationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecommendationTemplateInput(assessmentArn: \(Swift.String(describing: assessmentArn)), bucketName: \(Swift.String(describing: bucketName)), clientToken: \(Swift.String(describing: clientToken)), format: \(Swift.String(describing: format)), name: \(Swift.String(describing: name)), recommendationIds: \(Swift.String(describing: recommendationIds)), recommendationTypes: \(Swift.String(describing: recommendationTypes)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateRecommendationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for uuid0 in recommendationIds {
                try recommendationIdsContainer.encode(uuid0)
            }
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtype0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtype0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRecommendationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-recommendation-template"
    }
}

public struct CreateRecommendationTemplateInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The name of the Amazon S3 bucket that will contain the recommendation template.
    public var bucketName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The format for the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
    public var format: ResiliencehubClientTypes.TemplateFormat?
    /// The name for the recommendation template.
    /// This member is required.
    public var name: Swift.String?
    /// Identifiers for the recommendations used to create a recommendation template.
    public var recommendationIds: [Swift.String]?
    /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
    public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assessmentArn: Swift.String? = nil,
        bucketName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        format: ResiliencehubClientTypes.TemplateFormat? = nil,
        name: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.bucketName = bucketName
        self.clientToken = clientToken
        self.format = format
        self.name = name
        self.recommendationIds = recommendationIds
        self.recommendationTypes = recommendationTypes
        self.tags = tags
    }
}

struct CreateRecommendationTemplateInputBody: Swift.Equatable {
    let recommendationIds: [Swift.String]?
    let format: ResiliencehubClientTypes.TemplateFormat?
    let recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
    let assessmentArn: Swift.String?
    let name: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let bucketName: Swift.String?
}

extension CreateRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case bucketName
        case clientToken
        case format
        case name
        case recommendationIds
        case recommendationTypes
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension CreateRecommendationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecommendationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplate = output.recommendationTemplate
        } else {
            self.recommendationTemplate = nil
        }
    }
}

public struct CreateRecommendationTemplateOutput: Swift.Equatable {
    /// The newly created recommendation template, returned as an object. This object includes the template's name, format, status, tags, Amazon S3 bucket location, and more.
    public var recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?

    public init(
        recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate? = nil
    )
    {
        self.recommendationTemplate = recommendationTemplate
    }
}

struct CreateRecommendationTemplateOutputBody: Swift.Equatable {
    let recommendationTemplate: ResiliencehubClientTypes.RecommendationTemplate?
}

extension CreateRecommendationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplate.self, forKey: .recommendationTemplate)
        recommendationTemplate = recommendationTemplateDecoded
    }
}

enum CreateRecommendationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResiliencyPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResiliencyPolicyInput(clientToken: \(Swift.String(describing: clientToken)), dataLocationConstraint: \(Swift.String(describing: dataLocationConstraint)), policy: \(Swift.String(describing: policy)), policyDescription: \(Swift.String(describing: policyDescription)), policyName: \(Swift.String(describing: policyName)), tier: \(Swift.String(describing: tier)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataLocationConstraint = self.dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionPolicy0) in policy {
                try policyContainer.encode(disruptionPolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyDescription = self.policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension CreateResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-resiliency-policy"
    }
}

public struct CreateResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    /// This member is required.
    public var policyName: Swift.String?
    /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    /// This member is required.
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init(
        clientToken: Swift.String? = nil,
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.clientToken = clientToken
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tags = tags
        self.tier = tier
    }
}

struct CreateResiliencyPolicyInputBody: Swift.Equatable {
    let policyName: Swift.String?
    let policyDescription: Swift.String?
    let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataLocationConstraint
        case policy
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResiliencyPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResiliencyPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct CreateResiliencyPolicyOutput: Swift.Equatable {
    /// The type of resiliency policy that was created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init(
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct CreateResiliencyPolicyOutputBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension CreateResiliencyPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum CreateResiliencyPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum DataLocationConstraint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anyLocation
        case sameContinent
        case sameCountry
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLocationConstraint] {
            return [
                .anyLocation,
                .sameContinent,
                .sameCountry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anyLocation: return "AnyLocation"
            case .sameContinent: return "SameContinent"
            case .sameCountry: return "SameCountry"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataLocationConstraint(rawValue: rawValue) ?? DataLocationConstraint.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DeleteAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app-assessment"
    }
}

public struct DeleteAppAssessmentInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.clientToken = clientToken
    }
}

struct DeleteAppAssessmentInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentArn = output.assessmentArn
            self.assessmentStatus = output.assessmentStatus
        } else {
            self.assessmentArn = nil
            self.assessmentStatus = nil
        }
    }
}

public struct DeleteAppAssessmentOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    /// This member is required.
    public var assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?

    public init(
        assessmentArn: Swift.String? = nil,
        assessmentStatus: ResiliencehubClientTypes.AssessmentStatus? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.assessmentStatus = assessmentStatus
    }
}

struct DeleteAppAssessmentOutputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let assessmentStatus: ResiliencehubClientTypes.AssessmentStatus?
}

extension DeleteAppAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case assessmentStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let assessmentStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AssessmentStatus.self, forKey: .assessmentStatus)
        assessmentStatus = assessmentStatusDecoded
    }
}

enum DeleteAppAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let forceDelete = self.forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// A boolean option to force the deletion of an Resilience Hub application.
    public var forceDelete: Swift.Bool?

    public init(
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.clientToken = clientToken
        self.forceDelete = forceDelete
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let forceDelete: Swift.Bool?
    let clientToken: Swift.String?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case forceDelete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppInputSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case eksSourceClusterNamespace
        case sourceArn
        case terraformSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eksSourceClusterNamespace = self.eksSourceClusterNamespace {
            try encodeContainer.encode(eksSourceClusterNamespace, forKey: .eksSourceClusterNamespace)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let terraformSource = self.terraformSource {
            try encodeContainer.encode(terraformSource, forKey: .terraformSource)
        }
    }
}

extension DeleteAppInputSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app-input-source"
    }
}

public struct DeleteAppInputSourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The namespace on your Amazon Elastic Kubernetes Service cluster that you want to delete from the Resilience Hub application.
    public var eksSourceClusterNamespace: ResiliencehubClientTypes.EksSourceClusterNamespace?
    /// The Amazon Resource Name (ARN) of the imported resource you want to remove from the Resilience Hub application. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var sourceArn: Swift.String?
    /// The imported Terraform s3 state le you want to remove from the Resilience Hub application.
    public var terraformSource: ResiliencehubClientTypes.TerraformSource?

    public init(
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        eksSourceClusterNamespace: ResiliencehubClientTypes.EksSourceClusterNamespace? = nil,
        sourceArn: Swift.String? = nil,
        terraformSource: ResiliencehubClientTypes.TerraformSource? = nil
    )
    {
        self.appArn = appArn
        self.clientToken = clientToken
        self.eksSourceClusterNamespace = eksSourceClusterNamespace
        self.sourceArn = sourceArn
        self.terraformSource = terraformSource
    }
}

struct DeleteAppInputSourceInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let sourceArn: Swift.String?
    let terraformSource: ResiliencehubClientTypes.TerraformSource?
    let clientToken: Swift.String?
    let eksSourceClusterNamespace: ResiliencehubClientTypes.EksSourceClusterNamespace?
}

extension DeleteAppInputSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case eksSourceClusterNamespace
        case sourceArn
        case terraformSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let terraformSourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TerraformSource.self, forKey: .terraformSource)
        terraformSource = terraformSourceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let eksSourceClusterNamespaceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EksSourceClusterNamespace.self, forKey: .eksSourceClusterNamespace)
        eksSourceClusterNamespace = eksSourceClusterNamespaceDecoded
    }
}

extension DeleteAppInputSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppInputSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appInputSource = output.appInputSource
        } else {
            self.appArn = nil
            self.appInputSource = nil
        }
    }
}

public struct DeleteAppInputSourceOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var appArn: Swift.String?
    /// Name of the input source from where the application resource is imported from.
    public var appInputSource: ResiliencehubClientTypes.AppInputSource?

    public init(
        appArn: Swift.String? = nil,
        appInputSource: ResiliencehubClientTypes.AppInputSource? = nil
    )
    {
        self.appArn = appArn
        self.appInputSource = appInputSource
    }
}

struct DeleteAppInputSourceOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appInputSource: ResiliencehubClientTypes.AppInputSource?
}

extension DeleteAppInputSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appInputSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appInputSourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppInputSource.self, forKey: .appInputSource)
        appInputSource = appInputSourceDecoded
    }
}

enum DeleteAppInputSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
        } else {
            self.appArn = nil
        }
    }
}

public struct DeleteAppOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?

    public init(
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DeleteAppOutputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DeleteAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

enum DeleteAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppVersionAppComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteAppVersionAppComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app-version-app-component"
    }
}

public struct DeleteAppVersionAppComponentInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Identifier of the Application Component.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteAppVersionAppComponentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let id: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAppVersionAppComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case clientToken
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppVersionAppComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppVersionAppComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appComponent = output.appComponent
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appComponent = nil
            self.appVersion = nil
        }
    }
}

public struct DeleteAppVersionAppComponentOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that belong to this resource.
    public var appComponent: ResiliencehubClientTypes.AppComponent?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appComponent: ResiliencehubClientTypes.AppComponent? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appComponent = appComponent
        self.appVersion = appVersion
    }
}

struct DeleteAppVersionAppComponentOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appComponent: ResiliencehubClientTypes.AppComponent?
}

extension DeleteAppVersionAppComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appComponent
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appComponentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComponent.self, forKey: .appComponent)
        appComponent = appComponentDecoded
    }
}

enum DeleteAppVersionAppComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppVersionResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case awsAccountId
        case awsRegion
        case clientToken
        case logicalResourceId
        case physicalResourceId
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DeleteAppVersionResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-app-version-resource"
    }
}

public struct DeleteAppVersionResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Amazon Web Services account that owns the physical resource.
    public var awsAccountId: Swift.String?
    /// Amazon Web Services region that owns the physical resource.
    public var awsRegion: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Logical identifier of the resource.
    public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    /// Physical identifier of the resource.
    public var physicalResourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
        physicalResourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.awsAccountId = awsAccountId
        self.awsRegion = awsRegion
        self.clientToken = clientToken
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.resourceName = resourceName
    }
}

struct DeleteAppVersionResourceInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceName: Swift.String?
    let logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    let physicalResourceId: Swift.String?
    let awsRegion: Swift.String?
    let awsAccountId: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteAppVersionResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case awsAccountId
        case awsRegion
        case clientToken
        case logicalResourceId
        case physicalResourceId
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteAppVersionResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAppVersionResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.physicalResource = output.physicalResource
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.physicalResource = nil
        }
    }
}

public struct DeleteAppVersionResourceOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public var physicalResource: ResiliencehubClientTypes.PhysicalResource?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        physicalResource: ResiliencehubClientTypes.PhysicalResource? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.physicalResource = physicalResource
    }
}

struct DeleteAppVersionResourceOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let physicalResource: ResiliencehubClientTypes.PhysicalResource?
}

extension DeleteAppVersionResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case physicalResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let physicalResourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResource.self, forKey: .physicalResource)
        physicalResource = physicalResourceDecoded
    }
}

enum DeleteAppVersionResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecommendationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let recommendationTemplateArn = self.recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
    }
}

extension DeleteRecommendationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-recommendation-template"
    }
}

public struct DeleteRecommendationTemplateInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.recommendationTemplateArn = recommendationTemplateArn
    }
}

struct DeleteRecommendationTemplateInputBody: Swift.Equatable {
    let recommendationTemplateArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteRecommendationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case recommendationTemplateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteRecommendationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRecommendationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommendationTemplateArn = output.recommendationTemplateArn
            self.status = output.status
        } else {
            self.recommendationTemplateArn = nil
            self.status = nil
        }
    }
}

public struct DeleteRecommendationTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a recommendation template.
    /// This member is required.
    public var recommendationTemplateArn: Swift.String?
    /// Status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?

    public init(
        recommendationTemplateArn: Swift.String? = nil,
        status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil
    )
    {
        self.recommendationTemplateArn = recommendationTemplateArn
        self.status = status
    }
}

struct DeleteRecommendationTemplateOutputBody: Swift.Equatable {
    let recommendationTemplateArn: Swift.String?
    let status: ResiliencehubClientTypes.RecommendationTemplateStatus?
}

extension DeleteRecommendationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationTemplateArn
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteRecommendationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension DeleteResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-resiliency-policy"
    }
}

public struct DeleteResiliencyPolicyInput: Swift.Equatable {
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let clientToken: Swift.String?
}

extension DeleteResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case policyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResiliencyPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResiliencyPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyArn = output.policyArn
        } else {
            self.policyArn = nil
        }
    }
}

public struct DeleteResiliencyPolicyOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DeleteResiliencyPolicyOutputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DeleteResiliencyPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

enum DeleteResiliencyPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
    }
}

extension DescribeAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-assessment"
    }
}

public struct DescribeAppAssessmentInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
    }
}

struct DescribeAppAssessmentInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
}

extension DescribeAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension DescribeAppAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct DescribeAppAssessmentOutput: Swift.Equatable {
    /// The assessment for an Resilience Hub application, returned as an object. This object includes Amazon Resource Names (ARNs), compliance information, compliance status, cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init(
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct DescribeAppAssessmentOutputBody: Swift.Equatable {
    let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension DescribeAppAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

enum DescribeAppAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension DescribeAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app"
    }
}

public struct DescribeAppInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?

    public init(
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DescribeAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct DescribeAppOutput: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init(
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct DescribeAppOutputBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension DescribeAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum DescribeAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppVersionAppComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DescribeAppVersionAppComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-app-component"
    }
}

public struct DescribeAppVersionAppComponentInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Identifier of the Application Component.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.id = id
    }
}

struct DescribeAppVersionAppComponentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let id: Swift.String?
}

extension DescribeAppVersionAppComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeAppVersionAppComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppVersionAppComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appComponent = output.appComponent
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appComponent = nil
            self.appVersion = nil
        }
    }
}

public struct DescribeAppVersionAppComponentOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that belong to this resource.
    public var appComponent: ResiliencehubClientTypes.AppComponent?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appComponent: ResiliencehubClientTypes.AppComponent? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appComponent = appComponent
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionAppComponentOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appComponent: ResiliencehubClientTypes.AppComponent?
}

extension DescribeAppVersionAppComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appComponent
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appComponentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComponent.self, forKey: .appComponent)
        appComponent = appComponentDecoded
    }
}

enum DescribeAppVersionAppComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

extension DescribeAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version"
    }
}

public struct DescribeAppVersionInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension DescribeAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension DescribeAppVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalInfo = output.additionalInfo
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.additionalInfo = nil
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct DescribeAppVersionOutput: Swift.Equatable {
    /// Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter supports only failover region and account.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let additionalInfo: [Swift.String:[Swift.String]]?
}

extension DescribeAppVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

enum DescribeAppVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppVersionResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case awsAccountId
        case awsRegion
        case logicalResourceId
        case physicalResourceId
        case resourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension DescribeAppVersionResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-resource"
    }
}

public struct DescribeAppVersionResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Amazon Web Services account that owns the physical resource.
    public var awsAccountId: Swift.String?
    /// Amazon Web Services region that owns the physical resource.
    public var awsRegion: Swift.String?
    /// Logical identifier of the resource.
    public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    /// Physical identifier of the resource.
    public var physicalResourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
        physicalResourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.awsAccountId = awsAccountId
        self.awsRegion = awsRegion
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.resourceName = resourceName
    }
}

struct DescribeAppVersionResourceInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resourceName: Swift.String?
    let logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    let physicalResourceId: Swift.String?
    let awsRegion: Swift.String?
    let awsAccountId: Swift.String?
}

extension DescribeAppVersionResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case awsAccountId
        case awsRegion
        case logicalResourceId
        case physicalResourceId
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension DescribeAppVersionResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppVersionResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.physicalResource = output.physicalResource
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.physicalResource = nil
        }
    }
}

public struct DescribeAppVersionResourceOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public var physicalResource: ResiliencehubClientTypes.PhysicalResource?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        physicalResource: ResiliencehubClientTypes.PhysicalResource? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.physicalResource = physicalResource
    }
}

struct DescribeAppVersionResourceOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let physicalResource: ResiliencehubClientTypes.PhysicalResource?
}

extension DescribeAppVersionResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case physicalResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let physicalResourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResource.self, forKey: .physicalResource)
        physicalResource = physicalResourceDecoded
    }
}

enum DescribeAppVersionResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppVersionResourcesResolutionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let resolutionId = self.resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension DescribeAppVersionResourcesResolutionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-resources-resolution-status"
    }
}

public struct DescribeAppVersionResourcesResolutionStatusInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
    }
}

struct DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
    }
}

extension DescribeAppVersionResourcesResolutionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppVersionResourcesResolutionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct DescribeAppVersionResourcesResolutionStatusOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// Status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct DescribeAppVersionResourcesResolutionStatusOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
    let errorMessage: Swift.String?
}

extension DescribeAppVersionResourcesResolutionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case resolutionId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum DescribeAppVersionResourcesResolutionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppVersionTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

extension DescribeAppVersionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-app-version-template"
    }
}

public struct DescribeAppVersionTemplateInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension DescribeAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension DescribeAppVersionTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppVersionTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appTemplateBody = output.appTemplateBody
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appTemplateBody = nil
            self.appVersion = nil
        }
    }
}

public struct DescribeAppVersionTemplateOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// A JSON string that provides information about your application structure. To learn more about the appTemplateBody template, see the sample template provided in the Examples section. The appTemplateBody JSON string has the following structure:
    ///
    /// * resources The list of logical resources that must be included in the Resilience Hub application. Type: Array Don't add the resources that you want to exclude. Each resources array item includes the following fields:
    ///
    /// * logicalResourceId Logical identifier of the resource. Type: Object Each logicalResourceId object includes the following fields:
    ///
    /// * identifier Identifier of the resource. Type: String
    ///
    /// * logicalStackName The name of the CloudFormation stack this resource belongs to. Type: String
    ///
    /// * resourceGroupName The name of the resource group this resource belongs to. Type: String
    ///
    /// * terraformSourceName The name of the Terraform S3 state file this resource belongs to. Type: String
    ///
    /// * eksSourceName Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format. Type: String
    ///
    ///
    ///
    ///
    /// * type The type of resource. Type: string
    ///
    /// * name The name of the resource. Type: String
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    ///
    ///
    ///
    ///
    /// * appComponents List of Application Components that this resource belongs to. If an Application Component is not part of the Resilience Hub application, it will be added. Type: Array Each appComponents array item includes the following fields:
    ///
    /// * name Name of the Application Component. Type: String
    ///
    /// * type Type of Application Component. For more information about the types of Application Component, see [Grouping resources in an AppComponent](https://docs.aws.amazon.com/resilience-hub/latest/userguide/AppComponent.grouping.html). Type: String
    ///
    /// * resourceNames The list of included resources that are assigned to the Application Component. Type: Array of strings
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    ///
    ///
    ///
    ///
    /// * excludedResources The list of logical resource identifiers to be excluded from the application. Type: Array Don't add the resources that you want to include. Each excludedResources array item includes the following fields:
    ///
    /// * logicalResourceIds Logical identifier of the resource. Type: Object You can configure only one of the following fields:
    ///
    /// * logicalStackName
    ///
    /// * resourceGroupName
    ///
    /// * terraformSourceName
    ///
    /// * eksSourceName
    ///
    ///
    /// Each logicalResourceIds object includes the following fields:
    ///
    /// * identifier Identifier of the resource. Type: String
    ///
    /// * logicalStackName The name of the CloudFormation stack this resource belongs to. Type: String
    ///
    /// * resourceGroupName The name of the resource group this resource belongs to. Type: String
    ///
    /// * terraformSourceName The name of the Terraform S3 state file this resource belongs to. Type: String
    ///
    /// * eksSourceName Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format. Type: String
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * version Resilience Hub application version.
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    /// This member is required.
    public var appTemplateBody: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
        self.appVersion = appVersion
    }
}

struct DescribeAppVersionTemplateOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appTemplateBody: Swift.String?
}

extension DescribeAppVersionTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

enum DescribeAppVersionTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDraftAppVersionResourcesImportStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension DescribeDraftAppVersionResourcesImportStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-draft-app-version-resources-import-status"
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?

    public init(
        appArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
    }
}

struct DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Equatable {
    let appArn: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
    }
}

extension DescribeDraftAppVersionResourcesImportStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDraftAppVersionResourcesImportStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.errorMessage = output.errorMessage
            self.status = output.status
            self.statusChangeTime = output.statusChangeTime
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.errorMessage = nil
            self.status = nil
            self.statusChangeTime = nil
        }
    }
}

public struct DescribeDraftAppVersionResourcesImportStatusOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The returned error message for the request.
    public var errorMessage: Swift.String?
    /// Status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?
    /// The timestamp for when the status last changed.
    /// This member is required.
    public var statusChangeTime: ClientRuntime.Date?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil,
        statusChangeTime: ClientRuntime.Date? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.errorMessage = errorMessage
        self.status = status
        self.statusChangeTime = statusChangeTime
    }
}

struct DescribeDraftAppVersionResourcesImportStatusOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let status: ResiliencehubClientTypes.ResourceImportStatusType?
    let statusChangeTime: ClientRuntime.Date?
    let errorMessage: Swift.String?
}

extension DescribeDraftAppVersionResourcesImportStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case errorMessage
        case status
        case statusChangeTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
        let statusChangeTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .statusChangeTime)
        statusChangeTime = statusChangeTimeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum DescribeDraftAppVersionResourcesImportStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension DescribeResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-resiliency-policy"
    }
}

public struct DescribeResiliencyPolicyInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    )
    {
        self.policyArn = policyArn
    }
}

struct DescribeResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
}

extension DescribeResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension DescribeResiliencyPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeResiliencyPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DescribeResiliencyPolicyOutput: Swift.Equatable {
    /// Information about the specific resiliency policy, returned as an object. This object includes creation time, data location constraints, its name, description, tags, the recovery time objective (RTO) and recovery point objective (RPO) in seconds, and more.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init(
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DescribeResiliencyPolicyOutputBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension DescribeResiliencyPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DescribeResiliencyPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum DifferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferenceType] {
            return [
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DifferenceType(rawValue: rawValue) ?? DifferenceType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.DisruptionCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case achievableRpoInSecs
        case achievableRtoInSecs
        case complianceStatus
        case currentRpoInSecs
        case currentRtoInSecs
        case message
        case rpoDescription
        case rpoReferenceId
        case rtoDescription
        case rtoReferenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if achievableRpoInSecs != 0 {
            try encodeContainer.encode(achievableRpoInSecs, forKey: .achievableRpoInSecs)
        }
        if achievableRtoInSecs != 0 {
            try encodeContainer.encode(achievableRtoInSecs, forKey: .achievableRtoInSecs)
        }
        if let complianceStatus = self.complianceStatus {
            try encodeContainer.encode(complianceStatus.rawValue, forKey: .complianceStatus)
        }
        if currentRpoInSecs != 0 {
            try encodeContainer.encode(currentRpoInSecs, forKey: .currentRpoInSecs)
        }
        if currentRtoInSecs != 0 {
            try encodeContainer.encode(currentRtoInSecs, forKey: .currentRtoInSecs)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let rpoDescription = self.rpoDescription {
            try encodeContainer.encode(rpoDescription, forKey: .rpoDescription)
        }
        if let rpoReferenceId = self.rpoReferenceId {
            try encodeContainer.encode(rpoReferenceId, forKey: .rpoReferenceId)
        }
        if let rtoDescription = self.rtoDescription {
            try encodeContainer.encode(rtoDescription, forKey: .rtoDescription)
        }
        if let rtoReferenceId = self.rtoReferenceId {
            try encodeContainer.encode(rtoReferenceId, forKey: .rtoReferenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let achievableRtoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .achievableRtoInSecs) ?? 0
        achievableRtoInSecs = achievableRtoInSecsDecoded
        let currentRtoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentRtoInSecs) ?? 0
        currentRtoInSecs = currentRtoInSecsDecoded
        let rtoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoReferenceId)
        rtoReferenceId = rtoReferenceIdDecoded
        let rtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rtoDescription)
        rtoDescription = rtoDescriptionDecoded
        let currentRpoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentRpoInSecs) ?? 0
        currentRpoInSecs = currentRpoInSecsDecoded
        let rpoReferenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoReferenceId)
        rpoReferenceId = rpoReferenceIdDecoded
        let rpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rpoDescription)
        rpoDescription = rpoDescriptionDecoded
        let complianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .complianceStatus)
        complianceStatus = complianceStatusDecoded
        let achievableRpoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .achievableRpoInSecs) ?? 0
        achievableRpoInSecs = achievableRpoInSecsDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the compliance against the resiliency policy for a disruption.
    public struct DisruptionCompliance: Swift.Equatable {
        /// The Recovery Point Objective (RPO) that is achievable, in seconds.
        public var achievableRpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO) that is achievable, in seconds
        public var achievableRtoInSecs: Swift.Int
        /// The current status of compliance for the resiliency policy.
        /// This member is required.
        public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The current RPO, in seconds.
        public var currentRpoInSecs: Swift.Int
        /// The current RTO, in seconds.
        public var currentRtoInSecs: Swift.Int
        /// The disruption compliance message.
        public var message: Swift.String?
        /// The RPO description.
        public var rpoDescription: Swift.String?
        /// Reference identifier of the RPO .
        public var rpoReferenceId: Swift.String?
        /// The RTO description.
        public var rtoDescription: Swift.String?
        /// Reference identifier of the RTO.
        public var rtoReferenceId: Swift.String?

        public init(
            achievableRpoInSecs: Swift.Int = 0,
            achievableRtoInSecs: Swift.Int = 0,
            complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            currentRpoInSecs: Swift.Int = 0,
            currentRtoInSecs: Swift.Int = 0,
            message: Swift.String? = nil,
            rpoDescription: Swift.String? = nil,
            rpoReferenceId: Swift.String? = nil,
            rtoDescription: Swift.String? = nil,
            rtoReferenceId: Swift.String? = nil
        )
        {
            self.achievableRpoInSecs = achievableRpoInSecs
            self.achievableRtoInSecs = achievableRtoInSecs
            self.complianceStatus = complianceStatus
            self.currentRpoInSecs = currentRpoInSecs
            self.currentRtoInSecs = currentRtoInSecs
            self.message = message
            self.rpoDescription = rpoDescription
            self.rpoReferenceId = rpoReferenceId
            self.rtoDescription = rtoDescription
            self.rtoReferenceId = rtoReferenceId
        }
    }

}

extension ResiliencehubClientTypes {
    public enum DisruptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [DisruptionType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DisruptionType(rawValue: rawValue) ?? DisruptionType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum DriftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detected
        case notChecked
        case notDetected
        case sdkUnknown(Swift.String)

        public static var allCases: [DriftStatus] {
            return [
                .detected,
                .notChecked,
                .notDetected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detected: return "Detected"
            case .notChecked: return "NotChecked"
            case .notDetected: return "NotDetected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DriftStatus(rawValue: rawValue) ?? DriftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum DriftType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationCompliance
        case sdkUnknown(Swift.String)

        public static var allCases: [DriftType] {
            return [
                .applicationCompliance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationCompliance: return "ApplicationCompliance"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DriftType(rawValue: rawValue) ?? DriftType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.EksSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksClusterArn
        case namespaces
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksClusterArn = self.eksClusterArn {
            try encodeContainer.encode(eksClusterArn, forKey: .eksClusterArn)
        }
        if let namespaces = namespaces {
            var namespacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namespaces)
            for eksnamespace0 in namespaces {
                try namespacesContainer.encode(eksnamespace0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eksClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksClusterArn)
        eksClusterArn = eksClusterArnDecoded
        let namespacesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .namespaces)
        var namespacesDecoded0:[Swift.String]? = nil
        if let namespacesContainer = namespacesContainer {
            namespacesDecoded0 = [Swift.String]()
            for string0 in namespacesContainer {
                if let string0 = string0 {
                    namespacesDecoded0?.append(string0)
                }
            }
        }
        namespaces = namespacesDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// The input source of the Amazon Elastic Kubernetes Service cluster.
    public struct EksSource: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Elastic Kubernetes Service cluster. The format for this ARN is: arn:aws:eks:region:account-id:cluster/cluster-name. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var eksClusterArn: Swift.String?
        /// The list of namespaces located on your Amazon Elastic Kubernetes Service cluster.
        /// This member is required.
        public var namespaces: [Swift.String]?

        public init(
            eksClusterArn: Swift.String? = nil,
            namespaces: [Swift.String]? = nil
        )
        {
            self.eksClusterArn = eksClusterArn
            self.namespaces = namespaces
        }
    }

}

extension ResiliencehubClientTypes.EksSourceClusterNamespace: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksClusterArn
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksClusterArn = self.eksClusterArn {
            try encodeContainer.encode(eksClusterArn, forKey: .eksClusterArn)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eksClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksClusterArn)
        eksClusterArn = eksClusterArnDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The input source of the namespace that is located on your Amazon Elastic Kubernetes Service cluster.
    public struct EksSourceClusterNamespace: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon Elastic Kubernetes Service cluster. The format for this ARN is: arn:aws:eks:region:account-id:cluster/cluster-name. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var eksClusterArn: Swift.String?
        /// Name of the namespace that is located on your Amazon Elastic Kubernetes Service cluster.
        /// This member is required.
        public var namespace: Swift.String?

        public init(
            eksClusterArn: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.eksClusterArn = eksClusterArn
            self.namespace = namespace
        }
    }

}

extension ResiliencehubClientTypes {
    public enum EstimatedCostTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case l1
        case l2
        case l3
        case l4
        case sdkUnknown(Swift.String)

        public static var allCases: [EstimatedCostTier] {
            return [
                .l1,
                .l2,
                .l3,
                .l4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .l1: return "L1"
            case .l2: return "L2"
            case .l3: return "L3"
            case .l4: return "L4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EstimatedCostTier(rawValue: rawValue) ?? EstimatedCostTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.EventSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case name
        case snsTopicArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Indicates an event you would like to subscribe and get notification for. Currently, Resilience Hub supports notifications only for Drift detected and Scheduled assessment failure events.
    public struct EventSubscription: Swift.Equatable {
        /// The type of event you would like to subscribe and get notification for. Currently, Resilience Hub supports notifications only for Drift detected (DriftDetected) and Scheduled assessment failure (ScheduledAssessmentFailure) events.
        /// This member is required.
        public var eventType: ResiliencehubClientTypes.EventType?
        /// Unique name to identify an event subscription.
        /// This member is required.
        public var name: Swift.String?
        /// Amazon Resource Name (ARN) of the Amazon Simple Notification Service topic. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var snsTopicArn: Swift.String?

        public init(
            eventType: ResiliencehubClientTypes.EventType? = nil,
            name: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.name = name
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension ResiliencehubClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case driftDetected
        case scheduledAssessmentFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .driftDetected,
                .scheduledAssessmentFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .driftDetected: return "DriftDetected"
            case .scheduledAssessmentFailure: return "ScheduledAssessmentFailure"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum ExcludeRecommendationReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyImplemented
        case complexityOfImplementation
        case notRelevant
        case sdkUnknown(Swift.String)

        public static var allCases: [ExcludeRecommendationReason] {
            return [
                .alreadyImplemented,
                .complexityOfImplementation,
                .notRelevant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyImplemented: return "AlreadyImplemented"
            case .complexityOfImplementation: return "ComplexityOfImplementation"
            case .notRelevant: return "NotRelevant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExcludeRecommendationReason(rawValue: rawValue) ?? ExcludeRecommendationReason.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.FailurePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rpoInSecs
        case rtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if rpoInSecs != 0 {
            try encodeContainer.encode(rpoInSecs, forKey: .rpoInSecs)
        }
        if rtoInSecs != 0 {
            try encodeContainer.encode(rtoInSecs, forKey: .rtoInSecs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rtoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rtoInSecs) ?? 0
        rtoInSecs = rtoInSecsDecoded
        let rpoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rpoInSecs) ?? 0
        rpoInSecs = rpoInSecsDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a failure policy.
    public struct FailurePolicy: Swift.Equatable {
        /// The Recovery Point Objective (RPO), in seconds.
        /// This member is required.
        public var rpoInSecs: Swift.Int
        /// The Recovery Time Objective (RTO), in seconds.
        /// This member is required.
        public var rtoInSecs: Swift.Int

        public init(
            rpoInSecs: Swift.Int = 0,
            rtoInSecs: Swift.Int = 0
        )
        {
            self.rpoInSecs = rpoInSecs
            self.rtoInSecs = rtoInSecs
        }
    }

}

extension ResiliencehubClientTypes {
    public enum HaArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupAndRestore
        case multiSite
        case noRecoveryPlan
        case pilotLight
        case warmStandby
        case sdkUnknown(Swift.String)

        public static var allCases: [HaArchitecture] {
            return [
                .backupAndRestore,
                .multiSite,
                .noRecoveryPlan,
                .pilotLight,
                .warmStandby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupAndRestore: return "BackupAndRestore"
            case .multiSite: return "MultiSite"
            case .noRecoveryPlan: return "NoRecoveryPlan"
            case .pilotLight: return "PilotLight"
            case .warmStandby: return "WarmStandby"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HaArchitecture(rawValue: rawValue) ?? HaArchitecture.sdkUnknown(rawValue)
        }
    }
}

extension ImportResourcesToDraftAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case eksSources
        case importStrategy
        case sourceArns
        case terraformSources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let eksSources = eksSources {
            var eksSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eksSources)
            for ekssource0 in eksSources {
                try eksSourcesContainer.encode(ekssource0)
            }
        }
        if let importStrategy = self.importStrategy {
            try encodeContainer.encode(importStrategy.rawValue, forKey: .importStrategy)
        }
        if let sourceArns = sourceArns {
            var sourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceArns)
            for arn0 in sourceArns {
                try sourceArnsContainer.encode(arn0)
            }
        }
        if let terraformSources = terraformSources {
            var terraformSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terraformSources)
            for terraformsource0 in terraformSources {
                try terraformSourcesContainer.encode(terraformsource0)
            }
        }
    }
}

extension ImportResourcesToDraftAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import-resources-to-draft-app-version"
    }
}

public struct ImportResourcesToDraftAppVersionInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The input sources of the Amazon Elastic Kubernetes Service resources you need to import.
    public var eksSources: [ResiliencehubClientTypes.EksSource]?
    /// The import strategy you would like to set to import resources into Resilience Hub application.
    public var importStrategy: ResiliencehubClientTypes.ResourceImportStrategyType?
    /// The Amazon Resource Names (ARNs) for the resources.
    public var sourceArns: [Swift.String]?
    /// A list of terraform file s3 URLs you need to import.
    public var terraformSources: [ResiliencehubClientTypes.TerraformSource]?

    public init(
        appArn: Swift.String? = nil,
        eksSources: [ResiliencehubClientTypes.EksSource]? = nil,
        importStrategy: ResiliencehubClientTypes.ResourceImportStrategyType? = nil,
        sourceArns: [Swift.String]? = nil,
        terraformSources: [ResiliencehubClientTypes.TerraformSource]? = nil
    )
    {
        self.appArn = appArn
        self.eksSources = eksSources
        self.importStrategy = importStrategy
        self.sourceArns = sourceArns
        self.terraformSources = terraformSources
    }
}

struct ImportResourcesToDraftAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let sourceArns: [Swift.String]?
    let terraformSources: [ResiliencehubClientTypes.TerraformSource]?
    let importStrategy: ResiliencehubClientTypes.ResourceImportStrategyType?
    let eksSources: [ResiliencehubClientTypes.EksSource]?
}

extension ImportResourcesToDraftAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case eksSources
        case importStrategy
        case sourceArns
        case terraformSources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
        let terraformSourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.TerraformSource?].self, forKey: .terraformSources)
        var terraformSourcesDecoded0:[ResiliencehubClientTypes.TerraformSource]? = nil
        if let terraformSourcesContainer = terraformSourcesContainer {
            terraformSourcesDecoded0 = [ResiliencehubClientTypes.TerraformSource]()
            for structure0 in terraformSourcesContainer {
                if let structure0 = structure0 {
                    terraformSourcesDecoded0?.append(structure0)
                }
            }
        }
        terraformSources = terraformSourcesDecoded0
        let importStrategyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStrategyType.self, forKey: .importStrategy)
        importStrategy = importStrategyDecoded
        let eksSourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.EksSource?].self, forKey: .eksSources)
        var eksSourcesDecoded0:[ResiliencehubClientTypes.EksSource]? = nil
        if let eksSourcesContainer = eksSourcesContainer {
            eksSourcesDecoded0 = [ResiliencehubClientTypes.EksSource]()
            for structure0 in eksSourcesContainer {
                if let structure0 = structure0 {
                    eksSourcesDecoded0?.append(structure0)
                }
            }
        }
        eksSources = eksSourcesDecoded0
    }
}

extension ImportResourcesToDraftAppVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportResourcesToDraftAppVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.eksSources = output.eksSources
            self.sourceArns = output.sourceArns
            self.status = output.status
            self.terraformSources = output.terraformSources
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.eksSources = nil
            self.sourceArns = nil
            self.status = nil
            self.terraformSources = nil
        }
    }
}

public struct ImportResourcesToDraftAppVersionOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The input sources of the Amazon Elastic Kubernetes Service resources you have imported.
    public var eksSources: [ResiliencehubClientTypes.EksSource]?
    /// The Amazon Resource Names (ARNs) for the resources you have imported.
    public var sourceArns: [Swift.String]?
    /// Status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceImportStatusType?
    /// A list of terraform file s3 URLs you have imported.
    public var terraformSources: [ResiliencehubClientTypes.TerraformSource]?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        eksSources: [ResiliencehubClientTypes.EksSource]? = nil,
        sourceArns: [Swift.String]? = nil,
        status: ResiliencehubClientTypes.ResourceImportStatusType? = nil,
        terraformSources: [ResiliencehubClientTypes.TerraformSource]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.eksSources = eksSources
        self.sourceArns = sourceArns
        self.status = status
        self.terraformSources = terraformSources
    }
}

struct ImportResourcesToDraftAppVersionOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let sourceArns: [Swift.String]?
    let status: ResiliencehubClientTypes.ResourceImportStatusType?
    let terraformSources: [ResiliencehubClientTypes.TerraformSource]?
    let eksSources: [ResiliencehubClientTypes.EksSource]?
}

extension ImportResourcesToDraftAppVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case eksSources
        case sourceArns
        case status
        case terraformSources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let sourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceArns)
        var sourceArnsDecoded0:[Swift.String]? = nil
        if let sourceArnsContainer = sourceArnsContainer {
            sourceArnsDecoded0 = [Swift.String]()
            for string0 in sourceArnsContainer {
                if let string0 = string0 {
                    sourceArnsDecoded0?.append(string0)
                }
            }
        }
        sourceArns = sourceArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceImportStatusType.self, forKey: .status)
        status = statusDecoded
        let terraformSourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.TerraformSource?].self, forKey: .terraformSources)
        var terraformSourcesDecoded0:[ResiliencehubClientTypes.TerraformSource]? = nil
        if let terraformSourcesContainer = terraformSourcesContainer {
            terraformSourcesDecoded0 = [ResiliencehubClientTypes.TerraformSource]()
            for structure0 in terraformSourcesContainer {
                if let structure0 = structure0 {
                    terraformSourcesDecoded0?.append(structure0)
                }
            }
        }
        terraformSources = terraformSourcesDecoded0
        let eksSourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.EksSource?].self, forKey: .eksSources)
        var eksSourcesDecoded0:[ResiliencehubClientTypes.EksSource]? = nil
        if let eksSourcesContainer = eksSourcesContainer {
            eksSourcesDecoded0 = [ResiliencehubClientTypes.EksSource]()
            for structure0 in eksSourcesContainer {
                if let structure0 = structure0 {
                    eksSourcesDecoded0?.append(structure0)
                }
            }
        }
        eksSources = eksSourcesDecoded0
    }
}

enum ImportResourcesToDraftAppVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when there is an internal failure in the Resilience Hub service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAlarmRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-alarm-recommendations"
    }
}

public struct ListAlarmRecommendationsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAlarmRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAlarmRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAlarmRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.alarmRecommendations = output.alarmRecommendations
            self.nextToken = output.nextToken
        } else {
            self.alarmRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmRecommendationsOutput: Swift.Equatable {
    /// The alarm recommendations for an Resilience Hub application, returned as an object. This object includes Application Component names, descriptions, information about whether a recommendation has already been implemented or not, prerequisites, and more.
    /// This member is required.
    public var alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmRecommendations = alarmRecommendations
        self.nextToken = nextToken
    }
}

struct ListAlarmRecommendationsOutputBody: Swift.Equatable {
    let alarmRecommendations: [ResiliencehubClientTypes.AlarmRecommendation]?
    let nextToken: Swift.String?
}

extension ListAlarmRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRecommendations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AlarmRecommendation?].self, forKey: .alarmRecommendations)
        var alarmRecommendationsDecoded0:[ResiliencehubClientTypes.AlarmRecommendation]? = nil
        if let alarmRecommendationsContainer = alarmRecommendationsContainer {
            alarmRecommendationsDecoded0 = [ResiliencehubClientTypes.AlarmRecommendation]()
            for structure0 in alarmRecommendationsContainer {
                if let structure0 = structure0 {
                    alarmRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        alarmRecommendations = alarmRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAlarmRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppAssessmentComplianceDriftsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppAssessmentComplianceDriftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-assessment-compliance-drifts"
    }
}

public struct ListAppAssessmentComplianceDriftsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Indicates the maximum number of applications requested.
    public var maxResults: Swift.Int?
    /// Indicates the unique token number of the next application to be checked for compliance and regulatory requirements from the list of applications.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppAssessmentComplianceDriftsInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppAssessmentComplianceDriftsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppAssessmentComplianceDriftsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppAssessmentComplianceDriftsOutputBody = try responseDecoder.decode(responseBody: data)
            self.complianceDrifts = output.complianceDrifts
            self.nextToken = output.nextToken
        } else {
            self.complianceDrifts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppAssessmentComplianceDriftsOutput: Swift.Equatable {
    /// Indicates compliance drifts (recovery time objective (RTO) and recovery point objective (RPO)) detected for an assessed entity.
    /// This member is required.
    public var complianceDrifts: [ResiliencehubClientTypes.ComplianceDrift]?
    /// Token number of the next application to be checked for compliance and regulatory requirements from the list of applications.
    public var nextToken: Swift.String?

    public init(
        complianceDrifts: [ResiliencehubClientTypes.ComplianceDrift]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceDrifts = complianceDrifts
        self.nextToken = nextToken
    }
}

struct ListAppAssessmentComplianceDriftsOutputBody: Swift.Equatable {
    let complianceDrifts: [ResiliencehubClientTypes.ComplianceDrift]?
    let nextToken: Swift.String?
}

extension ListAppAssessmentComplianceDriftsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceDrifts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceDriftsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ComplianceDrift?].self, forKey: .complianceDrifts)
        var complianceDriftsDecoded0:[ResiliencehubClientTypes.ComplianceDrift]? = nil
        if let complianceDriftsContainer = complianceDriftsContainer {
            complianceDriftsDecoded0 = [ResiliencehubClientTypes.ComplianceDrift]()
            for structure0 in complianceDriftsContainer {
                if let structure0 = structure0 {
                    complianceDriftsDecoded0?.append(structure0)
                }
            }
        }
        complianceDrifts = complianceDriftsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppAssessmentComplianceDriftsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppAssessmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let reverseOrder = reverseOrder {
                let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
                items.append(reverseOrderQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let assessmentName = assessmentName {
                let assessmentNameQueryItem = ClientRuntime.URLQueryItem(name: "assessmentName".urlPercentEncoding(), value: Swift.String(assessmentName).urlPercentEncoding())
                items.append(assessmentNameQueryItem)
            }
            if let appArn = appArn {
                let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
                items.append(appArnQueryItem)
            }
            if let complianceStatus = complianceStatus {
                let complianceStatusQueryItem = ClientRuntime.URLQueryItem(name: "complianceStatus".urlPercentEncoding(), value: Swift.String(complianceStatus.rawValue).urlPercentEncoding())
                items.append(complianceStatusQueryItem)
            }
            if let assessmentStatus = assessmentStatus {
                assessmentStatus.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "assessmentStatus".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let invoker = invoker {
                let invokerQueryItem = ClientRuntime.URLQueryItem(name: "invoker".urlPercentEncoding(), value: Swift.String(invoker.rawValue).urlPercentEncoding())
                items.append(invokerQueryItem)
            }
            return items
        }
    }
}

extension ListAppAssessmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-assessments"
    }
}

public struct ListAppAssessmentsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var appArn: Swift.String?
    /// The name for the assessment.
    public var assessmentName: Swift.String?
    /// The current status of the assessment for the resiliency policy.
    public var assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]?
    /// The current status of compliance for the resiliency policy.
    public var complianceStatus: ResiliencehubClientTypes.ComplianceStatus?
    /// Specifies the entity that invoked a specific assessment, either a User or the System.
    public var invoker: ResiliencehubClientTypes.AssessmentInvoker?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?

    public init(
        appArn: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        assessmentStatus: [ResiliencehubClientTypes.AssessmentStatus]? = nil,
        complianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
        invoker: ResiliencehubClientTypes.AssessmentInvoker? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil
    )
    {
        self.appArn = appArn
        self.assessmentName = assessmentName
        self.assessmentStatus = assessmentStatus
        self.complianceStatus = complianceStatus
        self.invoker = invoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

struct ListAppAssessmentsInputBody: Swift.Equatable {
}

extension ListAppAssessmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppAssessmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppAssessmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentSummaries = output.assessmentSummaries
            self.nextToken = output.nextToken
        } else {
            self.assessmentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppAssessmentsOutput: Swift.Equatable {
    /// The summaries for the specified assessments, returned as an object. This object includes application versions, associated Amazon Resource Numbers (ARNs), cost, messages, resiliency scores, and more.
    /// This member is required.
    public var assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentSummaries = assessmentSummaries
        self.nextToken = nextToken
    }
}

struct ListAppAssessmentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let assessmentSummaries: [ResiliencehubClientTypes.AppAssessmentSummary]?
}

extension ListAppAssessmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assessmentSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppAssessmentSummary?].self, forKey: .assessmentSummaries)
        var assessmentSummariesDecoded0:[ResiliencehubClientTypes.AppAssessmentSummary]? = nil
        if let assessmentSummariesContainer = assessmentSummariesContainer {
            assessmentSummariesDecoded0 = [ResiliencehubClientTypes.AppAssessmentSummary]()
            for structure0 in assessmentSummariesContainer {
                if let structure0 = structure0 {
                    assessmentSummariesDecoded0?.append(structure0)
                }
            }
        }
        assessmentSummaries = assessmentSummariesDecoded0
    }
}

enum ListAppAssessmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppComponentCompliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppComponentCompliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-component-compliances"
    }
}

public struct ListAppComponentCompliancesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListAppComponentCompliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListAppComponentCompliancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppComponentCompliancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentCompliances = output.componentCompliances
            self.nextToken = output.nextToken
        } else {
            self.componentCompliances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentCompliancesOutput: Swift.Equatable {
    /// The compliances for an Resilience Hub Application Component, returned as an object. This object contains the names of the Application Components, compliances, costs, resiliency scores, outage scores, and more.
    /// This member is required.
    public var componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentCompliances = componentCompliances
        self.nextToken = nextToken
    }
}

struct ListAppComponentCompliancesOutputBody: Swift.Equatable {
    let componentCompliances: [ResiliencehubClientTypes.AppComponentCompliance]?
    let nextToken: Swift.String?
}

extension ListAppComponentCompliancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentCompliances
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentCompliancesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponentCompliance?].self, forKey: .componentCompliances)
        var componentCompliancesDecoded0:[ResiliencehubClientTypes.AppComponentCompliance]? = nil
        if let componentCompliancesContainer = componentCompliancesContainer {
            componentCompliancesDecoded0 = [ResiliencehubClientTypes.AppComponentCompliance]()
            for structure0 in componentCompliancesContainer {
                if let structure0 = structure0 {
                    componentCompliancesDecoded0?.append(structure0)
                }
            }
        }
        componentCompliances = componentCompliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppComponentCompliancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppComponentRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppComponentRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-component-recommendations"
    }
}

public struct ListAppComponentRecommendationsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsInputBody: Swift.Equatable {
    let assessmentArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppComponentRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppComponentRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppComponentRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.componentRecommendations = output.componentRecommendations
            self.nextToken = output.nextToken
        } else {
            self.componentRecommendations = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppComponentRecommendationsOutput: Swift.Equatable {
    /// The recommendations for an Resilience Hub Application Component, returned as an object. This object contains the names of the Application Components, configuration recommendations, and recommendation statuses.
    /// This member is required.
    public var componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentRecommendations = componentRecommendations
        self.nextToken = nextToken
    }
}

struct ListAppComponentRecommendationsOutputBody: Swift.Equatable {
    let componentRecommendations: [ResiliencehubClientTypes.ComponentRecommendation]?
    let nextToken: Swift.String?
}

extension ListAppComponentRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentRecommendations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ComponentRecommendation?].self, forKey: .componentRecommendations)
        var componentRecommendationsDecoded0:[ResiliencehubClientTypes.ComponentRecommendation]? = nil
        if let componentRecommendationsContainer = componentRecommendationsContainer {
            componentRecommendationsDecoded0 = [ResiliencehubClientTypes.ComponentRecommendation]()
            for structure0 in componentRecommendationsContainer {
                if let structure0 = structure0 {
                    componentRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        componentRecommendations = componentRecommendationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppComponentRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInputSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppInputSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-input-sources"
    }
}

public struct ListAppInputSourcesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Maximum number of input sources to be displayed per Resilience Hub application.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInputSourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppInputSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppInputSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInputSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInputSources = output.appInputSources
            self.nextToken = output.nextToken
        } else {
            self.appInputSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInputSourcesOutput: Swift.Equatable {
    /// The list of Resilience Hub application input sources.
    /// This member is required.
    public var appInputSources: [ResiliencehubClientTypes.AppInputSource]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        appInputSources: [ResiliencehubClientTypes.AppInputSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInputSources = appInputSources
        self.nextToken = nextToken
    }
}

struct ListAppInputSourcesOutputBody: Swift.Equatable {
    let appInputSources: [ResiliencehubClientTypes.AppInputSource]?
    let nextToken: Swift.String?
}

extension ListAppInputSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInputSources
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInputSourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppInputSource?].self, forKey: .appInputSources)
        var appInputSourcesDecoded0:[ResiliencehubClientTypes.AppInputSource]? = nil
        if let appInputSourcesContainer = appInputSourcesContainer {
            appInputSourcesDecoded0 = [ResiliencehubClientTypes.AppInputSource]()
            for structure0 in appInputSourcesContainer {
                if let structure0 = structure0 {
                    appInputSourcesDecoded0?.append(structure0)
                }
            }
        }
        appInputSources = appInputSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInputSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppVersionAppComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppVersionAppComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-version-app-components"
    }
}

public struct ListAppVersionAppComponentsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Version of the Application Component.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Maximum number of Application Components to be displayed per Resilience Hub application version.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionAppComponentsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionAppComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionAppComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppVersionAppComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appComponents = output.appComponents
            self.appVersion = output.appVersion
            self.nextToken = output.nextToken
        } else {
            self.appArn = nil
            self.appComponents = nil
            self.appVersion = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppVersionAppComponentsOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Defines an Application Component.
    public var appComponents: [ResiliencehubClientTypes.AppComponent]?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appComponents: [ResiliencehubClientTypes.AppComponent]? = nil,
        appVersion: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appComponents = appComponents
        self.appVersion = appVersion
        self.nextToken = nextToken
    }
}

struct ListAppVersionAppComponentsOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appComponents: [ResiliencehubClientTypes.AppComponent]?
    let nextToken: Swift.String?
}

extension ListAppVersionAppComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appComponents
        case appVersion
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponent?].self, forKey: .appComponents)
        var appComponentsDecoded0:[ResiliencehubClientTypes.AppComponent]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [ResiliencehubClientTypes.AppComponent]()
            for structure0 in appComponentsContainer {
                if let structure0 = structure0 {
                    appComponentsDecoded0?.append(structure0)
                }
            }
        }
        appComponents = appComponentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppVersionAppComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-version-resource-mappings"
    }
}

public struct ListAppVersionResourceMappingsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourceMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppVersionResourceMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceMappings = output.resourceMappings
        } else {
            self.nextToken = nil
            self.resourceMappings = nil
        }
    }
}

public struct ListAppVersionResourceMappingsOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Mappings used to map logical resources from the template to physical resources. You can use the mapping type CFN_STACK if the application template uses a logical stack name. Or you can map individual resources by using the mapping type RESOURCE. We recommend using the mapping type CFN_STACK if the application is backed by a CloudFormation stack.
    /// This member is required.
    public var resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?

    public init(
        nextToken: Swift.String? = nil,
        resourceMappings: [ResiliencehubClientTypes.ResourceMapping]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceMappings = resourceMappings
    }
}

struct ListAppVersionResourceMappingsOutputBody: Swift.Equatable {
    let resourceMappings: [ResiliencehubClientTypes.ResourceMapping]?
    let nextToken: Swift.String?
}

extension ListAppVersionResourceMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceMappings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceMappingsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceMapping?].self, forKey: .resourceMappings)
        var resourceMappingsDecoded0:[ResiliencehubClientTypes.ResourceMapping]? = nil
        if let resourceMappingsContainer = resourceMappingsContainer {
            resourceMappingsDecoded0 = [ResiliencehubClientTypes.ResourceMapping]()
            for structure0 in resourceMappingsContainer {
                if let structure0 = structure0 {
                    resourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        resourceMappings = resourceMappingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = self.resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension ListAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-version-resources"
    }
}

public struct ListAppVersionResourcesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppVersionResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppVersionResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.physicalResources = output.physicalResources
            self.resolutionId = output.resolutionId
        } else {
            self.nextToken = nil
            self.physicalResources = nil
            self.resolutionId = nil
        }
    }
}

public struct ListAppVersionResourcesOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The physical resources in the application version.
    /// This member is required.
    public var physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    /// The ID for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        physicalResources: [ResiliencehubClientTypes.PhysicalResource]? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.physicalResources = physicalResources
        self.resolutionId = resolutionId
    }
}

struct ListAppVersionResourcesOutputBody: Swift.Equatable {
    let physicalResources: [ResiliencehubClientTypes.PhysicalResource]?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
}

extension ListAppVersionResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case physicalResources
        case resolutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let physicalResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.PhysicalResource?].self, forKey: .physicalResources)
        var physicalResourcesDecoded0:[ResiliencehubClientTypes.PhysicalResource]? = nil
        if let physicalResourcesContainer = physicalResourcesContainer {
            physicalResourcesDecoded0 = [ResiliencehubClientTypes.PhysicalResource]()
            for structure0 in physicalResourcesContainer {
                if let structure0 = structure0 {
                    physicalResourcesDecoded0?.append(structure0)
                }
            }
        }
        physicalResources = physicalResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppVersionResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case endTime
        case maxResults
        case nextToken
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListAppVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-app-versions"
    }
}

public struct ListAppVersionsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Upper limit of the time range to filter the application versions.
    public var endTime: ClientRuntime.Date?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// Lower limit of the time range to filter the application versions.
    public var startTime: ClientRuntime.Date?

    public init(
        appArn: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.appArn = appArn
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListAppVersionsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension ListAppVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case endTime
        case maxResults
        case nextToken
        case startTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension ListAppVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appVersions = output.appVersions
            self.nextToken = output.nextToken
        } else {
            self.appVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppVersionsOutput: Swift.Equatable {
    /// The version of the application.
    /// This member is required.
    public var appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        appVersions: [ResiliencehubClientTypes.AppVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appVersions = appVersions
        self.nextToken = nextToken
    }
}

struct ListAppVersionsOutputBody: Swift.Equatable {
    let appVersions: [ResiliencehubClientTypes.AppVersionSummary]?
    let nextToken: Swift.String?
}

extension ListAppVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appVersions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppVersionSummary?].self, forKey: .appVersions)
        var appVersionsDecoded0:[ResiliencehubClientTypes.AppVersionSummary]? = nil
        if let appVersionsContainer = appVersionsContainer {
            appVersionsDecoded0 = [ResiliencehubClientTypes.AppVersionSummary]()
            for structure0 in appVersionsContainer {
                if let structure0 = structure0 {
                    appVersionsDecoded0?.append(structure0)
                }
            }
        }
        appVersions = appVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let appArn = appArn {
                let appArnQueryItem = ClientRuntime.URLQueryItem(name: "appArn".urlPercentEncoding(), value: Swift.String(appArn).urlPercentEncoding())
                items.append(appArnQueryItem)
            }
            return items
        }
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-apps"
    }
}

public struct ListAppsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var appArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for the one of the listed applications.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Swift.Equatable {
}

extension ListAppsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appSummaries = output.appSummaries
            self.nextToken = output.nextToken
        } else {
            self.appSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutput: Swift.Equatable {
    /// Summaries for the Resilience Hub application.
    /// This member is required.
    public var appSummaries: [ResiliencehubClientTypes.AppSummary]?
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        appSummaries: [ResiliencehubClientTypes.AppSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appSummaries = appSummaries
        self.nextToken = nextToken
    }
}

struct ListAppsOutputBody: Swift.Equatable {
    let appSummaries: [ResiliencehubClientTypes.AppSummary]?
    let nextToken: Swift.String?
}

extension ListAppsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummariesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppSummary?].self, forKey: .appSummaries)
        var appSummariesDecoded0:[ResiliencehubClientTypes.AppSummary]? = nil
        if let appSummariesContainer = appSummariesContainer {
            appSummariesDecoded0 = [ResiliencehubClientTypes.AppSummary]()
            for structure0 in appSummariesContainer {
                if let structure0 = structure0 {
                    appSummariesDecoded0?.append(structure0)
                }
            }
        }
        appSummaries = appSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let reverseOrder = reverseOrder {
                let reverseOrderQueryItem = ClientRuntime.URLQueryItem(name: "reverseOrder".urlPercentEncoding(), value: Swift.String(reverseOrder).urlPercentEncoding())
                items.append(reverseOrderQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            guard let assessmentArn = assessmentArn else {
                let message = "Creating a URL Query Item failed. assessmentArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assessmentArnQueryItem = ClientRuntime.URLQueryItem(name: "assessmentArn".urlPercentEncoding(), value: Swift.String(assessmentArn).urlPercentEncoding())
            items.append(assessmentArnQueryItem)
            if let recommendationTemplateArn = recommendationTemplateArn {
                let recommendationTemplateArnQueryItem = ClientRuntime.URLQueryItem(name: "recommendationTemplateArn".urlPercentEncoding(), value: Swift.String(recommendationTemplateArn).urlPercentEncoding())
                items.append(recommendationTemplateArnQueryItem)
            }
            if let status = status {
                status.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListRecommendationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-recommendation-templates"
    }
}

public struct ListRecommendationTemplatesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// The name for one of the listed recommendation templates.
    public var name: Swift.String?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for a recommendation template.
    public var recommendationTemplateArn: Swift.String?
    /// The default is to sort by ascending startTime. To sort by descending startTime, set reverseOrder to true.
    public var reverseOrder: Swift.Bool?
    /// Status of the action.
    public var status: [ResiliencehubClientTypes.RecommendationTemplateStatus]?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        recommendationTemplateArn: Swift.String? = nil,
        reverseOrder: Swift.Bool? = nil,
        status: [ResiliencehubClientTypes.RecommendationTemplateStatus]? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.recommendationTemplateArn = recommendationTemplateArn
        self.reverseOrder = reverseOrder
        self.status = status
    }
}

struct ListRecommendationTemplatesInputBody: Swift.Equatable {
}

extension ListRecommendationTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationTemplates = output.recommendationTemplates
        } else {
            self.nextToken = nil
            self.recommendationTemplates = nil
        }
    }
}

public struct ListRecommendationTemplatesOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The recommendation templates for the Resilience Hub applications.
    public var recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationTemplates = recommendationTemplates
    }
}

struct ListRecommendationTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recommendationTemplates: [ResiliencehubClientTypes.RecommendationTemplate]?
}

extension ListRecommendationTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommendationTemplates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationTemplatesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationTemplate?].self, forKey: .recommendationTemplates)
        var recommendationTemplatesDecoded0:[ResiliencehubClientTypes.RecommendationTemplate]? = nil
        if let recommendationTemplatesContainer = recommendationTemplatesContainer {
            recommendationTemplatesDecoded0 = [ResiliencehubClientTypes.RecommendationTemplate]()
            for structure0 in recommendationTemplatesContainer {
                if let structure0 = structure0 {
                    recommendationTemplatesDecoded0?.append(structure0)
                }
            }
        }
        recommendationTemplates = recommendationTemplatesDecoded0
    }
}

enum ListRecommendationTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResiliencyPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let policyName = policyName {
                let policyNameQueryItem = ClientRuntime.URLQueryItem(name: "policyName".urlPercentEncoding(), value: Swift.String(policyName).urlPercentEncoding())
                items.append(policyNameQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResiliencyPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-resiliency-policies"
    }
}

public struct ListResiliencyPoliciesInput: Swift.Equatable {
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyName = policyName
    }
}

struct ListResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListResiliencyPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResiliencyPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResiliencyPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListResiliencyPoliciesOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListResiliencyPoliciesOutputBody: Swift.Equatable {
    let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    let nextToken: Swift.String?
}

extension ListResiliencyPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResiliencyPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSopRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSopRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-sop-recommendations"
    }
}

public struct ListSopRecommendationsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSopRecommendationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListSopRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListSopRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSopRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sopRecommendations = output.sopRecommendations
        } else {
            self.nextToken = nil
            self.sopRecommendations = nil
        }
    }
}

public struct ListSopRecommendationsOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The standard operating procedure (SOP) recommendations for the Resilience Hub applications.
    /// This member is required.
    public var sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?

    public init(
        nextToken: Swift.String? = nil,
        sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.sopRecommendations = sopRecommendations
    }
}

struct ListSopRecommendationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sopRecommendations: [ResiliencehubClientTypes.SopRecommendation]?
}

extension ListSopRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sopRecommendations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sopRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.SopRecommendation?].self, forKey: .sopRecommendations)
        var sopRecommendationsDecoded0:[ResiliencehubClientTypes.SopRecommendation]? = nil
        if let sopRecommendationsContainer = sopRecommendationsContainer {
            sopRecommendationsDecoded0 = [ResiliencehubClientTypes.SopRecommendation]()
            for structure0 in sopRecommendationsContainer {
                if let structure0 = structure0 {
                    sopRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        sopRecommendations = sopRecommendationsDecoded0
    }
}

enum ListSopRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSuggestedResiliencyPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSuggestedResiliencyPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-suggested-resiliency-policies"
    }
}

public struct ListSuggestedResiliencyPoliciesInput: Swift.Equatable {
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuggestedResiliencyPoliciesInputBody: Swift.Equatable {
}

extension ListSuggestedResiliencyPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSuggestedResiliencyPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSuggestedResiliencyPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resiliencyPolicies = output.resiliencyPolicies
        } else {
            self.nextToken = nil
            self.resiliencyPolicies = nil
        }
    }
}

public struct ListSuggestedResiliencyPoliciesOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The suggested resiliency policies for the Resilience Hub applications.
    /// This member is required.
    public var resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resiliencyPolicies = resiliencyPolicies
    }
}

struct ListSuggestedResiliencyPoliciesOutputBody: Swift.Equatable {
    let resiliencyPolicies: [ResiliencehubClientTypes.ResiliencyPolicy]?
    let nextToken: Swift.String?
}

extension ListSuggestedResiliencyPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resiliencyPolicies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resiliencyPoliciesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResiliencyPolicy?].self, forKey: .resiliencyPolicies)
        var resiliencyPoliciesDecoded0:[ResiliencehubClientTypes.ResiliencyPolicy]? = nil
        if let resiliencyPoliciesContainer = resiliencyPoliciesContainer {
            resiliencyPoliciesDecoded0 = [ResiliencehubClientTypes.ResiliencyPolicy]()
            for structure0 in resiliencyPoliciesContainer {
                if let structure0 = structure0 {
                    resiliencyPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resiliencyPolicies = resiliencyPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSuggestedResiliencyPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for a specific resource in your Resilience Hub application.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTestRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTestRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-test-recommendations"
    }
}

public struct ListTestRecommendationsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var assessmentArn: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        assessmentArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assessmentArn = assessmentArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTestRecommendationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let assessmentArn: Swift.String?
}

extension ListTestRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
    }
}

extension ListTestRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTestRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.testRecommendations = output.testRecommendations
        } else {
            self.nextToken = nil
            self.testRecommendations = nil
        }
    }
}

public struct ListTestRecommendationsOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The test recommendations for the Resilience Hub application.
    /// This member is required.
    public var testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?

    public init(
        nextToken: Swift.String? = nil,
        testRecommendations: [ResiliencehubClientTypes.TestRecommendation]? = nil
    )
    {
        self.nextToken = nextToken
        self.testRecommendations = testRecommendations
    }
}

struct ListTestRecommendationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let testRecommendations: [ResiliencehubClientTypes.TestRecommendation]?
}

extension ListTestRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case testRecommendations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let testRecommendationsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.TestRecommendation?].self, forKey: .testRecommendations)
        var testRecommendationsDecoded0:[ResiliencehubClientTypes.TestRecommendation]? = nil
        if let testRecommendationsContainer = testRecommendationsContainer {
            testRecommendationsDecoded0 = [ResiliencehubClientTypes.TestRecommendation]()
            for structure0 in testRecommendationsContainer {
                if let structure0 = structure0 {
                    testRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        testRecommendations = testRecommendationsDecoded0
    }
}

enum ListTestRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUnsupportedAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resolutionId = self.resolutionId {
            try encodeContainer.encode(resolutionId, forKey: .resolutionId)
        }
    }
}

extension ListUnsupportedAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-unsupported-app-version-resources"
    }
}

public struct ListUnsupportedAppVersionResourcesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// Null, or the token from a previous call to get the next set of results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    public var resolutionId: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resolutionId = resolutionId
    }
}

struct ListUnsupportedAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListUnsupportedAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case maxResults
        case nextToken
        case resolutionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUnsupportedAppVersionResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUnsupportedAppVersionResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resolutionId = output.resolutionId
            self.unsupportedResources = output.unsupportedResources
        } else {
            self.nextToken = nil
            self.resolutionId = nil
            self.unsupportedResources = nil
        }
    }
}

public struct ListUnsupportedAppVersionResourcesOutput: Swift.Equatable {
    /// Token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// The unsupported resources for the application.
    /// This member is required.
    public var unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?

    public init(
        nextToken: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolutionId = resolutionId
        self.unsupportedResources = unsupportedResources
    }
}

struct ListUnsupportedAppVersionResourcesOutputBody: Swift.Equatable {
    let unsupportedResources: [ResiliencehubClientTypes.UnsupportedResource]?
    let resolutionId: Swift.String?
    let nextToken: Swift.String?
}

extension ListUnsupportedAppVersionResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resolutionId
        case unsupportedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unsupportedResourcesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.UnsupportedResource?].self, forKey: .unsupportedResources)
        var unsupportedResourcesDecoded0:[ResiliencehubClientTypes.UnsupportedResource]? = nil
        if let unsupportedResourcesContainer = unsupportedResourcesContainer {
            unsupportedResourcesDecoded0 = [ResiliencehubClientTypes.UnsupportedResource]()
            for structure0 in unsupportedResourcesContainer {
                if let structure0 = structure0 {
                    unsupportedResourcesDecoded0?.append(structure0)
                }
            }
        }
        unsupportedResources = unsupportedResourcesDecoded0
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUnsupportedAppVersionResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes.LogicalResourceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksSourceName
        case identifier
        case logicalStackName
        case resourceGroupName
        case terraformSourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksSourceName = self.eksSourceName {
            try encodeContainer.encode(eksSourceName, forKey: .eksSourceName)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let logicalStackName = self.logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let terraformSourceName = self.terraformSourceName {
            try encodeContainer.encode(terraformSourceName, forKey: .terraformSourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let terraformSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terraformSourceName)
        terraformSourceName = terraformSourceNameDecoded
        let eksSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksSourceName)
        eksSourceName = eksSourceNameDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a logical resource identifier.
    public struct LogicalResourceId: Swift.Equatable {
        /// Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format.
        public var eksSourceName: Swift.String?
        /// Identifier of the resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// The name of the CloudFormation stack this resource belongs to.
        public var logicalStackName: Swift.String?
        /// The name of the resource group that this resource belongs to.
        public var resourceGroupName: Swift.String?
        /// The name of the Terraform S3 state file this resource belongs to.
        public var terraformSourceName: Swift.String?

        public init(
            eksSourceName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            resourceGroupName: Swift.String? = nil,
            terraformSourceName: Swift.String? = nil
        )
        {
            self.eksSourceName = eksSourceName
            self.identifier = identifier
            self.logicalStackName = logicalStackName
            self.resourceGroupName = resourceGroupName
            self.terraformSourceName = terraformSourceName
        }
    }

}

extension ResiliencehubClientTypes.PermissionModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountRoleArns
        case invokerRoleName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccountRoleArns = crossAccountRoleArns {
            var crossAccountRoleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .crossAccountRoleArns)
            for iamrolearn0 in crossAccountRoleArns {
                try crossAccountRoleArnsContainer.encode(iamrolearn0)
            }
        }
        if let invokerRoleName = self.invokerRoleName {
            try encodeContainer.encode(invokerRoleName, forKey: .invokerRoleName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PermissionModelType.self, forKey: .type)
        type = typeDecoded
        let invokerRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokerRoleName)
        invokerRoleName = invokerRoleNameDecoded
        let crossAccountRoleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .crossAccountRoleArns)
        var crossAccountRoleArnsDecoded0:[Swift.String]? = nil
        if let crossAccountRoleArnsContainer = crossAccountRoleArnsContainer {
            crossAccountRoleArnsDecoded0 = [Swift.String]()
            for string0 in crossAccountRoleArnsContainer {
                if let string0 = string0 {
                    crossAccountRoleArnsDecoded0?.append(string0)
                }
            }
        }
        crossAccountRoleArns = crossAccountRoleArnsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines the roles and credentials that Resilience Hub would use while creating the application, importing its resources, and running an assessment.
    public struct PermissionModel: Swift.Equatable {
        /// Defines a list of role Amazon Resource Names (ARNs) to be used in other accounts. These ARNs are used for querying purposes while importing resources and assessing your application.
        ///
        /// * These ARNs are required only when your resources are in other accounts and you have different role name in these accounts. Else, the invoker role name will be used in the other accounts.
        ///
        /// * These roles must have a trust policy with iam:AssumeRole permission to the invoker role in the primary account.
        public var crossAccountRoleArns: [Swift.String]?
        /// Existing Amazon Web Services IAM role name in the primary Amazon Web Services account that will be assumed by Resilience Hub Service Principle to obtain a read-only access to your application resources while running an assessment. You must have iam:passRole permission for this role while creating or updating the application.
        public var invokerRoleName: Swift.String?
        /// Defines how Resilience Hub scans your resources. It can scan for the resources by using a pre-existing role in your Amazon Web Services account, or by using the credentials of the current IAM user.
        /// This member is required.
        public var type: ResiliencehubClientTypes.PermissionModelType?

        public init(
            crossAccountRoleArns: [Swift.String]? = nil,
            invokerRoleName: Swift.String? = nil,
            type: ResiliencehubClientTypes.PermissionModelType? = nil
        )
        {
            self.crossAccountRoleArns = crossAccountRoleArns
            self.invokerRoleName = invokerRoleName
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum PermissionModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case legacyIamUser
        case roleBased
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionModelType] {
            return [
                .legacyIamUser,
                .roleBased,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .legacyIamUser: return "LegacyIAMUser"
            case .roleBased: return "RoleBased"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionModelType(rawValue: rawValue) ?? PermissionModelType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum PhysicalIdentifierType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arn
        case native
        case sdkUnknown(Swift.String)

        public static var allCases: [PhysicalIdentifierType] {
            return [
                .arn,
                .native,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arn: return "Arn"
            case .native: return "Native"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhysicalIdentifierType(rawValue: rawValue) ?? PhysicalIdentifierType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.PhysicalResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appComponents
        case excluded
        case logicalResourceId
        case parentResourceName
        case physicalResourceId
        case resourceName
        case resourceType
        case sourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appComponents = appComponents {
            var appComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponents)
            for appcomponent0 in appComponents {
                try appComponentsContainer.encode(appcomponent0)
            }
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let parentResourceName = self.parentResourceName {
            try encodeContainer.encode(parentResourceName, forKey: .parentResourceName)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.AppComponent?].self, forKey: .appComponents)
        var appComponentsDecoded0:[ResiliencehubClientTypes.AppComponent]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [ResiliencehubClientTypes.AppComponent]()
            for structure0 in appComponentsContainer {
                if let structure0 = structure0 {
                    appComponentsDecoded0?.append(structure0)
                }
            }
        }
        appComponents = appComponentsDecoded0
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let parentResourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentResourceName)
        parentResourceName = parentResourceNameDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or an Resilience Hub-native identifier.
    public struct PhysicalResource: Swift.Equatable {
        /// Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
        public var additionalInfo: [Swift.String:[Swift.String]]?
        /// The application components that belong to this resource.
        public var appComponents: [ResiliencehubClientTypes.AppComponent]?
        /// Indicates if a resource is included or excluded from the assessment.
        public var excluded: Swift.Bool?
        /// Logical identifier of the resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// Name of the parent resource.
        public var parentResourceName: Swift.String?
        /// Identifier of the physical resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The name of the resource.
        public var resourceName: Swift.String?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Type of input source.
        public var sourceType: ResiliencehubClientTypes.ResourceSourceType?

        public init(
            additionalInfo: [Swift.String:[Swift.String]]? = nil,
            appComponents: [ResiliencehubClientTypes.AppComponent]? = nil,
            excluded: Swift.Bool? = nil,
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            parentResourceName: Swift.String? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceType: ResiliencehubClientTypes.ResourceSourceType? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.appComponents = appComponents
            self.excluded = excluded
            self.logicalResourceId = logicalResourceId
            self.parentResourceName = parentResourceName
            self.physicalResourceId = physicalResourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceType = sourceType
        }
    }

}

extension ResiliencehubClientTypes.PhysicalResourceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case awsRegion
        case identifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalIdentifierType.self, forKey: .type)
        type = typeDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a physical resource identifier.
    public struct PhysicalResourceId: Swift.Equatable {
        /// The Amazon Web Services account that owns the physical resource.
        public var awsAccountId: Swift.String?
        /// The Amazon Web Services Region that the physical resource is located in.
        public var awsRegion: Swift.String?
        /// Identifier of the physical resource.
        /// This member is required.
        public var identifier: Swift.String?
        /// Specifies the type of physical resource identifier. Arn The resource identifier is an Amazon Resource Name (ARN) and it can identify the following list of resources:
        ///
        /// * AWS::ECS::Service
        ///
        /// * AWS::EFS::FileSystem
        ///
        /// * AWS::ElasticLoadBalancingV2::LoadBalancer
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::SNS::Topic
        ///
        ///
        /// Native The resource identifier is an Resilience Hub-native identifier and it can identify the following list of resources:
        ///
        /// * AWS::ApiGateway::RestApi
        ///
        /// * AWS::ApiGatewayV2::Api
        ///
        /// * AWS::AutoScaling::AutoScalingGroup
        ///
        /// * AWS::DocDB::DBCluster
        ///
        /// * AWS::DocDB::DBGlobalCluster
        ///
        /// * AWS::DocDB::DBInstance
        ///
        /// * AWS::DynamoDB::GlobalTable
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::EC2::EC2Fleet
        ///
        /// * AWS::EC2::Instance
        ///
        /// * AWS::EC2::NatGateway
        ///
        /// * AWS::EC2::Volume
        ///
        /// * AWS::ElasticLoadBalancing::LoadBalancer
        ///
        /// * AWS::RDS::DBCluster
        ///
        /// * AWS::RDS::DBInstance
        ///
        /// * AWS::RDS::GlobalCluster
        ///
        /// * AWS::Route53::RecordSet
        ///
        /// * AWS::S3::Bucket
        ///
        /// * AWS::SQS::Queue
        /// This member is required.
        public var type: ResiliencehubClientTypes.PhysicalIdentifierType?

        public init(
            awsAccountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            identifier: Swift.String? = nil,
            type: ResiliencehubClientTypes.PhysicalIdentifierType? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsRegion = awsRegion
            self.identifier = identifier
            self.type = type
        }
    }

}

extension PublishAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case versionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let versionName = self.versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }
}

extension PublishAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/publish-app-version"
    }
}

public struct PublishAppVersionInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Name of the application version.
    public var versionName: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.versionName = versionName
    }
}

struct PublishAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let versionName: Swift.String?
}

extension PublishAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

extension PublishAppVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishAppVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.identifier = output.identifier
            self.versionName = output.versionName
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.identifier = nil
            self.versionName = nil
        }
    }
}

public struct PublishAppVersionOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?
    /// Identifier of the application version.
    public var identifier: Swift.Int?
    /// Name of the application version.
    public var versionName: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        identifier: Swift.Int? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.identifier = identifier
        self.versionName = versionName
    }
}

struct PublishAppVersionOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let identifier: Swift.Int?
    let versionName: Swift.String?
}

extension PublishAppVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case identifier
        case versionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .identifier)
        identifier = identifierDecoded
        let versionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionName)
        versionName = versionNameDecoded
    }
}

enum PublishAppVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutDraftAppVersionTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appTemplateBody = self.appTemplateBody {
            try encodeContainer.encode(appTemplateBody, forKey: .appTemplateBody)
        }
    }
}

extension PutDraftAppVersionTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-draft-app-version-template"
    }
}

public struct PutDraftAppVersionTemplateInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// A JSON string that provides information about your application structure. To learn more about the appTemplateBody template, see the sample template provided in the Examples section. The appTemplateBody JSON string has the following structure:
    ///
    /// * resources The list of logical resources that must be included in the Resilience Hub application. Type: Array Don't add the resources that you want to exclude. Each resources array item includes the following fields:
    ///
    /// * logicalResourceId Logical identifier of the resource. Type: Object Each logicalResourceId object includes the following fields:
    ///
    /// * identifier Identifier of the resource. Type: String
    ///
    /// * logicalStackName The name of the CloudFormation stack this resource belongs to. Type: String
    ///
    /// * resourceGroupName The name of the resource group this resource belongs to. Type: String
    ///
    /// * terraformSourceName The name of the Terraform S3 state file this resource belongs to. Type: String
    ///
    /// * eksSourceName Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format. Type: String
    ///
    ///
    ///
    ///
    /// * type The type of resource. Type: string
    ///
    /// * name The name of the resource. Type: String
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    ///
    ///
    ///
    ///
    /// * appComponents List of Application Components that this resource belongs to. If an Application Component is not part of the Resilience Hub application, it will be added. Type: Array Each appComponents array item includes the following fields:
    ///
    /// * name Name of the Application Component. Type: String
    ///
    /// * type Type of Application Component. For more information about the types of Application Component, see [Grouping resources in an AppComponent](https://docs.aws.amazon.com/resilience-hub/latest/userguide/AppComponent.grouping.html). Type: String
    ///
    /// * resourceNames The list of included resources that are assigned to the Application Component. Type: Array of strings
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    ///
    ///
    ///
    ///
    /// * excludedResources The list of logical resource identifiers to be excluded from the application. Type: Array Don't add the resources that you want to include. Each excludedResources array item includes the following fields:
    ///
    /// * logicalResourceIds Logical identifier of the resource. Type: Object You can configure only one of the following fields:
    ///
    /// * logicalStackName
    ///
    /// * resourceGroupName
    ///
    /// * terraformSourceName
    ///
    /// * eksSourceName
    ///
    ///
    /// Each logicalResourceIds object includes the following fields:
    ///
    /// * identifier Identifier of the resource. Type: String
    ///
    /// * logicalStackName The name of the CloudFormation stack this resource belongs to. Type: String
    ///
    /// * resourceGroupName The name of the resource group this resource belongs to. Type: String
    ///
    /// * terraformSourceName The name of the Terraform S3 state file this resource belongs to. Type: String
    ///
    /// * eksSourceName Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format. Type: String
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * version Resilience Hub application version.
    ///
    /// * additionalInfo Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    /// This member is required.
    public var appTemplateBody: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appTemplateBody: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appTemplateBody = appTemplateBody
    }
}

struct PutDraftAppVersionTemplateInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appTemplateBody: Swift.String?
}

extension PutDraftAppVersionTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appTemplateBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appTemplateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appTemplateBody)
        appTemplateBody = appTemplateBodyDecoded
    }
}

extension PutDraftAppVersionTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutDraftAppVersionTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct PutDraftAppVersionTemplateOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct PutDraftAppVersionTemplateOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension PutDraftAppVersionTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

enum PutDraftAppVersionTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum RecommendationComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case breachedCanMeet
        case breachedUnattainable
        case metCanImprove
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationComplianceStatus] {
            return [
                .breachedCanMeet,
                .breachedUnattainable,
                .metCanImprove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .breachedCanMeet: return "BreachedCanMeet"
            case .breachedUnattainable: return "BreachedUnattainable"
            case .metCanImprove: return "MetCanImprove"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationComplianceStatus(rawValue: rawValue) ?? RecommendationComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.RecommendationDisruptionCompliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedComplianceStatus
        case expectedRpoDescription
        case expectedRpoInSecs
        case expectedRtoDescription
        case expectedRtoInSecs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedComplianceStatus = self.expectedComplianceStatus {
            try encodeContainer.encode(expectedComplianceStatus.rawValue, forKey: .expectedComplianceStatus)
        }
        if let expectedRpoDescription = self.expectedRpoDescription {
            try encodeContainer.encode(expectedRpoDescription, forKey: .expectedRpoDescription)
        }
        if expectedRpoInSecs != 0 {
            try encodeContainer.encode(expectedRpoInSecs, forKey: .expectedRpoInSecs)
        }
        if let expectedRtoDescription = self.expectedRtoDescription {
            try encodeContainer.encode(expectedRtoDescription, forKey: .expectedRtoDescription)
        }
        if expectedRtoInSecs != 0 {
            try encodeContainer.encode(expectedRtoInSecs, forKey: .expectedRtoInSecs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expectedComplianceStatusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ComplianceStatus.self, forKey: .expectedComplianceStatus)
        expectedComplianceStatus = expectedComplianceStatusDecoded
        let expectedRtoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedRtoInSecs) ?? 0
        expectedRtoInSecs = expectedRtoInSecsDecoded
        let expectedRtoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRtoDescription)
        expectedRtoDescription = expectedRtoDescriptionDecoded
        let expectedRpoInSecsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedRpoInSecs) ?? 0
        expectedRpoInSecs = expectedRpoInSecsDecoded
        let expectedRpoDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedRpoDescription)
        expectedRpoDescription = expectedRpoDescriptionDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a disruption compliance recommendation.
    public struct RecommendationDisruptionCompliance: Swift.Equatable {
        /// The expected compliance status after applying the recommended configuration change.
        /// This member is required.
        public var expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus?
        /// The expected Recovery Point Objective (RPO) description after applying the recommended configuration change.
        public var expectedRpoDescription: Swift.String?
        /// The expected RPO after applying the recommended configuration change.
        public var expectedRpoInSecs: Swift.Int
        /// The expected Recovery Time Objective (RTO) description after applying the recommended configuration change.
        public var expectedRtoDescription: Swift.String?
        /// The expected RTO after applying the recommended configuration change.
        public var expectedRtoInSecs: Swift.Int

        public init(
            expectedComplianceStatus: ResiliencehubClientTypes.ComplianceStatus? = nil,
            expectedRpoDescription: Swift.String? = nil,
            expectedRpoInSecs: Swift.Int = 0,
            expectedRtoDescription: Swift.String? = nil,
            expectedRtoInSecs: Swift.Int = 0
        )
        {
            self.expectedComplianceStatus = expectedComplianceStatus
            self.expectedRpoDescription = expectedRpoDescription
            self.expectedRpoInSecs = expectedRpoInSecs
            self.expectedRtoDescription = expectedRtoDescription
            self.expectedRtoInSecs = expectedRtoInSecs
        }
    }

}

extension ResiliencehubClientTypes.RecommendationItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alreadyImplemented
        case excludeReason
        case excluded
        case resourceId
        case targetAccountId
        case targetRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alreadyImplemented = self.alreadyImplemented {
            try encodeContainer.encode(alreadyImplemented, forKey: .alreadyImplemented)
        }
        if let excludeReason = self.excludeReason {
            try encodeContainer.encode(excludeReason.rawValue, forKey: .excludeReason)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
        if let targetRegion = self.targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
        let alreadyImplementedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .alreadyImplemented)
        alreadyImplemented = alreadyImplementedDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let excludeReasonDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ExcludeRecommendationReason.self, forKey: .excludeReason)
        excludeReason = excludeReasonDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation.
    public struct RecommendationItem: Swift.Equatable {
        /// Specifies if the recommendation has already been implemented.
        public var alreadyImplemented: Swift.Bool?
        /// Indicates the reason for excluding an operational recommendation.
        public var excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason?
        /// Indicates if an operational recommendation item is excluded.
        public var excluded: Swift.Bool?
        /// Identifier of the resource.
        public var resourceId: Swift.String?
        /// Identifier of the target account.
        public var targetAccountId: Swift.String?
        /// The target region.
        public var targetRegion: Swift.String?

        public init(
            alreadyImplemented: Swift.Bool? = nil,
            excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason? = nil,
            excluded: Swift.Bool? = nil,
            resourceId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.alreadyImplemented = alreadyImplemented
            self.excludeReason = excludeReason
            self.excluded = excluded
            self.resourceId = resourceId
            self.targetAccountId = targetAccountId
            self.targetRegion = targetRegion
        }
    }

}

extension ResiliencehubClientTypes.RecommendationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentArn
        case endTime
        case format
        case message
        case name
        case needsReplacements
        case recommendationIds
        case recommendationTemplateArn
        case recommendationTypes
        case startTime
        case status
        case tags
        case templatesLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentArn = self.assessmentArn {
            try encodeContainer.encode(assessmentArn, forKey: .assessmentArn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let needsReplacements = self.needsReplacements {
            try encodeContainer.encode(needsReplacements, forKey: .needsReplacements)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for uuid0 in recommendationIds {
                try recommendationIdsContainer.encode(uuid0)
            }
        }
        if let recommendationTemplateArn = self.recommendationTemplateArn {
            try encodeContainer.encode(recommendationTemplateArn, forKey: .recommendationTemplateArn)
        }
        if let recommendationTypes = recommendationTypes {
            var recommendationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationTypes)
            for renderrecommendationtype0 in recommendationTypes {
                try recommendationTypesContainer.encode(renderrecommendationtype0.rawValue)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templatesLocation = self.templatesLocation {
            try encodeContainer.encode(templatesLocation, forKey: .templatesLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesLocationDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.S3Location.self, forKey: .templatesLocation)
        templatesLocation = templatesLocationDecoded
        let assessmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentArn)
        assessmentArn = assessmentArnDecoded
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let recommendationTypesContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RenderRecommendationType?].self, forKey: .recommendationTypes)
        var recommendationTypesDecoded0:[ResiliencehubClientTypes.RenderRecommendationType]? = nil
        if let recommendationTypesContainer = recommendationTypesContainer {
            recommendationTypesDecoded0 = [ResiliencehubClientTypes.RenderRecommendationType]()
            for string0 in recommendationTypesContainer {
                if let string0 = string0 {
                    recommendationTypesDecoded0?.append(string0)
                }
            }
        }
        recommendationTypes = recommendationTypesDecoded0
        let formatDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TemplateFormat.self, forKey: .format)
        format = formatDecoded
        let recommendationTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationTemplateArn)
        recommendationTemplateArn = recommendationTemplateArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.RecommendationTemplateStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let needsReplacementsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .needsReplacements)
        needsReplacements = needsReplacementsDecoded
    }
}

extension ResiliencehubClientTypes.RecommendationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationTemplate(appArn: \(Swift.String(describing: appArn)), assessmentArn: \(Swift.String(describing: assessmentArn)), endTime: \(Swift.String(describing: endTime)), format: \(Swift.String(describing: format)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), needsReplacements: \(Swift.String(describing: needsReplacements)), recommendationIds: \(Swift.String(describing: recommendationIds)), recommendationTemplateArn: \(Swift.String(describing: recommendationTemplateArn)), recommendationTypes: \(Swift.String(describing: recommendationTypes)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), templatesLocation: \(Swift.String(describing: templatesLocation)), tags: \"CONTENT_REDACTED\")"}
}

extension ResiliencehubClientTypes {
    /// Defines a recommendation template created with the [CreateRecommendationTemplate] action.
    public struct RecommendationTemplate: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var appArn: Swift.String?
        /// Amazon Resource Name (ARN) of the assessment. The format for this ARN is: arn:partition:resiliencehub:region:account:app-assessment/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        /// This member is required.
        public var assessmentArn: Swift.String?
        /// The end time for the action.
        public var endTime: ClientRuntime.Date?
        /// Format of the recommendation template. CfnJson The template is CloudFormation JSON. CfnYaml The template is CloudFormation YAML.
        /// This member is required.
        public var format: ResiliencehubClientTypes.TemplateFormat?
        /// Message for the recommendation template.
        public var message: Swift.String?
        /// Name for the recommendation template.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates if replacements are needed.
        public var needsReplacements: Swift.Bool?
        /// Identifiers for the recommendations used in the recommendation template.
        public var recommendationIds: [Swift.String]?
        /// Amazon Resource Name (ARN) for the recommendation template.
        /// This member is required.
        public var recommendationTemplateArn: Swift.String?
        /// An array of strings that specify the recommendation template type or types. Alarm The template is an [AlarmRecommendation] template. Sop The template is a [SopRecommendation] template. Test The template is a [TestRecommendation] template.
        /// This member is required.
        public var recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]?
        /// The start time for the action.
        public var startTime: ClientRuntime.Date?
        /// Status of the action.
        /// This member is required.
        public var status: ResiliencehubClientTypes.RecommendationTemplateStatus?
        /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The file location of the template.
        public var templatesLocation: ResiliencehubClientTypes.S3Location?

        public init(
            appArn: Swift.String? = nil,
            assessmentArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            format: ResiliencehubClientTypes.TemplateFormat? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            needsReplacements: Swift.Bool? = nil,
            recommendationIds: [Swift.String]? = nil,
            recommendationTemplateArn: Swift.String? = nil,
            recommendationTypes: [ResiliencehubClientTypes.RenderRecommendationType]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ResiliencehubClientTypes.RecommendationTemplateStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            templatesLocation: ResiliencehubClientTypes.S3Location? = nil
        )
        {
            self.appArn = appArn
            self.assessmentArn = assessmentArn
            self.endTime = endTime
            self.format = format
            self.message = message
            self.name = name
            self.needsReplacements = needsReplacements
            self.recommendationIds = recommendationIds
            self.recommendationTemplateArn = recommendationTemplateArn
            self.recommendationTypes = recommendationTypes
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.templatesLocation = templatesLocation
        }
    }

}

extension ResiliencehubClientTypes {
    public enum RecommendationTemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTemplateStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTemplateStatus(rawValue: rawValue) ?? RecommendationTemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension RemoveDraftAppVersionResourceMappingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case eksSourceNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
        case terraformSourceNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appRegistryAppNames = appRegistryAppNames {
            var appRegistryAppNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appRegistryAppNames)
            for entityname0 in appRegistryAppNames {
                try appRegistryAppNamesContainer.encode(entityname0)
            }
        }
        if let eksSourceNames = eksSourceNames {
            var eksSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eksSourceNames)
            for string2550 in eksSourceNames {
                try eksSourceNamesContainer.encode(string2550)
            }
        }
        if let logicalStackNames = logicalStackNames {
            var logicalStackNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logicalStackNames)
            for string2550 in logicalStackNames {
                try logicalStackNamesContainer.encode(string2550)
            }
        }
        if let resourceGroupNames = resourceGroupNames {
            var resourceGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupNames)
            for entityname0 in resourceGroupNames {
                try resourceGroupNamesContainer.encode(entityname0)
            }
        }
        if let resourceNames = resourceNames {
            var resourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceNames)
            for entityname0 in resourceNames {
                try resourceNamesContainer.encode(entityname0)
            }
        }
        if let terraformSourceNames = terraformSourceNames {
            var terraformSourceNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terraformSourceNames)
            for string2550 in terraformSourceNames {
                try terraformSourceNamesContainer.encode(string2550)
            }
        }
    }
}

extension RemoveDraftAppVersionResourceMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/remove-draft-app-version-resource-mappings"
    }
}

public struct RemoveDraftAppVersionResourceMappingsInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The names of the registered applications you want to remove from the resource mappings.
    public var appRegistryAppNames: [Swift.String]?
    /// The names of the Amazon Elastic Kubernetes Service clusters and namespaces you want to remove from the resource mappings. This parameter accepts values in "eks-cluster/namespace" format.
    public var eksSourceNames: [Swift.String]?
    /// The names of the CloudFormation stacks you want to remove from the resource mappings.
    public var logicalStackNames: [Swift.String]?
    /// The names of the resource groups you want to remove from the resource mappings.
    public var resourceGroupNames: [Swift.String]?
    /// The names of the resources you want to remove from the resource mappings.
    public var resourceNames: [Swift.String]?
    /// The names of the Terraform sources you want to remove from the resource mappings.
    public var terraformSourceNames: [Swift.String]?

    public init(
        appArn: Swift.String? = nil,
        appRegistryAppNames: [Swift.String]? = nil,
        eksSourceNames: [Swift.String]? = nil,
        logicalStackNames: [Swift.String]? = nil,
        resourceGroupNames: [Swift.String]? = nil,
        resourceNames: [Swift.String]? = nil,
        terraformSourceNames: [Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appRegistryAppNames = appRegistryAppNames
        self.eksSourceNames = eksSourceNames
        self.logicalStackNames = logicalStackNames
        self.resourceGroupNames = resourceGroupNames
        self.resourceNames = resourceNames
        self.terraformSourceNames = terraformSourceNames
    }
}

struct RemoveDraftAppVersionResourceMappingsInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceNames: [Swift.String]?
    let logicalStackNames: [Swift.String]?
    let appRegistryAppNames: [Swift.String]?
    let resourceGroupNames: [Swift.String]?
    let terraformSourceNames: [Swift.String]?
    let eksSourceNames: [Swift.String]?
}

extension RemoveDraftAppVersionResourceMappingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appRegistryAppNames
        case eksSourceNames
        case logicalStackNames
        case resourceGroupNames
        case resourceNames
        case terraformSourceNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceNames)
        var resourceNamesDecoded0:[Swift.String]? = nil
        if let resourceNamesContainer = resourceNamesContainer {
            resourceNamesDecoded0 = [Swift.String]()
            for string0 in resourceNamesContainer {
                if let string0 = string0 {
                    resourceNamesDecoded0?.append(string0)
                }
            }
        }
        resourceNames = resourceNamesDecoded0
        let logicalStackNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logicalStackNames)
        var logicalStackNamesDecoded0:[Swift.String]? = nil
        if let logicalStackNamesContainer = logicalStackNamesContainer {
            logicalStackNamesDecoded0 = [Swift.String]()
            for string0 in logicalStackNamesContainer {
                if let string0 = string0 {
                    logicalStackNamesDecoded0?.append(string0)
                }
            }
        }
        logicalStackNames = logicalStackNamesDecoded0
        let appRegistryAppNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appRegistryAppNames)
        var appRegistryAppNamesDecoded0:[Swift.String]? = nil
        if let appRegistryAppNamesContainer = appRegistryAppNamesContainer {
            appRegistryAppNamesDecoded0 = [Swift.String]()
            for string0 in appRegistryAppNamesContainer {
                if let string0 = string0 {
                    appRegistryAppNamesDecoded0?.append(string0)
                }
            }
        }
        appRegistryAppNames = appRegistryAppNamesDecoded0
        let resourceGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceGroupNames)
        var resourceGroupNamesDecoded0:[Swift.String]? = nil
        if let resourceGroupNamesContainer = resourceGroupNamesContainer {
            resourceGroupNamesDecoded0 = [Swift.String]()
            for string0 in resourceGroupNamesContainer {
                if let string0 = string0 {
                    resourceGroupNamesDecoded0?.append(string0)
                }
            }
        }
        resourceGroupNames = resourceGroupNamesDecoded0
        let terraformSourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .terraformSourceNames)
        var terraformSourceNamesDecoded0:[Swift.String]? = nil
        if let terraformSourceNamesContainer = terraformSourceNamesContainer {
            terraformSourceNamesDecoded0 = [Swift.String]()
            for string0 in terraformSourceNamesContainer {
                if let string0 = string0 {
                    terraformSourceNamesDecoded0?.append(string0)
                }
            }
        }
        terraformSourceNames = terraformSourceNamesDecoded0
        let eksSourceNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eksSourceNames)
        var eksSourceNamesDecoded0:[Swift.String]? = nil
        if let eksSourceNamesContainer = eksSourceNamesContainer {
            eksSourceNamesDecoded0 = [Swift.String]()
            for string0 in eksSourceNamesContainer {
                if let string0 = string0 {
                    eksSourceNamesDecoded0?.append(string0)
                }
            }
        }
        eksSourceNames = eksSourceNamesDecoded0
    }
}

extension RemoveDraftAppVersionResourceMappingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveDraftAppVersionResourceMappingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct RemoveDraftAppVersionResourceMappingsOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var appArn: Swift.String?
    /// The version of the application.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct RemoveDraftAppVersionResourceMappingsOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension RemoveDraftAppVersionResourceMappingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

enum RemoveDraftAppVersionResourceMappingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum RenderRecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case sop
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [RenderRecommendationType] {
            return [
                .alarm,
                .sop,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "Alarm"
            case .sop: return "Sop"
            case .test: return "Test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenderRecommendationType(rawValue: rawValue) ?? RenderRecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case dataLocationConstraint
        case estimatedCostTier
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tags
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataLocationConstraint = self.dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let estimatedCostTier = self.estimatedCostTier {
            try encodeContainer.encode(estimatedCostTier.rawValue, forKey: .estimatedCostTier)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionPolicy0) in policy {
                try policyContainer.encode(disruptionPolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = self.policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let estimatedCostTierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.EstimatedCostTier.self, forKey: .estimatedCostTier)
        estimatedCostTier = estimatedCostTierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResiliencehubClientTypes.ResiliencyPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResiliencyPolicy(creationTime: \(Swift.String(describing: creationTime)), dataLocationConstraint: \(Swift.String(describing: dataLocationConstraint)), estimatedCostTier: \(Swift.String(describing: estimatedCostTier)), policy: \(Swift.String(describing: policy)), policyArn: \(Swift.String(describing: policyArn)), policyDescription: \(Swift.String(describing: policyDescription)), policyName: \(Swift.String(describing: policyName)), tier: \(Swift.String(describing: tier)), tags: \"CONTENT_REDACTED\")"}
}

extension ResiliencehubClientTypes {
    /// Defines a resiliency policy.
    public struct ResiliencyPolicy: Swift.Equatable {
        /// The timestamp for when the resiliency policy was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
        public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
        /// Specifies the estimated cost tier of the resiliency policy.
        public var estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier?
        /// The resiliency policy.
        public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
        /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
        public var policyArn: Swift.String?
        /// The description for the policy.
        public var policyDescription: Swift.String?
        /// The name of the policy
        public var policyName: Swift.String?
        /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
        public var tags: [Swift.String:Swift.String]?
        /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
        public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
            estimatedCostTier: ResiliencehubClientTypes.EstimatedCostTier? = nil,
            policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
            policyArn: Swift.String? = nil,
            policyDescription: Swift.String? = nil,
            policyName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
        )
        {
            self.creationTime = creationTime
            self.dataLocationConstraint = dataLocationConstraint
            self.estimatedCostTier = estimatedCostTier
            self.policy = policy
            self.policyArn = policyArn
            self.policyDescription = policyDescription
            self.policyName = policyName
            self.tags = tags
            self.tier = tier
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResiliencyPolicyTier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case coreServices
        case critical
        case important
        case missionCritical
        case nonCritical
        case notApplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [ResiliencyPolicyTier] {
            return [
                .coreServices,
                .critical,
                .important,
                .missionCritical,
                .nonCritical,
                .notApplicable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .coreServices: return "CoreServices"
            case .critical: return "Critical"
            case .important: return "Important"
            case .missionCritical: return "MissionCritical"
            case .nonCritical: return "NonCritical"
            case .notApplicable: return "NotApplicable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResiliencyPolicyTier(rawValue: rawValue) ?? ResiliencyPolicyTier.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResiliencyScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disruptionScore
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disruptionScore = disruptionScore {
            var disruptionScoreContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .disruptionScore)
            for (dictKey0, disruptionResiliencyScore0) in disruptionScore {
                try disruptionScoreContainer.encode(disruptionResiliencyScore0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
        let disruptionScoreContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .disruptionScore)
        var disruptionScoreDecoded0: [Swift.String:Swift.Double]? = nil
        if let disruptionScoreContainer = disruptionScoreContainer {
            disruptionScoreDecoded0 = [Swift.String:Swift.Double]()
            for (key0, double0) in disruptionScoreContainer {
                if let double0 = double0 {
                    disruptionScoreDecoded0?[key0] = double0
                }
            }
        }
        disruptionScore = disruptionScoreDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// The overall resiliency score, returned as an object that includes the disruption score and outage score.
    public struct ResiliencyScore: Swift.Equatable {
        /// The disruption score for a valid key.
        /// This member is required.
        public var disruptionScore: [Swift.String:Swift.Double]?
        /// The outage score for a valid key.
        /// This member is required.
        public var score: Swift.Double

        public init(
            disruptionScore: [Swift.String:Swift.Double]? = nil,
            score: Swift.Double = 0.0
        )
        {
            self.disruptionScore = disruptionScore
            self.score = score
        }
    }

}

extension ResolveAppVersionResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
    }
}

extension ResolveAppVersionResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resolve-app-version-resources"
    }
}

public struct ResolveAppVersionResourcesInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct ResolveAppVersionResourcesInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
}

extension ResolveAppVersionResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
    }
}

extension ResolveAppVersionResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResolveAppVersionResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.resolutionId = output.resolutionId
            self.status = output.status
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.resolutionId = nil
            self.status = nil
        }
    }
}

public struct ResolveAppVersionResourcesOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The identifier for a specific resolution.
    /// This member is required.
    public var resolutionId: Swift.String?
    /// Status of the action.
    /// This member is required.
    public var status: ResiliencehubClientTypes.ResourceResolutionStatusType?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        resolutionId: Swift.String? = nil,
        status: ResiliencehubClientTypes.ResourceResolutionStatusType? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.resolutionId = resolutionId
        self.status = status
    }
}

struct ResolveAppVersionResourcesOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let resolutionId: Swift.String?
    let status: ResiliencehubClientTypes.ResourceResolutionStatusType?
}

extension ResolveAppVersionResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case resolutionId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let resolutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionId)
        resolutionId = resolutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceResolutionStatusType.self, forKey: .status)
        status = statusDecoded
    }
}

enum ResolveAppVersionResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes.ResourceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalResourceId
        case physicalResourceId
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines application resource errors.
    public struct ResourceError: Swift.Equatable {
        /// Identifier of the logical resource.
        public var logicalResourceId: Swift.String?
        /// Identifier of the physical resource.
        public var physicalResourceId: Swift.String?
        /// This is the error message.
        public var reason: Swift.String?

        public init(
            logicalResourceId: Swift.String? = nil,
            physicalResourceId: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.reason = reason
        }
    }

}

extension ResiliencehubClientTypes.ResourceErrorsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasMoreErrors
        case resourceErrors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hasMoreErrors = self.hasMoreErrors {
            try encodeContainer.encode(hasMoreErrors, forKey: .hasMoreErrors)
        }
        if let resourceErrors = resourceErrors {
            var resourceErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceErrors)
            for resourceerror0 in resourceErrors {
                try resourceErrorsContainer.encode(resourceerror0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceErrorsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.ResourceError?].self, forKey: .resourceErrors)
        var resourceErrorsDecoded0:[ResiliencehubClientTypes.ResourceError]? = nil
        if let resourceErrorsContainer = resourceErrorsContainer {
            resourceErrorsDecoded0 = [ResiliencehubClientTypes.ResourceError]()
            for structure0 in resourceErrorsContainer {
                if let structure0 = structure0 {
                    resourceErrorsDecoded0?.append(structure0)
                }
            }
        }
        resourceErrors = resourceErrorsDecoded0
        let hasMoreErrorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasMoreErrors)
        hasMoreErrors = hasMoreErrorsDecoded
    }
}

extension ResiliencehubClientTypes {
    /// A list of errors retrieving an application's resources.
    public struct ResourceErrorsDetails: Swift.Equatable {
        /// This indicates if there are more errors not listed in the resourceErrors list.
        public var hasMoreErrors: Swift.Bool?
        /// A list of errors retrieving an application's resources.
        public var resourceErrors: [ResiliencehubClientTypes.ResourceError]?

        public init(
            hasMoreErrors: Swift.Bool? = nil,
            resourceErrors: [ResiliencehubClientTypes.ResourceError]? = nil
        )
        {
            self.hasMoreErrors = hasMoreErrors
            self.resourceErrors = resourceErrors
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResourceImportStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceImportStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceImportStatusType(rawValue: rawValue) ?? ResourceImportStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceImportStrategyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addOnly
        case replaceAll
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceImportStrategyType] {
            return [
                .addOnly,
                .replaceAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addOnly: return "AddOnly"
            case .replaceAll: return "ReplaceAll"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceImportStrategyType(rawValue: rawValue) ?? ResourceImportStrategyType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.ResourceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appRegistryAppName
        case eksSourceName
        case logicalStackName
        case mappingType
        case physicalResourceId
        case resourceGroupName
        case resourceName
        case terraformSourceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appRegistryAppName = self.appRegistryAppName {
            try encodeContainer.encode(appRegistryAppName, forKey: .appRegistryAppName)
        }
        if let eksSourceName = self.eksSourceName {
            try encodeContainer.encode(eksSourceName, forKey: .eksSourceName)
        }
        if let logicalStackName = self.logicalStackName {
            try encodeContainer.encode(logicalStackName, forKey: .logicalStackName)
        }
        if let mappingType = self.mappingType {
            try encodeContainer.encode(mappingType.rawValue, forKey: .mappingType)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceGroupName = self.resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let terraformSourceName = self.terraformSourceName {
            try encodeContainer.encode(terraformSourceName, forKey: .terraformSourceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalStackName)
        logicalStackName = logicalStackNameDecoded
        let appRegistryAppNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appRegistryAppName)
        appRegistryAppName = appRegistryAppNameDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let mappingTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResourceMappingType.self, forKey: .mappingType)
        mappingType = mappingTypeDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let terraformSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terraformSourceName)
        terraformSourceName = terraformSourceNameDecoded
        let eksSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksSourceName)
        eksSourceName = eksSourceNameDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a resource mapping.
    public struct ResourceMapping: Swift.Equatable {
        /// The name of the application this resource is mapped to.
        public var appRegistryAppName: Swift.String?
        /// Name of the Amazon Elastic Kubernetes Service cluster and namespace this resource belongs to. This parameter accepts values in "eks-cluster/namespace" format.
        public var eksSourceName: Swift.String?
        /// The name of the CloudFormation stack this resource is mapped to.
        public var logicalStackName: Swift.String?
        /// Specifies the type of resource mapping. AppRegistryApp The resource is mapped to another application. The name of the application is contained in the appRegistryAppName property. CfnStack The resource is mapped to a CloudFormation stack. The name of the CloudFormation stack is contained in the logicalStackName property. Resource The resource is mapped to another resource. The name of the resource is contained in the resourceName property. ResourceGroup The resource is mapped to Resource Groups. The name of the resource group is contained in the resourceGroupName property.
        /// This member is required.
        public var mappingType: ResiliencehubClientTypes.ResourceMappingType?
        /// Identifier of the physical resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// Name of the resource group that the resource is mapped to.
        public var resourceGroupName: Swift.String?
        /// Name of the resource that the resource is mapped to.
        public var resourceName: Swift.String?
        /// The short name of the Terraform source.
        public var terraformSourceName: Swift.String?

        public init(
            appRegistryAppName: Swift.String? = nil,
            eksSourceName: Swift.String? = nil,
            logicalStackName: Swift.String? = nil,
            mappingType: ResiliencehubClientTypes.ResourceMappingType? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceGroupName: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            terraformSourceName: Swift.String? = nil
        )
        {
            self.appRegistryAppName = appRegistryAppName
            self.eksSourceName = eksSourceName
            self.logicalStackName = logicalStackName
            self.mappingType = mappingType
            self.physicalResourceId = physicalResourceId
            self.resourceGroupName = resourceGroupName
            self.resourceName = resourceName
            self.terraformSourceName = terraformSourceName
        }
    }

}

extension ResiliencehubClientTypes {
    public enum ResourceMappingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appRegistryApp
        case cfnStack
        case eks
        case resource
        case resourceGroup
        case terraform
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceMappingType] {
            return [
                .appRegistryApp,
                .cfnStack,
                .eks,
                .resource,
                .resourceGroup,
                .terraform,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appRegistryApp: return "AppRegistryApp"
            case .cfnStack: return "CfnStack"
            case .eks: return "EKS"
            case .resource: return "Resource"
            case .resourceGroup: return "ResourceGroup"
            case .terraform: return "Terraform"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceMappingType(rawValue: rawValue) ?? ResourceMappingType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when the specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that the exception applies to.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that the exception applies to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceResolutionStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceResolutionStatusType] {
            return [
                .failed,
                .inProgress,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceResolutionStatusType(rawValue: rawValue) ?? ResourceResolutionStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum ResourceSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appTemplate
        case discovered
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSourceType] {
            return [
                .appTemplate,
                .discovered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appTemplate: return "AppTemplate"
            case .discovered: return "Discovered"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSourceType(rawValue: rawValue) ?? ResourceSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The location of the Amazon S3 bucket.
    public struct S3Location: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        public var bucket: Swift.String?
        /// The prefix for the Amazon S3 bucket.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when you have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResiliencehubClientTypes.SopRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case description
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case serviceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitem0 in items {
                try itemsContainer.encode(recommendationitem0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = self.prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType.rawValue, forKey: .serviceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.SopServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a standard operating procedure (SOP) recommendation.
    public struct SopRecommendation: Swift.Equatable {
        /// Name of the Application Component.
        public var appComponentName: Swift.String?
        /// Description of the SOP recommendation.
        public var description: Swift.String?
        /// The recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// Name of the SOP recommendation.
        public var name: Swift.String?
        /// Prerequisite for the SOP recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the SOP recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// Reference identifier for the SOP recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// The service type.
        /// This member is required.
        public var serviceType: ResiliencehubClientTypes.SopServiceType?

        public init(
            appComponentName: Swift.String? = nil,
            description: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            serviceType: ResiliencehubClientTypes.SopServiceType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.description = description
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.serviceType = serviceType
        }
    }

}

extension ResiliencehubClientTypes {
    public enum SopServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [SopServiceType] {
            return [
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SopServiceType(rawValue: rawValue) ?? SopServiceType.sdkUnknown(rawValue)
        }
    }
}

extension StartAppAssessmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAppAssessmentInput(appArn: \(Swift.String(describing: appArn)), appVersion: \(Swift.String(describing: appVersion)), assessmentName: \(Swift.String(describing: assessmentName)), clientToken: \(Swift.String(describing: clientToken)), tags: \"CONTENT_REDACTED\")"}
}

extension StartAppAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appVersion = self.appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let assessmentName = self.assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartAppAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-app-assessment"
    }
}

public struct StartAppAssessmentInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// The version of the application.
    /// This member is required.
    public var appVersion: Swift.String?
    /// The name for the assessment.
    /// This member is required.
    public var assessmentName: Swift.String?
    /// Used for an idempotency token. A client token is a unique, case-sensitive string of up to 64 ASCII characters. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Tags assigned to the resource. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key/value pair.
    public var tags: [Swift.String:Swift.String]?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        assessmentName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.assessmentName = assessmentName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct StartAppAssessmentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let assessmentName: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartAppAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case assessmentName
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartAppAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAppAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct StartAppAssessmentOutput: Swift.Equatable {
    /// The assessment created.
    /// This member is required.
    public var assessment: ResiliencehubClientTypes.AppAssessment?

    public init(
        assessment: ResiliencehubClientTypes.AppAssessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct StartAppAssessmentOutputBody: Swift.Equatable {
    let assessment: ResiliencehubClientTypes.AppAssessment?
}

extension StartAppAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

enum StartAppAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the resource. Each tag consists of a key/value pair.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum TemplateFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cfnJson
        case cfnYaml
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateFormat] {
            return [
                .cfnJson,
                .cfnYaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cfnJson: return "CfnJson"
            case .cfnYaml: return "CfnYaml"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateFormat(rawValue: rawValue) ?? TemplateFormat.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes.TerraformSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3StateFileUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3StateFileUrl = self.s3StateFileUrl {
            try encodeContainer.encode(s3StateFileUrl, forKey: .s3StateFileUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3StateFileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3StateFileUrl)
        s3StateFileUrl = s3StateFileUrlDecoded
    }
}

extension ResiliencehubClientTypes {
    /// The Terraform s3 state file you need to import.
    public struct TerraformSource: Swift.Equatable {
        /// The URL of the Terraform s3 state file you need to import.
        /// This member is required.
        public var s3StateFileUrl: Swift.String?

        public init(
            s3StateFileUrl: Swift.String? = nil
        )
        {
            self.s3StateFileUrl = s3StateFileUrl
        }
    }

}

extension ResiliencehubClientTypes.TestRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appComponentName
        case dependsOnAlarms
        case description
        case intent
        case items
        case name
        case prerequisite
        case recommendationId
        case referenceId
        case risk
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appComponentName = self.appComponentName {
            try encodeContainer.encode(appComponentName, forKey: .appComponentName)
        }
        if let dependsOnAlarms = dependsOnAlarms {
            var dependsOnAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependsOnAlarms)
            for string5000 in dependsOnAlarms {
                try dependsOnAlarmsContainer.encode(string5000)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let intent = self.intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for recommendationitem0 in items {
                try itemsContainer.encode(recommendationitem0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let prerequisite = self.prerequisite {
            try encodeContainer.encode(prerequisite, forKey: .prerequisite)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let appComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appComponentName)
        appComponentName = appComponentNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let intentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intent)
        intent = intentDecoded
        let riskDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestRisk.self, forKey: .risk)
        risk = riskDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.TestType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let itemsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.RecommendationItem?].self, forKey: .items)
        var itemsDecoded0:[ResiliencehubClientTypes.RecommendationItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ResiliencehubClientTypes.RecommendationItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let prerequisiteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prerequisite)
        prerequisite = prerequisiteDecoded
        let dependsOnAlarmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dependsOnAlarms)
        var dependsOnAlarmsDecoded0:[Swift.String]? = nil
        if let dependsOnAlarmsContainer = dependsOnAlarmsContainer {
            dependsOnAlarmsDecoded0 = [Swift.String]()
            for string0 in dependsOnAlarmsContainer {
                if let string0 = string0 {
                    dependsOnAlarmsDecoded0?.append(string0)
                }
            }
        }
        dependsOnAlarms = dependsOnAlarmsDecoded0
    }
}

extension ResiliencehubClientTypes {
    /// Defines a test recommendation.
    public struct TestRecommendation: Swift.Equatable {
        /// Name of the Application Component.
        public var appComponentName: Swift.String?
        /// A list of recommended alarms that are used in the test and must be exported before or with the test.
        public var dependsOnAlarms: [Swift.String]?
        /// Description for the test recommendation.
        public var description: Swift.String?
        /// Intent of the test recommendation.
        public var intent: Swift.String?
        /// The test recommendation items.
        public var items: [ResiliencehubClientTypes.RecommendationItem]?
        /// Name of the test recommendation.
        public var name: Swift.String?
        /// Prerequisite of the test recommendation.
        public var prerequisite: Swift.String?
        /// Identifier for the test recommendation.
        public var recommendationId: Swift.String?
        /// Reference identifier for the test recommendation.
        /// This member is required.
        public var referenceId: Swift.String?
        /// Level of risk for this test recommendation.
        public var risk: ResiliencehubClientTypes.TestRisk?
        /// Type of test recommendation.
        public var type: ResiliencehubClientTypes.TestType?

        public init(
            appComponentName: Swift.String? = nil,
            dependsOnAlarms: [Swift.String]? = nil,
            description: Swift.String? = nil,
            intent: Swift.String? = nil,
            items: [ResiliencehubClientTypes.RecommendationItem]? = nil,
            name: Swift.String? = nil,
            prerequisite: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            referenceId: Swift.String? = nil,
            risk: ResiliencehubClientTypes.TestRisk? = nil,
            type: ResiliencehubClientTypes.TestType? = nil
        )
        {
            self.appComponentName = appComponentName
            self.dependsOnAlarms = dependsOnAlarms
            self.description = description
            self.intent = intent
            self.items = items
            self.name = name
            self.prerequisite = prerequisite
            self.recommendationId = recommendationId
            self.referenceId = referenceId
            self.risk = risk
            self.type = type
        }
    }

}

extension ResiliencehubClientTypes {
    public enum TestRisk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [TestRisk] {
            return [
                .high,
                .medium,
                .small,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .medium: return "Medium"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestRisk(rawValue: rawValue) ?? TestRisk.sdkUnknown(rawValue)
        }
    }
}

extension ResiliencehubClientTypes {
    public enum TestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case az
        case hardware
        case region
        case software
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .az,
                .hardware,
                .region,
                .software,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .hardware: return "Hardware"
            case .region: return "Region"
            case .software: return "Software"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestType(rawValue: rawValue) ?? TestType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.retryAfterSeconds = output.retryAfterSeconds
        } else {
            self.properties.message = nil
            self.properties.retryAfterSeconds = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when you have exceeded the limit on the number of requests per second.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let retryAfterSeconds: Swift.Int?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryAfterSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryAfterSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAfterSeconds)
        retryAfterSeconds = retryAfterSecondsDecoded
    }
}

extension ResiliencehubClientTypes.UnsupportedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logicalResourceId
        case physicalResourceId
        case resourceType
        case unsupportedResourceStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let unsupportedResourceStatus = self.unsupportedResourceStatus {
            try encodeContainer.encode(unsupportedResourceStatus, forKey: .unsupportedResourceStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResourceId.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let unsupportedResourceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unsupportedResourceStatus)
        unsupportedResourceStatus = unsupportedResourceStatusDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines a resource that is not supported by Resilience Hub.
    public struct UnsupportedResource: Swift.Equatable {
        /// Logical resource identifier for the unsupported resource.
        /// This member is required.
        public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
        /// Physical resource identifier for the unsupported resource.
        /// This member is required.
        public var physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId?
        /// The type of resource.
        /// This member is required.
        public var resourceType: Swift.String?
        /// The status of the unsupported resource.
        public var unsupportedResourceStatus: Swift.String?

        public init(
            logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
            physicalResourceId: ResiliencehubClientTypes.PhysicalResourceId? = nil,
            resourceType: Swift.String? = nil,
            unsupportedResourceStatus: Swift.String? = nil
        )
        {
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.resourceType = resourceType
            self.unsupportedResourceStatus = unsupportedResourceStatus
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentSchedule
        case clearResiliencyPolicyArn
        case description
        case eventSubscriptions
        case permissionModel
        case policyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let assessmentSchedule = self.assessmentSchedule {
            try encodeContainer.encode(assessmentSchedule.rawValue, forKey: .assessmentSchedule)
        }
        if let clearResiliencyPolicyArn = self.clearResiliencyPolicyArn {
            try encodeContainer.encode(clearResiliencyPolicyArn, forKey: .clearResiliencyPolicyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscription0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscription0)
            }
        }
        if let permissionModel = self.permissionModel {
            try encodeContainer.encode(permissionModel, forKey: .permissionModel)
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
    }
}

extension UpdateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-app"
    }
}

public struct UpdateAppInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Assessment execution schedule with 'Daily' or 'Disabled' values.
    public var assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
    /// Specifies if the resiliency policy ARN should be cleared.
    public var clearResiliencyPolicyArn: Swift.Bool?
    /// The optional description for an app.
    public var description: Swift.String?
    /// The list of events you would like to subscribe and get notification for. Currently, Resilience Hub supports notifications only for Drift detected and Scheduled assessment failure events.
    public var eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]?
    /// Defines the roles and credentials that Resilience Hub would use while creating an application, importing its resources, and running an assessment.
    public var permissionModel: ResiliencehubClientTypes.PermissionModel?
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    public var policyArn: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType? = nil,
        clearResiliencyPolicyArn: Swift.Bool? = nil,
        description: Swift.String? = nil,
        eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]? = nil,
        permissionModel: ResiliencehubClientTypes.PermissionModel? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.assessmentSchedule = assessmentSchedule
        self.clearResiliencyPolicyArn = clearResiliencyPolicyArn
        self.description = description
        self.eventSubscriptions = eventSubscriptions
        self.permissionModel = permissionModel
        self.policyArn = policyArn
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let description: Swift.String?
    let policyArn: Swift.String?
    let clearResiliencyPolicyArn: Swift.Bool?
    let assessmentSchedule: ResiliencehubClientTypes.AppAssessmentScheduleType?
    let permissionModel: ResiliencehubClientTypes.PermissionModel?
    let eventSubscriptions: [ResiliencehubClientTypes.EventSubscription]?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case assessmentSchedule
        case clearResiliencyPolicyArn
        case description
        case eventSubscriptions
        case permissionModel
        case policyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let clearResiliencyPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clearResiliencyPolicyArn)
        clearResiliencyPolicyArn = clearResiliencyPolicyArnDecoded
        let assessmentScheduleDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppAssessmentScheduleType.self, forKey: .assessmentSchedule)
        assessmentSchedule = assessmentScheduleDecoded
        let permissionModelDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PermissionModel.self, forKey: .permissionModel)
        permissionModel = permissionModelDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([ResiliencehubClientTypes.EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[ResiliencehubClientTypes.EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [ResiliencehubClientTypes.EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
    }
}

extension UpdateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.app = output.app
        } else {
            self.app = nil
        }
    }
}

public struct UpdateAppOutput: Swift.Equatable {
    /// The specified application, returned as an object with details including compliance status, creation time, description, resiliency score, and more.
    /// This member is required.
    public var app: ResiliencehubClientTypes.App?

    public init(
        app: ResiliencehubClientTypes.App? = nil
    )
    {
        self.app = app
    }
}

struct UpdateAppOutputBody: Swift.Equatable {
    let app: ResiliencehubClientTypes.App?
}

extension UpdateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.App.self, forKey: .app)
        app = appDecoded
    }
}

enum UpdateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppVersionAppComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension UpdateAppVersionAppComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-app-version-app-component"
    }
}

public struct UpdateAppVersionAppComponentInput: Swift.Equatable {
    /// Currently, there is no supported additional information for Application Components.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Identifier of the Application Component.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the Application Component.
    public var name: Swift.String?
    /// Type of Application Component. For more information about the types of Application Component, see [Grouping resources in an AppComponent](https://docs.aws.amazon.com/resilience-hub/latest/userguide/AppComponent.grouping.html).
    public var type: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.id = id
        self.name = name
        self.type = type
    }
}

struct UpdateAppVersionAppComponentInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let type: Swift.String?
    let additionalInfo: [Swift.String:[Swift.String]]?
}

extension UpdateAppVersionAppComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case id
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension UpdateAppVersionAppComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppVersionAppComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appComponent = output.appComponent
            self.appVersion = output.appVersion
        } else {
            self.appArn = nil
            self.appComponent = nil
            self.appVersion = nil
        }
    }
}

public struct UpdateAppVersionAppComponentOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that belong to this resource.
    public var appComponent: ResiliencehubClientTypes.AppComponent?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        appComponent: ResiliencehubClientTypes.AppComponent? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.appComponent = appComponent
        self.appVersion = appVersion
    }
}

struct UpdateAppVersionAppComponentOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let appComponent: ResiliencehubClientTypes.AppComponent?
}

extension UpdateAppVersionAppComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appComponent
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let appComponentDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.AppComponent.self, forKey: .appComponent)
        appComponent = appComponentDecoded
    }
}

enum UpdateAppVersionAppComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
    }
}

extension UpdateAppVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-app-version"
    }
}

public struct UpdateAppVersionInput: Swift.Equatable {
    /// Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter accepts a key-value mapping (in a string format) of only one failover region and one associated account. Key: "failover-regions" Value: "[{"region":"<REGION>", "accounts":[{"id":"<ACCOUNT_ID>"}]}]"
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
    }
}

struct UpdateAppVersionInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let additionalInfo: [Swift.String:[Swift.String]]?
}

extension UpdateAppVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

extension UpdateAppVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalInfo = output.additionalInfo
            self.appArn = output.appArn
            self.appVersion = output.appVersion
        } else {
            self.additionalInfo = nil
            self.appArn = nil
            self.appVersion = nil
        }
    }
}

public struct UpdateAppVersionOutput: Swift.Equatable {
    /// Additional configuration parameters for an Resilience Hub application. If you want to implement additionalInfo through the Resilience Hub console rather than using an API call, see [Configure the application configuration parameters](https://docs.aws.amazon.com/resilience-hub/latest/userguide/app-config-param.html). Currently, this parameter supports only failover region and account.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.appVersion = appVersion
    }
}

struct UpdateAppVersionOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let additionalInfo: [Swift.String:[Swift.String]]?
}

extension UpdateAppVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
    }
}

enum UpdateAppVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppVersionResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appComponents
        case awsAccountId
        case awsRegion
        case excluded
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInfo = additionalInfo {
            var additionalInfoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalInfo)
            for (dictKey0, additionalInfoMap0) in additionalInfo {
                var additionalInfoMap0Container = additionalInfoContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string10241 in additionalInfoMap0 {
                    try additionalInfoMap0Container.encode(string10241)
                }
            }
        }
        if let appArn = self.appArn {
            try encodeContainer.encode(appArn, forKey: .appArn)
        }
        if let appComponents = appComponents {
            var appComponentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appComponents)
            for string2550 in appComponents {
                try appComponentsContainer.encode(string2550)
            }
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let logicalResourceId = self.logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = self.physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension UpdateAppVersionResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-app-version-resource"
    }
}

public struct UpdateAppVersionResourceInput: Swift.Equatable {
    /// Currently, there is no supported additional information for resources.
    public var additionalInfo: [Swift.String:[Swift.String]]?
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// List of Application Components that this resource belongs to. If an Application Component is not part of the Resilience Hub application, it will be added.
    public var appComponents: [Swift.String]?
    /// Amazon Web Services account that owns the physical resource.
    public var awsAccountId: Swift.String?
    /// Amazon Web Services region that owns the physical resource.
    public var awsRegion: Swift.String?
    /// Indicates if a resource is excluded from an Resilience Hub application. You can exclude only imported resources from an Resilience Hub application.
    public var excluded: Swift.Bool?
    /// Logical identifier of the resource.
    public var logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    /// Physical identifier of the resource.
    public var physicalResourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?
    /// Type of resource.
    public var resourceType: Swift.String?

    public init(
        additionalInfo: [Swift.String:[Swift.String]]? = nil,
        appArn: Swift.String? = nil,
        appComponents: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        excluded: Swift.Bool? = nil,
        logicalResourceId: ResiliencehubClientTypes.LogicalResourceId? = nil,
        physicalResourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.additionalInfo = additionalInfo
        self.appArn = appArn
        self.appComponents = appComponents
        self.awsAccountId = awsAccountId
        self.awsRegion = awsRegion
        self.excluded = excluded
        self.logicalResourceId = logicalResourceId
        self.physicalResourceId = physicalResourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

struct UpdateAppVersionResourceInputBody: Swift.Equatable {
    let appArn: Swift.String?
    let resourceName: Swift.String?
    let logicalResourceId: ResiliencehubClientTypes.LogicalResourceId?
    let physicalResourceId: Swift.String?
    let awsRegion: Swift.String?
    let awsAccountId: Swift.String?
    let resourceType: Swift.String?
    let appComponents: [Swift.String]?
    let additionalInfo: [Swift.String:[Swift.String]]?
    let excluded: Swift.Bool?
}

extension UpdateAppVersionResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo
        case appArn
        case appComponents
        case awsAccountId
        case awsRegion
        case excluded
        case logicalResourceId
        case physicalResourceId
        case resourceName
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.LogicalResourceId.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let appComponentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appComponents)
        var appComponentsDecoded0:[Swift.String]? = nil
        if let appComponentsContainer = appComponentsContainer {
            appComponentsDecoded0 = [Swift.String]()
            for string0 in appComponentsContainer {
                if let string0 = string0 {
                    appComponentsDecoded0?.append(string0)
                }
            }
        }
        appComponents = appComponentsDecoded0
        let additionalInfoContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .additionalInfo)
        var additionalInfoDecoded0: [Swift.String:[Swift.String]]? = nil
        if let additionalInfoContainer = additionalInfoContainer {
            additionalInfoDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, additionalinfovaluelist0) in additionalInfoContainer {
                var additionalinfovaluelist0Decoded0: [Swift.String]? = nil
                if let additionalinfovaluelist0 = additionalinfovaluelist0 {
                    additionalinfovaluelist0Decoded0 = [Swift.String]()
                    for string1 in additionalinfovaluelist0 {
                        if let string1 = string1 {
                            additionalinfovaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                additionalInfoDecoded0?[key0] = additionalinfovaluelist0Decoded0
            }
        }
        additionalInfo = additionalInfoDecoded0
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
    }
}

extension UpdateAppVersionResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppVersionResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appArn = output.appArn
            self.appVersion = output.appVersion
            self.physicalResource = output.physicalResource
        } else {
            self.appArn = nil
            self.appVersion = nil
            self.physicalResource = nil
        }
    }
}

public struct UpdateAppVersionResourceOutput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the Resilience Hub application. The format for this ARN is: arn:partition:resiliencehub:region:account:app/app-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var appArn: Swift.String?
    /// Resilience Hub application version.
    /// This member is required.
    public var appVersion: Swift.String?
    /// Defines a physical resource. A physical resource is a resource that exists in your account. It can be identified using an Amazon Resource Name (ARN) or a Resilience Hub-native identifier.
    public var physicalResource: ResiliencehubClientTypes.PhysicalResource?

    public init(
        appArn: Swift.String? = nil,
        appVersion: Swift.String? = nil,
        physicalResource: ResiliencehubClientTypes.PhysicalResource? = nil
    )
    {
        self.appArn = appArn
        self.appVersion = appVersion
        self.physicalResource = physicalResource
    }
}

struct UpdateAppVersionResourceOutputBody: Swift.Equatable {
    let appArn: Swift.String?
    let appVersion: Swift.String?
    let physicalResource: ResiliencehubClientTypes.PhysicalResource?
}

extension UpdateAppVersionResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appArn
        case appVersion
        case physicalResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appArn)
        appArn = appArnDecoded
        let appVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let physicalResourceDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.PhysicalResource.self, forKey: .physicalResource)
        physicalResource = physicalResourceDecoded
    }
}

enum UpdateAppVersionResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResiliencehubClientTypes.UpdateRecommendationStatusItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId
        case targetAccountId
        case targetRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let targetAccountId = self.targetAccountId {
            try encodeContainer.encode(targetAccountId, forKey: .targetAccountId)
        }
        if let targetRegion = self.targetRegion {
            try encodeContainer.encode(targetRegion, forKey: .targetRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let targetAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAccountId)
        targetAccountId = targetAccountIdDecoded
        let targetRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetRegion)
        targetRegion = targetRegionDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the operational recommendation item that needs a status update.
    public struct UpdateRecommendationStatusItem: Swift.Equatable {
        /// Resource identifier of the operational recommendation item.
        public var resourceId: Swift.String?
        /// Identifier of the target Amazon Web Services account.
        public var targetAccountId: Swift.String?
        /// Identifier of the target Amazon Web Services Region.
        public var targetRegion: Swift.String?

        public init(
            resourceId: Swift.String? = nil,
            targetAccountId: Swift.String? = nil,
            targetRegion: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.targetAccountId = targetAccountId
            self.targetRegion = targetRegion
        }
    }

}

extension ResiliencehubClientTypes.UpdateRecommendationStatusRequestEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case excludeReason
        case excluded
        case item
        case referenceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let excludeReason = self.excludeReason {
            try encodeContainer.encode(excludeReason.rawValue, forKey: .excludeReason)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let item = self.item {
            try encodeContainer.encode(item, forKey: .item)
        }
        if let referenceId = self.referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let referenceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let itemDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.UpdateRecommendationStatusItem.self, forKey: .item)
        item = itemDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let excludeReasonDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ExcludeRecommendationReason.self, forKey: .excludeReason)
        excludeReason = excludeReasonDecoded
    }
}

extension ResiliencehubClientTypes {
    /// Defines the operational recommendation item that is to be included or excluded.
    public struct UpdateRecommendationStatusRequestEntry: Swift.Equatable {
        /// An identifier for an entry in this batch that is used to communicate the result. The entryIds of a batch request need to be unique within a request.
        /// This member is required.
        public var entryId: Swift.String?
        /// Indicates the reason for excluding an operational recommendation.
        public var excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason?
        /// Indicates if the operational recommendation needs to be excluded. If set to True, the operational recommendation will be excluded.
        /// This member is required.
        public var excluded: Swift.Bool?
        /// The operational recommendation item.
        /// This member is required.
        public var item: ResiliencehubClientTypes.UpdateRecommendationStatusItem?
        /// Reference identifier of the operational recommendation item.
        /// This member is required.
        public var referenceId: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            excludeReason: ResiliencehubClientTypes.ExcludeRecommendationReason? = nil,
            excluded: Swift.Bool? = nil,
            item: ResiliencehubClientTypes.UpdateRecommendationStatusItem? = nil,
            referenceId: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.excludeReason = excludeReason
            self.excluded = excluded
            self.item = item
            self.referenceId = referenceId
        }
    }

}

extension UpdateResiliencyPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocationConstraint = self.dataLocationConstraint {
            try encodeContainer.encode(dataLocationConstraint.rawValue, forKey: .dataLocationConstraint)
        }
        if let policy = policy {
            var policyContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .policy)
            for (dictKey0, disruptionPolicy0) in policy {
                try policyContainer.encode(disruptionPolicy0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyDescription = self.policyDescription {
            try encodeContainer.encode(policyDescription, forKey: .policyDescription)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension UpdateResiliencyPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-resiliency-policy"
    }
}

public struct UpdateResiliencyPolicyInput: Swift.Equatable {
    /// Specifies a high-level geographical location constraint for where your resilience policy data can be stored.
    public var dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    /// The type of resiliency policy to be created, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    public var policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
    /// Amazon Resource Name (ARN) of the resiliency policy. The format for this ARN is: arn:partition:resiliencehub:region:account:resiliency-policy/policy-id. For more information about ARNs, see [ Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the AWS General Reference guide.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The description for the policy.
    public var policyDescription: Swift.String?
    /// The name of the policy
    public var policyName: Swift.String?
    /// The tier for this resiliency policy, ranging from the highest severity (MissionCritical) to lowest (NonCritical).
    public var tier: ResiliencehubClientTypes.ResiliencyPolicyTier?

    public init(
        dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint? = nil,
        policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil,
        policyArn: Swift.String? = nil,
        policyDescription: Swift.String? = nil,
        policyName: Swift.String? = nil,
        tier: ResiliencehubClientTypes.ResiliencyPolicyTier? = nil
    )
    {
        self.dataLocationConstraint = dataLocationConstraint
        self.policy = policy
        self.policyArn = policyArn
        self.policyDescription = policyDescription
        self.policyName = policyName
        self.tier = tier
    }
}

struct UpdateResiliencyPolicyInputBody: Swift.Equatable {
    let policyArn: Swift.String?
    let policyName: Swift.String?
    let policyDescription: Swift.String?
    let dataLocationConstraint: ResiliencehubClientTypes.DataLocationConstraint?
    let tier: ResiliencehubClientTypes.ResiliencyPolicyTier?
    let policy: [Swift.String:ResiliencehubClientTypes.FailurePolicy]?
}

extension UpdateResiliencyPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocationConstraint
        case policy
        case policyArn
        case policyDescription
        case policyName
        case tier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDescription)
        policyDescription = policyDescriptionDecoded
        let dataLocationConstraintDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.DataLocationConstraint.self, forKey: .dataLocationConstraint)
        dataLocationConstraint = dataLocationConstraintDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicyTier.self, forKey: .tier)
        tier = tierDecoded
        let policyContainer = try containerValues.decodeIfPresent([Swift.String: ResiliencehubClientTypes.FailurePolicy?].self, forKey: .policy)
        var policyDecoded0: [Swift.String:ResiliencehubClientTypes.FailurePolicy]? = nil
        if let policyContainer = policyContainer {
            policyDecoded0 = [Swift.String:ResiliencehubClientTypes.FailurePolicy]()
            for (key0, failurepolicy0) in policyContainer {
                if let failurepolicy0 = failurepolicy0 {
                    policyDecoded0?[key0] = failurepolicy0
                }
            }
        }
        policy = policyDecoded0
    }
}

extension UpdateResiliencyPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResiliencyPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct UpdateResiliencyPolicyOutput: Swift.Equatable {
    /// The type of resiliency policy that was updated, including the recovery time objective (RTO) and recovery point objective (RPO) in seconds.
    /// This member is required.
    public var policy: ResiliencehubClientTypes.ResiliencyPolicy?

    public init(
        policy: ResiliencehubClientTypes.ResiliencyPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct UpdateResiliencyPolicyOutputBody: Swift.Equatable {
    let policy: ResiliencehubClientTypes.ResiliencyPolicy?
}

extension UpdateResiliencyPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(ResiliencehubClientTypes.ResiliencyPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum UpdateResiliencyPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when a request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
