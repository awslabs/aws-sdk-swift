// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception that occurs when there are not sufficient permissions to perform an action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message explaining why access was denied.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocDBElasticClientTypes {
    public enum Auth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plainText
        case secretArn
        case sdkUnknown(Swift.String)

        public static var allCases: [Auth] {
            return [
                .plainText,
                .secretArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plainText: return "PLAIN_TEXT"
            case .secretArn: return "SECRET_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Auth(rawValue: rawValue) ?? Auth.sdkUnknown(rawValue)
        }
    }
}

extension DocDBElasticClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserName
        case authType
        case clusterArn
        case clusterEndpoint
        case clusterName
        case createTime
        case kmsKeyId
        case preferredMaintenanceWindow
        case shardCapacity
        case shardCount
        case status
        case subnetIds
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserName = self.adminUserName {
            try encodeContainer.encode(adminUserName, forKey: .adminUserName)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterEndpoint = self.clusterEndpoint {
            try encodeContainer.encode(clusterEndpoint, forKey: .clusterEndpoint)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let shardCapacity = self.shardCapacity {
            try encodeContainer.encode(shardCapacity, forKey: .shardCapacity)
        }
        if let shardCount = self.shardCount {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let clusterEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterEndpoint)
        clusterEndpoint = clusterEndpointDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let adminUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserName)
        adminUserName = adminUserNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Auth.self, forKey: .authType)
        authType = authTypeDecoded
        let shardCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCapacity)
        shardCapacity = shardCapacityDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount)
        shardCount = shardCountDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension DocDBElasticClientTypes {
    /// Returns information about a specific Elastic DocumentDB cluster.
    public struct Cluster: Swift.Equatable {
        /// The name of the Elastic DocumentDB cluster administrator.
        /// This member is required.
        public var adminUserName: Swift.String?
        /// The authentication type for the Elastic DocumentDB cluster.
        /// This member is required.
        public var authType: DocDBElasticClientTypes.Auth?
        /// The arn of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// The URL used to connect to the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterEndpoint: Swift.String?
        /// The name of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterName: Swift.String?
        /// The time when the Elastic DocumentDB cluster was created in Universal Coordinated Time (UTC).
        /// This member is required.
        public var createTime: Swift.String?
        /// The KMS key identifier to use to encrypt the Elastic DocumentDB cluster.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi
        /// This member is required.
        public var preferredMaintenanceWindow: Swift.String?
        /// The capacity of each shard in the Elastic DocumentDB cluster.
        /// This member is required.
        public var shardCapacity: Swift.Int?
        /// The number of shards in the Elastic DocumentDB cluster.
        /// This member is required.
        public var shardCount: Swift.Int?
        /// The status of the Elastic DocumentDB cluster.
        /// This member is required.
        public var status: DocDBElasticClientTypes.Status?
        /// The Amazon EC2 subnet IDs for the Elastic DocumentDB cluster.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// A list of EC2 VPC security groups associated with this cluster.
        /// This member is required.
        public var vpcSecurityGroupIds: [Swift.String]?

        public init(
            adminUserName: Swift.String? = nil,
            authType: DocDBElasticClientTypes.Auth? = nil,
            clusterArn: Swift.String? = nil,
            clusterEndpoint: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            createTime: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            shardCapacity: Swift.Int? = nil,
            shardCount: Swift.Int? = nil,
            status: DocDBElasticClientTypes.Status? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil
        )
        {
            self.adminUserName = adminUserName
            self.authType = authType
            self.clusterArn = clusterArn
            self.clusterEndpoint = clusterEndpoint
            self.clusterName = clusterName
            self.createTime = createTime
            self.kmsKeyId = kmsKeyId
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.shardCapacity = shardCapacity
            self.shardCount = shardCount
            self.status = status
            self.subnetIds = subnetIds
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }
    }

}

extension DocDBElasticClientTypes.ClusterInList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn
        case clusterName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension DocDBElasticClientTypes {
    /// A list of Elastic DocumentDB cluster.
    public struct ClusterInList: Swift.Equatable {
        /// The arn of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// The name of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterName: Swift.String?
        /// The status of the Elastic DocumentDB cluster.
        /// This member is required.
        public var status: DocDBElasticClientTypes.Status?

        public init(
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            status: DocDBElasticClientTypes.Status? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.status = status
        }
    }

}

extension DocDBElasticClientTypes.ClusterSnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserName
        case clusterArn
        case clusterCreationTime
        case kmsKeyId
        case snapshotArn
        case snapshotCreationTime
        case snapshotName
        case status
        case subnetIds
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserName = self.adminUserName {
            try encodeContainer.encode(adminUserName, forKey: .adminUserName)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterCreationTime = self.clusterCreationTime {
            try encodeContainer.encode(clusterCreationTime, forKey: .clusterCreationTime)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotCreationTime = self.snapshotCreationTime {
            try encodeContainer.encode(snapshotCreationTime, forKey: .snapshotCreationTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let snapshotCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreationTime)
        snapshotCreationTime = snapshotCreationTimeDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let clusterCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreationTime)
        clusterCreationTime = clusterCreationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let adminUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserName)
        adminUserName = adminUserNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension DocDBElasticClientTypes {
    /// Returns information about a specific Elastic DocumentDB snapshot.
    public struct ClusterSnapshot: Swift.Equatable {
        /// The name of the Elastic DocumentDB cluster administrator.
        /// This member is required.
        public var adminUserName: Swift.String?
        /// The arn of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// The time when the Elastic DocumentDB cluster was created in Universal Coordinated Time (UTC).
        /// This member is required.
        public var clusterCreationTime: Swift.String?
        /// The KMS key identifier to use to encrypt the Elastic DocumentDB cluster.
        /// This member is required.
        public var kmsKeyId: Swift.String?
        /// The arn of the Elastic DocumentDB snapshot
        /// This member is required.
        public var snapshotArn: Swift.String?
        /// The time when the Elastic DocumentDB snapshot was created in Universal Coordinated Time (UTC).
        /// This member is required.
        public var snapshotCreationTime: Swift.String?
        /// The name of the Elastic DocumentDB snapshot.
        /// This member is required.
        public var snapshotName: Swift.String?
        /// The status of the Elastic DocumentDB snapshot.
        /// This member is required.
        public var status: DocDBElasticClientTypes.Status?
        /// A list of the IDs of subnets associated with the DB cluster snapshot.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// A list of the IDs of the VPC security groups associated with the cluster snapshot.
        /// This member is required.
        public var vpcSecurityGroupIds: [Swift.String]?

        public init(
            adminUserName: Swift.String? = nil,
            clusterArn: Swift.String? = nil,
            clusterCreationTime: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            snapshotCreationTime: Swift.String? = nil,
            snapshotName: Swift.String? = nil,
            status: DocDBElasticClientTypes.Status? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil
        )
        {
            self.adminUserName = adminUserName
            self.clusterArn = clusterArn
            self.clusterCreationTime = clusterCreationTime
            self.kmsKeyId = kmsKeyId
            self.snapshotArn = snapshotArn
            self.snapshotCreationTime = snapshotCreationTime
            self.snapshotName = snapshotName
            self.status = status
            self.subnetIds = subnetIds
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }
    }

}

extension DocDBElasticClientTypes.ClusterSnapshotInList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn
        case snapshotArn
        case snapshotCreationTime
        case snapshotName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let snapshotCreationTime = self.snapshotCreationTime {
            try encodeContainer.encode(snapshotCreationTime, forKey: .snapshotCreationTime)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let snapshotCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreationTime)
        snapshotCreationTime = snapshotCreationTimeDecoded
    }
}

extension DocDBElasticClientTypes {
    /// A list of Elastic DocumentDB snapshots.
    public struct ClusterSnapshotInList: Swift.Equatable {
        /// The arn of the Elastic DocumentDB cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// The arn of the Elastic DocumentDB snapshot
        /// This member is required.
        public var snapshotArn: Swift.String?
        /// The time when the Elastic DocumentDB snapshot was created in Universal Coordinated Time (UTC).
        /// This member is required.
        public var snapshotCreationTime: Swift.String?
        /// The name of the Elastic DocumentDB snapshot.
        /// This member is required.
        public var snapshotName: Swift.String?
        /// The status of the Elastic DocumentDB snapshot.
        /// This member is required.
        public var status: DocDBElasticClientTypes.Status?

        public init(
            clusterArn: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            snapshotCreationTime: Swift.String? = nil,
            snapshotName: Swift.String? = nil,
            status: DocDBElasticClientTypes.Status? = nil
        )
        {
            self.clusterArn = clusterArn
            self.snapshotArn = snapshotArn
            self.snapshotCreationTime = snapshotCreationTime
            self.snapshotName = snapshotName
            self.status = status
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an access conflict.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource where there was an access conflict.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource where there was an access conflict.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(adminUserName: \(Swift.String(describing: adminUserName)), authType: \(Swift.String(describing: authType)), clientToken: \(Swift.String(describing: clientToken)), clusterName: \(Swift.String(describing: clusterName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), shardCapacity: \(Swift.String(describing: shardCapacity)), shardCount: \(Swift.String(describing: shardCount)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), adminUserPassword: \"CONTENT_REDACTED\")"}
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserName
        case adminUserPassword
        case authType
        case clientToken
        case clusterName
        case kmsKeyId
        case preferredMaintenanceWindow
        case shardCapacity
        case shardCount
        case subnetIds
        case tags
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserName = self.adminUserName {
            try encodeContainer.encode(adminUserName, forKey: .adminUserName)
        }
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let shardCapacity = self.shardCapacity {
            try encodeContainer.encode(shardCapacity, forKey: .shardCapacity)
        }
        if let shardCount = self.shardCount {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cluster"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// The name of the Elastic DocumentDB cluster administrator. Constraints:
    ///
    /// * Must be from 1 to 63 letters or numbers.
    ///
    /// * The first character must be a letter.
    ///
    /// * Cannot be a reserved word.
    /// This member is required.
    public var adminUserName: Swift.String?
    /// The password for the Elastic DocumentDB cluster administrator and can contain any printable ASCII characters. Constraints:
    ///
    /// * Must contain from 8 to 100 characters.
    ///
    /// * Cannot contain a forward slash (/), double quote ("), or the "at" symbol (@).
    /// This member is required.
    public var adminUserPassword: Swift.String?
    /// The authentication type for the Elastic DocumentDB cluster.
    /// This member is required.
    public var authType: DocDBElasticClientTypes.Auth?
    /// The client token for the Elastic DocumentDB cluster.
    public var clientToken: Swift.String?
    /// The name of the new Elastic DocumentDB cluster. This parameter is stored as a lowercase string. Constraints:
    ///
    /// * Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    /// * The first character must be a letter.
    ///
    /// * Cannot end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    /// Example: my-cluster
    /// This member is required.
    public var clusterName: Swift.String?
    /// The KMS key identifier to use to encrypt the new Elastic DocumentDB cluster. The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a cluster using the same Amazon account that owns this KMS encryption key, you can use the KMS key alias instead of the ARN as the KMS encryption key. If an encryption key is not specified, Elastic DocumentDB uses the default encryption key that KMS creates for your account. Your account has a different default encryption key for each Amazon Region.
    public var kmsKeyId: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The capacity of each shard in the new Elastic DocumentDB cluster.
    /// This member is required.
    public var shardCapacity: Swift.Int?
    /// The number of shards to create in the new Elastic DocumentDB cluster.
    /// This member is required.
    public var shardCount: Swift.Int?
    /// The Amazon EC2 subnet IDs for the new Elastic DocumentDB cluster.
    public var subnetIds: [Swift.String]?
    /// The tags to be assigned to the new Elastic DocumentDB cluster.
    public var tags: [Swift.String:Swift.String]?
    /// A list of EC2 VPC security groups to associate with the new Elastic DocumentDB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        adminUserName: Swift.String? = nil,
        adminUserPassword: Swift.String? = nil,
        authType: DocDBElasticClientTypes.Auth? = nil,
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        shardCapacity: Swift.Int? = nil,
        shardCount: Swift.Int? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.adminUserName = adminUserName
        self.adminUserPassword = adminUserPassword
        self.authType = authType
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.kmsKeyId = kmsKeyId
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.shardCapacity = shardCapacity
        self.shardCount = shardCount
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let authType: DocDBElasticClientTypes.Auth?
    let adminUserName: Swift.String?
    let adminUserPassword: Swift.String?
    let shardCapacity: Swift.Int?
    let shardCount: Swift.Int?
    let vpcSecurityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let kmsKeyId: Swift.String?
    let clientToken: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserName
        case adminUserPassword
        case authType
        case clientToken
        case clusterName
        case kmsKeyId
        case preferredMaintenanceWindow
        case shardCapacity
        case shardCount
        case subnetIds
        case tags
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Auth.self, forKey: .authType)
        authType = authTypeDecoded
        let adminUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserName)
        adminUserName = adminUserNameDecoded
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let shardCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCapacity)
        shardCapacity = shardCapacityDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount)
        shardCount = shardCountDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// The new Elastic DocumentDB cluster that has been created.
    /// This member is required.
    public var cluster: DocDBElasticClientTypes.Cluster?

    public init(
        cluster: DocDBElasticClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    let cluster: DocDBElasticClientTypes.Cluster?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension CreateClusterSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn
        case snapshotName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let snapshotName = self.snapshotName {
            try encodeContainer.encode(snapshotName, forKey: .snapshotName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cluster-snapshot"
    }
}

public struct CreateClusterSnapshotInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB cluster that the snapshot will be taken from.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The name of the Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// The tags to be assigned to the new Elastic DocumentDB snapshot.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clusterArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clusterArn = clusterArn
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

struct CreateClusterSnapshotInputBody: Swift.Equatable {
    let clusterArn: Swift.String?
    let snapshotName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateClusterSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn
        case snapshotName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateClusterSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct CreateClusterSnapshotOutputResponse: Swift.Equatable {
    /// Returns information about the new Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshot: DocDBElasticClientTypes.ClusterSnapshot?

    public init(
        snapshot: DocDBElasticClientTypes.ClusterSnapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct CreateClusterSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: DocDBElasticClientTypes.ClusterSnapshot?
}

extension CreateClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.ClusterSnapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension DeleteClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/cluster/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DeleteClusterInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB cluster that is to be deleted.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct DeleteClusterInputBody: Swift.Equatable {
}

extension DeleteClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Swift.Equatable {
    /// Returns information about the newly deleted Elastic DocumentDB cluster.
    /// This member is required.
    public var cluster: DocDBElasticClientTypes.Cluster?

    public init(
        cluster: DocDBElasticClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Swift.Equatable {
    let cluster: DocDBElasticClientTypes.Cluster?
}

extension DeleteClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension DeleteClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotArn = snapshotArn else {
            return nil
        }
        return "/cluster-snapshot/\(snapshotArn.urlPercentEncoding())"
    }
}

public struct DeleteClusterSnapshotInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB snapshot that is to be deleted.
    /// This member is required.
    public var snapshotArn: Swift.String?

    public init(
        snapshotArn: Swift.String? = nil
    )
    {
        self.snapshotArn = snapshotArn
    }
}

struct DeleteClusterSnapshotInputBody: Swift.Equatable {
}

extension DeleteClusterSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum DeleteClusterSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct DeleteClusterSnapshotOutputResponse: Swift.Equatable {
    /// Returns information about the newly deleted Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshot: DocDBElasticClientTypes.ClusterSnapshot?

    public init(
        snapshot: DocDBElasticClientTypes.ClusterSnapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct DeleteClusterSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: DocDBElasticClientTypes.ClusterSnapshot?
}

extension DeleteClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.ClusterSnapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension GetClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/cluster/\(clusterArn.urlPercentEncoding())"
    }
}

public struct GetClusterInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

struct GetClusterInputBody: Swift.Equatable {
}

extension GetClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum GetClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct GetClusterOutputResponse: Swift.Equatable {
    /// Returns information about a specific Elastic DocumentDB cluster.
    /// This member is required.
    public var cluster: DocDBElasticClientTypes.Cluster?

    public init(
        cluster: DocDBElasticClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct GetClusterOutputResponseBody: Swift.Equatable {
    let cluster: DocDBElasticClientTypes.Cluster?
}

extension GetClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension GetClusterSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotArn = snapshotArn else {
            return nil
        }
        return "/cluster-snapshot/\(snapshotArn.urlPercentEncoding())"
    }
}

public struct GetClusterSnapshotInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshotArn: Swift.String?

    public init(
        snapshotArn: Swift.String? = nil
    )
    {
        self.snapshotArn = snapshotArn
    }
}

struct GetClusterSnapshotInputBody: Swift.Equatable {
}

extension GetClusterSnapshotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum GetClusterSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snapshot = output.snapshot
        } else {
            self.snapshot = nil
        }
    }
}

public struct GetClusterSnapshotOutputResponse: Swift.Equatable {
    /// Returns information about a specific Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshot: DocDBElasticClientTypes.ClusterSnapshot?

    public init(
        snapshot: DocDBElasticClientTypes.ClusterSnapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

struct GetClusterSnapshotOutputResponseBody: Swift.Equatable {
    let snapshot: DocDBElasticClientTypes.ClusterSnapshot?
}

extension GetClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snapshot
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.ClusterSnapshot.self, forKey: .snapshot)
        snapshot = snapshotDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListClusterSnapshotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clusterArn = clusterArn {
                let clusterArnQueryItem = ClientRuntime.URLQueryItem(name: "clusterArn".urlPercentEncoding(), value: Swift.String(clusterArn).urlPercentEncoding())
                items.append(clusterArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListClusterSnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cluster-snapshots"
    }
}

public struct ListClusterSnapshotsInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB cluster.
    public var clusterArn: Swift.String?
    /// The maximum number of entries to recieve in the response.
    public var maxResults: Swift.Int?
    /// The nextToken which is used the get the next page of data.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterSnapshotsInputBody: Swift.Equatable {
}

extension ListClusterSnapshotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum ListClusterSnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.snapshots = output.snapshots
        } else {
            self.nextToken = nil
            self.snapshots = nil
        }
    }
}

public struct ListClusterSnapshotsOutputResponse: Swift.Equatable {
    /// The response will provide a nextToken if there is more data beyond the maxResults. If there is no more data in the responce, the nextToken will not be returned.
    public var nextToken: Swift.String?
    /// A list of Elastic DocumentDB snapshots for a specified cluster.
    public var snapshots: [DocDBElasticClientTypes.ClusterSnapshotInList]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [DocDBElasticClientTypes.ClusterSnapshotInList]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

struct ListClusterSnapshotsOutputResponseBody: Swift.Equatable {
    let snapshots: [DocDBElasticClientTypes.ClusterSnapshotInList]?
    let nextToken: Swift.String?
}

extension ListClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case snapshots
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotsContainer = try containerValues.decodeIfPresent([DocDBElasticClientTypes.ClusterSnapshotInList?].self, forKey: .snapshots)
        var snapshotsDecoded0:[DocDBElasticClientTypes.ClusterSnapshotInList]? = nil
        if let snapshotsContainer = snapshotsContainer {
            snapshotsDecoded0 = [DocDBElasticClientTypes.ClusterSnapshotInList]()
            for structure0 in snapshotsContainer {
                if let structure0 = structure0 {
                    snapshotsDecoded0?.append(structure0)
                }
            }
        }
        snapshots = snapshotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/clusters"
    }
}

public struct ListClustersInput: Swift.Equatable {
    /// The maximum number of entries to recieve in the response.
    public var maxResults: Swift.Int?
    /// The nextToken which is used the get the next page of data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
}

extension ListClustersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum ListClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Swift.Equatable {
    /// A list of Elastic DocumentDB cluster.
    public var clusters: [DocDBElasticClientTypes.ClusterInList]?
    /// The response will provide a nextToken if there is more data beyond the maxResults. If there is no more data in the responce, the nextToken will not be returned.
    public var nextToken: Swift.String?

    public init(
        clusters: [DocDBElasticClientTypes.ClusterInList]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Swift.Equatable {
    let clusters: [DocDBElasticClientTypes.ClusterInList]?
    let nextToken: Swift.String?
}

extension ListClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusters
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clustersContainer = try containerValues.decodeIfPresent([DocDBElasticClientTypes.ClusterInList?].self, forKey: .clusters)
        var clustersDecoded0:[DocDBElasticClientTypes.ClusterInList]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [DocDBElasticClientTypes.ClusterInList]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags for the specified Elastic DocumentDB resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource could not be located.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An error message describing the failure.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that could not be located.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that could not be found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RestoreClusterFromSnapshotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName
        case kmsKeyId
        case subnetIds
        case tags
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension RestoreClusterFromSnapshotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let snapshotArn = snapshotArn else {
            return nil
        }
        return "/cluster-snapshot/\(snapshotArn.urlPercentEncoding())/restore"
    }
}

public struct RestoreClusterFromSnapshotInput: Swift.Equatable {
    /// The name of the Elastic DocumentDB cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The KMS key identifier to use to encrypt the new Elastic DocumentDB cluster. The KMS key identifier is the Amazon Resource Name (ARN) for the KMS encryption key. If you are creating a cluster using the same Amazon account that owns this KMS encryption key, you can use the KMS key alias instead of the ARN as the KMS encryption key. If an encryption key is not specified here, Elastic DocumentDB uses the default encryption key that KMS creates for your account. Your account has a different default encryption key for each Amazon Region.
    public var kmsKeyId: Swift.String?
    /// The arn of the Elastic DocumentDB snapshot.
    /// This member is required.
    public var snapshotArn: Swift.String?
    /// The Amazon EC2 subnet IDs for the Elastic DocumentDB cluster.
    public var subnetIds: [Swift.String]?
    /// A list of the tag names to be assigned to the restored DB cluster, in the form of an array of key-value pairs in which the key is the tag name and the value is the key value.
    public var tags: [Swift.String:Swift.String]?
    /// A list of EC2 VPC security groups to associate with the Elastic DocumentDB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        clusterName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.clusterName = clusterName
        self.kmsKeyId = kmsKeyId
        self.snapshotArn = snapshotArn
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct RestoreClusterFromSnapshotInputBody: Swift.Equatable {
    let clusterName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension RestoreClusterFromSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterName
        case kmsKeyId
        case subnetIds
        case tags
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum RestoreClusterFromSnapshotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestoreClusterFromSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RestoreClusterFromSnapshotOutputResponse: Swift.Equatable {
    /// Returns information about a the restored Elastic DocumentDB cluster.
    /// This member is required.
    public var cluster: DocDBElasticClientTypes.Cluster?

    public init(
        cluster: DocDBElasticClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RestoreClusterFromSnapshotOutputResponseBody: Swift.Equatable {
    let cluster: DocDBElasticClientTypes.Cluster?
}

extension RestoreClusterFromSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota for the action was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocDBElasticClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case inaccessibleEncryptionCreds
        case invalidSecurityGroupId
        case invalidSubnetId
        case ipAddressLimitExceeded
        case updating
        case vpcEndpointLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .creating,
                .deleting,
                .inaccessibleEncryptionCreds,
                .invalidSecurityGroupId,
                .invalidSubnetId,
                .ipAddressLimitExceeded,
                .updating,
                .vpcEndpointLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .inaccessibleEncryptionCreds: return "INACCESSIBLE_ENCRYPTION_CREDS"
            case .invalidSecurityGroupId: return "INVALID_SECURITY_GROUP_ID"
            case .invalidSubnetId: return "INVALID_SUBNET_ID"
            case .ipAddressLimitExceeded: return "IP_ADDRESS_LIMIT_EXCEEDED"
            case .updating: return "UPDATING"
            case .vpcEndpointLimitExceeded: return "VPC_ENDPOINT_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be assigned to the Elastic DocumentDB resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// ThrottlingException will be thrown when request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the operation.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The arn of the Elastic DocumentDB resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to be removed from the Elastic DocumentDB resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterInput(authType: \(Swift.String(describing: authType)), clientToken: \(Swift.String(describing: clientToken)), clusterArn: \(Swift.String(describing: clusterArn)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), shardCapacity: \(Swift.String(describing: shardCapacity)), shardCount: \(Swift.String(describing: shardCount)), subnetIds: \(Swift.String(describing: subnetIds)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), adminUserPassword: \"CONTENT_REDACTED\")"}
}

extension UpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case authType
        case clientToken
        case preferredMaintenanceWindow
        case shardCapacity
        case shardCount
        case subnetIds
        case vpcSecurityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminUserPassword = self.adminUserPassword {
            try encodeContainer.encode(adminUserPassword, forKey: .adminUserPassword)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let shardCapacity = self.shardCapacity {
            try encodeContainer.encode(shardCapacity, forKey: .shardCapacity)
        }
        if let shardCount = self.shardCount {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroupIds)
            for string0 in vpcSecurityGroupIds {
                try vpcSecurityGroupIdsContainer.encode(string0)
            }
        }
    }
}

extension UpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clusterArn = clusterArn else {
            return nil
        }
        return "/cluster/\(clusterArn.urlPercentEncoding())"
    }
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The password for the Elastic DocumentDB cluster administrator. This password can contain any printable ASCII character except forward slash (/), double quote ("), or the "at" symbol (@). Constraints: Must contain from 8 to 100 characters.
    public var adminUserPassword: Swift.String?
    /// The authentication type for the Elastic DocumentDB cluster.
    public var authType: DocDBElasticClientTypes.Auth?
    /// The client token for the Elastic DocumentDB cluster.
    public var clientToken: Swift.String?
    /// The arn of the Elastic DocumentDB cluster.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi Default: a 30-minute window selected at random from an 8-hour block of time for each Amazon Web Services Region, occurring on a random day of the week. Valid days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The capacity of each shard in the Elastic DocumentDB cluster.
    public var shardCapacity: Swift.Int?
    /// The number of shards to create in the Elastic DocumentDB cluster.
    public var shardCount: Swift.Int?
    /// The number of shards to create in the Elastic DocumentDB cluster.
    public var subnetIds: [Swift.String]?
    /// A list of EC2 VPC security groups to associate with the new Elastic DocumentDB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        adminUserPassword: Swift.String? = nil,
        authType: DocDBElasticClientTypes.Auth? = nil,
        clientToken: Swift.String? = nil,
        clusterArn: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        shardCapacity: Swift.Int? = nil,
        shardCount: Swift.Int? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.adminUserPassword = adminUserPassword
        self.authType = authType
        self.clientToken = clientToken
        self.clusterArn = clusterArn
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.shardCapacity = shardCapacity
        self.shardCount = shardCount
        self.subnetIds = subnetIds
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    let authType: DocDBElasticClientTypes.Auth?
    let shardCapacity: Swift.Int?
    let shardCount: Swift.Int?
    let vpcSecurityGroupIds: [Swift.String]?
    let subnetIds: [Swift.String]?
    let adminUserPassword: Swift.String?
    let clientToken: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminUserPassword
        case authType
        case clientToken
        case preferredMaintenanceWindow
        case shardCapacity
        case shardCount
        case subnetIds
        case vpcSecurityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authTypeDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Auth.self, forKey: .authType)
        authType = authTypeDecoded
        let shardCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCapacity)
        shardCapacity = shardCapacityDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount)
        shardCount = shardCountDecoded
        let vpcSecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcSecurityGroupIds)
        var vpcSecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
            vpcSecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in vpcSecurityGroupIdsContainer {
                if let string0 = string0 {
                    vpcSecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        vpcSecurityGroupIds = vpcSecurityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let adminUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminUserPassword)
        adminUserPassword = adminUserPasswordDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
    }
}

enum UpdateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {
    /// Returns information about the updated Elastic DocumentDB cluster.
    /// This member is required.
    public var cluster: DocDBElasticClientTypes.Cluster?

    public init(
        cluster: DocDBElasticClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputResponseBody: Swift.Equatable {
    let cluster: DocDBElasticClientTypes.Cluster?
}

extension UpdateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A structure defining a validation exception.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of the fields in which the validation exception occurred.
        public internal(set) var fieldList: [DocDBElasticClientTypes.ValidationExceptionField]? = nil
        /// An error message describing the validation exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why the validation exception occurred (one of unknownOperation, cannotParse, fieldValidationFailed, or other).
        /// This member is required.
        public internal(set) var reason: DocDBElasticClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [DocDBElasticClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DocDBElasticClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: DocDBElasticClientTypes.ValidationExceptionReason?
    let fieldList: [DocDBElasticClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DocDBElasticClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([DocDBElasticClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[DocDBElasticClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [DocDBElasticClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension DocDBElasticClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DocDBElasticClientTypes {
    /// A specific field in which a given validation exception occurred.
    public struct ValidationExceptionField: Swift.Equatable {
        /// An error message describing the validation exception in this field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field where the validation exception occurred.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DocDBElasticClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
