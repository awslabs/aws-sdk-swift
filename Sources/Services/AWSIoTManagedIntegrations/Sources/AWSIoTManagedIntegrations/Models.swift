//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAccountAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCloudConnectorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConnectorDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCredentialLockerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEventLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteManagedThingOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOtaTaskConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOtaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisioningProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterAccountAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct PutRuntimeLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct ResetRuntimeLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAccountAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCloudConnectorOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectorDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEventLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateManagedThingOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateNotificationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateOtaTaskOutput: Swift.Sendable {

    public init() { }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AbortCriteriaAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortCriteriaAction] {
            return [
                .cancel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AbortCriteriaFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortCriteriaFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one abort config criteria.
    public struct AbortConfigCriteria: Swift.Sendable {
        /// The action taken by the abort configuration.
        public var action: IoTManagedIntegrationsClientTypes.AbortCriteriaAction?
        /// Over-the-air (OTA) task abort criteria failure type.
        public var failureType: IoTManagedIntegrationsClientTypes.AbortCriteriaFailureType?
        /// The minimum number of things that must receive task execution notifications before the task can be aborted.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of over-the-air (OTA) task execution failures that must occur to initiate the last abort.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTManagedIntegrationsClientTypes.AbortCriteriaAction? = nil,
            failureType: IoTManagedIntegrationsClientTypes.AbortCriteriaFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        ) {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }
}

/// User is not authorized.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AssociationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associationDeleting
        case associationFailed
        case associationInProgress
        case associationSucceeded
        case refreshTokenExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationState] {
            return [
                .associationDeleting,
                .associationFailed,
                .associationInProgress,
                .associationSucceeded,
                .refreshTokenExpired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associationDeleting: return "ASSOCIATION_DELETING"
            case .associationFailed: return "ASSOCIATION_FAILED"
            case .associationInProgress: return "ASSOCIATION_IN_PROGRESS"
            case .associationSucceeded: return "ASSOCIATION_SUCCEEDED"
            case .refreshTokenExpired: return "REFRESH_TOKEN_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure containing information about an account association, including its identifier, state, and related metadata.
    public struct AccountAssociationItem: Swift.Sendable {
        /// The unique identifier of the account association.
        /// This member is required.
        public var accountAssociationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the account association.
        public var arn: Swift.String?
        /// The current state of the account association, indicating its status in the association lifecycle.
        /// This member is required.
        public var associationState: IoTManagedIntegrationsClientTypes.AssociationState?
        /// The identifier of the connector destination associated with this account association.
        public var connectorDestinationId: Swift.String?
        /// A description of the account association.
        public var description: Swift.String?
        /// The error message explaining any issues with the account association, if applicable.
        public var errorMessage: Swift.String?
        /// The name of the account association.
        public var name: Swift.String?

        public init(
            accountAssociationId: Swift.String? = nil,
            arn: Swift.String? = nil,
            associationState: IoTManagedIntegrationsClientTypes.AssociationState? = nil,
            connectorDestinationId: Swift.String? = nil,
            description: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.associationState = associationState
            self.connectorDestinationId = connectorDestinationId
            self.description = description
            self.errorMessage = errorMessage
            self.name = name
        }
    }
}

/// There is a conflict with the request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Internal error from the service that indicates an unexpected error or that the service is unavailable.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// Id of the affected resource
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the affected resource
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// A validation error occurred when performing the API request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateAccountAssociationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The identifier of the connector destination.
    /// This member is required.
    public var connectorDestinationId: Swift.String?
    /// A description of the account association request.
    public var description: Swift.String?
    /// The name of the destination for the new account association.
    public var name: Swift.String?
    /// A set of key/value pairs that are used to manage the account association.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        connectorDestinationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.connectorDestinationId = connectorDestinationId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateAccountAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccountAssociationInput(clientToken: \(Swift.String(describing: clientToken)), connectorDestinationId: \(Swift.String(describing: connectorDestinationId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateAccountAssociationOutput: Swift.Sendable {
    /// The identifier for the account association request.
    /// This member is required.
    public var accountAssociationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the account association.
    public var arn: Swift.String?
    /// The current state of the account association request.
    /// This member is required.
    public var associationState: IoTManagedIntegrationsClientTypes.AssociationState?
    /// Third-party IoT platform OAuth authorization server URL backed with all the required parameters to perform end-user authentication.
    /// This member is required.
    public var oAuthAuthorizationUrl: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        associationState: IoTManagedIntegrationsClientTypes.AssociationState? = nil,
        oAuthAuthorizationUrl: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.arn = arn
        self.associationState = associationState
        self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
    }
}

extension CreateAccountAssociationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccountAssociationOutput(accountAssociationId: \(Swift.String(describing: accountAssociationId)), arn: \(Swift.String(describing: arn)), associationState: \(Swift.String(describing: associationState)), oAuthAuthorizationUrl: \"CONTENT_REDACTED\")"}
}

public struct DeleteAccountAssociationInput: Swift.Sendable {
    /// The unique identifier of the account association to be deleted.
    /// This member is required.
    public var accountAssociationId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
    }
}

public struct GetAccountAssociationInput: Swift.Sendable {
    /// The unique identifier of the account association to retrieve.
    /// This member is required.
    public var accountAssociationId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
    }
}

public struct GetAccountAssociationOutput: Swift.Sendable {
    /// The unique identifier of the retrieved account association.
    /// This member is required.
    public var accountAssociationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the account association.
    public var arn: Swift.String?
    /// The current status state for the account association.
    /// This member is required.
    public var associationState: IoTManagedIntegrationsClientTypes.AssociationState?
    /// The identifier of the connector destination associated with this account association.
    public var connectorDestinationId: Swift.String?
    /// The description of the account association.
    public var description: Swift.String?
    /// The error message explaining the current account association error.
    public var errorMessage: Swift.String?
    /// The name of the account association.
    public var name: Swift.String?
    /// Third party IoT platform OAuth authorization server URL backed with all the required parameters to perform end-user authentication.
    /// This member is required.
    public var oAuthAuthorizationUrl: Swift.String?
    /// A set of key/value pairs that are used to manage the account association.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountAssociationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        associationState: IoTManagedIntegrationsClientTypes.AssociationState? = nil,
        connectorDestinationId: Swift.String? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        name: Swift.String? = nil,
        oAuthAuthorizationUrl: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.arn = arn
        self.associationState = associationState
        self.connectorDestinationId = connectorDestinationId
        self.description = description
        self.errorMessage = errorMessage
        self.name = name
        self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
        self.tags = tags
    }
}

extension GetAccountAssociationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccountAssociationOutput(accountAssociationId: \(Swift.String(describing: accountAssociationId)), arn: \(Swift.String(describing: arn)), associationState: \(Swift.String(describing: associationState)), connectorDestinationId: \(Swift.String(describing: connectorDestinationId)), description: \(Swift.String(describing: description)), errorMessage: \(Swift.String(describing: errorMessage)), name: \(Swift.String(describing: name)), oAuthAuthorizationUrl: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct ListAccountAssociationsInput: Swift.Sendable {
    /// The identifier of the connector destination to filter account associations by.
    public var connectorDestinationId: Swift.String?
    /// The maximum number of account associations to return in a single response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results.
    public var nextToken: Swift.String?

    public init(
        connectorDestinationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.connectorDestinationId = connectorDestinationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountAssociationsOutput: Swift.Sendable {
    /// The list of account associations that match the specified criteria.
    public var items: [IoTManagedIntegrationsClientTypes.AccountAssociationItem]?
    /// A token used for pagination of results when there are more account associations than can be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.AccountAssociationItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct StartAccountAssociationRefreshInput: Swift.Sendable {
    /// The unique identifier of the account association to refresh.
    /// This member is required.
    public var accountAssociationId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
    }
}

public struct StartAccountAssociationRefreshOutput: Swift.Sendable {
    /// Third-party IoT platform OAuth authorization server URL with all required parameters to perform end-user authentication during the refresh process.
    /// This member is required.
    public var oAuthAuthorizationUrl: Swift.String?

    public init(
        oAuthAuthorizationUrl: Swift.String? = nil
    ) {
        self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
    }
}

extension StartAccountAssociationRefreshOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAccountAssociationRefreshOutput(oAuthAuthorizationUrl: \"CONTENT_REDACTED\")"}
}

public struct UpdateAccountAssociationInput: Swift.Sendable {
    /// The unique identifier of the account association to update.
    /// This member is required.
    public var accountAssociationId: Swift.String?
    /// The new description to assign to the account association.
    public var description: Swift.String?
    /// The new name to assign to the account association.
    public var name: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.description = description
        self.name = name
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Configuration settings for proactively refreshing OAuth tokens before they expire.
    public struct ProactiveRefreshTokenRenewal: Swift.Sendable {
        /// The days before token expiration when the system should attempt to renew the token, specified in days.
        public var daysBeforeRenewal: Swift.Int?
        /// Indicates whether proactive refresh token renewal is enabled.
        public var enabled: Swift.Bool?

        public init(
            daysBeforeRenewal: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        ) {
            self.daysBeforeRenewal = daysBeforeRenewal
            self.enabled = enabled
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum TokenEndpointAuthenticationScheme: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case httpBasic
        case requestBodyCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenEndpointAuthenticationScheme] {
            return [
                .httpBasic,
                .requestBodyCredentials
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .httpBasic: return "HTTP_BASIC"
            case .requestBodyCredentials: return "REQUEST_BODY_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Configuration details for OAuth authentication with a third-party service.
    public struct OAuthConfig: Swift.Sendable {
        /// The authorization URL for the OAuth service, where users are directed to authenticate and authorize access.
        /// This member is required.
        public var authUrl: Swift.String?
        /// The URL where users are redirected after completing the OAuth authorization process.
        public var oAuthCompleteRedirectUrl: Swift.String?
        /// Configuration for proactively refreshing OAuth tokens before they expire.
        public var proactiveRefreshTokenRenewal: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal?
        /// The OAuth scopes requested during authorization, which define the permissions granted to the application.
        public var scope: Swift.String?
        /// The authentication scheme used when requesting tokens from the token endpoint.
        /// This member is required.
        public var tokenEndpointAuthenticationScheme: IoTManagedIntegrationsClientTypes.TokenEndpointAuthenticationScheme?
        /// The token URL for the OAuth service, where authorization codes are exchanged for access tokens.
        /// This member is required.
        public var tokenUrl: Swift.String?

        public init(
            authUrl: Swift.String? = nil,
            oAuthCompleteRedirectUrl: Swift.String? = nil,
            proactiveRefreshTokenRenewal: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal? = nil,
            scope: Swift.String? = nil,
            tokenEndpointAuthenticationScheme: IoTManagedIntegrationsClientTypes.TokenEndpointAuthenticationScheme? = nil,
            tokenUrl: Swift.String? = nil
        ) {
            self.authUrl = authUrl
            self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
            self.proactiveRefreshTokenRenewal = proactiveRefreshTokenRenewal
            self.scope = scope
            self.tokenEndpointAuthenticationScheme = tokenEndpointAuthenticationScheme
            self.tokenUrl = tokenUrl
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The authentication configuration details for a connector destination, including OAuth settings and other authentication parameters.
    public struct AuthConfig: Swift.Sendable {
        /// The OAuth configuration settings used for authentication with the third-party service.
        public var oAuth: IoTManagedIntegrationsClientTypes.OAuthConfig?

        public init(
            oAuth: IoTManagedIntegrationsClientTypes.OAuthConfig? = nil
        ) {
            self.oAuth = oAuth
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure containing updated OAuth configuration settings.
    public struct OAuthUpdate: Swift.Sendable {
        /// The updated URL where users are redirected after completing the OAuth authorization process.
        public var oAuthCompleteRedirectUrl: Swift.String?
        /// Updated configuration for proactively refreshing OAuth tokens before they expire.
        public var proactiveRefreshTokenRenewal: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal?

        public init(
            oAuthCompleteRedirectUrl: Swift.String? = nil,
            proactiveRefreshTokenRenewal: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal? = nil
        ) {
            self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
            self.proactiveRefreshTokenRenewal = proactiveRefreshTokenRenewal
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The updated authentication configuration details for a connector destination.
    public struct AuthConfigUpdate: Swift.Sendable {
        /// The updated OAuth configuration settings for the authentication configuration.
        public var oAuthUpdate: IoTManagedIntegrationsClientTypes.OAuthUpdate?

        public init(
            oAuthUpdate: IoTManagedIntegrationsClientTypes.OAuthUpdate? = nil
        ) {
            self.oAuthUpdate = oAuthUpdate
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AuthMaterialType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customProtocolQrBarCode
        case discoveredDevice
        case wifiSetupQrBarCode
        case zigbeeQrBarCode
        case zwaveQrBarCode
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMaterialType] {
            return [
                .customProtocolQrBarCode,
                .discoveredDevice,
                .wifiSetupQrBarCode,
                .zigbeeQrBarCode,
                .zwaveQrBarCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customProtocolQrBarCode: return "CUSTOM_PROTOCOL_QR_BAR_CODE"
            case .discoveredDevice: return "DISCOVERED_DEVICE"
            case .wifiSetupQrBarCode: return "WIFI_SETUP_QR_BAR_CODE"
            case .zigbeeQrBarCode: return "ZIGBEE_QR_BAR_CODE"
            case .zwaveQrBarCode: return "ZWAVE_QR_BAR_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oauth
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .oauth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oauth: return "OAUTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Action for an Amazon Web Services capability, containing the action parameters for control.
    public struct CapabilityAction: Swift.Sendable {
        /// Describe a capability action with an actionTraceId for a response command.
        public var actionTraceId: Swift.String?
        /// Describe a capability action with a name.
        /// This member is required.
        public var name: Swift.String?
        /// Describe a capability action with a capability property.
        public var parameters: Smithy.Document?
        /// Describe a capability action with an reference.
        public var ref: Swift.String?

        public init(
            actionTraceId: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: Smithy.Document? = nil,
            ref: Swift.String? = nil
        ) {
            self.actionTraceId = actionTraceId
            self.name = name
            self.parameters = parameters
            self.ref = ref
        }
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CapabilityAction(actionTraceId: \(Swift.String(describing: actionTraceId)), name: \(Swift.String(describing: name)), ref: \(Swift.String(describing: ref)), parameters: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// The capability used in capability report.
    public struct CapabilityReportCapability: Swift.Sendable {
        /// The capability actions used in the capability report.
        /// This member is required.
        public var actions: [Swift.String]?
        /// The capability events used in the capability report.
        /// This member is required.
        public var events: [Swift.String]?
        /// The id of the schema version.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the capability.
        /// This member is required.
        public var name: Swift.String?
        /// The capability properties used in the capability report.
        /// This member is required.
        public var properties: [Swift.String]?
        /// The version of the capability.
        /// This member is required.
        public var version: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            events: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [Swift.String]? = nil,
            version: Swift.String? = nil
        ) {
            self.actions = actions
            self.events = events
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The endpoint used in the capability report.
    public struct CapabilityReportEndpoint: Swift.Sendable {
        /// The capabilities used in the capability report.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.CapabilityReportCapability]?
        /// The type of device.
        /// This member is required.
        public var deviceTypes: [Swift.String]?
        /// The id of the endpoint used in the capability report.
        /// This member is required.
        public var id: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.CapabilityReportCapability]? = nil,
            deviceTypes: [Swift.String]? = nil,
            id: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.deviceTypes = deviceTypes
            self.id = id
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Report of all capabilities supported by the device.
    public struct CapabilityReport: Swift.Sendable {
        /// The endpoints used in the capability report.
        /// This member is required.
        public var endpoints: [IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint]?
        /// The numeric identifier of the node.
        public var nodeId: Swift.String?
        /// The version of the capability report.
        /// This member is required.
        public var version: Swift.String?

        public init(
            endpoints: [IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint]? = nil,
            nodeId: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case connector
        case zcl
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionFormat] {
            return [
                .aws,
                .connector,
                .zcl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .connector: return "CONNECTOR"
            case .zcl: return "ZCL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing a capability schema item that defines the functionality and features supported by a managed thing.
    public struct CapabilitySchemaItem: Swift.Sendable {
        /// The unique identifier of the capability defined in the schema.
        /// This member is required.
        public var capabilityId: Swift.String?
        /// The external identifier for the capability, used when referencing the capability outside of the AWS ecosystem.
        /// This member is required.
        public var extrinsicId: Swift.String?
        /// The version of the external capability definition, used to track compatibility with external systems.
        /// This member is required.
        public var extrinsicVersion: Swift.Int?
        /// The format of the capability schema, which defines how the schema is structured and interpreted.
        /// This member is required.
        public var format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat?
        /// The actual schema definition that describes the capability's properties, actions, and events.
        /// This member is required.
        public var schema: Smithy.Document?

        public init(
            capabilityId: Swift.String? = nil,
            extrinsicId: Swift.String? = nil,
            extrinsicVersion: Swift.Int? = nil,
            format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat? = nil,
            schema: Smithy.Document? = nil
        ) {
            self.capabilityId = capabilityId
            self.extrinsicId = extrinsicId
            self.extrinsicVersion = extrinsicVersion
            self.format = format
            self.schema = schema
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Configuration details for an AWS Lambda function used as an endpoint for a cloud connector.
    public struct LambdaConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function used as an endpoint.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        ) {
            self.arn = arn
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The configuration details for an endpoint, which defines how to connect to and communicate with external services.
    public struct EndpointConfig: Swift.Sendable {
        /// The Lambda function configuration for the endpoint, used when the endpoint communicates through an AWS Lambda function.
        public var lambda: IoTManagedIntegrationsClientTypes.LambdaConfig?

        public init(
            lambda: IoTManagedIntegrationsClientTypes.LambdaConfig? = nil
        ) {
            self.lambda = lambda
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum EndpointType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCloudConnectorInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// A description of the C2C connector.
    public var description: Swift.String?
    /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
    /// This member is required.
    public var endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig?
    /// The type of endpoint used for the cloud connector, which defines how the connector communicates with external services.
    public var endpointType: IoTManagedIntegrationsClientTypes.EndpointType?
    /// The display name of the C2C connector.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig? = nil,
        endpointType: IoTManagedIntegrationsClientTypes.EndpointType? = nil,
        name: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.endpointConfig = endpointConfig
        self.endpointType = endpointType
        self.name = name
    }
}

public struct CreateCloudConnectorOutput: Swift.Sendable {
    /// The unique identifier assigned to the newly created cloud connector.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct DeleteCloudConnectorInput: Swift.Sendable {
    /// The identifier of the cloud connector.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetCloudConnectorInput: Swift.Sendable {
    /// The identifier of the C2C connector.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum CloudConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case listed
        case unlisted
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudConnectorType] {
            return [
                .listed,
                .unlisted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .listed: return "LISTED"
            case .unlisted: return "UNLISTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCloudConnectorOutput: Swift.Sendable {
    /// A description of the C2C connector.
    public var description: Swift.String?
    /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
    /// This member is required.
    public var endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig?
    /// The type of endpoint used for the cloud connector, which defines how the connector communicates with external services.
    public var endpointType: IoTManagedIntegrationsClientTypes.EndpointType?
    /// The unique identifier of the cloud connector.
    public var id: Swift.String?
    /// The display name of the C2C connector.
    /// This member is required.
    public var name: Swift.String?
    /// The type of cloud connector created.
    public var type: IoTManagedIntegrationsClientTypes.CloudConnectorType?

    public init(
        description: Swift.String? = nil,
        endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig? = nil,
        endpointType: IoTManagedIntegrationsClientTypes.EndpointType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.CloudConnectorType? = nil
    ) {
        self.description = description
        self.endpointConfig = endpointConfig
        self.endpointType = endpointType
        self.id = id
        self.name = name
        self.type = type
    }
}

public struct ListCloudConnectorsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Lambda function to filter cloud connectors by.
    public var lambdaArn: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The type of cloud connectors to filter by when listing available connectors.
    public var type: IoTManagedIntegrationsClientTypes.CloudConnectorType?

    public init(
        lambdaArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.CloudConnectorType? = nil
    ) {
        self.lambdaArn = lambdaArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a connector.
    public struct ConnectorItem: Swift.Sendable {
        /// A description of the C2C connector.
        public var description: Swift.String?
        /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
        /// This member is required.
        public var endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig?
        /// The type of endpoint used for the C2C connector.
        public var endpointType: IoTManagedIntegrationsClientTypes.EndpointType?
        /// The identifier of the C2C connector.
        public var id: Swift.String?
        /// The display name of the C2C connector.
        /// This member is required.
        public var name: Swift.String?
        /// The type of cloud connector created.
        public var type: IoTManagedIntegrationsClientTypes.CloudConnectorType?

        public init(
            description: Swift.String? = nil,
            endpointConfig: IoTManagedIntegrationsClientTypes.EndpointConfig? = nil,
            endpointType: IoTManagedIntegrationsClientTypes.EndpointType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTManagedIntegrationsClientTypes.CloudConnectorType? = nil
        ) {
            self.description = description
            self.endpointConfig = endpointConfig
            self.endpointType = endpointType
            self.id = id
            self.name = name
            self.type = type
        }
    }
}

public struct ListCloudConnectorsOutput: Swift.Sendable {
    /// The list of connectors.
    public var items: [IoTManagedIntegrationsClientTypes.ConnectorItem]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ConnectorItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateCloudConnectorInput: Swift.Sendable {
    /// The new description to assign to the cloud connector.
    public var description: Swift.String?
    /// The unique identifier of the cloud connector to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The new display name to assign to the cloud connector.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.description = description
        self.identifier = identifier
        self.name = name
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The command capabilities added for the managed thing
    public struct CommandCapability: Swift.Sendable {
        /// Describe the command capability with the actions it supports.
        /// This member is required.
        public var actions: [IoTManagedIntegrationsClientTypes.CapabilityAction]?
        /// Describe the capability with an id.
        /// This member is required.
        public var id: Swift.String?
        /// Describe the capability with an name.
        /// This member is required.
        public var name: Swift.String?
        /// Describe the capability with a version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            actions: [IoTManagedIntegrationsClientTypes.CapabilityAction]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.actions = actions
            self.id = id
            self.name = name
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The endpoint for a managed thing when sending a command.
    public struct CommandEndpoint: Swift.Sendable {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for sending commands.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.CommandCapability]?
        /// The id of the endpoint for a managed thing.
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.CommandCapability]? = nil,
            endpointId: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Provides the default encryption configuration error update details.
    public struct ConfigurationError: Swift.Sendable {
        /// The error code returned when the default encryption configuration update fails.
        public var code: Swift.String?
        /// The error message returned when the default encryption configuration update fails.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ConfigurationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .enabled,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    public struct ConfigurationStatus: Swift.Sendable {
        /// The error details describing a failed default encryption configuration update.
        public var error: IoTManagedIntegrationsClientTypes.ConfigurationError?
        /// The status state describing the default encryption configuration update.
        /// This member is required.
        public var state: IoTManagedIntegrationsClientTypes.ConfigurationState?

        public init(
            error: IoTManagedIntegrationsClientTypes.ConfigurationError? = nil,
            state: IoTManagedIntegrationsClientTypes.ConfigurationState? = nil
        ) {
            self.error = error
            self.state = state
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure containing summary information about a connector destination, which defines how a cloud-to-cloud connector connects to a customer's AWS account.
    public struct ConnectorDestinationSummary: Swift.Sendable {
        /// The identifier of the cloud connector associated with this connector destination.
        public var cloudConnectorId: Swift.String?
        /// A description of the connector destination.
        public var description: Swift.String?
        /// The unique identifier of the connector destination.
        public var id: Swift.String?
        /// The display name of the connector destination.
        public var name: Swift.String?

        public init(
            cloudConnectorId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.cloudConnectorId = cloudConnectorId
            self.description = description
            self.id = id
            self.name = name
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Configuration for AWS Secrets Manager, used to securely store and manage sensitive information for connector destinations.
    public struct SecretsManager: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret.
        /// This member is required.
        public var arn: Swift.String?
        /// The version ID of the AWS Secrets Manager secret.
        /// This member is required.
        public var versionId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            versionId: Swift.String? = nil
        ) {
            self.arn = arn
            self.versionId = versionId
        }
    }
}

public struct CreateConnectorDestinationInput: Swift.Sendable {
    /// The authentication configuration details for the connector destination, including OAuth settings and other authentication parameters.
    /// This member is required.
    public var authConfig: IoTManagedIntegrationsClientTypes.AuthConfig?
    /// The authentication type used for the connector destination, which determines how credentials and access are managed.
    /// This member is required.
    public var authType: IoTManagedIntegrationsClientTypes.AuthType?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The identifier of the C2C connector.
    /// This member is required.
    public var cloudConnectorId: Swift.String?
    /// A description of the connector destination.
    public var description: Swift.String?
    /// The display name of the connector destination.
    public var name: Swift.String?
    /// The AWS Secrets Manager configuration used to securely store and manage sensitive information for the connector destination.
    /// This member is required.
    public var secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager?

    public init(
        authConfig: IoTManagedIntegrationsClientTypes.AuthConfig? = nil,
        authType: IoTManagedIntegrationsClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        cloudConnectorId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager? = nil
    ) {
        self.authConfig = authConfig
        self.authType = authType
        self.clientToken = clientToken
        self.cloudConnectorId = cloudConnectorId
        self.description = description
        self.name = name
        self.secretsManager = secretsManager
    }
}

public struct CreateConnectorDestinationOutput: Swift.Sendable {
    /// The identifier of the C2C connector destination creation request.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct DeleteConnectorDestinationInput: Swift.Sendable {
    /// The identifier of the connector destination.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetConnectorDestinationInput: Swift.Sendable {
    /// The identifier of the C2C connector destination.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetConnectorDestinationOutput: Swift.Sendable {
    /// The authentication configuration details for the connector destination, including OAuth settings and other authentication parameters.
    public var authConfig: IoTManagedIntegrationsClientTypes.AuthConfig?
    /// The authentication type used for the connector destination, which determines how credentials and access are managed.
    public var authType: IoTManagedIntegrationsClientTypes.AuthType?
    /// The identifier of the C2C connector.
    public var cloudConnectorId: Swift.String?
    /// A description of the connector destination.
    public var description: Swift.String?
    /// The unique identifier of the connector destination.
    public var id: Swift.String?
    /// The display name of the connector destination.
    public var name: Swift.String?
    /// The URL where users are redirected after completing the OAuth authorization process for the connector destination.
    public var oAuthCompleteRedirectUrl: Swift.String?
    /// The AWS Secrets Manager configuration used to securely store and manage sensitive information for the connector destination.
    public var secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager?

    public init(
        authConfig: IoTManagedIntegrationsClientTypes.AuthConfig? = nil,
        authType: IoTManagedIntegrationsClientTypes.AuthType? = nil,
        cloudConnectorId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        oAuthCompleteRedirectUrl: Swift.String? = nil,
        secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager? = nil
    ) {
        self.authConfig = authConfig
        self.authType = authType
        self.cloudConnectorId = cloudConnectorId
        self.description = description
        self.id = id
        self.name = name
        self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
        self.secretsManager = secretsManager
    }
}

public struct ListConnectorDestinationsInput: Swift.Sendable {
    /// The identifier of the cloud connector to filter connector destinations by.
    public var cloudConnectorId: Swift.String?
    /// The maximum number of connector destinations to return in a single response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results.
    public var nextToken: Swift.String?

    public init(
        cloudConnectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.cloudConnectorId = cloudConnectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorDestinationsOutput: Swift.Sendable {
    /// The list of connector destinations that match the specified criteria.
    public var connectorDestinationList: [IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary]?
    /// A token used for pagination of results when there are more connector destinations than can be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        connectorDestinationList: [IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.connectorDestinationList = connectorDestinationList
        self.nextToken = nextToken
    }
}

public struct UpdateConnectorDestinationInput: Swift.Sendable {
    /// The updated authentication configuration details for the connector destination.
    public var authConfig: IoTManagedIntegrationsClientTypes.AuthConfigUpdate?
    /// The new authentication type to use for the connector destination.
    public var authType: IoTManagedIntegrationsClientTypes.AuthType?
    /// The new description to assign to the connector destination.
    public var description: Swift.String?
    /// The unique identifier of the connector destination to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The new display name to assign to the connector destination.
    public var name: Swift.String?
    /// The updated AWS Secrets Manager configuration for the connector destination.
    public var secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager?

    public init(
        authConfig: IoTManagedIntegrationsClientTypes.AuthConfigUpdate? = nil,
        authType: IoTManagedIntegrationsClientTypes.AuthType? = nil,
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        secretsManager: IoTManagedIntegrationsClientTypes.SecretsManager? = nil
    ) {
        self.authConfig = authConfig
        self.authType = authType
        self.description = description
        self.identifier = identifier
        self.name = name
        self.secretsManager = secretsManager
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ConnectorEventOperation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deviceCommandRequest
        case deviceCommandResponse
        case deviceDiscovery
        case deviceEvent
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorEventOperation] {
            return [
                .deviceCommandRequest,
                .deviceCommandResponse,
                .deviceDiscovery,
                .deviceEvent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deviceCommandRequest: return "DEVICE_COMMAND_REQUEST"
            case .deviceCommandResponse: return "DEVICE_COMMAND_RESPONSE"
            case .deviceDiscovery: return "DEVICE_DISCOVERY"
            case .deviceEvent: return "DEVICE_EVENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The service quota has been exceeded for this request.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateCredentialLockerInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the credential locker.
    public var name: Swift.String?
    /// A set of key/value pairs that are used to manage the credential locker.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

extension CreateCredentialLockerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCredentialLockerInput(clientToken: \(Swift.String(describing: clientToken)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateCredentialLockerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the credential locker.
    public var arn: Swift.String?
    /// The timestamp value of when the credential locker request occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker creation request.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DeliveryDestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kinesis
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryDestinationType] {
            return [
                .kinesis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kinesis: return "KINESIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDestinationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    /// This member is required.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    /// This member is required.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of key/value pairs that are used to manage the destination.
    @available(*, deprecated, message: "Tags have been deprecated from this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDestinationInput(clientToken: \(Swift.String(describing: clientToken)), deliveryDestinationArn: \(Swift.String(describing: deliveryDestinationArn)), deliveryDestinationType: \(Swift.String(describing: deliveryDestinationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateDestinationOutput: Swift.Sendable {
    /// The name of the customer-managed destination.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum LogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEventLogConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The logging level for the event log configuration.
    /// This member is required.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The identifier of the resource for the event log configuration.
    public var resourceId: Swift.String?
    /// The type of resource for the event log configuration.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.eventLogLevel = eventLogLevel
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct CreateEventLogConfigurationOutput: Swift.Sendable {
    /// The identifier of the event log configuration request.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case controller
        case device
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .controller,
                .device
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .controller: return "CONTROLLER"
            case .device: return "DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateManagedThingInput: Swift.Sendable {
    /// The authentication material defining the device connectivity setup requests. The authentication materials used are the device bar code.
    /// This member is required.
    public var authenticationMaterial: Swift.String?
    /// The type of authentication material used for device connectivity setup requests.
    /// This member is required.
    public var authenticationMaterialType: IoTManagedIntegrationsClientTypes.AuthMaterialType?
    /// The brand of the device.
    public var brand: Swift.String?
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The capability schemas that define the functionality and features supported by the managed thing, including device capabilities and their associated properties.
    public var capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The identifier of the credential for the managed thing.
    public var credentialLockerId: Swift.String?
    /// The metadata for the managed thing. The managedThingmetadata parameter is used for associating attributes with a managedThing that can be used for grouping over-the-air (OTA) tasks. Name value pairs in metadata can be used in the OtaTargetQueryString parameter for the CreateOtaTask API operation.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// The type of device used. This will be the hub controller, cloud device, or AWS IoT device.
    /// This member is required.
    public var role: IoTManagedIntegrationsClientTypes.Role?
    /// The serial number of the device.
    public var serialNumber: Swift.String?
    /// A set of key/value pairs that are used to manage the managed thing.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authenticationMaterial: Swift.String? = nil,
        authenticationMaterialType: IoTManagedIntegrationsClientTypes.AuthMaterialType? = nil,
        brand: Swift.String? = nil,
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]? = nil,
        classification: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        credentialLockerId: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        role: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authenticationMaterial = authenticationMaterial
        self.authenticationMaterialType = authenticationMaterialType
        self.brand = brand
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.capabilitySchemas = capabilitySchemas
        self.classification = classification
        self.clientToken = clientToken
        self.credentialLockerId = credentialLockerId
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.role = role
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

extension CreateManagedThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateManagedThingInput(authenticationMaterialType: \(Swift.String(describing: authenticationMaterialType)), capabilities: \(Swift.String(describing: capabilities)), capabilityReport: \(Swift.String(describing: capabilityReport)), capabilitySchemas: \(Swift.String(describing: capabilitySchemas)), clientToken: \(Swift.String(describing: clientToken)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), role: \(Swift.String(describing: role)), authenticationMaterial: \"CONTENT_REDACTED\", brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateManagedThingOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the managed thing.
    public var arn: Swift.String?
    /// The timestamp value of when the device creation request occurred.
    public var createdAt: Foundation.Date?
    /// The id of the managed thing.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountAssociation
        case connectorAssociation
        case connectorErrorReport
        case deviceCommand
        case deviceCommandRequest
        case deviceDiscoveryStatus
        case deviceEvent
        case deviceLifeCycle
        case deviceOta
        case deviceState
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .accountAssociation,
                .connectorAssociation,
                .connectorErrorReport,
                .deviceCommand,
                .deviceCommandRequest,
                .deviceDiscoveryStatus,
                .deviceEvent,
                .deviceLifeCycle,
                .deviceOta,
                .deviceState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountAssociation: return "ACCOUNT_ASSOCIATION"
            case .connectorAssociation: return "CONNECTOR_ASSOCIATION"
            case .connectorErrorReport: return "CONNECTOR_ERROR_REPORT"
            case .deviceCommand: return "DEVICE_COMMAND"
            case .deviceCommandRequest: return "DEVICE_COMMAND_REQUEST"
            case .deviceDiscoveryStatus: return "DEVICE_DISCOVERY_STATUS"
            case .deviceEvent: return "DEVICE_EVENT"
            case .deviceLifeCycle: return "DEVICE_LIFE_CYCLE"
            case .deviceOta: return "DEVICE_OTA"
            case .deviceState: return "DEVICE_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNotificationConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the destination for the notification configuration.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?
    /// A set of key/value pairs that are used to manage the notification configuration.
    @available(*, deprecated, message: "Tags has been deprecated from this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.destinationName = destinationName
        self.eventType = eventType
        self.tags = tags
    }
}

extension CreateNotificationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNotificationConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), destinationName: \(Swift.String(describing: destinationName)), eventType: \(Swift.String(describing: eventType)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNotificationConfigurationOutput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaMechanism: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case push
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaMechanism] {
            return [
                .push
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .push: return "PUSH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchedulingConfigEndBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case forceCancel
        case stopRollout
        case sdkUnknown(Swift.String)

        public static var allCases: [SchedulingConfigEndBehavior] {
            return [
                .cancel,
                .forceCancel,
                .stopRollout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case .forceCancel: return "FORCE_CANCEL"
            case .stopRollout: return "STOP_ROLLOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing scheduling maintenance window.
    public struct ScheduleMaintenanceWindow: Swift.Sendable {
        /// Displays the duration of the next maintenance window.
        public var durationInMinutes: Swift.Int?
        /// Displays the start time of the next maintenance window.
        public var startTime: Swift.String?

        public init(
            durationInMinutes: Swift.Int? = nil,
            startTime: Swift.String? = nil
        ) {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task scheduling config.
    public struct OtaTaskSchedulingConfig: Swift.Sendable {
        /// Specifies the end behavior for all task executions after a task reaches the selected endTime. If endTime is not selected when creating the task, then endBehavior does not apply.
        public var endBehavior: IoTManagedIntegrationsClientTypes.SchedulingConfigEndBehavior?
        /// The time an over-the-air (OTA) task will stop.
        public var endTime: Swift.String?
        /// Maintenance window list for over-the-air (OTA) task scheduling config.
        public var maintenanceWindows: [IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow]?
        /// The time an over-the-air (OTA) task will start.
        public var startTime: Swift.String?

        public init(
            endBehavior: IoTManagedIntegrationsClientTypes.SchedulingConfigEndBehavior? = nil,
            endTime: Swift.String? = nil,
            maintenanceWindows: [IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow]? = nil,
            startTime: Swift.String? = nil
        ) {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum RetryCriteriaFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [RetryCriteriaFailureType] {
            return [
                .all,
                .failed,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one retry config criteria.
    public struct RetryConfigCriteria: Swift.Sendable {
        /// Over-the-air (OTA) retry criteria failure type.
        public var failureType: IoTManagedIntegrationsClientTypes.RetryCriteriaFailureType?
        /// The number of retries allowed for a failure type for the over-the-air (OTA) task.
        public var minNumberOfRetries: Swift.Int?

        public init(
            failureType: IoTManagedIntegrationsClientTypes.RetryCriteriaFailureType? = nil,
            minNumberOfRetries: Swift.Int? = nil
        ) {
            self.failureType = failureType
            self.minNumberOfRetries = minNumberOfRetries
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task retry config.
    public struct OtaTaskExecutionRetryConfig: Swift.Sendable {
        /// The list of retry config criteria.
        public var retryConfigCriteria: [IoTManagedIntegrationsClientTypes.RetryConfigCriteria]?

        public init(
            retryConfigCriteria: [IoTManagedIntegrationsClientTypes.RetryConfigCriteria]? = nil
        ) {
            self.retryConfigCriteria = retryConfigCriteria
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuous
        case oneTime
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaType] {
            return [
                .continuous,
                .oneTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .oneTime: return "ONE_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaProtocol] {
            return [
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOtaTaskInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The deployment mechanism for the over-the-air (OTA) task.
    public var otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism?
    /// Over-the-air (OTA) task scheduling config.
    public var otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?
    /// The query string to add things to the thing group.
    public var otaTargetQueryString: Swift.String?
    /// Over-the-air (OTA) task retry config.
    public var otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?
    /// The frequency type for the over-the-air (OTA) task.
    /// This member is required.
    public var otaType: IoTManagedIntegrationsClientTypes.OtaType?
    /// The connection protocol the over-the-air (OTA) task uses to update the device.
    public var `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol?
    /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
    /// This member is required.
    public var s3Url: Swift.String?
    /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
    public var tags: [Swift.String: Swift.String]?
    /// The device targeted for the over-the-air (OTA) task.
    public var target: [Swift.String]?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism? = nil,
        otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig? = nil,
        otaTargetQueryString: Swift.String? = nil,
        otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig? = nil,
        otaType: IoTManagedIntegrationsClientTypes.OtaType? = nil,
        `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol? = nil,
        s3Url: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: [Swift.String]? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.otaMechanism = otaMechanism
        self.otaSchedulingConfig = otaSchedulingConfig
        self.otaTargetQueryString = otaTargetQueryString
        self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
        self.otaType = otaType
        self.`protocol` = `protocol`
        self.s3Url = s3Url
        self.tags = tags
        self.target = target
        self.taskConfigurationId = taskConfigurationId
    }
}

extension CreateOtaTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOtaTaskInput(protocol: \(Swift.String(describing: `protocol`)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), otaMechanism: \(Swift.String(describing: otaMechanism)), otaSchedulingConfig: \(Swift.String(describing: otaSchedulingConfig)), otaTargetQueryString: \(Swift.String(describing: otaTargetQueryString)), otaTaskExecutionRetryConfig: \(Swift.String(describing: otaTaskExecutionRetryConfig)), otaType: \(Swift.String(describing: otaType)), s3Url: \(Swift.String(describing: s3Url)), target: \(Swift.String(describing: target)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateOtaTaskOutput: Swift.Sendable {
    /// A description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
    public var taskArn: Swift.String?
    /// The identifier of the over-the-air (OTA) task.
    public var taskId: Swift.String?

    public init(
        description: Swift.String? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    ) {
        self.description = description
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task abort config.
    public struct OtaTaskAbortConfig: Swift.Sendable {
        /// The list of criteria for the abort config.
        public var abortConfigCriteriaList: [IoTManagedIntegrationsClientTypes.AbortConfigCriteria]?

        public init(
            abortConfigCriteriaList: [IoTManagedIntegrationsClientTypes.AbortConfigCriteria]? = nil
        ) {
            self.abortConfigCriteriaList = abortConfigCriteriaList
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing rollout config criteria.
    public struct RolloutRateIncreaseCriteria: Swift.Sendable {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public var numberOfNotifiedThings: Swift.Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        ) {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
    public struct ExponentialRolloutRate: Swift.Sendable {
        /// The base rate per minute for the rollout of an over-the-air (OTA) task.
        public var baseRatePerMinute: Swift.Int?
        /// The incremental factor for increasing the rollout rate of an over-the-air (OTA) task.
        public var incrementFactor: Swift.Double?
        /// The criteria for increasing the rollout rate of an over-the-air (OTA) task.
        public var rateIncreaseCriteria: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double? = nil,
            rateIncreaseCriteria: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria? = nil
        ) {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task rollout config.
    public struct OtaTaskExecutionRolloutConfig: Swift.Sendable {
        /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
        public var exponentialRolloutRate: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending task, per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRolloutRate: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        ) {
            self.exponentialRolloutRate = exponentialRolloutRate
            self.maximumPerMinute = maximumPerMinute
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task timeout config.
    public struct OtaTaskTimeoutConfig: Swift.Sendable {
        /// Specifies the amount of time the device has to finish execution of this task. The timeout interval can be anywhere between 1 minute and 7 days.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        ) {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing a push config.
    public struct PushConfig: Swift.Sendable {
        /// Structure representing one abort config.
        public var abortConfig: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig?
        /// Structure representing one rollout config.
        public var rolloutConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig?
        /// Structure representing one timeout config.
        public var timeoutConfig: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig?

        public init(
            abortConfig: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig? = nil,
            rolloutConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig? = nil,
            timeoutConfig: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig? = nil
        ) {
            self.abortConfig = abortConfig
            self.rolloutConfig = rolloutConfig
            self.timeoutConfig = timeoutConfig
        }
    }
}

public struct CreateOtaTaskConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// A description of the over-the-air (OTA) task configuration.
    public var description: Swift.String?
    /// The name of the over-the-air (OTA) task.
    public var name: Swift.String?
    /// Describes the type of configuration used for the over-the-air (OTA) task.
    public var pushConfig: IoTManagedIntegrationsClientTypes.PushConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pushConfig: IoTManagedIntegrationsClientTypes.PushConfig? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.pushConfig = pushConfig
    }
}

extension CreateOtaTaskConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOtaTaskConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), pushConfig: \(Swift.String(describing: pushConfig)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateOtaTaskConfigurationOutput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        taskConfigurationId: Swift.String? = nil
    ) {
        self.taskConfigurationId = taskConfigurationId
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ProvisioningType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fleetProvisioning
        case jitr
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningType] {
            return [
                .fleetProvisioning,
                .jitr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fleetProvisioning: return "FLEET_PROVISIONING"
            case .jitr: return "JITR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisioningProfileInput: Swift.Sendable {
    /// The id of the certificate authority (CA) certificate.
    public var caCertificate: Swift.String?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    /// This member is required.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?
    /// A set of key/value pairs that are used to manage the provisioning profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        caCertificate: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.caCertificate = caCertificate
        self.clientToken = clientToken
        self.name = name
        self.provisioningType = provisioningType
        self.tags = tags
    }
}

extension CreateProvisioningProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningProfileInput(clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), caCertificate: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateProvisioningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
    public var arn: Swift.String?
    /// The id of the claim certificate.
    public var claimCertificate: Swift.String?
    /// The private key of the claim certificate. This is stored securely on the device for validating the connection endpoint with IoT managed integrations using the public key.
    public var claimCertificatePrivateKey: Swift.String?
    /// The identifier of the provisioning profile.
    public var id: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?

    public init(
        arn: Swift.String? = nil,
        claimCertificate: Swift.String? = nil,
        claimCertificatePrivateKey: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil
    ) {
        self.arn = arn
        self.claimCertificate = claimCertificate
        self.claimCertificatePrivateKey = claimCertificatePrivateKey
        self.id = id
        self.name = name
        self.provisioningType = provisioningType
    }
}

extension CreateProvisioningProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningProfileOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), claimCertificate: \"CONTENT_REDACTED\", claimCertificatePrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing one Credential Locker.
    public struct CredentialLockerSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public var arn: Swift.String?
        /// The timestampe value of when the credential locker was created at.
        public var createdAt: Foundation.Date?
        /// The id of the credential locker.
        public var id: Swift.String?
        /// The name of the credential locker.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
        }
    }
}

extension IoTManagedIntegrationsClientTypes.CredentialLockerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CredentialLockerSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

public struct DeleteCredentialLockerInput: Swift.Sendable {
    /// The identifier of the credential locker.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetCredentialLockerInput: Swift.Sendable {
    /// The identifier of the credential locker.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetCredentialLockerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the credential locker.
    public var arn: Swift.String?
    /// The timestamp value of when the credential locker requset occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker.
    public var id: Swift.String?
    /// The name of the credential locker.
    public var name: Swift.String?
    /// A set of key/value pairs that are used to manage the credential locker.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.tags = tags
    }
}

extension GetCredentialLockerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialLockerOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct ListCredentialLockersInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCredentialLockersOutput: Swift.Sendable {
    /// The list of credential lockers.
    public var items: [IoTManagedIntegrationsClientTypes.CredentialLockerSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.CredentialLockerSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct DeleteDestinationInput: Swift.Sendable {
    /// The id of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct DeleteEventLogConfigurationInput: Swift.Sendable {
    /// The identifier of the event log configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct DeleteManagedThingInput: Swift.Sendable {
    /// When set to TRUE, a forceful deteletion of the managed thing will occur. When set to FALSE, a non-forceful deletion of the managed thing will occur.
    public var force: Swift.Bool?
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        identifier: Swift.String? = nil
    ) {
        self.force = force
        self.identifier = identifier
    }
}

public struct DeleteNotificationConfigurationInput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

/// The request exceeds a service limit or quota. Adjust your request parameters and try again.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteOtaTaskInput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DeleteOtaTaskConfigurationInput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DeleteProvisioningProfileInput: Swift.Sendable {
    /// The name of the provisioning template.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

/// Request for deregister a managed thing from account association
public struct DeregisterAccountAssociationInput: Swift.Sendable {
    /// The unique identifier of the account association to be deregistered.
    /// This member is required.
    public var accountAssociationId: Swift.String?
    /// The identifier of the managed thing to be deregistered from the account association.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.managedThingId = managedThingId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a destination for IoT managed integrations to deliver notifications for a device.
    public struct DestinationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public var deliveryDestinationArn: Swift.String?
        /// The destination type for the customer-managed destination.
        public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public var description: Swift.String?
        /// The name of the customer-managed destination.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the delivery destination.
        public var roleArn: Swift.String?

        public init(
            deliveryDestinationArn: Swift.String? = nil,
            deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        ) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }
    }
}

public struct GetDestinationInput: Swift.Sendable {
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct GetDestinationOutput: Swift.Sendable {
    /// The timestamp value of when the destination creation requset occurred.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    public var roleArn: Swift.String?
    /// A set of key/value pairs that are used to manage the customer-managed destination.
    @available(*, deprecated, message: "Tags has been deprecated from this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp value of when the destination update requset occurred.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension GetDestinationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDestinationOutput(createdAt: \(Swift.String(describing: createdAt)), deliveryDestinationArn: \(Swift.String(describing: deliveryDestinationArn)), deliveryDestinationType: \(Swift.String(describing: deliveryDestinationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), updatedAt: \(Swift.String(describing: updatedAt)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListDestinationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDestinationsOutput: Swift.Sendable {
    /// The list of destinations.
    public var destinationList: [IoTManagedIntegrationsClientTypes.DestinationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        destinationList: [IoTManagedIntegrationsClientTypes.DestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

public struct UpdateDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    public var roleArn: Swift.String?

    public init(
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Matter attribute used in capability report.
    public struct MatterCapabilityReportAttribute: Swift.Sendable {
        /// The id of the Matter attribute.
        public var id: Swift.String?
        /// Name for the Amazon Web Services Matter capability report attribute.
        public var name: Swift.String?
        /// Value for the Amazon Web Services Matter capability report attribute.
        public var value: Smithy.Document?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            value: Smithy.Document? = nil
        ) {
            self.id = id
            self.name = name
            self.value = value
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Capability used in Matter capability report.
    public struct MatterCapabilityReportCluster: Swift.Sendable {
        /// The attributes of the Amazon Web Services Matter capability report.
        public var attributes: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportAttribute]?
        /// The commands used with the Amazon Web Services Matter capability report.
        public var commands: [Swift.String]?
        /// The events used with the Amazon Web Services Matter capability report.
        public var events: [Swift.String]?
        /// The fabric index for the Amazon Web Services Matter capability report.
        public var fabricIndex: Swift.Int?
        /// 32 bit-map used to indicate which features a cluster supports.
        public var featureMap: Swift.Int?
        /// Matter clusters used in capability report.
        public var generatedCommands: [Swift.String]?
        /// The id of the Amazon Web Services Matter capability report cluster.
        /// This member is required.
        public var id: Swift.String?
        /// The capability name used in the Amazon Web Services Matter capability report.
        public var name: Swift.String?
        /// The id of the schema version.
        public var publicId: Swift.String?
        /// The id of the revision for the Amazon Web Services Matter capability report.
        /// This member is required.
        public var revision: Swift.Int?
        /// The spec version used in the Amazon Web Services Matter capability report.
        public var specVersion: Swift.String?

        public init(
            attributes: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportAttribute]? = nil,
            commands: [Swift.String]? = nil,
            events: [Swift.String]? = nil,
            fabricIndex: Swift.Int? = nil,
            featureMap: Swift.Int? = nil,
            generatedCommands: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            publicId: Swift.String? = nil,
            revision: Swift.Int? = nil,
            specVersion: Swift.String? = nil
        ) {
            self.attributes = attributes
            self.commands = commands
            self.events = events
            self.fabricIndex = fabricIndex
            self.featureMap = featureMap
            self.generatedCommands = generatedCommands
            self.id = id
            self.name = name
            self.publicId = publicId
            self.revision = revision
            self.specVersion = specVersion
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Matter endpoint used in capability report.
    public struct MatterCapabilityReportEndpoint: Swift.Sendable {
        /// Semantic information related to endpoint.
        public var clientClusters: [Swift.String]?
        /// Matter clusters used in capability report.
        /// This member is required.
        public var clusters: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportCluster]?
        /// The type of device.
        /// This member is required.
        public var deviceTypes: [Swift.String]?
        /// The id of the Amazon Web Services Matter capability report endpoint.
        /// This member is required.
        public var id: Swift.String?
        /// Heirachy of child endpoints contained in the given endpoint.
        public var parts: [Swift.String]?
        /// Semantic information related to endpoint.
        public var semanticTags: [Swift.String]?

        public init(
            clientClusters: [Swift.String]? = nil,
            clusters: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportCluster]? = nil,
            deviceTypes: [Swift.String]? = nil,
            id: Swift.String? = nil,
            parts: [Swift.String]? = nil,
            semanticTags: [Swift.String]? = nil
        ) {
            self.clientClusters = clientClusters
            self.clusters = clusters
            self.deviceTypes = deviceTypes
            self.id = id
            self.parts = parts
            self.semanticTags = semanticTags
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Matter based capability report.
    public struct MatterCapabilityReport: Swift.Sendable {
        /// The endpoints used in the capability report.
        /// This member is required.
        public var endpoints: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportEndpoint]?
        /// The numeric identifier of the node.
        public var nodeId: Swift.String?
        /// The version of the capability report.
        /// This member is required.
        public var version: Swift.String?

        public init(
            endpoints: [IoTManagedIntegrationsClientTypes.MatterCapabilityReportEndpoint]? = nil,
            nodeId: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Describe the device using the relevant metadata and supported clusters for device discovery.
    public struct Device: Swift.Sendable {
        /// The capability report for the device.
        /// This member is required.
        public var capabilityReport: IoTManagedIntegrationsClientTypes.MatterCapabilityReport?
        /// Report of all capabilities supported by the device.
        public var capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]?
        /// The device id as defined by the connector. This parameter is used for cloud-to-cloud devices only.
        /// This member is required.
        public var connectorDeviceId: Swift.String?
        /// The name of the device as defined by the connector.
        public var connectorDeviceName: Swift.String?
        /// The metadata attributes for a device.
        public var deviceMetadata: Smithy.Document?

        public init(
            capabilityReport: IoTManagedIntegrationsClientTypes.MatterCapabilityReport? = nil,
            capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]? = nil,
            connectorDeviceId: Swift.String? = nil,
            connectorDeviceName: Swift.String? = nil,
            deviceMetadata: Smithy.Document? = nil
        ) {
            self.capabilityReport = capabilityReport
            self.capabilitySchemas = capabilitySchemas
            self.connectorDeviceId = connectorDeviceId
            self.connectorDeviceName = connectorDeviceName
            self.deviceMetadata = deviceMetadata
        }
    }
}

extension IoTManagedIntegrationsClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(capabilityReport: \(Swift.String(describing: capabilityReport)), capabilitySchemas: \(Swift.String(describing: capabilitySchemas)), deviceMetadata: \(Swift.String(describing: deviceMetadata)), connectorDeviceId: \"CONTENT_REDACTED\", connectorDeviceName: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    public enum DiscoveryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloud
        case custom
        case zigbee
        case zwave
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryType] {
            return [
                .cloud,
                .custom,
                .zigbee,
                .zwave
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .custom: return "CUSTOM"
            case .zigbee: return "ZIGBEE"
            case .zwave: return "ZWAVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DeviceDiscoveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceDiscoveryStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure containing summary information about a device discovery job, including its identifier, type, and status.
    public struct DeviceDiscoverySummary: Swift.Sendable {
        /// The type of discovery process used to find devices.
        public var discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType?
        /// The unique identifier of the device discovery job.
        public var id: Swift.String?
        /// The current status of the device discovery job.
        public var status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus?

        public init(
            discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil,
            id: Swift.String? = nil,
            status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus? = nil
        ) {
            self.discoveryType = discoveryType
            self.id = id
            self.status = status
        }
    }
}

public struct GetDeviceDiscoveryInput: Swift.Sendable {
    /// The id of the device discovery job request.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetDeviceDiscoveryOutput: Swift.Sendable {
    /// The identifier of the account association used for the device discovery.
    public var accountAssociationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the device discovery job request.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID tracking the current discovery process for one connector association.
    @available(*, deprecated, message: "ConnectorAssociationId has been deprecated API deprecated since 2025-06-25")
    public var connectorAssociationId: Swift.String?
    /// The id of the end-user's IoT hub.
    public var controllerId: Swift.String?
    /// The discovery type supporting the type of device to be discovered in the device discovery job request.
    /// This member is required.
    public var discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType?
    /// The timestamp value for the completion time of the device discovery.
    public var finishedAt: Foundation.Date?
    /// The id of the device discovery job request.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp value for the start time of the device discovery.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The status of the device discovery job request.
    /// This member is required.
    public var status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus?
    /// A set of key/value pairs that are used to manage the device discovery request.
    @available(*, deprecated, message: "Tags have been deprecated from this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountAssociationId: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectorAssociationId: Swift.String? = nil,
        controllerId: Swift.String? = nil,
        discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil,
        finishedAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.arn = arn
        self.connectorAssociationId = connectorAssociationId
        self.controllerId = controllerId
        self.discoveryType = discoveryType
        self.finishedAt = finishedAt
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.tags = tags
    }
}

extension GetDeviceDiscoveryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceDiscoveryOutput(accountAssociationId: \(Swift.String(describing: accountAssociationId)), arn: \(Swift.String(describing: arn)), connectorAssociationId: \(Swift.String(describing: connectorAssociationId)), controllerId: \(Swift.String(describing: controllerId)), discoveryType: \(Swift.String(describing: discoveryType)), finishedAt: \(Swift.String(describing: finishedAt)), id: \(Swift.String(describing: id)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListDeviceDiscoveriesInput: Swift.Sendable {
    /// The maximum number of device discovery jobs to return in a single response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results.
    public var nextToken: Swift.String?
    /// The status to filter device discovery jobs by.
    public var statusFilter: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus?
    /// The discovery type to filter device discovery jobs by.
    public var typeFilter: IoTManagedIntegrationsClientTypes.DiscoveryType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus? = nil,
        typeFilter: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
        self.typeFilter = typeFilter
    }
}

public struct ListDeviceDiscoveriesOutput: Swift.Sendable {
    /// The list of device discovery jobs that match the specified criteria.
    public var items: [IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary]?
    /// A token used for pagination of results when there are more device discovery jobs than can be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListDiscoveredDevicesInput: Swift.Sendable {
    /// The identifier of the device discovery job to list discovered devices for.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of discovered devices to return in a single response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results.
    public var nextToken: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DiscoveryModification: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case discovered
        case noChange
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryModification] {
            return [
                .discovered,
                .noChange,
                .updated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .discovered: return "DISCOVERED"
            case .noChange: return "NO_CHANGE"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure containing summary information about a device discovered during a device discovery job.
    public struct DiscoveredDeviceSummary: Swift.Sendable {
        /// The authentication material required for connecting to the discovered device, such as credentials or tokens.
        public var authenticationMaterial: Swift.String?
        /// The brand of the discovered device.
        public var brand: Swift.String?
        /// The third-party device identifier as defined by the connector. This identifier must not contain personal identifiable information (PII).
        public var connectorDeviceId: Swift.String?
        /// The name of the device as defined by the connector or third-party system.
        public var connectorDeviceName: Swift.String?
        /// The list of device types or categories that the discovered device belongs to.
        public var deviceTypes: [Swift.String]?
        /// The timestamp indicating when the device was discovered.
        public var discoveredAt: Foundation.Date?
        /// The identifier of the managed thing created for this discovered device, if one exists.
        public var managedThingId: Swift.String?
        /// The model of the discovered device.
        public var model: Swift.String?
        /// The status of the discovered device, indicating whether it has been added, removed, or modified since the last discovery.
        public var modification: IoTManagedIntegrationsClientTypes.DiscoveryModification?

        public init(
            authenticationMaterial: Swift.String? = nil,
            brand: Swift.String? = nil,
            connectorDeviceId: Swift.String? = nil,
            connectorDeviceName: Swift.String? = nil,
            deviceTypes: [Swift.String]? = nil,
            discoveredAt: Foundation.Date? = nil,
            managedThingId: Swift.String? = nil,
            model: Swift.String? = nil,
            modification: IoTManagedIntegrationsClientTypes.DiscoveryModification? = nil
        ) {
            self.authenticationMaterial = authenticationMaterial
            self.brand = brand
            self.connectorDeviceId = connectorDeviceId
            self.connectorDeviceName = connectorDeviceName
            self.deviceTypes = deviceTypes
            self.discoveredAt = discoveredAt
            self.managedThingId = managedThingId
            self.model = model
            self.modification = modification
        }
    }
}

extension IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoveredDeviceSummary(deviceTypes: \(Swift.String(describing: deviceTypes)), discoveredAt: \(Swift.String(describing: discoveredAt)), managedThingId: \(Swift.String(describing: managedThingId)), modification: \(Swift.String(describing: modification)), authenticationMaterial: \"CONTENT_REDACTED\", brand: \"CONTENT_REDACTED\", connectorDeviceId: \"CONTENT_REDACTED\", connectorDeviceName: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\")"}
}

public struct ListDiscoveredDevicesOutput: Swift.Sendable {
    /// The list of discovered devices that match the specified criteria.
    public var items: [IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary]?
    /// A token used for pagination of results when there are more discovered devices than can be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DiscoveryAuthMaterialType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case zwaveInstallCode
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryAuthMaterialType] {
            return [
                .zwaveInstallCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .zwaveInstallCode: return "ZWAVE_INSTALL_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartDeviceDiscoveryInput: Swift.Sendable {
    /// The identifier of the cloud-to-cloud account association to use for discovery of third-party devices.
    public var accountAssociationId: Swift.String?
    /// The authentication material required to start the local device discovery job request.
    public var authenticationMaterial: Swift.String?
    /// The type of authentication material used for device discovery jobs.
    public var authenticationMaterialType: IoTManagedIntegrationsClientTypes.DiscoveryAuthMaterialType?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The id of the connector association.
    @available(*, deprecated, message: "ConnectorAssociationIdentifier is deprecated API deprecated since 06-25-2025")
    public var connectorAssociationIdentifier: Swift.String?
    /// The id of the end-user's IoT hub.
    public var controllerIdentifier: Swift.String?
    /// Additional protocol-specific details required for device discovery, which vary based on the discovery type. For a DiscoveryType of CUSTOM, the string-to-string map must have a key value of Name set to a non-empty-string.
    public var customProtocolDetail: [Swift.String: Swift.String]?
    /// The discovery type supporting the type of device to be discovered in the device discovery task request.
    /// This member is required.
    public var discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType?
    /// A set of key/value pairs that are used to manage the device discovery request.
    @available(*, deprecated, message: "Tags have been deprecated from this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountAssociationId: Swift.String? = nil,
        authenticationMaterial: Swift.String? = nil,
        authenticationMaterialType: IoTManagedIntegrationsClientTypes.DiscoveryAuthMaterialType? = nil,
        clientToken: Swift.String? = nil,
        connectorAssociationIdentifier: Swift.String? = nil,
        controllerIdentifier: Swift.String? = nil,
        customProtocolDetail: [Swift.String: Swift.String]? = nil,
        discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.authenticationMaterial = authenticationMaterial
        self.authenticationMaterialType = authenticationMaterialType
        self.clientToken = clientToken
        self.connectorAssociationIdentifier = connectorAssociationIdentifier
        self.controllerIdentifier = controllerIdentifier
        self.customProtocolDetail = customProtocolDetail
        self.discoveryType = discoveryType
        self.tags = tags
    }
}

extension StartDeviceDiscoveryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeviceDiscoveryInput(accountAssociationId: \(Swift.String(describing: accountAssociationId)), authenticationMaterialType: \(Swift.String(describing: authenticationMaterialType)), clientToken: \(Swift.String(describing: clientToken)), connectorAssociationIdentifier: \(Swift.String(describing: connectorAssociationIdentifier)), controllerIdentifier: \(Swift.String(describing: controllerIdentifier)), customProtocolDetail: \(Swift.String(describing: customProtocolDetail)), discoveryType: \(Swift.String(describing: discoveryType)), authenticationMaterial: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct StartDeviceDiscoveryOutput: Swift.Sendable {
    /// The id of the device discovery job request.
    public var id: Swift.String?
    /// The timestamp value for the start time of the device discovery.
    public var startedAt: Foundation.Date?

    public init(
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil
    ) {
        self.id = id
        self.startedAt = startedAt
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DisconnectReasonValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authError
        case clientError
        case clientInitiatedDisconnect
        case connectionLost
        case customauthTtlExpiration
        case duplicateClientid
        case forbiddenAccess
        case mqttKeepAliveTimeout
        case `none`
        case serverError
        case serverInitiatedDisconnect
        case throttled
        case unknown
        case websocketTtlExpiration
        case sdkUnknown(Swift.String)

        public static var allCases: [DisconnectReasonValue] {
            return [
                .authError,
                .clientError,
                .clientInitiatedDisconnect,
                .connectionLost,
                .customauthTtlExpiration,
                .duplicateClientid,
                .forbiddenAccess,
                .mqttKeepAliveTimeout,
                .none,
                .serverError,
                .serverInitiatedDisconnect,
                .throttled,
                .unknown,
                .websocketTtlExpiration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authError: return "AUTH_ERROR"
            case .clientError: return "CLIENT_ERROR"
            case .clientInitiatedDisconnect: return "CLIENT_INITIATED_DISCONNECT"
            case .connectionLost: return "CONNECTION_LOST"
            case .customauthTtlExpiration: return "CUSTOMAUTH_TTL_EXPIRATION"
            case .duplicateClientid: return "DUPLICATE_CLIENTID"
            case .forbiddenAccess: return "FORBIDDEN_ACCESS"
            case .mqttKeepAliveTimeout: return "MQTT_KEEP_ALIVE_TIMEOUT"
            case .none: return "NONE"
            case .serverError: return "SERVER_ERROR"
            case .serverInitiatedDisconnect: return "SERVER_INITIATED_DISCONNECT"
            case .throttled: return "THROTTLED"
            case .unknown: return "UNKNOWN"
            case .websocketTtlExpiration: return "WEBSOCKET_TTL_EXPIRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum EncryptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerKeyEncryption
        case managedIntegrationsDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .customerKeyEncryption,
                .managedIntegrationsDefaultEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerKeyEncryption: return "CUSTOMER_KEY_ENCRYPTION"
            case .managedIntegrationsDefaultEncryption: return "MANAGED_INTEGRATIONS_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// List of event log configurations.
    public struct EventLogConfigurationSummary: Swift.Sendable {
        /// The logging level for the event log configuration.
        public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// The identifier of the event log configuration.
        public var id: Swift.String?
        /// The identifier of the resource for the event log configuration.
        public var resourceId: Swift.String?
        /// The type of resource for the event log configuration.
        public var resourceType: Swift.String?

        public init(
            eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            id: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        ) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct GetEventLogConfigurationInput: Swift.Sendable {
    /// The identifier of the event log configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct GetEventLogConfigurationOutput: Swift.Sendable {
    /// The logging level for the event log configuration.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The identifier of the event log configuration.
    public var id: Swift.String?
    /// The identifier of the resource for the event log configuration.
    public var resourceId: Swift.String?
    /// The type of resource for the event log configuration.
    public var resourceType: Swift.String?

    public init(
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        id: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.eventLogLevel = eventLogLevel
        self.id = id
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct ListEventLogConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEventLogConfigurationsOutput: Swift.Sendable {
    /// A list of each event log configuration and pertinent information.
    public var eventLogConfigurationList: [IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventLogConfigurationList: [IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.eventLogConfigurationList = eventLogConfigurationList
        self.nextToken = nextToken
    }
}

public struct UpdateEventLogConfigurationInput: Swift.Sendable {
    /// The log level for the event in terms of severity.
    /// This member is required.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The log configuration id.
    /// This member is required.
    public var id: Swift.String?

    public init(
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        id: Swift.String? = nil
    ) {
        self.eventLogLevel = eventLogLevel
        self.id = id
    }
}

public struct GetCustomEndpointInput: Swift.Sendable {

    public init() { }
}

public struct GetCustomEndpointOutput: Swift.Sendable {
    /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
    /// This member is required.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    ) {
        self.endpointAddress = endpointAddress
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetDefaultEncryptionConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    /// This member is required.
    public var configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct GetHubConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetHubConfigurationOutput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?
    /// The timestamp value of when the hub configuration was updated.
    public var updatedAt: Foundation.Date?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        self.updatedAt = updatedAt
    }
}

public struct GetManagedThingInput: Swift.Sendable {
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum HubNetworkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case networkWideExclusion
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [HubNetworkMode] {
            return [
                .networkWideExclusion,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .networkWideExclusion: return "NETWORK_WIDE_EXCLUSION"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ProvisioningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deleted
        case deleteInProgress
        case deletionFailed
        case discovered
        case isolated
        case preAssociated
        case unassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .activated,
                .deleted,
                .deleteInProgress,
                .deletionFailed,
                .discovered,
                .isolated,
                .preAssociated,
                .unassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deletionFailed: return "DELETION_FAILED"
            case .discovered: return "DISCOVERED"
            case .isolated: return "ISOLATED"
            case .preAssociated: return "PRE_ASSOCIATED"
            case .unassociated: return "UNASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetManagedThingOutput: Swift.Sendable {
    /// The timestampe value of when the device was activated.
    public var activatedAt: Foundation.Date?
    /// The id of the advertised product.
    public var advertisedProductId: Swift.String?
    /// The Amazon Resource Name (ARN) of the managed thing.
    public var arn: Swift.String?
    /// The brand of the device.
    public var brand: Swift.String?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// The identifier of the connector destination associated with this managed thing.
    public var connectorDestinationId: Swift.String?
    /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII). This parameter is used for cloud-to-cloud devices only.
    public var connectorDeviceId: Swift.String?
    /// The id of the connector policy. This parameter is used for cloud-to-cloud devices only.
    @available(*, deprecated, message: "ConnectorPolicyId is deprecated API deprecated since 2025-06-25")
    public var connectorPolicyId: Swift.String?
    /// The timestamp value of when the device creation request occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker for the managed thing.
    public var credentialLockerId: Swift.String?
    /// A Zwave device-specific key used during device activation. This parameter is used for Zwave devices only.
    public var deviceSpecificKey: Swift.String?
    /// The network mode for the hub-connected device.
    public var hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode?
    /// The id of the managed thing.
    public var id: Swift.String?
    /// The unique 13 digit number that identifies the managed thing.
    public var internationalArticleNumber: Swift.String?
    /// The media access control (MAC) address for the device represented by the managed thing. This parameter is used for Zigbee devices only.
    public var macAddress: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// Id of the controller device used for the discovery job.
    public var parentControllerId: Swift.String?
    /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
    public var provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
    /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
    public var role: IoTManagedIntegrationsClientTypes.Role?
    /// The serial number of the device.
    public var serialNumber: Swift.String?
    /// A set of key/value pairs that are used to manage the managed thing.
    public var tags: [Swift.String: Swift.String]?
    /// The universal product code (UPC) of the device model. The UPC is typically used in the United States of America and Canada.
    public var universalProductCode: Swift.String?
    /// The timestamp value of when the managed thing was last updated at.
    public var updatedAt: Foundation.Date?

    public init(
        activatedAt: Foundation.Date? = nil,
        advertisedProductId: Swift.String? = nil,
        arn: Swift.String? = nil,
        brand: Swift.String? = nil,
        classification: Swift.String? = nil,
        connectorDestinationId: Swift.String? = nil,
        connectorDeviceId: Swift.String? = nil,
        connectorPolicyId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        credentialLockerId: Swift.String? = nil,
        deviceSpecificKey: Swift.String? = nil,
        hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode? = nil,
        id: Swift.String? = nil,
        internationalArticleNumber: Swift.String? = nil,
        macAddress: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        parentControllerId: Swift.String? = nil,
        provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
        role: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        universalProductCode: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.activatedAt = activatedAt
        self.advertisedProductId = advertisedProductId
        self.arn = arn
        self.brand = brand
        self.classification = classification
        self.connectorDestinationId = connectorDestinationId
        self.connectorDeviceId = connectorDeviceId
        self.connectorPolicyId = connectorPolicyId
        self.createdAt = createdAt
        self.credentialLockerId = credentialLockerId
        self.deviceSpecificKey = deviceSpecificKey
        self.hubNetworkMode = hubNetworkMode
        self.id = id
        self.internationalArticleNumber = internationalArticleNumber
        self.macAddress = macAddress
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.parentControllerId = parentControllerId
        self.provisioningStatus = provisioningStatus
        self.role = role
        self.serialNumber = serialNumber
        self.tags = tags
        self.universalProductCode = universalProductCode
        self.updatedAt = updatedAt
    }
}

extension GetManagedThingOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetManagedThingOutput(activatedAt: \(Swift.String(describing: activatedAt)), advertisedProductId: \(Swift.String(describing: advertisedProductId)), arn: \(Swift.String(describing: arn)), connectorDestinationId: \(Swift.String(describing: connectorDestinationId)), connectorPolicyId: \(Swift.String(describing: connectorPolicyId)), createdAt: \(Swift.String(describing: createdAt)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), hubNetworkMode: \(Swift.String(describing: hubNetworkMode)), id: \(Swift.String(describing: id)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), parentControllerId: \(Swift.String(describing: parentControllerId)), provisioningStatus: \(Swift.String(describing: provisioningStatus)), role: \(Swift.String(describing: role)), updatedAt: \(Swift.String(describing: updatedAt)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", connectorDeviceId: \"CONTENT_REDACTED\", deviceSpecificKey: \"CONTENT_REDACTED\", internationalArticleNumber: \"CONTENT_REDACTED\", macAddress: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\", universalProductCode: \"CONTENT_REDACTED\")"}
}

public struct GetManagedThingCapabilitiesInput: Swift.Sendable {
    /// The id of the device.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingCapabilitiesOutput: Swift.Sendable {
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The id of the device.
    public var managedThingId: Swift.String?

    public init(
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.managedThingId = managedThingId
    }
}

public struct GetManagedThingCertificateInput: Swift.Sendable {
    /// The identifier of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingCertificateOutput: Swift.Sendable {
    /// The PEM-encoded certificate for the managed thing.
    public var certificatePem: Swift.String?
    /// The identifier of the managed thing.
    public var managedThingId: Swift.String?

    public init(
        certificatePem: Swift.String? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.certificatePem = certificatePem
        self.managedThingId = managedThingId
    }
}

public struct GetManagedThingConnectivityDataInput: Swift.Sendable {
    /// The identifier of a managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingConnectivityDataOutput: Swift.Sendable {
    /// The connectivity status for a managed thing.
    public var connected: Swift.Bool?
    /// The reason for the connectivity disconnect with the managed thing.
    public var disconnectReason: IoTManagedIntegrationsClientTypes.DisconnectReasonValue?
    /// The id of a managed thing.
    public var managedThingId: Swift.String?
    /// The timestamp value of when the connectivity status for a managed thing was last taken.
    public var timestamp: Foundation.Date?

    public init(
        connected: Swift.Bool? = nil,
        disconnectReason: IoTManagedIntegrationsClientTypes.DisconnectReasonValue? = nil,
        managedThingId: Swift.String? = nil,
        timestamp: Foundation.Date? = nil
    ) {
        self.connected = connected
        self.disconnectReason = disconnectReason
        self.managedThingId = managedThingId
        self.timestamp = timestamp
    }
}

public struct GetManagedThingMetaDataInput: Swift.Sendable {
    /// The managed thing id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingMetaDataOutput: Swift.Sendable {
    /// The managed thing id.
    public var managedThingId: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?

    public init(
        managedThingId: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil
    ) {
        self.managedThingId = managedThingId
        self.metaData = metaData
    }
}

public struct GetManagedThingStateInput: Swift.Sendable {
    /// The id of the device.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// State capabilities added for the managed thing.
    public struct StateCapability: Swift.Sendable {
        /// The id of the managed thing in the capability report.
        /// This member is required.
        public var id: Swift.String?
        /// Name for the Amazon Web Services capability.
        /// This member is required.
        public var name: Swift.String?
        /// Describe the command capability with the properties it supports.
        public var properties: Smithy.Document?
        /// Version for the Amazon Web Services capability.
        /// This member is required.
        public var version: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: Smithy.Document? = nil,
            version: Swift.String? = nil
        ) {
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes.StateCapability: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateCapability(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)), properties: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Describe the endpoint with an Id, a name, and the relevant capabilities for reporting state
    public struct StateEndpoint: Swift.Sendable {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for the reporting state.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.StateCapability]?
        /// Numeric identifier of the endpoint
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.StateCapability]? = nil,
            endpointId: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }
    }
}

public struct GetManagedThingStateOutput: Swift.Sendable {
    /// The device endpoint.
    /// This member is required.
    public var endpoints: [IoTManagedIntegrationsClientTypes.StateEndpoint]?

    public init(
        endpoints: [IoTManagedIntegrationsClientTypes.StateEndpoint]? = nil
    ) {
        self.endpoints = endpoints
    }
}

public struct GetNotificationConfigurationInput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

public struct GetNotificationConfigurationOutput: Swift.Sendable {
    /// The timestamp value of when the notification configuration was created.
    public var createdAt: Foundation.Date?
    /// The name of the destination for the notification configuration.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?
    /// A set of key/value pairs that are used to manage the notification configuration.
    @available(*, deprecated, message: "Tags has been deprecated for this api API deprecated since 06-25-2025")
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp value of when the notification configuration was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.destinationName = destinationName
        self.eventType = eventType
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension GetNotificationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNotificationConfigurationOutput(createdAt: \(Swift.String(describing: createdAt)), destinationName: \(Swift.String(describing: destinationName)), eventType: \(Swift.String(describing: eventType)), updatedAt: \(Swift.String(describing: updatedAt)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetOtaTaskInput: Swift.Sendable {
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case deletionInProgress
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaStatus] {
            return [
                .canceled,
                .completed,
                .deletionInProgress,
                .inProgress,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Details about the over-the-air (OTA) task process.
    public struct TaskProcessingDetails: Swift.Sendable {
        /// The number of canceled things in an over-the-air (OTA) task.
        public var numberOfCanceledThings: Swift.Int?
        /// The number of failed things in an over-the-air (OTA) task.
        public var numberOfFailedThings: Swift.Int?
        /// The number of in progress things in an over-the-air (OTA) task.
        public var numberOfInProgressThings: Swift.Int?
        /// The number of queued things in an over-the-air (OTA) task.
        public var numberOfQueuedThings: Swift.Int?
        /// The number of rejected things in an over-the-air (OTA) task.
        public var numberOfRejectedThings: Swift.Int?
        /// The number of removed things in an over-the-air (OTA) task.
        public var numberOfRemovedThings: Swift.Int?
        /// The number of succeeded things in an over-the-air (OTA) task.
        public var numberOfSucceededThings: Swift.Int?
        /// The number of timed out things in an over-the-air (OTA) task.
        public var numberOfTimedOutThings: Swift.Int?
        /// The targets of the over-the-air (OTA) task.
        public var processingTargets: [Swift.String]?

        public init(
            numberOfCanceledThings: Swift.Int? = nil,
            numberOfFailedThings: Swift.Int? = nil,
            numberOfInProgressThings: Swift.Int? = nil,
            numberOfQueuedThings: Swift.Int? = nil,
            numberOfRejectedThings: Swift.Int? = nil,
            numberOfRemovedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil,
            numberOfTimedOutThings: Swift.Int? = nil,
            processingTargets: [Swift.String]? = nil
        ) {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }
    }
}

public struct GetOtaTaskOutput: Swift.Sendable {
    /// The timestamp value of when the over-the-air (OTA) task was created.
    public var createdAt: Foundation.Date?
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The timestamp value of when the over-the-air (OTA) task was last updated at.
    public var lastUpdatedAt: Foundation.Date?
    /// The deployment mechanism for the over-the-air (OTA) task.
    public var otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism?
    /// Over-the-air (OTA) task scheduling config.
    public var otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?
    /// The query string to add things to the thing group.
    public var otaTargetQueryString: Swift.String?
    /// Over-the-air (OTA) task retry config.
    public var otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?
    /// The frequency type for the over-the-air (OTA) task.
    public var otaType: IoTManagedIntegrationsClientTypes.OtaType?
    /// The connection protocol the over-the-air (OTA) task uses to update the device.
    public var `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol?
    /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
    public var s3Url: Swift.String?
    /// The status of the over-the-air (OTA) task.
    public var status: IoTManagedIntegrationsClientTypes.OtaStatus?
    /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
    public var tags: [Swift.String: Swift.String]?
    /// The device targeted for the over-the-air (OTA) task.
    public var target: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task
    public var taskArn: Swift.String?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?
    /// The id of the over-the-air (OTA) task.
    public var taskId: Swift.String?
    /// The processing details of all over-the-air (OTA) tasks.
    public var taskProcessingDetails: IoTManagedIntegrationsClientTypes.TaskProcessingDetails?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism? = nil,
        otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig? = nil,
        otaTargetQueryString: Swift.String? = nil,
        otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig? = nil,
        otaType: IoTManagedIntegrationsClientTypes.OtaType? = nil,
        `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol? = nil,
        s3Url: Swift.String? = nil,
        status: IoTManagedIntegrationsClientTypes.OtaStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: [Swift.String]? = nil,
        taskArn: Swift.String? = nil,
        taskConfigurationId: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskProcessingDetails: IoTManagedIntegrationsClientTypes.TaskProcessingDetails? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.otaMechanism = otaMechanism
        self.otaSchedulingConfig = otaSchedulingConfig
        self.otaTargetQueryString = otaTargetQueryString
        self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
        self.otaType = otaType
        self.`protocol` = `protocol`
        self.s3Url = s3Url
        self.status = status
        self.tags = tags
        self.target = target
        self.taskArn = taskArn
        self.taskConfigurationId = taskConfigurationId
        self.taskId = taskId
        self.taskProcessingDetails = taskProcessingDetails
    }
}

extension GetOtaTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOtaTaskOutput(protocol: \(Swift.String(describing: `protocol`)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), otaMechanism: \(Swift.String(describing: otaMechanism)), otaSchedulingConfig: \(Swift.String(describing: otaSchedulingConfig)), otaTargetQueryString: \(Swift.String(describing: otaTargetQueryString)), otaTaskExecutionRetryConfig: \(Swift.String(describing: otaTaskExecutionRetryConfig)), otaType: \(Swift.String(describing: otaType)), s3Url: \(Swift.String(describing: s3Url)), status: \(Swift.String(describing: status)), target: \(Swift.String(describing: target)), taskArn: \(Swift.String(describing: taskArn)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), taskId: \(Swift.String(describing: taskId)), taskProcessingDetails: \(Swift.String(describing: taskProcessingDetails)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetOtaTaskConfigurationInput: Swift.Sendable {
    /// The over-the-air (OTA) task configuration id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetOtaTaskConfigurationOutput: Swift.Sendable {
    /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
    public var createdAt: Foundation.Date?
    /// A description of the over-the-air (OTA) task configuration.
    public var description: Swift.String?
    /// The name of the over-the-air (OTA) task configuration.
    public var name: Swift.String?
    /// Describes the type of configuration used for the over-the-air (OTA) task.
    public var pushConfig: IoTManagedIntegrationsClientTypes.PushConfig?
    /// The over-the-air (OTA) task configuration id.
    public var taskConfigurationId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pushConfig: IoTManagedIntegrationsClientTypes.PushConfig? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.name = name
        self.pushConfig = pushConfig
        self.taskConfigurationId = taskConfigurationId
    }
}

extension GetOtaTaskConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOtaTaskConfigurationOutput(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), pushConfig: \(Swift.String(describing: pushConfig)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), name: \"CONTENT_REDACTED\")"}
}

public struct GetProvisioningProfileInput: Swift.Sendable {
    /// The provisioning template the device uses for the provisioning process.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetProvisioningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
    public var arn: Swift.String?
    /// The id of the claim certificate.
    public var claimCertificate: Swift.String?
    /// The provisioning profile id.
    public var id: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?
    /// A set of key/value pairs that are used to manage the provisioning profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        claimCertificate: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.claimCertificate = claimCertificate
        self.id = id
        self.name = name
        self.provisioningType = provisioningType
        self.tags = tags
    }
}

extension GetProvisioningProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisioningProfileOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), claimCertificate: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct GetRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id for a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The different configurations for runtime logs.
    public struct RuntimeLogConfigurations: Swift.Sendable {
        /// Configuration to enable or disable deleting of runtime logs in the device once uploaded to the cloud.
        public var deleteLocalStoreAfterUpload: Swift.Bool?
        /// Configuration to set the maximum bytes of runtime logs that can be stored on the device before the oldest logs are deleted or overwritten.
        public var localStoreFileRotationMaxBytes: Swift.Int?
        /// Configuration to set the maximum number of runtime log files that can be stored on the device before the oldest files are deleted or overwritten.
        public var localStoreFileRotationMaxFiles: Swift.Int?
        /// Configuration of where to store runtime logs in the device.
        public var localStoreLocation: Swift.String?
        /// The different log levels available for configuration.
        public var logFlushLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// The different log levels available for configuration.
        public var logLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// Configuration to enable or disable uploading of runtime logs to the cloud.
        public var uploadLog: Swift.Bool?
        /// Configuration to set the time interval in minutes between each batch of runtime logs that the device uploads to the cloud.
        public var uploadPeriodMinutes: Swift.Int?

        public init(
            deleteLocalStoreAfterUpload: Swift.Bool? = nil,
            localStoreFileRotationMaxBytes: Swift.Int? = nil,
            localStoreFileRotationMaxFiles: Swift.Int? = nil,
            localStoreLocation: Swift.String? = nil,
            logFlushLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            logLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            uploadLog: Swift.Bool? = nil,
            uploadPeriodMinutes: Swift.Int? = nil
        ) {
            self.deleteLocalStoreAfterUpload = deleteLocalStoreAfterUpload
            self.localStoreFileRotationMaxBytes = localStoreFileRotationMaxBytes
            self.localStoreFileRotationMaxFiles = localStoreFileRotationMaxFiles
            self.localStoreLocation = localStoreLocation
            self.logFlushLevel = logFlushLevel
            self.logLevel = logLevel
            self.uploadLog = uploadLog
            self.uploadPeriodMinutes = uploadPeriodMinutes
        }
    }
}

public struct GetRuntimeLogConfigurationOutput: Swift.Sendable {
    /// The id for a managed thing.
    public var managedThingId: Swift.String?
    /// The runtime log configuration for a managed thing.
    public var runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?

    public init(
        managedThingId: Swift.String? = nil,
        runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations? = nil
    ) {
        self.managedThingId = managedThingId
        self.runtimeLogConfigurations = runtimeLogConfigurations
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capability
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionType] {
            return [
                .capability,
                .definition
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capability: return "capability"
            case .definition: return "definition"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaVersionInput: Swift.Sendable {
    /// The format of the schema version.
    public var format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat?
    /// Schema id with a version specified. If the version is missing, it defaults to latest version.
    /// This member is required.
    public var schemaVersionedId: Swift.String?
    /// The type of schema version.
    /// This member is required.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?

    public init(
        format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat? = nil,
        schemaVersionedId: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil
    ) {
        self.format = format
        self.schemaVersionedId = schemaVersionedId
        self.type = type
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionVisibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionVisibility] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaVersionOutput: Swift.Sendable {
    /// The description of the schema version.
    public var description: Swift.String?
    /// The name of the schema version.
    public var namespace: Swift.String?
    /// The schema of the schema version.
    public var schema: Smithy.Document?
    /// The id of the schema version.
    public var schemaId: Swift.String?
    /// The schema version. If this is left blank, it defaults to the latest version.
    public var semanticVersion: Swift.String?
    /// The type of schema version.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
    /// The visibility of the schema version.
    public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

    public init(
        description: Swift.String? = nil,
        namespace: Swift.String? = nil,
        schema: Smithy.Document? = nil,
        schemaId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
        visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
    ) {
        self.description = description
        self.namespace = namespace
        self.schema = schema
        self.schemaId = schemaId
        self.semanticVersion = semanticVersion
        self.type = type
        self.visibility = visibility
    }
}

public struct PutHubConfigurationInput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    /// This member is required.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
    }
}

public struct PutHubConfigurationOutput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
    }
}

/// The request is not valid.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Sendable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct PutDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    /// This member is required.
    public var configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A set of key/value pairs that are used to manage the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct ListManagedThingAccountAssociationsInput: Swift.Sendable {
    /// The identifier of the account association to filter results by. When specified, only associations with this account association ID will be returned.
    public var accountAssociationId: Swift.String?
    /// The identifier of the managed thing to list account associations for.
    public var managedThingId: Swift.String?
    /// The maximum number of account associations to return in a single response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results.
    public var nextToken: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        managedThingId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.managedThingId = managedThingId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing an association between a managed thing and an account association, which connects a device to a third-party account.
    public struct ManagedThingAssociation: Swift.Sendable {
        /// The identifier of the account association in the association.
        public var accountAssociationId: Swift.String?
        /// The identifier of the managed thing in the association.
        public var managedThingId: Swift.String?

        public init(
            accountAssociationId: Swift.String? = nil,
            managedThingId: Swift.String? = nil
        ) {
            self.accountAssociationId = accountAssociationId
            self.managedThingId = managedThingId
        }
    }
}

public struct ListManagedThingAccountAssociationsOutput: Swift.Sendable {
    /// The list of managed thing associations that match the specified criteria, including the managed thing ID and account association ID for each association.
    public var items: [IoTManagedIntegrationsClientTypes.ManagedThingAssociation]?
    /// A token used for pagination of results when there are more account associations than can be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ManagedThingAssociation]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct RegisterAccountAssociationInput: Swift.Sendable {
    /// The identifier of the account association to register with the managed thing.
    /// This member is required.
    public var accountAssociationId: Swift.String?
    /// The identifier of the device discovery job associated with this registration.
    /// This member is required.
    public var deviceDiscoveryId: Swift.String?
    /// The identifier of the managed thing to register with the account association.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        deviceDiscoveryId: Swift.String? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.deviceDiscoveryId = deviceDiscoveryId
        self.managedThingId = managedThingId
    }
}

public struct RegisterAccountAssociationOutput: Swift.Sendable {
    /// The identifier of the account association that was registered.
    public var accountAssociationId: Swift.String?
    /// The identifier of the device discovery job associated with this registration.
    public var deviceDiscoveryId: Swift.String?
    /// The identifier of the managed thing that was registered with the account association.
    public var managedThingId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        deviceDiscoveryId: Swift.String? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.deviceDiscoveryId = deviceDiscoveryId
        self.managedThingId = managedThingId
    }
}

public struct SendManagedThingCommandInput: Swift.Sendable {
    /// The identifier of the account association to use when sending a command to a managed thing.
    public var accountAssociationId: Swift.String?
    /// The ID tracking the current discovery process for one connector association.
    @available(*, deprecated, message: "ConnectorAssociationId has been deprecated API deprecated since 06-25-2025")
    public var connectorAssociationId: Swift.String?
    /// The device endpoint.
    /// This member is required.
    public var endpoints: [IoTManagedIntegrationsClientTypes.CommandEndpoint]?
    /// The id of the device.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        accountAssociationId: Swift.String? = nil,
        connectorAssociationId: Swift.String? = nil,
        endpoints: [IoTManagedIntegrationsClientTypes.CommandEndpoint]? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.accountAssociationId = accountAssociationId
        self.connectorAssociationId = connectorAssociationId
        self.endpoints = endpoints
        self.managedThingId = managedThingId
    }
}

public struct SendManagedThingCommandOutput: Swift.Sendable {
    /// The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.
    public var traceId: Swift.String?

    public init(
        traceId: Swift.String? = nil
    ) {
        self.traceId = traceId
    }
}

public struct ListManagedThingsInput: Swift.Sendable {
    /// Filter managed things by the connector destination ID they are associated with.
    public var connectorDestinationIdFilter: Swift.String?
    /// Filter managed things by the connector device ID they are associated with. When specified, only managed things with this connector device ID will be returned.
    public var connectorDeviceIdFilter: Swift.String?
    /// Filter on a connector policy id for a managed thing.
    @available(*, deprecated, message: "ConnectorPolicyIdFilter is deprecated API deprecated since 06-25-2025")
    public var connectorPolicyIdFilter: Swift.String?
    /// Filter on a credential locker for a managed thing.
    public var credentialLockerFilter: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Filter on device owners when listing managed things.
    public var ownerFilter: Swift.String?
    /// Filter on a parent controller id for a managed thing.
    public var parentControllerIdentifierFilter: Swift.String?
    /// Filter on the status of the device.
    public var provisioningStatusFilter: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
    /// Filter on the type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
    public var roleFilter: IoTManagedIntegrationsClientTypes.Role?
    /// Filter on the serial number of the device.
    public var serialNumberFilter: Swift.String?

    public init(
        connectorDestinationIdFilter: Swift.String? = nil,
        connectorDeviceIdFilter: Swift.String? = nil,
        connectorPolicyIdFilter: Swift.String? = nil,
        credentialLockerFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerFilter: Swift.String? = nil,
        parentControllerIdentifierFilter: Swift.String? = nil,
        provisioningStatusFilter: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
        roleFilter: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumberFilter: Swift.String? = nil
    ) {
        self.connectorDestinationIdFilter = connectorDestinationIdFilter
        self.connectorDeviceIdFilter = connectorDeviceIdFilter
        self.connectorPolicyIdFilter = connectorPolicyIdFilter
        self.credentialLockerFilter = credentialLockerFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerFilter = ownerFilter
        self.parentControllerIdentifierFilter = parentControllerIdentifierFilter
        self.provisioningStatusFilter = provisioningStatusFilter
        self.roleFilter = roleFilter
        self.serialNumberFilter = serialNumberFilter
    }
}

extension ListManagedThingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedThingsInput(connectorDestinationIdFilter: \(Swift.String(describing: connectorDestinationIdFilter)), connectorPolicyIdFilter: \(Swift.String(describing: connectorPolicyIdFilter)), credentialLockerFilter: \(Swift.String(describing: credentialLockerFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parentControllerIdentifierFilter: \(Swift.String(describing: parentControllerIdentifierFilter)), provisioningStatusFilter: \(Swift.String(describing: provisioningStatusFilter)), roleFilter: \(Swift.String(describing: roleFilter)), connectorDeviceIdFilter: \"CONTENT_REDACTED\", ownerFilter: \"CONTENT_REDACTED\", serialNumberFilter: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one managed thing.
    public struct ManagedThingSummary: Swift.Sendable {
        /// The timestampe value of when the managed thing was activated at.
        public var activatedAt: Foundation.Date?
        /// The id of the advertised product.
        public var advertisedProductId: Swift.String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public var arn: Swift.String?
        /// The brand of the device.
        public var brand: Swift.String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public var classification: Swift.String?
        /// The identifier of the connector destination associated with this managed thing, if applicable.
        public var connectorDestinationId: Swift.String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII). This parameter is used for cloud-to-cloud devices only.
        public var connectorDeviceId: Swift.String?
        /// The id of the connector policy. This parameter is used for cloud-to-cloud devices only.
        @available(*, deprecated, message: "ConnectorPolicyId has been deprecated API deprecated since 06-25-2025")
        public var connectorPolicyId: Swift.String?
        /// The timestamp value of when the device creation request occurred.
        public var createdAt: Foundation.Date?
        /// The identifier of the credential locker for the managed thing.
        public var credentialLockerId: Swift.String?
        /// The id of the device.
        public var id: Swift.String?
        /// The model of the device.
        public var model: Swift.String?
        /// The name of the managed thing representing the physical device.
        public var name: Swift.String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public var owner: Swift.String?
        /// Id of the controller device used for the discovery job.
        public var parentControllerId: Swift.String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public var provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public var role: IoTManagedIntegrationsClientTypes.Role?
        /// The serial number of the device.
        public var serialNumber: Swift.String?
        /// The timestamp value of when the managed thing was last updated at.
        public var updatedAt: Foundation.Date?

        public init(
            activatedAt: Foundation.Date? = nil,
            advertisedProductId: Swift.String? = nil,
            arn: Swift.String? = nil,
            brand: Swift.String? = nil,
            classification: Swift.String? = nil,
            connectorDestinationId: Swift.String? = nil,
            connectorDeviceId: Swift.String? = nil,
            connectorPolicyId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            credentialLockerId: Swift.String? = nil,
            id: Swift.String? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentControllerId: Swift.String? = nil,
            provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
            role: IoTManagedIntegrationsClientTypes.Role? = nil,
            serialNumber: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDestinationId = connectorDestinationId
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.id = id
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.updatedAt = updatedAt
        }
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedThingSummary(activatedAt: \(Swift.String(describing: activatedAt)), advertisedProductId: \(Swift.String(describing: advertisedProductId)), arn: \(Swift.String(describing: arn)), connectorDestinationId: \(Swift.String(describing: connectorDestinationId)), connectorPolicyId: \(Swift.String(describing: connectorPolicyId)), createdAt: \(Swift.String(describing: createdAt)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), parentControllerId: \(Swift.String(describing: parentControllerId)), provisioningStatus: \(Swift.String(describing: provisioningStatus)), role: \(Swift.String(describing: role)), updatedAt: \(Swift.String(describing: updatedAt)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", connectorDeviceId: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\")"}
}

public struct ListManagedThingsOutput: Swift.Sendable {
    /// The list of managed things.
    public var items: [IoTManagedIntegrationsClientTypes.ManagedThingSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ManagedThingSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListManagedThingSchemasInput: Swift.Sendable {
    /// Filter on a capability id.
    public var capabilityIdFilter: Swift.String?
    /// Filter on an endpoint id.
    public var endpointIdFilter: Swift.String?
    /// The managed thing id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        capabilityIdFilter: Swift.String? = nil,
        endpointIdFilter: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.capabilityIdFilter = capabilityIdFilter
        self.endpointIdFilter = endpointIdFilter
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one schema item associated with a managed thing.
    public struct ManagedThingSchemaListItem: Swift.Sendable {
        /// The id of the capability for a managed thing.
        public var capabilityId: Swift.String?
        /// The id of the endpoint for a managed thing.
        public var endpointId: Swift.String?
        /// The validation schema for one schema item associated with a managed thing.
        public var schema: Smithy.Document?

        public init(
            capabilityId: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            schema: Smithy.Document? = nil
        ) {
            self.capabilityId = capabilityId
            self.endpointId = endpointId
            self.schema = schema
        }
    }
}

public struct ListManagedThingSchemasOutput: Swift.Sendable {
    /// The list of managed thing schemas.
    public var items: [IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateManagedThingInput: Swift.Sendable {
    /// The brand of the device.
    public var brand: Swift.String?
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The updated capability schemas that define the functionality and features supported by the managed thing.
    public var capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// The identifier of the credential for the managed thing.
    public var credentialLockerId: Swift.String?
    /// The network mode for the hub-connected device.
    public var hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode?
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// The serial number of the device.
    public var serialNumber: Swift.String?

    public init(
        brand: Swift.String? = nil,
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        capabilitySchemas: [IoTManagedIntegrationsClientTypes.CapabilitySchemaItem]? = nil,
        classification: Swift.String? = nil,
        credentialLockerId: Swift.String? = nil,
        hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode? = nil,
        identifier: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        serialNumber: Swift.String? = nil
    ) {
        self.brand = brand
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.capabilitySchemas = capabilitySchemas
        self.classification = classification
        self.credentialLockerId = credentialLockerId
        self.hubNetworkMode = hubNetworkMode
        self.identifier = identifier
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.serialNumber = serialNumber
    }
}

extension UpdateManagedThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateManagedThingInput(capabilities: \(Swift.String(describing: capabilities)), capabilityReport: \(Swift.String(describing: capabilityReport)), capabilitySchemas: \(Swift.String(describing: capabilitySchemas)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), hubNetworkMode: \(Swift.String(describing: hubNetworkMode)), identifier: \(Swift.String(describing: identifier)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\")"}
}

public struct ListNotificationConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a notification configuration.
    public struct NotificationConfigurationSummary: Swift.Sendable {
        /// The name of the destination for the notification configuration.
        public var destinationName: Swift.String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public var eventType: IoTManagedIntegrationsClientTypes.EventType?

        public init(
            destinationName: Swift.String? = nil,
            eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
        ) {
            self.destinationName = destinationName
            self.eventType = eventType
        }
    }
}

public struct ListNotificationConfigurationsOutput: Swift.Sendable {
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of notification configurations.
    public var notificationConfigurationList: [IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationConfigurationList: [IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.notificationConfigurationList = notificationConfigurationList
    }
}

public struct UpdateNotificationConfigurationInput: Swift.Sendable {
    /// The name of the destination for the notification configuration.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.destinationName = destinationName
        self.eventType = eventType
    }
}

public struct ListOtaTaskConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task configuration.
    public struct OtaTaskConfigurationSummary: Swift.Sendable {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public var createdAt: Foundation.Date?
        /// The name of the over-the-air (OTA) task configuration.
        public var name: Swift.String?
        /// The id of the over-the-air (OTA) task configuration
        public var taskConfigurationId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            taskConfigurationId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.name = name
            self.taskConfigurationId = taskConfigurationId
        }
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OtaTaskConfigurationSummary(createdAt: \(Swift.String(describing: createdAt)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), name: \"CONTENT_REDACTED\")"}
}

public struct ListOtaTaskConfigurationsOutput: Swift.Sendable {
    /// The list of the over-the-air (OTA) task configurations.
    public var items: [IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListOtaTaskExecutionsInput: Swift.Sendable {
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaTaskExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case removed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaTaskExecutionStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .removed,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .removed: return "REMOVED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task execution summary.
    public struct OtaTaskExecutionSummary: Swift.Sendable {
        /// The execution number of the over-the-air (OTA) task execution summary.
        public var executionNumber: Swift.Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The timestamp value of when the over-the-air (OTA) task execution summary is targeted to start.
        public var queuedAt: Foundation.Date?
        /// The number of retry attempts for starting the over-the-air (OTA) task execution summary after a failed attempt.
        public var retryAttempt: Swift.Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary started.
        public var startedAt: Foundation.Date?
        /// The status of the over-the-air (OTA) task execution summary.
        public var status: IoTManagedIntegrationsClientTypes.OtaTaskExecutionStatus?

        public init(
            executionNumber: Swift.Int? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            queuedAt: Foundation.Date? = nil,
            retryAttempt: Swift.Int? = nil,
            startedAt: Foundation.Date? = nil,
            status: IoTManagedIntegrationsClientTypes.OtaTaskExecutionStatus? = nil
        ) {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one execution summary.
    public struct OtaTaskExecutionSummaries: Swift.Sendable {
        /// The id of a managed thing.
        public var managedThingId: Swift.String?
        /// Structure representing one over-the-air (OTA) task execution summary
        public var taskExecutionSummary: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary?

        public init(
            managedThingId: Swift.String? = nil,
            taskExecutionSummary: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary? = nil
        ) {
            self.managedThingId = managedThingId
            self.taskExecutionSummary = taskExecutionSummary
        }
    }
}

public struct ListOtaTaskExecutionsOutput: Swift.Sendable {
    /// A list of all of the over-the-air (OTA) task executions.
    public var executionSummaries: [IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

public struct ListOtaTasksInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task.
    public struct OtaTaskSummary: Swift.Sendable {
        /// The timestamp value of when the over-the-air (OTA) task was created at.
        public var createdAt: Foundation.Date?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of the over-the-air (OTA) task summary.
        public var status: IoTManagedIntegrationsClientTypes.OtaStatus?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public var taskArn: Swift.String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public var taskConfigurationId: Swift.String?
        /// The id of the over-the-air (OTA) task.
        public var taskId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTManagedIntegrationsClientTypes.OtaStatus? = nil,
            taskArn: Swift.String? = nil,
            taskConfigurationId: Swift.String? = nil,
            taskId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
        }
    }
}

public struct ListOtaTasksOutput: Swift.Sendable {
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of all of the over-the-air (OTA) tasks.
    public var tasks: [IoTManagedIntegrationsClientTypes.OtaTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTManagedIntegrationsClientTypes.OtaTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct UpdateOtaTaskInput: Swift.Sendable {
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.description = description
        self.identifier = identifier
        self.taskConfigurationId = taskConfigurationId
    }
}

public struct ListProvisioningProfilesInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a provisioning profile.
    public struct ProvisioningProfileSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public var arn: Swift.String?
        /// The identifier of the provisioning profile.
        public var id: Swift.String?
        /// The name of the provisioning template.
        public var name: Swift.String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil
        ) {
            self.arn = arn
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }
    }
}

public struct ListProvisioningProfilesOutput: Swift.Sendable {
    /// The list of provisioning profiles.
    public var items: [IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct RegisterCustomEndpointInput: Swift.Sendable {

    public init() { }
}

public struct RegisterCustomEndpointOutput: Swift.Sendable {
    /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
    /// This member is required.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    ) {
        self.endpointAddress = endpointAddress
    }
}

public struct PutRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id for a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?
    /// The runtime log configuration for a managed thing.
    /// This member is required.
    public var runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?

    public init(
        managedThingId: Swift.String? = nil,
        runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations? = nil
    ) {
        self.managedThingId = managedThingId
        self.runtimeLogConfigurations = runtimeLogConfigurations
    }
}

public struct ResetRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id of a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

public struct ListSchemaVersionsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// Filter on the name of the schema version.
    public var namespace: Swift.String?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Filter on the id of the schema version.
    public var schemaId: Swift.String?
    /// The schema version. If this is left blank, it defaults to the latest version.
    public var semanticVersion: Swift.String?
    /// Filter on the type of schema version.
    /// This member is required.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
    /// The visibility of the schema version.
    public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

    public init(
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
        visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
    ) {
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.schemaId = schemaId
        self.semanticVersion = semanticVersion
        self.type = type
        self.visibility = visibility
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// List item describing a schema version.
    public struct SchemaVersionListItem: Swift.Sendable {
        /// A description of the schema version.
        public var description: Swift.String?
        /// The name of the schema version.
        public var namespace: Swift.String?
        /// The identifier of the schema version.
        public var schemaId: Swift.String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public var semanticVersion: Swift.String?
        /// The type of schema version.
        public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
        /// The visibility of the schema version.
        public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

        public init(
            description: Swift.String? = nil,
            namespace: Swift.String? = nil,
            schemaId: Swift.String? = nil,
            semanticVersion: Swift.String? = nil,
            type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
            visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
        ) {
            self.description = description
            self.namespace = namespace
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }
    }
}

public struct ListSchemaVersionsOutput: Swift.Sendable {
    /// The list of schema versions.
    public var items: [IoTManagedIntegrationsClientTypes.SchemaVersionListItem]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.SchemaVersionListItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Describe a Matter cluster with an id, and the relevant attributes, commands, and events.
    public struct MatterCluster: Swift.Sendable {
        /// The Matter attributes.
        public var attributes: Smithy.Document?
        /// Describe the Matter commands with the Matter command identifier mapped to the command fields.
        public var commands: [Swift.String: Smithy.Document]?
        /// Describe the Matter events with the Matter event identifier mapped to the event fields.
        public var events: [Swift.String: Smithy.Document]?
        /// The cluster id.
        public var id: Swift.String?

        public init(
            attributes: Smithy.Document? = nil,
            commands: [Swift.String: Smithy.Document]? = nil,
            events: [Swift.String: Smithy.Document]? = nil,
            id: Swift.String? = nil
        ) {
            self.attributes = attributes
            self.commands = commands
            self.events = events
            self.id = id
        }
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MatterCluster(id: \(Swift.String(describing: id)), attributes: \"CONTENT_REDACTED\", commands: [keys: \(Swift.String(describing: commands?.keys)), values: \"CONTENT_REDACTED\"], events: [keys: \(Swift.String(describing: events?.keys)), values: \"CONTENT_REDACTED\"])"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a managed thing.
    public struct MatterEndpoint: Swift.Sendable {
        /// A list of Matter clusters for a managed thing.
        public var clusters: [IoTManagedIntegrationsClientTypes.MatterCluster]?
        /// The Matter endpoint id.
        public var id: Swift.String?

        public init(
            clusters: [IoTManagedIntegrationsClientTypes.MatterCluster]? = nil,
            id: Swift.String? = nil
        ) {
            self.clusters = clusters
            self.id = id
        }
    }
}

public struct SendConnectorEventInput: Swift.Sendable {
    /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII). This parameter is used for cloud-to-cloud devices only.
    public var connectorDeviceId: Swift.String?
    /// The id of the connector between the third-party cloud provider and IoT managed integrations.
    /// This member is required.
    public var connectorId: Swift.String?
    /// The id for the device discovery job.
    public var deviceDiscoveryId: Swift.String?
    /// The list of devices.
    public var devices: [IoTManagedIntegrationsClientTypes.Device]?
    /// The device endpoint.
    public var matterEndpoint: IoTManagedIntegrationsClientTypes.MatterEndpoint?
    /// The device state change event payload. This parameter will include the following three fields:
    ///
    /// * uri: schema auc://<PARTNER-DEVICE-ID>/ResourcePath (The Resourcepath corresponds to an OCF resource.)
    ///
    /// * op: For device state changes, this field must populate as n+d.
    ///
    /// * cn: The content depends on the OCF resource referenced in ResourcePath.
    public var message: Swift.String?
    /// The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing. The field op can have a value of "I" or "U". The field "cn" will contain the capability types.
    /// This member is required.
    public var operation: IoTManagedIntegrationsClientTypes.ConnectorEventOperation?
    /// The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see [OCF Security Specification](https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf).
    public var operationVersion: Swift.String?
    /// The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.
    public var statusCode: Swift.Int?
    /// The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.
    public var traceId: Swift.String?
    /// The id of the third-party cloud provider.
    public var userId: Swift.String?

    public init(
        connectorDeviceId: Swift.String? = nil,
        connectorId: Swift.String? = nil,
        deviceDiscoveryId: Swift.String? = nil,
        devices: [IoTManagedIntegrationsClientTypes.Device]? = nil,
        matterEndpoint: IoTManagedIntegrationsClientTypes.MatterEndpoint? = nil,
        message: Swift.String? = nil,
        operation: IoTManagedIntegrationsClientTypes.ConnectorEventOperation? = nil,
        operationVersion: Swift.String? = nil,
        statusCode: Swift.Int? = nil,
        traceId: Swift.String? = nil,
        userId: Swift.String? = nil
    ) {
        self.connectorDeviceId = connectorDeviceId
        self.connectorId = connectorId
        self.deviceDiscoveryId = deviceDiscoveryId
        self.devices = devices
        self.matterEndpoint = matterEndpoint
        self.message = message
        self.operation = operation
        self.operationVersion = operationVersion
        self.statusCode = statusCode
        self.traceId = traceId
        self.userId = userId
    }
}

extension SendConnectorEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendConnectorEventInput(connectorId: \(Swift.String(describing: connectorId)), deviceDiscoveryId: \(Swift.String(describing: deviceDiscoveryId)), devices: \(Swift.String(describing: devices)), matterEndpoint: \(Swift.String(describing: matterEndpoint)), operation: \(Swift.String(describing: operation)), traceId: \(Swift.String(describing: traceId)), connectorDeviceId: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", operationVersion: \"CONTENT_REDACTED\", statusCode: \"CONTENT_REDACTED\", userId: \"CONTENT_REDACTED\")"}
}

public struct SendConnectorEventOutput: Swift.Sendable {
    /// The id of the connector between the third-party cloud provider and IoT managed integrations.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    ) {
        self.connectorId = connectorId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A set of key/value pairs that are used to manage the resource
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateAccountAssociationInput {

    static func urlPathProvider(_ value: CreateAccountAssociationInput) -> Swift.String? {
        return "/account-associations"
    }
}

extension CreateCloudConnectorInput {

    static func urlPathProvider(_ value: CreateCloudConnectorInput) -> Swift.String? {
        return "/cloud-connectors"
    }
}

extension CreateConnectorDestinationInput {

    static func urlPathProvider(_ value: CreateConnectorDestinationInput) -> Swift.String? {
        return "/connector-destinations"
    }
}

extension CreateCredentialLockerInput {

    static func urlPathProvider(_ value: CreateCredentialLockerInput) -> Swift.String? {
        return "/credential-lockers"
    }
}

extension CreateDestinationInput {

    static func urlPathProvider(_ value: CreateDestinationInput) -> Swift.String? {
        return "/destinations"
    }
}

extension CreateEventLogConfigurationInput {

    static func urlPathProvider(_ value: CreateEventLogConfigurationInput) -> Swift.String? {
        return "/event-log-configurations"
    }
}

extension CreateManagedThingInput {

    static func urlPathProvider(_ value: CreateManagedThingInput) -> Swift.String? {
        return "/managed-things"
    }
}

extension CreateNotificationConfigurationInput {

    static func urlPathProvider(_ value: CreateNotificationConfigurationInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension CreateOtaTaskInput {

    static func urlPathProvider(_ value: CreateOtaTaskInput) -> Swift.String? {
        return "/ota-tasks"
    }
}

extension CreateOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: CreateOtaTaskConfigurationInput) -> Swift.String? {
        return "/ota-task-configurations"
    }
}

extension CreateProvisioningProfileInput {

    static func urlPathProvider(_ value: CreateProvisioningProfileInput) -> Swift.String? {
        return "/provisioning-profiles"
    }
}

extension DeleteAccountAssociationInput {

    static func urlPathProvider(_ value: DeleteAccountAssociationInput) -> Swift.String? {
        guard let accountAssociationId = value.accountAssociationId else {
            return nil
        }
        return "/account-associations/\(accountAssociationId.urlPercentEncoding())"
    }
}

extension DeleteCloudConnectorInput {

    static func urlPathProvider(_ value: DeleteCloudConnectorInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/cloud-connectors/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteConnectorDestinationInput {

    static func urlPathProvider(_ value: DeleteConnectorDestinationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/connector-destinations/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteCredentialLockerInput {

    static func urlPathProvider(_ value: DeleteCredentialLockerInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/credential-lockers/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDestinationInput {

    static func urlPathProvider(_ value: DeleteDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension DeleteEventLogConfigurationInput {

    static func urlPathProvider(_ value: DeleteEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension DeleteManagedThingInput {

    static func urlPathProvider(_ value: DeleteManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteManagedThingInput {

    static func queryItemProvider(_ value: DeleteManagedThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "Force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteNotificationConfigurationInput {

    static func urlPathProvider(_ value: DeleteNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension DeleteOtaTaskInput {

    static func urlPathProvider(_ value: DeleteOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: DeleteOtaTaskConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-task-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteProvisioningProfileInput {

    static func urlPathProvider(_ value: DeleteProvisioningProfileInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/provisioning-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension DeregisterAccountAssociationInput {

    static func urlPathProvider(_ value: DeregisterAccountAssociationInput) -> Swift.String? {
        return "/managed-thing-associations/deregister"
    }
}

extension GetAccountAssociationInput {

    static func urlPathProvider(_ value: GetAccountAssociationInput) -> Swift.String? {
        guard let accountAssociationId = value.accountAssociationId else {
            return nil
        }
        return "/account-associations/\(accountAssociationId.urlPercentEncoding())"
    }
}

extension GetCloudConnectorInput {

    static func urlPathProvider(_ value: GetCloudConnectorInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/cloud-connectors/\(identifier.urlPercentEncoding())"
    }
}

extension GetConnectorDestinationInput {

    static func urlPathProvider(_ value: GetConnectorDestinationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/connector-destinations/\(identifier.urlPercentEncoding())"
    }
}

extension GetCredentialLockerInput {

    static func urlPathProvider(_ value: GetCredentialLockerInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/credential-lockers/\(identifier.urlPercentEncoding())"
    }
}

extension GetCustomEndpointInput {

    static func urlPathProvider(_ value: GetCustomEndpointInput) -> Swift.String? {
        return "/custom-endpoint"
    }
}

extension GetDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: GetDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension GetDestinationInput {

    static func urlPathProvider(_ value: GetDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension GetDeviceDiscoveryInput {

    static func urlPathProvider(_ value: GetDeviceDiscoveryInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/device-discoveries/\(identifier.urlPercentEncoding())"
    }
}

extension GetEventLogConfigurationInput {

    static func urlPathProvider(_ value: GetEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension GetHubConfigurationInput {

    static func urlPathProvider(_ value: GetHubConfigurationInput) -> Swift.String? {
        return "/hub-configuration"
    }
}

extension GetManagedThingInput {

    static func urlPathProvider(_ value: GetManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingCapabilitiesInput {

    static func urlPathProvider(_ value: GetManagedThingCapabilitiesInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-capabilities/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingCertificateInput {

    static func urlPathProvider(_ value: GetManagedThingCertificateInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-certificate/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingConnectivityDataInput {

    static func urlPathProvider(_ value: GetManagedThingConnectivityDataInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-connectivity-data/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingMetaDataInput {

    static func urlPathProvider(_ value: GetManagedThingMetaDataInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-metadata/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingStateInput {

    static func urlPathProvider(_ value: GetManagedThingStateInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/managed-thing-states/\(managedThingId.urlPercentEncoding())"
    }
}

extension GetNotificationConfigurationInput {

    static func urlPathProvider(_ value: GetNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension GetOtaTaskInput {

    static func urlPathProvider(_ value: GetOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension GetOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: GetOtaTaskConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-task-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension GetProvisioningProfileInput {

    static func urlPathProvider(_ value: GetProvisioningProfileInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/provisioning-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension GetRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: GetRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension GetSchemaVersionInput {

    static func urlPathProvider(_ value: GetSchemaVersionInput) -> Swift.String? {
        guard let type = value.type else {
            return nil
        }
        guard let schemaVersionedId = value.schemaVersionedId else {
            return nil
        }
        return "/schema-versions/\(type.rawValue.urlPercentEncoding())/\(schemaVersionedId.urlPercentEncoding())"
    }
}

extension GetSchemaVersionInput {

    static func queryItemProvider(_ value: GetSchemaVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let format = value.format {
            let formatQueryItem = Smithy.URIQueryItem(name: "Format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension ListAccountAssociationsInput {

    static func urlPathProvider(_ value: ListAccountAssociationsInput) -> Swift.String? {
        return "/account-associations"
    }
}

extension ListAccountAssociationsInput {

    static func queryItemProvider(_ value: ListAccountAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let connectorDestinationId = value.connectorDestinationId {
            let connectorDestinationIdQueryItem = Smithy.URIQueryItem(name: "ConnectorDestinationId".urlPercentEncoding(), value: Swift.String(connectorDestinationId).urlPercentEncoding())
            items.append(connectorDestinationIdQueryItem)
        }
        return items
    }
}

extension ListCloudConnectorsInput {

    static func urlPathProvider(_ value: ListCloudConnectorsInput) -> Swift.String? {
        return "/cloud-connectors"
    }
}

extension ListCloudConnectorsInput {

    static func queryItemProvider(_ value: ListCloudConnectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let lambdaArn = value.lambdaArn {
            let lambdaArnQueryItem = Smithy.URIQueryItem(name: "LambdaArn".urlPercentEncoding(), value: Swift.String(lambdaArn).urlPercentEncoding())
            items.append(lambdaArnQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorDestinationsInput {

    static func urlPathProvider(_ value: ListConnectorDestinationsInput) -> Swift.String? {
        return "/connector-destinations"
    }
}

extension ListConnectorDestinationsInput {

    static func queryItemProvider(_ value: ListConnectorDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let cloudConnectorId = value.cloudConnectorId {
            let cloudConnectorIdQueryItem = Smithy.URIQueryItem(name: "CloudConnectorId".urlPercentEncoding(), value: Swift.String(cloudConnectorId).urlPercentEncoding())
            items.append(cloudConnectorIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCredentialLockersInput {

    static func urlPathProvider(_ value: ListCredentialLockersInput) -> Swift.String? {
        return "/credential-lockers"
    }
}

extension ListCredentialLockersInput {

    static func queryItemProvider(_ value: ListCredentialLockersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDestinationsInput {

    static func urlPathProvider(_ value: ListDestinationsInput) -> Swift.String? {
        return "/destinations"
    }
}

extension ListDestinationsInput {

    static func queryItemProvider(_ value: ListDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceDiscoveriesInput {

    static func urlPathProvider(_ value: ListDeviceDiscoveriesInput) -> Swift.String? {
        return "/device-discoveries"
    }
}

extension ListDeviceDiscoveriesInput {

    static func queryItemProvider(_ value: ListDeviceDiscoveriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let statusFilter = value.statusFilter {
            let statusFilterQueryItem = Smithy.URIQueryItem(name: "StatusFilter".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
            items.append(statusFilterQueryItem)
        }
        if let typeFilter = value.typeFilter {
            let typeFilterQueryItem = Smithy.URIQueryItem(name: "TypeFilter".urlPercentEncoding(), value: Swift.String(typeFilter.rawValue).urlPercentEncoding())
            items.append(typeFilterQueryItem)
        }
        return items
    }
}

extension ListDiscoveredDevicesInput {

    static func urlPathProvider(_ value: ListDiscoveredDevicesInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/device-discoveries/\(identifier.urlPercentEncoding())/devices"
    }
}

extension ListDiscoveredDevicesInput {

    static func queryItemProvider(_ value: ListDiscoveredDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventLogConfigurationsInput {

    static func urlPathProvider(_ value: ListEventLogConfigurationsInput) -> Swift.String? {
        return "/event-log-configurations"
    }
}

extension ListEventLogConfigurationsInput {

    static func queryItemProvider(_ value: ListEventLogConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListManagedThingAccountAssociationsInput {

    static func urlPathProvider(_ value: ListManagedThingAccountAssociationsInput) -> Swift.String? {
        return "/managed-thing-associations"
    }
}

extension ListManagedThingAccountAssociationsInput {

    static func queryItemProvider(_ value: ListManagedThingAccountAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let managedThingId = value.managedThingId {
            let managedThingIdQueryItem = Smithy.URIQueryItem(name: "ManagedThingId".urlPercentEncoding(), value: Swift.String(managedThingId).urlPercentEncoding())
            items.append(managedThingIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let accountAssociationId = value.accountAssociationId {
            let accountAssociationIdQueryItem = Smithy.URIQueryItem(name: "AccountAssociationId".urlPercentEncoding(), value: Swift.String(accountAssociationId).urlPercentEncoding())
            items.append(accountAssociationIdQueryItem)
        }
        return items
    }
}

extension ListManagedThingsInput {

    static func urlPathProvider(_ value: ListManagedThingsInput) -> Swift.String? {
        return "/managed-things"
    }
}

extension ListManagedThingsInput {

    static func queryItemProvider(_ value: ListManagedThingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let parentControllerIdentifierFilter = value.parentControllerIdentifierFilter {
            let parentControllerIdentifierFilterQueryItem = Smithy.URIQueryItem(name: "ParentControllerIdentifierFilter".urlPercentEncoding(), value: Swift.String(parentControllerIdentifierFilter).urlPercentEncoding())
            items.append(parentControllerIdentifierFilterQueryItem)
        }
        if let ownerFilter = value.ownerFilter {
            let ownerFilterQueryItem = Smithy.URIQueryItem(name: "OwnerFilter".urlPercentEncoding(), value: Swift.String(ownerFilter).urlPercentEncoding())
            items.append(ownerFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let connectorPolicyIdFilter = value.connectorPolicyIdFilter {
            let connectorPolicyIdFilterQueryItem = Smithy.URIQueryItem(name: "ConnectorPolicyIdFilter".urlPercentEncoding(), value: Swift.String(connectorPolicyIdFilter).urlPercentEncoding())
            items.append(connectorPolicyIdFilterQueryItem)
        }
        if let connectorDestinationIdFilter = value.connectorDestinationIdFilter {
            let connectorDestinationIdFilterQueryItem = Smithy.URIQueryItem(name: "ConnectorDestinationIdFilter".urlPercentEncoding(), value: Swift.String(connectorDestinationIdFilter).urlPercentEncoding())
            items.append(connectorDestinationIdFilterQueryItem)
        }
        if let connectorDeviceIdFilter = value.connectorDeviceIdFilter {
            let connectorDeviceIdFilterQueryItem = Smithy.URIQueryItem(name: "ConnectorDeviceIdFilter".urlPercentEncoding(), value: Swift.String(connectorDeviceIdFilter).urlPercentEncoding())
            items.append(connectorDeviceIdFilterQueryItem)
        }
        if let serialNumberFilter = value.serialNumberFilter {
            let serialNumberFilterQueryItem = Smithy.URIQueryItem(name: "SerialNumberFilter".urlPercentEncoding(), value: Swift.String(serialNumberFilter).urlPercentEncoding())
            items.append(serialNumberFilterQueryItem)
        }
        if let roleFilter = value.roleFilter {
            let roleFilterQueryItem = Smithy.URIQueryItem(name: "RoleFilter".urlPercentEncoding(), value: Swift.String(roleFilter.rawValue).urlPercentEncoding())
            items.append(roleFilterQueryItem)
        }
        if let provisioningStatusFilter = value.provisioningStatusFilter {
            let provisioningStatusFilterQueryItem = Smithy.URIQueryItem(name: "ProvisioningStatusFilter".urlPercentEncoding(), value: Swift.String(provisioningStatusFilter.rawValue).urlPercentEncoding())
            items.append(provisioningStatusFilterQueryItem)
        }
        if let credentialLockerFilter = value.credentialLockerFilter {
            let credentialLockerFilterQueryItem = Smithy.URIQueryItem(name: "CredentialLockerFilter".urlPercentEncoding(), value: Swift.String(credentialLockerFilter).urlPercentEncoding())
            items.append(credentialLockerFilterQueryItem)
        }
        return items
    }
}

extension ListManagedThingSchemasInput {

    static func urlPathProvider(_ value: ListManagedThingSchemasInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-thing-schemas/\(identifier.urlPercentEncoding())"
    }
}

extension ListManagedThingSchemasInput {

    static func queryItemProvider(_ value: ListManagedThingSchemasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let endpointIdFilter = value.endpointIdFilter {
            let endpointIdFilterQueryItem = Smithy.URIQueryItem(name: "EndpointIdFilter".urlPercentEncoding(), value: Swift.String(endpointIdFilter).urlPercentEncoding())
            items.append(endpointIdFilterQueryItem)
        }
        if let capabilityIdFilter = value.capabilityIdFilter {
            let capabilityIdFilterQueryItem = Smithy.URIQueryItem(name: "CapabilityIdFilter".urlPercentEncoding(), value: Swift.String(capabilityIdFilter).urlPercentEncoding())
            items.append(capabilityIdFilterQueryItem)
        }
        return items
    }
}

extension ListNotificationConfigurationsInput {

    static func urlPathProvider(_ value: ListNotificationConfigurationsInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension ListNotificationConfigurationsInput {

    static func queryItemProvider(_ value: ListNotificationConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTaskConfigurationsInput {

    static func urlPathProvider(_ value: ListOtaTaskConfigurationsInput) -> Swift.String? {
        return "/ota-task-configurations"
    }
}

extension ListOtaTaskConfigurationsInput {

    static func queryItemProvider(_ value: ListOtaTaskConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTaskExecutionsInput {

    static func urlPathProvider(_ value: ListOtaTaskExecutionsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())/devices"
    }
}

extension ListOtaTaskExecutionsInput {

    static func queryItemProvider(_ value: ListOtaTaskExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTasksInput {

    static func urlPathProvider(_ value: ListOtaTasksInput) -> Swift.String? {
        return "/ota-tasks"
    }
}

extension ListOtaTasksInput {

    static func queryItemProvider(_ value: ListOtaTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProvisioningProfilesInput {

    static func urlPathProvider(_ value: ListProvisioningProfilesInput) -> Swift.String? {
        return "/provisioning-profiles"
    }
}

extension ListProvisioningProfilesInput {

    static func queryItemProvider(_ value: ListProvisioningProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSchemaVersionsInput {

    static func urlPathProvider(_ value: ListSchemaVersionsInput) -> Swift.String? {
        guard let type = value.type else {
            return nil
        }
        return "/schema-versions/\(type.rawValue.urlPercentEncoding())"
    }
}

extension ListSchemaVersionsInput {

    static func queryItemProvider(_ value: ListSchemaVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let schemaId = value.schemaId {
            let schemaIdQueryItem = Smithy.URIQueryItem(name: "SchemaIdFilter".urlPercentEncoding(), value: Swift.String(schemaId).urlPercentEncoding())
            items.append(schemaIdQueryItem)
        }
        if let visibility = value.visibility {
            let visibilityQueryItem = Smithy.URIQueryItem(name: "VisibilityFilter".urlPercentEncoding(), value: Swift.String(visibility.rawValue).urlPercentEncoding())
            items.append(visibilityQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "NamespaceFilter".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let semanticVersion = value.semanticVersion {
            let semanticVersionQueryItem = Smithy.URIQueryItem(name: "SemanticVersionFilter".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            items.append(semanticVersionQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: PutDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension PutHubConfigurationInput {

    static func urlPathProvider(_ value: PutHubConfigurationInput) -> Swift.String? {
        return "/hub-configuration"
    }
}

extension PutRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: PutRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension RegisterAccountAssociationInput {

    static func urlPathProvider(_ value: RegisterAccountAssociationInput) -> Swift.String? {
        return "/managed-thing-associations/register"
    }
}

extension RegisterCustomEndpointInput {

    static func urlPathProvider(_ value: RegisterCustomEndpointInput) -> Swift.String? {
        return "/custom-endpoint"
    }
}

extension ResetRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: ResetRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension SendConnectorEventInput {

    static func urlPathProvider(_ value: SendConnectorEventInput) -> Swift.String? {
        guard let connectorId = value.connectorId else {
            return nil
        }
        return "/connector-event/\(connectorId.urlPercentEncoding())"
    }
}

extension SendManagedThingCommandInput {

    static func urlPathProvider(_ value: SendManagedThingCommandInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/managed-things-command/\(managedThingId.urlPercentEncoding())"
    }
}

extension StartAccountAssociationRefreshInput {

    static func urlPathProvider(_ value: StartAccountAssociationRefreshInput) -> Swift.String? {
        guard let accountAssociationId = value.accountAssociationId else {
            return nil
        }
        return "/account-associations/\(accountAssociationId.urlPercentEncoding())/refresh"
    }
}

extension StartDeviceDiscoveryInput {

    static func urlPathProvider(_ value: StartDeviceDiscoveryInput) -> Swift.String? {
        return "/device-discoveries"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccountAssociationInput {

    static func urlPathProvider(_ value: UpdateAccountAssociationInput) -> Swift.String? {
        guard let accountAssociationId = value.accountAssociationId else {
            return nil
        }
        return "/account-associations/\(accountAssociationId.urlPercentEncoding())"
    }
}

extension UpdateCloudConnectorInput {

    static func urlPathProvider(_ value: UpdateCloudConnectorInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/cloud-connectors/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateConnectorDestinationInput {

    static func urlPathProvider(_ value: UpdateConnectorDestinationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/connector-destinations/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateDestinationInput {

    static func urlPathProvider(_ value: UpdateDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension UpdateEventLogConfigurationInput {

    static func urlPathProvider(_ value: UpdateEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension UpdateManagedThingInput {

    static func urlPathProvider(_ value: UpdateManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateNotificationConfigurationInput {

    static func urlPathProvider(_ value: UpdateNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateOtaTaskInput {

    static func urlPathProvider(_ value: UpdateOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension CreateAccountAssociationInput {

    static func write(value: CreateAccountAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectorDestinationId"].write(value.connectorDestinationId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCloudConnectorInput {

    static func write(value: CreateCloudConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["EndpointConfig"].write(value.endpointConfig, with: IoTManagedIntegrationsClientTypes.EndpointConfig.write(value:to:))
        try writer["EndpointType"].write(value.endpointType)
        try writer["Name"].write(value.name)
    }
}

extension CreateConnectorDestinationInput {

    static func write(value: CreateConnectorDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthConfig"].write(value.authConfig, with: IoTManagedIntegrationsClientTypes.AuthConfig.write(value:to:))
        try writer["AuthType"].write(value.authType)
        try writer["ClientToken"].write(value.clientToken)
        try writer["CloudConnectorId"].write(value.cloudConnectorId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SecretsManager"].write(value.secretsManager, with: IoTManagedIntegrationsClientTypes.SecretsManager.write(value:to:))
    }
}

extension CreateCredentialLockerInput {

    static func write(value: CreateCredentialLockerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDestinationInput {

    static func write(value: CreateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeliveryDestinationArn"].write(value.deliveryDestinationArn)
        try writer["DeliveryDestinationType"].write(value.deliveryDestinationType)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventLogConfigurationInput {

    static func write(value: CreateEventLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["EventLogLevel"].write(value.eventLogLevel)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension CreateManagedThingInput {

    static func write(value: CreateManagedThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationMaterial"].write(value.authenticationMaterial)
        try writer["AuthenticationMaterialType"].write(value.authenticationMaterialType)
        try writer["Brand"].write(value.brand)
        try writer["Capabilities"].write(value.capabilities)
        try writer["CapabilityReport"].write(value.capabilityReport, with: IoTManagedIntegrationsClientTypes.CapabilityReport.write(value:to:))
        try writer["CapabilitySchemas"].writeList(value.capabilitySchemas, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilitySchemaItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Classification"].write(value.classification)
        try writer["ClientToken"].write(value.clientToken)
        try writer["CredentialLockerId"].write(value.credentialLockerId)
        try writer["MetaData"].writeMap(value.metaData, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Model"].write(value.model)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["Role"].write(value.role)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateNotificationConfigurationInput {

    static func write(value: CreateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DestinationName"].write(value.destinationName)
        try writer["EventType"].write(value.eventType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateOtaTaskInput {

    static func write(value: CreateOtaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["OtaMechanism"].write(value.otaMechanism)
        try writer["OtaSchedulingConfig"].write(value.otaSchedulingConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig.write(value:to:))
        try writer["OtaTargetQueryString"].write(value.otaTargetQueryString)
        try writer["OtaTaskExecutionRetryConfig"].write(value.otaTaskExecutionRetryConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig.write(value:to:))
        try writer["OtaType"].write(value.otaType)
        try writer["Protocol"].write(value.`protocol`)
        try writer["S3Url"].write(value.s3Url)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Target"].writeList(value.target, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskConfigurationId"].write(value.taskConfigurationId)
    }
}

extension CreateOtaTaskConfigurationInput {

    static func write(value: CreateOtaTaskConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PushConfig"].write(value.pushConfig, with: IoTManagedIntegrationsClientTypes.PushConfig.write(value:to:))
    }
}

extension CreateProvisioningProfileInput {

    static func write(value: CreateProvisioningProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CaCertificate"].write(value.caCertificate)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Name"].write(value.name)
        try writer["ProvisioningType"].write(value.provisioningType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeregisterAccountAssociationInput {

    static func write(value: DeregisterAccountAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssociationId"].write(value.accountAssociationId)
        try writer["ManagedThingId"].write(value.managedThingId)
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func write(value: PutDefaultEncryptionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionType"].write(value.encryptionType)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension PutHubConfigurationInput {

    static func write(value: PutHubConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HubTokenTimerExpirySettingInSeconds"].write(value.hubTokenTimerExpirySettingInSeconds)
    }
}

extension PutRuntimeLogConfigurationInput {

    static func write(value: PutRuntimeLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuntimeLogConfigurations"].write(value.runtimeLogConfigurations, with: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations.write(value:to:))
    }
}

extension RegisterAccountAssociationInput {

    static func write(value: RegisterAccountAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssociationId"].write(value.accountAssociationId)
        try writer["DeviceDiscoveryId"].write(value.deviceDiscoveryId)
        try writer["ManagedThingId"].write(value.managedThingId)
    }
}

extension SendConnectorEventInput {

    static func write(value: SendConnectorEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorDeviceId"].write(value.connectorDeviceId)
        try writer["DeviceDiscoveryId"].write(value.deviceDiscoveryId)
        try writer["Devices"].writeList(value.devices, memberWritingClosure: IoTManagedIntegrationsClientTypes.Device.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatterEndpoint"].write(value.matterEndpoint, with: IoTManagedIntegrationsClientTypes.MatterEndpoint.write(value:to:))
        try writer["Message"].write(value.message)
        try writer["Operation"].write(value.operation)
        try writer["OperationVersion"].write(value.operationVersion)
        try writer["StatusCode"].write(value.statusCode)
        try writer["TraceId"].write(value.traceId)
        try writer["UserId"].write(value.userId)
    }
}

extension SendManagedThingCommandInput {

    static func write(value: SendManagedThingCommandInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssociationId"].write(value.accountAssociationId)
        try writer["ConnectorAssociationId"].write(value.connectorAssociationId)
        try writer["Endpoints"].writeList(value.endpoints, memberWritingClosure: IoTManagedIntegrationsClientTypes.CommandEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartDeviceDiscoveryInput {

    static func write(value: StartDeviceDiscoveryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssociationId"].write(value.accountAssociationId)
        try writer["AuthenticationMaterial"].write(value.authenticationMaterial)
        try writer["AuthenticationMaterialType"].write(value.authenticationMaterialType)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectorAssociationIdentifier"].write(value.connectorAssociationIdentifier)
        try writer["ControllerIdentifier"].write(value.controllerIdentifier)
        try writer["CustomProtocolDetail"].writeMap(value.customProtocolDetail, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DiscoveryType"].write(value.discoveryType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccountAssociationInput {

    static func write(value: UpdateAccountAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateCloudConnectorInput {

    static func write(value: UpdateCloudConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateConnectorDestinationInput {

    static func write(value: UpdateConnectorDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthConfig"].write(value.authConfig, with: IoTManagedIntegrationsClientTypes.AuthConfigUpdate.write(value:to:))
        try writer["AuthType"].write(value.authType)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["SecretsManager"].write(value.secretsManager, with: IoTManagedIntegrationsClientTypes.SecretsManager.write(value:to:))
    }
}

extension UpdateDestinationInput {

    static func write(value: UpdateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryDestinationArn"].write(value.deliveryDestinationArn)
        try writer["DeliveryDestinationType"].write(value.deliveryDestinationType)
        try writer["Description"].write(value.description)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension UpdateEventLogConfigurationInput {

    static func write(value: UpdateEventLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventLogLevel"].write(value.eventLogLevel)
    }
}

extension UpdateManagedThingInput {

    static func write(value: UpdateManagedThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Brand"].write(value.brand)
        try writer["Capabilities"].write(value.capabilities)
        try writer["CapabilityReport"].write(value.capabilityReport, with: IoTManagedIntegrationsClientTypes.CapabilityReport.write(value:to:))
        try writer["CapabilitySchemas"].writeList(value.capabilitySchemas, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilitySchemaItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Classification"].write(value.classification)
        try writer["CredentialLockerId"].write(value.credentialLockerId)
        try writer["HubNetworkMode"].write(value.hubNetworkMode)
        try writer["MetaData"].writeMap(value.metaData, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Model"].write(value.model)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["SerialNumber"].write(value.serialNumber)
    }
}

extension UpdateNotificationConfigurationInput {

    static func write(value: UpdateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationName"].write(value.destinationName)
    }
}

extension UpdateOtaTaskInput {

    static func write(value: UpdateOtaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["TaskConfigurationId"].write(value.taskConfigurationId)
    }
}

extension CreateAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountAssociationOutput()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.associationState = try reader["AssociationState"].readIfPresent() ?? .sdkUnknown("")
        value.oAuthAuthorizationUrl = try reader["OAuthAuthorizationUrl"].readIfPresent() ?? ""
        return value
    }
}

extension CreateCloudConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudConnectorOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateConnectorDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorDestinationOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCredentialLockerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCredentialLockerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDestinationOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventLogConfigurationOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateManagedThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateManagedThingOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotificationConfigurationOutput()
        value.eventType = try reader["EventType"].readIfPresent()
        return value
    }
}

extension CreateOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOtaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOtaTaskOutput()
        value.description = try reader["Description"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        return value
    }
}

extension CreateOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOtaTaskConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOtaTaskConfigurationOutput()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        return value
    }
}

extension CreateProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.claimCertificate = try reader["ClaimCertificate"].readIfPresent()
        value.claimCertificatePrivateKey = try reader["ClaimCertificatePrivateKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        return value
    }
}

extension DeleteAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountAssociationOutput {
        return DeleteAccountAssociationOutput()
    }
}

extension DeleteCloudConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCloudConnectorOutput {
        return DeleteCloudConnectorOutput()
    }
}

extension DeleteConnectorDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorDestinationOutput {
        return DeleteConnectorDestinationOutput()
    }
}

extension DeleteCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCredentialLockerOutput {
        return DeleteCredentialLockerOutput()
    }
}

extension DeleteDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDestinationOutput {
        return DeleteDestinationOutput()
    }
}

extension DeleteEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventLogConfigurationOutput {
        return DeleteEventLogConfigurationOutput()
    }
}

extension DeleteManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteManagedThingOutput {
        return DeleteManagedThingOutput()
    }
}

extension DeleteNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationConfigurationOutput {
        return DeleteNotificationConfigurationOutput()
    }
}

extension DeleteOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOtaTaskOutput {
        return DeleteOtaTaskOutput()
    }
}

extension DeleteOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOtaTaskConfigurationOutput {
        return DeleteOtaTaskConfigurationOutput()
    }
}

extension DeleteProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisioningProfileOutput {
        return DeleteProvisioningProfileOutput()
    }
}

extension DeregisterAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterAccountAssociationOutput {
        return DeregisterAccountAssociationOutput()
    }
}

extension GetAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountAssociationOutput()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.associationState = try reader["AssociationState"].readIfPresent() ?? .sdkUnknown("")
        value.connectorDestinationId = try reader["ConnectorDestinationId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.oAuthAuthorizationUrl = try reader["OAuthAuthorizationUrl"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCloudConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudConnectorOutput()
        value.description = try reader["Description"].readIfPresent()
        value.endpointConfig = try reader["EndpointConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.EndpointConfig.read(from:))
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetConnectorDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectorDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorDestinationOutput()
        value.authConfig = try reader["AuthConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.AuthConfig.read(from:))
        value.authType = try reader["AuthType"].readIfPresent()
        value.cloudConnectorId = try reader["CloudConnectorId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.oAuthCompleteRedirectUrl = try reader["OAuthCompleteRedirectUrl"].readIfPresent()
        value.secretsManager = try reader["SecretsManager"].readIfPresent(with: IoTManagedIntegrationsClientTypes.SecretsManager.read(from:))
        return value
    }
}

extension GetCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCredentialLockerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCredentialLockerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCustomEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomEndpointOutput()
        value.endpointAddress = try reader["EndpointAddress"].readIfPresent() ?? ""
        return value
    }
}

extension GetDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension GetDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDestinationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deliveryDestinationArn = try reader["DeliveryDestinationArn"].readIfPresent()
        value.deliveryDestinationType = try reader["DeliveryDestinationType"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetDeviceDiscoveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceDiscoveryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDiscoveryOutput()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.connectorAssociationId = try reader["ConnectorAssociationId"].readIfPresent()
        value.controllerId = try reader["ControllerId"].readIfPresent()
        value.discoveryType = try reader["DiscoveryType"].readIfPresent() ?? .sdkUnknown("")
        value.finishedAt = try reader["FinishedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventLogConfigurationOutput()
        value.eventLogLevel = try reader["EventLogLevel"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension GetHubConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHubConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHubConfigurationOutput()
        value.hubTokenTimerExpirySettingInSeconds = try reader["HubTokenTimerExpirySettingInSeconds"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingOutput()
        value.activatedAt = try reader["ActivatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.advertisedProductId = try reader["AdvertisedProductId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.brand = try reader["Brand"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.connectorDestinationId = try reader["ConnectorDestinationId"].readIfPresent()
        value.connectorDeviceId = try reader["ConnectorDeviceId"].readIfPresent()
        value.connectorPolicyId = try reader["ConnectorPolicyId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.credentialLockerId = try reader["CredentialLockerId"].readIfPresent()
        value.deviceSpecificKey = try reader["DeviceSpecificKey"].readIfPresent()
        value.hubNetworkMode = try reader["HubNetworkMode"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.internationalArticleNumber = try reader["InternationalArticleNumber"].readIfPresent()
        value.macAddress = try reader["MacAddress"].readIfPresent()
        value.metaData = try reader["MetaData"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.model = try reader["Model"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.parentControllerId = try reader["ParentControllerId"].readIfPresent()
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.universalProductCode = try reader["UniversalProductCode"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingCapabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingCapabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingCapabilitiesOutput()
        value.capabilities = try reader["Capabilities"].readIfPresent()
        value.capabilityReport = try reader["CapabilityReport"].readIfPresent(with: IoTManagedIntegrationsClientTypes.CapabilityReport.read(from:))
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension GetManagedThingCertificateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingCertificateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingCertificateOutput()
        value.certificatePem = try reader["CertificatePem"].readIfPresent()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension GetManagedThingConnectivityDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingConnectivityDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingConnectivityDataOutput()
        value.connected = try reader["Connected"].readIfPresent()
        value.disconnectReason = try reader["DisconnectReason"].readIfPresent()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingMetaDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingMetaDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingMetaDataOutput()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.metaData = try reader["MetaData"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetManagedThingStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingStateOutput()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.StateEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotificationConfigurationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.eventType = try reader["EventType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOtaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOtaTaskOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.otaMechanism = try reader["OtaMechanism"].readIfPresent()
        value.otaSchedulingConfig = try reader["OtaSchedulingConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig.read(from:))
        value.otaTargetQueryString = try reader["OtaTargetQueryString"].readIfPresent()
        value.otaTaskExecutionRetryConfig = try reader["OtaTaskExecutionRetryConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig.read(from:))
        value.otaType = try reader["OtaType"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.s3Url = try reader["S3Url"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.target = try reader["Target"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskProcessingDetails = try reader["TaskProcessingDetails"].readIfPresent(with: IoTManagedIntegrationsClientTypes.TaskProcessingDetails.read(from:))
        return value
    }
}

extension GetOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOtaTaskConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOtaTaskConfigurationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.pushConfig = try reader["PushConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.PushConfig.read(from:))
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        return value
    }
}

extension GetProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisioningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisioningProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.claimCertificate = try reader["ClaimCertificate"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuntimeLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuntimeLogConfigurationOutput()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.runtimeLogConfigurations = try reader["RuntimeLogConfigurations"].readIfPresent(with: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations.read(from:))
        return value
    }
}

extension GetSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaVersionOutput()
        value.description = try reader["Description"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.semanticVersion = try reader["SemanticVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension ListAccountAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssociationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.AccountAssociationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCloudConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCloudConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCloudConnectorsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ConnectorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorDestinationsOutput()
        value.connectorDestinationList = try reader["ConnectorDestinationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCredentialLockersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCredentialLockersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCredentialLockersOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CredentialLockerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDestinationsOutput()
        value.destinationList = try reader["DestinationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.DestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDeviceDiscoveriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceDiscoveriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceDiscoveriesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDiscoveredDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDiscoveredDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDiscoveredDevicesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventLogConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventLogConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventLogConfigurationsOutput()
        value.eventLogConfigurationList = try reader["EventLogConfigurationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedThingAccountAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedThingAccountAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedThingAccountAssociationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ManagedThingAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedThingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedThingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedThingsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ManagedThingSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedThingSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedThingSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedThingSchemasOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notificationConfigurationList = try reader["NotificationConfigurationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOtaTaskConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTaskConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTaskConfigurationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOtaTaskExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTaskExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTaskExecutionsOutput()
        value.executionSummaries = try reader["ExecutionSummaries"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOtaTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tasks = try reader["Tasks"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningProfilesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSchemaVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaVersionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.SchemaVersionListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension PutHubConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutHubConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutHubConfigurationOutput()
        value.hubTokenTimerExpirySettingInSeconds = try reader["HubTokenTimerExpirySettingInSeconds"].readIfPresent()
        return value
    }
}

extension PutRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRuntimeLogConfigurationOutput {
        return PutRuntimeLogConfigurationOutput()
    }
}

extension RegisterAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterAccountAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterAccountAssociationOutput()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent()
        value.deviceDiscoveryId = try reader["DeviceDiscoveryId"].readIfPresent()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension RegisterCustomEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCustomEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterCustomEndpointOutput()
        value.endpointAddress = try reader["EndpointAddress"].readIfPresent() ?? ""
        return value
    }
}

extension ResetRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetRuntimeLogConfigurationOutput {
        return ResetRuntimeLogConfigurationOutput()
    }
}

extension SendConnectorEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendConnectorEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendConnectorEventOutput()
        value.connectorId = try reader["ConnectorId"].readIfPresent() ?? ""
        return value
    }
}

extension SendManagedThingCommandOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendManagedThingCommandOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendManagedThingCommandOutput()
        value.traceId = try reader["TraceId"].readIfPresent()
        return value
    }
}

extension StartAccountAssociationRefreshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAccountAssociationRefreshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAccountAssociationRefreshOutput()
        value.oAuthAuthorizationUrl = try reader["OAuthAuthorizationUrl"].readIfPresent() ?? ""
        return value
    }
}

extension StartDeviceDiscoveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDeviceDiscoveryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDeviceDiscoveryOutput()
        value.id = try reader["Id"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccountAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountAssociationOutput {
        return UpdateAccountAssociationOutput()
    }
}

extension UpdateCloudConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCloudConnectorOutput {
        return UpdateCloudConnectorOutput()
    }
}

extension UpdateConnectorDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorDestinationOutput {
        return UpdateConnectorDestinationOutput()
    }
}

extension UpdateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDestinationOutput {
        return UpdateDestinationOutput()
    }
}

extension UpdateEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventLogConfigurationOutput {
        return UpdateEventLogConfigurationOutput()
    }
}

extension UpdateManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateManagedThingOutput {
        return UpdateManagedThingOutput()
    }
}

extension UpdateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNotificationConfigurationOutput {
        return UpdateNotificationConfigurationOutput()
    }
}

extension UpdateOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOtaTaskOutput {
        return UpdateOtaTaskOutput()
    }
}

enum CreateAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCloudConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectorDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceDiscoveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHubConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingCapabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingCertificateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingConnectivityDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingMetaDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCloudConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCredentialLockersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceDiscoveriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDiscoveredDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventLogConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedThingAccountAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedThingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedThingSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTaskConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTaskExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemaVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutHubConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCustomEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendConnectorEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendManagedThingCommandOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAccountAssociationRefreshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDeviceDiscoveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCloudConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.EndpointConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.EndpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambda"].write(value.lambda, with: IoTManagedIntegrationsClientTypes.LambdaConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.EndpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.EndpointConfig()
        value.lambda = try reader["lambda"].readIfPresent(with: IoTManagedIntegrationsClientTypes.LambdaConfig.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.LambdaConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.LambdaConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.LambdaConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.LambdaConfig()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.AuthConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.AuthConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuth"].write(value.oAuth, with: IoTManagedIntegrationsClientTypes.OAuthConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.AuthConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.AuthConfig()
        value.oAuth = try reader["oAuth"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OAuthConfig.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OAuthConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OAuthConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authUrl"].write(value.authUrl)
        try writer["oAuthCompleteRedirectUrl"].write(value.oAuthCompleteRedirectUrl)
        try writer["proactiveRefreshTokenRenewal"].write(value.proactiveRefreshTokenRenewal, with: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal.write(value:to:))
        try writer["scope"].write(value.scope)
        try writer["tokenEndpointAuthenticationScheme"].write(value.tokenEndpointAuthenticationScheme)
        try writer["tokenUrl"].write(value.tokenUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OAuthConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OAuthConfig()
        value.authUrl = try reader["authUrl"].readIfPresent() ?? ""
        value.tokenUrl = try reader["tokenUrl"].readIfPresent() ?? ""
        value.scope = try reader["scope"].readIfPresent()
        value.tokenEndpointAuthenticationScheme = try reader["tokenEndpointAuthenticationScheme"].readIfPresent() ?? .sdkUnknown("")
        value.oAuthCompleteRedirectUrl = try reader["oAuthCompleteRedirectUrl"].readIfPresent()
        value.proactiveRefreshTokenRenewal = try reader["proactiveRefreshTokenRenewal"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal {

    static func write(value: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DaysBeforeRenewal"].write(value.daysBeforeRenewal)
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal()
        value.enabled = try reader["enabled"].readIfPresent()
        value.daysBeforeRenewal = try reader["DaysBeforeRenewal"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.SecretsManager {

    static func write(value: IoTManagedIntegrationsClientTypes.SecretsManager?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["versionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.SecretsManager {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.SecretsManager()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.versionId = try reader["versionId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConfigurationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConfigurationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConfigurationStatus()
        value.error = try reader["error"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationError.read(from:))
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConfigurationError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConfigurationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConfigurationError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReport {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReport?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoints"].writeList(value.endpoints, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodeId"].write(value.nodeId)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReport()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.nodeId = try reader["nodeId"].readIfPresent()
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deviceTypes"].writeList(value.deviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.deviceTypes = try reader["deviceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReportCapability {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReportCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReportCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReportCapability()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.StateEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.StateEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.StateEndpoint()
        value.endpointId = try reader["endpointId"].readIfPresent() ?? ""
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.StateCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.StateCapability {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.StateCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.StateCapability()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.TaskProcessingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.TaskProcessingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.TaskProcessingDetails()
        value.numberOfCanceledThings = try reader["NumberOfCanceledThings"].readIfPresent()
        value.numberOfFailedThings = try reader["NumberOfFailedThings"].readIfPresent()
        value.numberOfInProgressThings = try reader["NumberOfInProgressThings"].readIfPresent()
        value.numberOfQueuedThings = try reader["numberOfQueuedThings"].readIfPresent()
        value.numberOfRejectedThings = try reader["numberOfRejectedThings"].readIfPresent()
        value.numberOfRemovedThings = try reader["numberOfRemovedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        value.numberOfTimedOutThings = try reader["numberOfTimedOutThings"].readIfPresent()
        value.processingTargets = try reader["processingTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndBehavior"].write(value.endBehavior)
        try writer["EndTime"].write(value.endTime)
        try writer["MaintenanceWindows"].writeList(value.maintenanceWindows, memberWritingClosure: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig()
        value.endBehavior = try reader["EndBehavior"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.maintenanceWindows = try reader["MaintenanceWindows"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow {

    static func write(value: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInMinutes"].write(value.durationInMinutes)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow()
        value.durationInMinutes = try reader["DurationInMinutes"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetryConfigCriteria"].writeList(value.retryConfigCriteria, memberWritingClosure: IoTManagedIntegrationsClientTypes.RetryConfigCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig()
        value.retryConfigCriteria = try reader["RetryConfigCriteria"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.RetryConfigCriteria.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RetryConfigCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.RetryConfigCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureType"].write(value.failureType)
        try writer["MinNumberOfRetries"].write(value.minNumberOfRetries)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RetryConfigCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RetryConfigCriteria()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.minNumberOfRetries = try reader["MinNumberOfRetries"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.PushConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.PushConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortConfig"].write(value.abortConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig.write(value:to:))
        try writer["RolloutConfig"].write(value.rolloutConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig.write(value:to:))
        try writer["TimeoutConfig"].write(value.timeoutConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.PushConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.PushConfig()
        value.abortConfig = try reader["AbortConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig.read(from:))
        value.rolloutConfig = try reader["RolloutConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig.read(from:))
        value.timeoutConfig = try reader["TimeoutConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InProgressTimeoutInMinutes"].write(value.inProgressTimeoutInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig()
        value.inProgressTimeoutInMinutes = try reader["InProgressTimeoutInMinutes"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExponentialRolloutRate"].write(value.exponentialRolloutRate, with: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate.write(value:to:))
        try writer["MaximumPerMinute"].write(value.maximumPerMinute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig()
        value.exponentialRolloutRate = try reader["ExponentialRolloutRate"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate.read(from:))
        value.maximumPerMinute = try reader["MaximumPerMinute"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ExponentialRolloutRate {

    static func write(value: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseRatePerMinute"].write(value.baseRatePerMinute)
        try writer["IncrementFactor"].write(value.incrementFactor)
        try writer["RateIncreaseCriteria"].write(value.rateIncreaseCriteria, with: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ExponentialRolloutRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ExponentialRolloutRate()
        value.baseRatePerMinute = try reader["BaseRatePerMinute"].readIfPresent()
        value.incrementFactor = try reader["IncrementFactor"].readIfPresent()
        value.rateIncreaseCriteria = try reader["RateIncreaseCriteria"].readIfPresent(with: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfNotifiedThings"].write(value.numberOfNotifiedThings)
        try writer["numberOfSucceededThings"].write(value.numberOfSucceededThings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria()
        value.numberOfNotifiedThings = try reader["numberOfNotifiedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortConfigCriteriaList"].writeList(value.abortConfigCriteriaList, memberWritingClosure: IoTManagedIntegrationsClientTypes.AbortConfigCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig()
        value.abortConfigCriteriaList = try reader["AbortConfigCriteriaList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.AbortConfigCriteria.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.AbortConfigCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.AbortConfigCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["FailureType"].write(value.failureType)
        try writer["MinNumberOfExecutedThings"].write(value.minNumberOfExecutedThings)
        try writer["ThresholdPercentage"].write(value.thresholdPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.AbortConfigCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.AbortConfigCriteria()
        value.action = try reader["Action"].readIfPresent()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.minNumberOfExecutedThings = try reader["MinNumberOfExecutedThings"].readIfPresent()
        value.thresholdPercentage = try reader["ThresholdPercentage"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations {

    static func write(value: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteLocalStoreAfterUpload"].write(value.deleteLocalStoreAfterUpload)
        try writer["LocalStoreFileRotationMaxBytes"].write(value.localStoreFileRotationMaxBytes)
        try writer["LocalStoreFileRotationMaxFiles"].write(value.localStoreFileRotationMaxFiles)
        try writer["LocalStoreLocation"].write(value.localStoreLocation)
        try writer["LogFlushLevel"].write(value.logFlushLevel)
        try writer["LogLevel"].write(value.logLevel)
        try writer["UploadLog"].write(value.uploadLog)
        try writer["UploadPeriodMinutes"].write(value.uploadPeriodMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        value.logFlushLevel = try reader["LogFlushLevel"].readIfPresent()
        value.localStoreLocation = try reader["LocalStoreLocation"].readIfPresent()
        value.localStoreFileRotationMaxFiles = try reader["LocalStoreFileRotationMaxFiles"].readIfPresent()
        value.localStoreFileRotationMaxBytes = try reader["LocalStoreFileRotationMaxBytes"].readIfPresent()
        value.uploadLog = try reader["UploadLog"].readIfPresent()
        value.uploadPeriodMinutes = try reader["UploadPeriodMinutes"].readIfPresent()
        value.deleteLocalStoreAfterUpload = try reader["DeleteLocalStoreAfterUpload"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.AccountAssociationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.AccountAssociationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.AccountAssociationItem()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent() ?? ""
        value.associationState = try reader["AssociationState"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.connectorDestinationId = try reader["ConnectorDestinationId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConnectorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConnectorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConnectorItem()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.endpointConfig = try reader["EndpointConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.EndpointConfig.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConnectorDestinationSummary()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.cloudConnectorId = try reader["CloudConnectorId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CredentialLockerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CredentialLockerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CredentialLockerSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.DestinationSummary()
        value.description = try reader["Description"].readIfPresent()
        value.deliveryDestinationArn = try reader["DeliveryDestinationArn"].readIfPresent()
        value.deliveryDestinationType = try reader["DeliveryDestinationType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.DeviceDiscoverySummary()
        value.id = try reader["Id"].readIfPresent()
        value.discoveryType = try reader["DiscoveryType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.DiscoveredDeviceSummary()
        value.connectorDeviceId = try reader["ConnectorDeviceId"].readIfPresent()
        value.connectorDeviceName = try reader["ConnectorDeviceName"].readIfPresent()
        value.deviceTypes = try reader["DeviceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.modification = try reader["Modification"].readIfPresent()
        value.discoveredAt = try reader["DiscoveredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.brand = try reader["Brand"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.authenticationMaterial = try reader["AuthenticationMaterial"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.eventLogLevel = try reader["EventLogLevel"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ManagedThingAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ManagedThingAssociation()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.accountAssociationId = try reader["AccountAssociationId"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ManagedThingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ManagedThingSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.advertisedProductId = try reader["AdvertisedProductId"].readIfPresent()
        value.brand = try reader["Brand"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.connectorDeviceId = try reader["ConnectorDeviceId"].readIfPresent()
        value.connectorPolicyId = try reader["ConnectorPolicyId"].readIfPresent()
        value.connectorDestinationId = try reader["ConnectorDestinationId"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.credentialLockerId = try reader["CredentialLockerId"].readIfPresent()
        value.parentControllerId = try reader["ParentControllerId"].readIfPresent()
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.activatedAt = try reader["ActivatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.capabilityId = try reader["CapabilityId"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary()
        value.eventType = try reader["EventType"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries()
        value.taskExecutionSummary = try reader["TaskExecutionSummary"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary.read(from:))
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary()
        value.executionNumber = try reader["ExecutionNumber"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.queuedAt = try reader["QueuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.retryAttempt = try reader["RetryAttempt"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskSummary()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.SchemaVersionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.SchemaVersionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.SchemaVersionListItem()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.semanticVersion = try reader["SemanticVersion"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilitySchemaItem {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilitySchemaItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapabilityId"].write(value.capabilityId)
        try writer["ExtrinsicId"].write(value.extrinsicId)
        try writer["ExtrinsicVersion"].write(value.extrinsicVersion)
        try writer["Format"].write(value.format)
        try writer["Schema"].write(value.schema)
    }
}

extension IoTManagedIntegrationsClientTypes.Device {

    static func write(value: IoTManagedIntegrationsClientTypes.Device?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapabilityReport"].write(value.capabilityReport, with: IoTManagedIntegrationsClientTypes.MatterCapabilityReport.write(value:to:))
        try writer["CapabilitySchemas"].writeList(value.capabilitySchemas, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilitySchemaItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConnectorDeviceId"].write(value.connectorDeviceId)
        try writer["ConnectorDeviceName"].write(value.connectorDeviceName)
        try writer["DeviceMetadata"].write(value.deviceMetadata)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCapabilityReport {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterCapabilityReport?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoints"].writeList(value.endpoints, memberWritingClosure: IoTManagedIntegrationsClientTypes.MatterCapabilityReportEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodeId"].write(value.nodeId)
        try writer["version"].write(value.version)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCapabilityReportEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterCapabilityReportEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientClusters"].writeList(value.clientClusters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clusters"].writeList(value.clusters, memberWritingClosure: IoTManagedIntegrationsClientTypes.MatterCapabilityReportCluster.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deviceTypes"].writeList(value.deviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["parts"].writeList(value.parts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["semanticTags"].writeList(value.semanticTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCapabilityReportCluster {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterCapabilityReportCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: IoTManagedIntegrationsClientTypes.MatterCapabilityReportAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["commands"].writeList(value.commands, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["fabricIndex"].write(value.fabricIndex)
        try writer["featureMap"].write(value.featureMap)
        try writer["generatedCommands"].writeList(value.generatedCommands, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["publicId"].write(value.publicId)
        try writer["revision"].write(value.revision)
        try writer["specVersion"].write(value.specVersion)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCapabilityReportAttribute {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterCapabilityReportAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusters"].writeList(value.clusters, memberWritingClosure: IoTManagedIntegrationsClientTypes.MatterCluster.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
    }
}

extension IoTManagedIntegrationsClientTypes.MatterCluster {

    static func write(value: IoTManagedIntegrationsClientTypes.MatterCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes)
        try writer["commands"].writeMap(value.commands, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["events"].writeMap(value.events, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["id"].write(value.id)
    }
}

extension IoTManagedIntegrationsClientTypes.CommandEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.CommandEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IoTManagedIntegrationsClientTypes.CommandCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["endpointId"].write(value.endpointId)
    }
}

extension IoTManagedIntegrationsClientTypes.CommandCapability {

    static func write(value: IoTManagedIntegrationsClientTypes.CommandCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityAction {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionTraceId"].write(value.actionTraceId)
        try writer["name"].write(value.name)
        try writer["parameters"].write(value.parameters)
        try writer["ref"].write(value.ref)
    }
}

extension IoTManagedIntegrationsClientTypes.AuthConfigUpdate {

    static func write(value: IoTManagedIntegrationsClientTypes.AuthConfigUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuthUpdate"].write(value.oAuthUpdate, with: IoTManagedIntegrationsClientTypes.OAuthUpdate.write(value:to:))
    }
}

extension IoTManagedIntegrationsClientTypes.OAuthUpdate {

    static func write(value: IoTManagedIntegrationsClientTypes.OAuthUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oAuthCompleteRedirectUrl"].write(value.oAuthCompleteRedirectUrl)
        try writer["proactiveRefreshTokenRenewal"].write(value.proactiveRefreshTokenRenewal, with: IoTManagedIntegrationsClientTypes.ProactiveRefreshTokenRenewal.write(value:to:))
    }
}

public enum IoTManagedIntegrationsClientTypes {}
