//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteCredentialLockerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEventLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteManagedThingOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOtaTaskConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOtaTaskOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisioningProfileOutput: Swift.Sendable {

    public init() { }
}

public struct PutRuntimeLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct ResetRuntimeLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEventLogConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateManagedThingOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateNotificationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateOtaTaskOutput: Swift.Sendable {

    public init() { }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AbortCriteriaAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortCriteriaAction] {
            return [
                .cancel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AbortCriteriaFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case rejected
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AbortCriteriaFailureType] {
            return [
                .all,
                .failed,
                .rejected,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .rejected: return "REJECTED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one abort config criteria.
    public struct AbortConfigCriteria: Swift.Sendable {
        /// The action taken by the abort configuration.
        public var action: IoTManagedIntegrationsClientTypes.AbortCriteriaAction?
        /// Over-the-air (OTA) task abort criteria failure type.
        public var failureType: IoTManagedIntegrationsClientTypes.AbortCriteriaFailureType?
        /// The minimum number of things that must receive task execution notifications before the task can be aborted.
        public var minNumberOfExecutedThings: Swift.Int?
        /// The minimum percentage of over-the-air (OTA) task execution failures that must occur to initiate the last abort.
        public var thresholdPercentage: Swift.Double?

        public init(
            action: IoTManagedIntegrationsClientTypes.AbortCriteriaAction? = nil,
            failureType: IoTManagedIntegrationsClientTypes.AbortCriteriaFailureType? = nil,
            minNumberOfExecutedThings: Swift.Int? = nil,
            thresholdPercentage: Swift.Double? = nil
        ) {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }
    }
}

/// User is not authorized.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum AuthMaterialType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case wifiSetupQrBarCode
        case zigbeeQrBarCode
        case zwaveQrBarCode
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMaterialType] {
            return [
                .wifiSetupQrBarCode,
                .zigbeeQrBarCode,
                .zwaveQrBarCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .wifiSetupQrBarCode: return "WIFI_SETUP_QR_BAR_CODE"
            case .zigbeeQrBarCode: return "ZIGBEE_QR_BAR_CODE"
            case .zwaveQrBarCode: return "ZWAVE_QR_BAR_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Action for an Amazon Web Services capability, containing the action parameters for control.
    public struct CapabilityAction: Swift.Sendable {
        /// Describe a capability action with an actionTraceId for a response command.
        public var actionTraceId: Swift.String?
        /// Describe a capability action with a name.
        /// This member is required.
        public var name: Swift.String?
        /// Describe a capability action with a capability property.
        public var parameters: Smithy.Document?
        /// Describe a capability action with an reference.
        public var ref: Swift.String?

        public init(
            actionTraceId: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: Smithy.Document? = nil,
            ref: Swift.String? = nil
        ) {
            self.actionTraceId = actionTraceId
            self.name = name
            self.parameters = parameters
            self.ref = ref
        }
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CapabilityAction(actionTraceId: \(Swift.String(describing: actionTraceId)), name: \(Swift.String(describing: name)), ref: \(Swift.String(describing: ref)), parameters: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// The capability used in capability report.
    public struct CapabilityReportCapability: Swift.Sendable {
        /// The capability actions used in the capability report.
        /// This member is required.
        public var actions: [Swift.String]?
        /// The capability events used in the capability report.
        /// This member is required.
        public var events: [Swift.String]?
        /// The id of the schema version.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the capability.
        /// This member is required.
        public var name: Swift.String?
        /// The capability properties used in the capability report.
        /// This member is required.
        public var properties: [Swift.String]?
        /// The version of the capability.
        /// This member is required.
        public var version: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            events: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [Swift.String]? = nil,
            version: Swift.String? = nil
        ) {
            self.actions = actions
            self.events = events
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The endpoint used in the capability report.
    public struct CapabilityReportEndpoint: Swift.Sendable {
        /// The capabilities used in the capability report.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.CapabilityReportCapability]?
        /// The type of device.
        /// This member is required.
        public var deviceTypes: [Swift.String]?
        /// The id of the endpoint used in the capability report.
        /// This member is required.
        public var id: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.CapabilityReportCapability]? = nil,
            deviceTypes: [Swift.String]? = nil,
            id: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.deviceTypes = deviceTypes
            self.id = id
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Report of all capabilities supported by the device.
    public struct CapabilityReport: Swift.Sendable {
        /// The endpoints used in the capability report.
        /// This member is required.
        public var endpoints: [IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint]?
        /// The numeric identifier of the node.
        public var nodeId: Swift.String?
        /// The version of the capability report.
        /// This member is required.
        public var version: Swift.String?

        public init(
            endpoints: [IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint]? = nil,
            nodeId: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The command capabilities added for the managed thing
    public struct CommandCapability: Swift.Sendable {
        /// Describe the command capability with the actions it supports.
        /// This member is required.
        public var actions: [IoTManagedIntegrationsClientTypes.CapabilityAction]?
        /// Describe the capability with an id.
        /// This member is required.
        public var id: Swift.String?
        /// Describe the capability with an name.
        /// This member is required.
        public var name: Swift.String?
        /// Describe the capability with a version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            actions: [IoTManagedIntegrationsClientTypes.CapabilityAction]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.actions = actions
            self.id = id
            self.name = name
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The endpoint for a managed thing when sending a command.
    public struct CommandEndpoint: Swift.Sendable {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for sending commands.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.CommandCapability]?
        /// The id of the endpoint for a managed thing.
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.CommandCapability]? = nil,
            endpointId: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Provides the default encryption configuration error update details.
    public struct ConfigurationError: Swift.Sendable {
        /// The error code returned when the default encryption configuration update fails.
        public var code: Swift.String?
        /// The error message returned when the default encryption configuration update fails.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ConfigurationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .enabled,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    public struct ConfigurationStatus: Swift.Sendable {
        /// The error details describing a failed default encryption configuration update.
        public var error: IoTManagedIntegrationsClientTypes.ConfigurationError?
        /// The status state describing the default encryption configuration update.
        /// This member is required.
        public var state: IoTManagedIntegrationsClientTypes.ConfigurationState?

        public init(
            error: IoTManagedIntegrationsClientTypes.ConfigurationError? = nil,
            state: IoTManagedIntegrationsClientTypes.ConfigurationState? = nil
        ) {
            self.error = error
            self.state = state
        }
    }
}

/// There is a conflict with the request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Internal error from the service that indicates an unexpected error or that the service is unavailable.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service quota has been exceeded for this request.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// A validation error occurred when performing the API request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateCredentialLockerInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the credential locker.
    public var name: Swift.String?
    /// A set of key/value pairs that are used to manage the credential locker.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

extension CreateCredentialLockerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCredentialLockerInput(clientToken: \(Swift.String(describing: clientToken)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateCredentialLockerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the credential locker.
    public var arn: Swift.String?
    /// The timestamp value of when the credential locker request occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker creation request.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DeliveryDestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kinesis
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryDestinationType] {
            return [
                .kinesis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kinesis: return "KINESIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDestinationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    /// This member is required.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    /// This member is required.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A set of key/value pairs that are used to manage the destination.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateDestinationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDestinationInput(clientToken: \(Swift.String(describing: clientToken)), deliveryDestinationArn: \(Swift.String(describing: deliveryDestinationArn)), deliveryDestinationType: \(Swift.String(describing: deliveryDestinationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateDestinationOutput: Swift.Sendable {
    /// The name of the customer-managed destination.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum LogLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .debug,
                .error,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEventLogConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The logging level for the event log configuration.
    /// This member is required.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The identifier of the resource for the event log configuration.
    public var resourceId: Swift.String?
    /// The type of resource for the event log configuration.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.eventLogLevel = eventLogLevel
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct CreateEventLogConfigurationOutput: Swift.Sendable {
    /// The identifier of the event log configuration request.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// You are not authorized to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case controller
        case device
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .controller,
                .device
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .controller: return "CONTROLLER"
            case .device: return "DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateManagedThingInput: Swift.Sendable {
    /// The authentication material defining the device connectivity setup requests. The authentication materials used are the device bar code.
    /// This member is required.
    public var authenticationMaterial: Swift.String?
    /// The type of authentication material used for device connectivity setup requests.
    /// This member is required.
    public var authenticationMaterialType: IoTManagedIntegrationsClientTypes.AuthMaterialType?
    /// The brand of the device.
    public var brand: Swift.String?
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The identifier of the credential for the managed thing.
    public var credentialLockerId: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// The type of device used. This will be the hub controller, cloud device, or AWS IoT device.
    /// This member is required.
    public var role: IoTManagedIntegrationsClientTypes.Role?
    /// The serial number of the device.
    public var serialNumber: Swift.String?
    /// A set of key/value pairs that are used to manage the managed thing.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authenticationMaterial: Swift.String? = nil,
        authenticationMaterialType: IoTManagedIntegrationsClientTypes.AuthMaterialType? = nil,
        brand: Swift.String? = nil,
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        classification: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        credentialLockerId: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        role: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authenticationMaterial = authenticationMaterial
        self.authenticationMaterialType = authenticationMaterialType
        self.brand = brand
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.classification = classification
        self.clientToken = clientToken
        self.credentialLockerId = credentialLockerId
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.role = role
        self.serialNumber = serialNumber
        self.tags = tags
    }
}

extension CreateManagedThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateManagedThingInput(authenticationMaterialType: \(Swift.String(describing: authenticationMaterialType)), capabilities: \(Swift.String(describing: capabilities)), capabilityReport: \(Swift.String(describing: capabilityReport)), clientToken: \(Swift.String(describing: clientToken)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), role: \(Swift.String(describing: role)), authenticationMaterial: \"CONTENT_REDACTED\", brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateManagedThingOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the managed thing.
    public var arn: Swift.String?
    /// The timestamp value of when the device creation request occurred.
    public var createdAt: Foundation.Date?
    /// The id of the managed thing.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectorAssociation
        case connectorErrorReport
        case deviceCommand
        case deviceCommandRequest
        case deviceEvent
        case deviceLifeCycle
        case deviceOta
        case deviceState
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .connectorAssociation,
                .connectorErrorReport,
                .deviceCommand,
                .deviceCommandRequest,
                .deviceEvent,
                .deviceLifeCycle,
                .deviceOta,
                .deviceState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectorAssociation: return "CONNECTOR_ASSOCIATION"
            case .connectorErrorReport: return "CONNECTOR_ERROR_REPORT"
            case .deviceCommand: return "DEVICE_COMMAND"
            case .deviceCommandRequest: return "DEVICE_COMMAND_REQUEST"
            case .deviceEvent: return "DEVICE_EVENT"
            case .deviceLifeCycle: return "DEVICE_LIFE_CYCLE"
            case .deviceOta: return "DEVICE_OTA"
            case .deviceState: return "DEVICE_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNotificationConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the destination for the notification configuration.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?
    /// A set of key/value pairs that are used to manage the notification configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.destinationName = destinationName
        self.eventType = eventType
        self.tags = tags
    }
}

extension CreateNotificationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNotificationConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), destinationName: \(Swift.String(describing: destinationName)), eventType: \(Swift.String(describing: eventType)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateNotificationConfigurationOutput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaMechanism: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case push
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaMechanism] {
            return [
                .push
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .push: return "PUSH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchedulingConfigEndBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case forceCancel
        case stopRollout
        case sdkUnknown(Swift.String)

        public static var allCases: [SchedulingConfigEndBehavior] {
            return [
                .cancel,
                .forceCancel,
                .stopRollout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "CANCEL"
            case .forceCancel: return "FORCE_CANCEL"
            case .stopRollout: return "STOP_ROLLOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing scheduling maintenance window.
    public struct ScheduleMaintenanceWindow: Swift.Sendable {
        /// Displays the duration of the next maintenance window.
        public var durationInMinutes: Swift.Int?
        /// Displays the start time of the next maintenance window.
        public var startTime: Swift.String?

        public init(
            durationInMinutes: Swift.Int? = nil,
            startTime: Swift.String? = nil
        ) {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task scheduling config.
    public struct OtaTaskSchedulingConfig: Swift.Sendable {
        /// Specifies the end behavior for all task executions after a task reaches the selected endTime. If endTime is not selected when creating the task, then endBehavior does not apply.
        public var endBehavior: IoTManagedIntegrationsClientTypes.SchedulingConfigEndBehavior?
        /// The time an over-the-air (OTA) task will stop.
        public var endTime: Swift.String?
        /// Maintenance window list for over-the-air (OTA) task scheduling config.
        public var maintenanceWindows: [IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow]?
        /// The time an over-the-air (OTA) task will start.
        public var startTime: Swift.String?

        public init(
            endBehavior: IoTManagedIntegrationsClientTypes.SchedulingConfigEndBehavior? = nil,
            endTime: Swift.String? = nil,
            maintenanceWindows: [IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow]? = nil,
            startTime: Swift.String? = nil
        ) {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum RetryCriteriaFailureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case failed
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [RetryCriteriaFailureType] {
            return [
                .all,
                .failed,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .failed: return "FAILED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one retry config criteria.
    public struct RetryConfigCriteria: Swift.Sendable {
        /// Over-the-air (OTA) retry criteria failure type.
        public var failureType: IoTManagedIntegrationsClientTypes.RetryCriteriaFailureType?
        /// The number of retries allowed for a failure type for the over-the-air (OTA) task.
        public var minNumberOfRetries: Swift.Int?

        public init(
            failureType: IoTManagedIntegrationsClientTypes.RetryCriteriaFailureType? = nil,
            minNumberOfRetries: Swift.Int? = nil
        ) {
            self.failureType = failureType
            self.minNumberOfRetries = minNumberOfRetries
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task retry config.
    public struct OtaTaskExecutionRetryConfig: Swift.Sendable {
        /// The list of retry config criteria.
        public var retryConfigCriteria: [IoTManagedIntegrationsClientTypes.RetryConfigCriteria]?

        public init(
            retryConfigCriteria: [IoTManagedIntegrationsClientTypes.RetryConfigCriteria]? = nil
        ) {
            self.retryConfigCriteria = retryConfigCriteria
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuous
        case oneTime
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaType] {
            return [
                .continuous,
                .oneTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .oneTime: return "ONE_TIME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaProtocol] {
            return [
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateOtaTaskInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The deployment mechanism for the over-the-air (OTA) task.
    public var otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism?
    /// Over-the-air (OTA) task scheduling config.
    public var otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?
    /// The query string to add things to the thing group.
    public var otaTargetQueryString: Swift.String?
    /// Over-the-air (OTA) task retry config.
    public var otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?
    /// The frequency type for the over-the-air (OTA) task.
    /// This member is required.
    public var otaType: IoTManagedIntegrationsClientTypes.OtaType?
    /// The connection protocol the over-the-air (OTA) task uses to update the device.
    public var `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol?
    /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
    /// This member is required.
    public var s3Url: Swift.String?
    /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
    public var tags: [Swift.String: Swift.String]?
    /// The device targeted for the over-the-air (OTA) task.
    public var target: [Swift.String]?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism? = nil,
        otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig? = nil,
        otaTargetQueryString: Swift.String? = nil,
        otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig? = nil,
        otaType: IoTManagedIntegrationsClientTypes.OtaType? = nil,
        `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol? = nil,
        s3Url: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: [Swift.String]? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.otaMechanism = otaMechanism
        self.otaSchedulingConfig = otaSchedulingConfig
        self.otaTargetQueryString = otaTargetQueryString
        self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
        self.otaType = otaType
        self.`protocol` = `protocol`
        self.s3Url = s3Url
        self.tags = tags
        self.target = target
        self.taskConfigurationId = taskConfigurationId
    }
}

extension CreateOtaTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOtaTaskInput(protocol: \(Swift.String(describing: `protocol`)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), otaMechanism: \(Swift.String(describing: otaMechanism)), otaSchedulingConfig: \(Swift.String(describing: otaSchedulingConfig)), otaTargetQueryString: \(Swift.String(describing: otaTargetQueryString)), otaTaskExecutionRetryConfig: \(Swift.String(describing: otaTaskExecutionRetryConfig)), otaType: \(Swift.String(describing: otaType)), s3Url: \(Swift.String(describing: s3Url)), target: \(Swift.String(describing: target)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), tags: \"CONTENT_REDACTED\")"}
}

public struct CreateOtaTaskOutput: Swift.Sendable {
    /// A description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
    public var taskArn: Swift.String?
    /// The identifier of the over-the-air (OTA) task.
    public var taskId: Swift.String?

    public init(
        description: Swift.String? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    ) {
        self.description = description
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task abort config.
    public struct OtaTaskAbortConfig: Swift.Sendable {
        /// The list of criteria for the abort config.
        public var abortConfigCriteriaList: [IoTManagedIntegrationsClientTypes.AbortConfigCriteria]?

        public init(
            abortConfigCriteriaList: [IoTManagedIntegrationsClientTypes.AbortConfigCriteria]? = nil
        ) {
            self.abortConfigCriteriaList = abortConfigCriteriaList
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing rollout config criteria.
    public struct RolloutRateIncreaseCriteria: Swift.Sendable {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public var numberOfNotifiedThings: Swift.Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public var numberOfSucceededThings: Swift.Int?

        public init(
            numberOfNotifiedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil
        ) {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
    public struct ExponentialRolloutRate: Swift.Sendable {
        /// The base rate per minute for the rollout of an over-the-air (OTA) task.
        public var baseRatePerMinute: Swift.Int?
        /// The incremental factor for increasing the rollout rate of an over-the-air (OTA) task.
        public var incrementFactor: Swift.Double?
        /// The criteria for increasing the rollout rate of an over-the-air (OTA) task.
        public var rateIncreaseCriteria: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria?

        public init(
            baseRatePerMinute: Swift.Int? = nil,
            incrementFactor: Swift.Double? = nil,
            rateIncreaseCriteria: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria? = nil
        ) {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task rollout config.
    public struct OtaTaskExecutionRolloutConfig: Swift.Sendable {
        /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
        public var exponentialRolloutRate: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending task, per minute.
        public var maximumPerMinute: Swift.Int?

        public init(
            exponentialRolloutRate: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate? = nil,
            maximumPerMinute: Swift.Int? = nil
        ) {
            self.exponentialRolloutRate = exponentialRolloutRate
            self.maximumPerMinute = maximumPerMinute
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Over-the-air (OTA) task timeout config.
    public struct OtaTaskTimeoutConfig: Swift.Sendable {
        /// Specifies the amount of time the device has to finish execution of this task. The timeout interval can be anywhere between 1 minute and 7 days.
        public var inProgressTimeoutInMinutes: Swift.Int?

        public init(
            inProgressTimeoutInMinutes: Swift.Int? = nil
        ) {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing a push config.
    public struct PushConfig: Swift.Sendable {
        /// Structure representing one abort config.
        public var abortConfig: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig?
        /// Structure representing one rollout config.
        public var rolloutConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig?
        /// Structure representing one timeout config.
        public var timeoutConfig: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig?

        public init(
            abortConfig: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig? = nil,
            rolloutConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig? = nil,
            timeoutConfig: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig? = nil
        ) {
            self.abortConfig = abortConfig
            self.rolloutConfig = rolloutConfig
            self.timeoutConfig = timeoutConfig
        }
    }
}

public struct CreateOtaTaskConfigurationInput: Swift.Sendable {
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// A description of the over-the-air (OTA) task configuration.
    public var description: Swift.String?
    /// The name of the over-the-air (OTA) task.
    public var name: Swift.String?
    /// Describes the type of configuration used for the over-the-air (OTA) task.
    public var pushConfig: IoTManagedIntegrationsClientTypes.PushConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pushConfig: IoTManagedIntegrationsClientTypes.PushConfig? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.pushConfig = pushConfig
    }
}

extension CreateOtaTaskConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOtaTaskConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), pushConfig: \(Swift.String(describing: pushConfig)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateOtaTaskConfigurationOutput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        taskConfigurationId: Swift.String? = nil
    ) {
        self.taskConfigurationId = taskConfigurationId
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ProvisioningType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fleetProvisioning
        case jitr
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningType] {
            return [
                .fleetProvisioning,
                .jitr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fleetProvisioning: return "FLEET_PROVISIONING"
            case .jitr: return "JITR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisioningProfileInput: Swift.Sendable {
    /// The id of the certificate authority (CA) certificate.
    public var caCertificate: Swift.String?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    /// This member is required.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?
    /// A set of key/value pairs that are used to manage the provisioning profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        caCertificate: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.caCertificate = caCertificate
        self.clientToken = clientToken
        self.name = name
        self.provisioningType = provisioningType
        self.tags = tags
    }
}

extension CreateProvisioningProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningProfileInput(clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), caCertificate: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateProvisioningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
    public var arn: Swift.String?
    /// The id of the claim certificate.
    public var claimCertificate: Swift.String?
    /// The private key of the claim certificate. This is stored securely on the device for validating the connection endpoint with IoT managed integrations using the public key.
    public var claimCertificatePrivateKey: Swift.String?
    /// The identifier of the provisioning profile.
    public var id: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?

    public init(
        arn: Swift.String? = nil,
        claimCertificate: Swift.String? = nil,
        claimCertificatePrivateKey: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil
    ) {
        self.arn = arn
        self.claimCertificate = claimCertificate
        self.claimCertificatePrivateKey = claimCertificatePrivateKey
        self.id = id
        self.name = name
        self.provisioningType = provisioningType
    }
}

extension CreateProvisioningProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningProfileOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), claimCertificate: \"CONTENT_REDACTED\", claimCertificatePrivateKey: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing one Credential Locker.
    public struct CredentialLockerSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public var arn: Swift.String?
        /// The timestampe value of when the credential locker was created at.
        public var createdAt: Foundation.Date?
        /// The id of the credential locker.
        public var id: Swift.String?
        /// The name of the credential locker.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
        }
    }
}

extension IoTManagedIntegrationsClientTypes.CredentialLockerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CredentialLockerSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

public struct DeleteCredentialLockerInput: Swift.Sendable {
    /// The identifier of the credential locker.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetCredentialLockerInput: Swift.Sendable {
    /// The identifier of the credential locker.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetCredentialLockerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the credential locker.
    public var arn: Swift.String?
    /// The timestamp value of when the credential locker requset occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker.
    public var id: Swift.String?
    /// The name of the credential locker.
    public var name: Swift.String?
    /// A set of key/value pairs that are used to manage the credential locker.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.tags = tags
    }
}

extension GetCredentialLockerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialLockerOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct ListCredentialLockersInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCredentialLockersOutput: Swift.Sendable {
    /// The list of credential lockers.
    public var items: [IoTManagedIntegrationsClientTypes.CredentialLockerSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.CredentialLockerSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct DeleteDestinationInput: Swift.Sendable {
    /// The id of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct DeleteEventLogConfigurationInput: Swift.Sendable {
    /// The identifier of the event log configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct DeleteManagedThingInput: Swift.Sendable {
    /// When set to TRUE, a forceful deteletion of the managed thing will occur. When set to FALSE, a non-forceful deletion of the managed thing will occur.
    public var force: Swift.Bool?
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        identifier: Swift.String? = nil
    ) {
        self.force = force
        self.identifier = identifier
    }
}

public struct DeleteNotificationConfigurationInput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

public struct DeleteOtaTaskInput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DeleteOtaTaskConfigurationInput: Swift.Sendable {
    /// The identifier of the over-the-air (OTA) task configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DeleteProvisioningProfileInput: Swift.Sendable {
    /// The name of the provisioning template.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a destination for IoT managed integrations to deliver notifications for a device.
    public struct DestinationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public var deliveryDestinationArn: Swift.String?
        /// The destination type for the customer-managed destination.
        public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public var description: Swift.String?
        /// The name of the customer-managed destination.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the delivery destination.
        public var roleArn: Swift.String?

        public init(
            deliveryDestinationArn: Swift.String? = nil,
            deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil
        ) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }
    }
}

public struct GetDestinationInput: Swift.Sendable {
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct GetDestinationOutput: Swift.Sendable {
    /// The timestamp value of when the destination creation requset occurred.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    public var roleArn: Swift.String?
    /// A set of key/value pairs that are used to manage the customer-managed destination.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp value of when the destination update requset occurred.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension GetDestinationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDestinationOutput(createdAt: \(Swift.String(describing: createdAt)), deliveryDestinationArn: \(Swift.String(describing: deliveryDestinationArn)), deliveryDestinationType: \(Swift.String(describing: deliveryDestinationType)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), updatedAt: \(Swift.String(describing: updatedAt)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListDestinationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDestinationsOutput: Swift.Sendable {
    /// The list of destinations.
    public var destinationList: [IoTManagedIntegrationsClientTypes.DestinationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        destinationList: [IoTManagedIntegrationsClientTypes.DestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

public struct UpdateDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the customer-managed destination.
    public var deliveryDestinationArn: Swift.String?
    /// The destination type for the customer-managed destination.
    public var deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType?
    /// The description of the customer-managed destination.
    public var description: Swift.String?
    /// The name of the customer-managed destination.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the delivery destination role.
    public var roleArn: Swift.String?

    public init(
        deliveryDestinationArn: Swift.String? = nil,
        deliveryDestinationType: IoTManagedIntegrationsClientTypes.DeliveryDestinationType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.deliveryDestinationArn = deliveryDestinationArn
        self.deliveryDestinationType = deliveryDestinationType
        self.description = description
        self.name = name
        self.roleArn = roleArn
    }
}

public struct GetDeviceDiscoveryInput: Swift.Sendable {
    /// The id of the device discovery job request.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DiscoveryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloud
        case zigbee
        case zwave
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryType] {
            return [
                .cloud,
                .zigbee,
                .zwave
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .zigbee: return "ZIGBEE"
            case .zwave: return "ZWAVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DeviceDiscoveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceDiscoveryStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDeviceDiscoveryOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the device discovery job request.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID tracking the current discovery process for one connector association.
    public var connectorAssociationId: Swift.String?
    /// The id of the end-user's IoT hub.
    public var controllerId: Swift.String?
    /// The discovery type supporting the type of device to be discovered in the device discovery job request.
    /// This member is required.
    public var discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType?
    /// The timestamp value for the completion time of the device discovery.
    public var finishedAt: Foundation.Date?
    /// The id of the device discovery job request.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp value for the start time of the device discovery.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The status of the device discovery job request.
    /// This member is required.
    public var status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus?
    /// A set of key/value pairs that are used to manage the device discovery request.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        connectorAssociationId: Swift.String? = nil,
        controllerId: Swift.String? = nil,
        discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil,
        finishedAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: IoTManagedIntegrationsClientTypes.DeviceDiscoveryStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.connectorAssociationId = connectorAssociationId
        self.controllerId = controllerId
        self.discoveryType = discoveryType
        self.finishedAt = finishedAt
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.tags = tags
    }
}

extension GetDeviceDiscoveryOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceDiscoveryOutput(arn: \(Swift.String(describing: arn)), connectorAssociationId: \(Swift.String(describing: connectorAssociationId)), controllerId: \(Swift.String(describing: controllerId)), discoveryType: \(Swift.String(describing: discoveryType)), finishedAt: \(Swift.String(describing: finishedAt)), id: \(Swift.String(describing: id)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), tags: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    public enum DiscoveryAuthMaterialType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case zwaveInstallCode
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryAuthMaterialType] {
            return [
                .zwaveInstallCode
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .zwaveInstallCode: return "ZWAVE_INSTALL_CODE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartDeviceDiscoveryInput: Swift.Sendable {
    /// The authentication material required to start the local device discovery job request.
    public var authenticationMaterial: Swift.String?
    /// The type of authentication material used for device discovery jobs.
    public var authenticationMaterialType: IoTManagedIntegrationsClientTypes.DiscoveryAuthMaterialType?
    /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
    public var clientToken: Swift.String?
    /// The id of the connector association.
    public var connectorAssociationIdentifier: Swift.String?
    /// The id of the end-user's IoT hub.
    public var controllerIdentifier: Swift.String?
    /// The discovery type supporting the type of device to be discovered in the device discovery job request.
    /// This member is required.
    public var discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType?
    /// A set of key/value pairs that are used to manage the device discovery request.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authenticationMaterial: Swift.String? = nil,
        authenticationMaterialType: IoTManagedIntegrationsClientTypes.DiscoveryAuthMaterialType? = nil,
        clientToken: Swift.String? = nil,
        connectorAssociationIdentifier: Swift.String? = nil,
        controllerIdentifier: Swift.String? = nil,
        discoveryType: IoTManagedIntegrationsClientTypes.DiscoveryType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authenticationMaterial = authenticationMaterial
        self.authenticationMaterialType = authenticationMaterialType
        self.clientToken = clientToken
        self.connectorAssociationIdentifier = connectorAssociationIdentifier
        self.controllerIdentifier = controllerIdentifier
        self.discoveryType = discoveryType
        self.tags = tags
    }
}

extension StartDeviceDiscoveryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeviceDiscoveryInput(authenticationMaterialType: \(Swift.String(describing: authenticationMaterialType)), clientToken: \(Swift.String(describing: clientToken)), connectorAssociationIdentifier: \(Swift.String(describing: connectorAssociationIdentifier)), controllerIdentifier: \(Swift.String(describing: controllerIdentifier)), discoveryType: \(Swift.String(describing: discoveryType)), authenticationMaterial: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct StartDeviceDiscoveryOutput: Swift.Sendable {
    /// The id of the device discovery job request.
    public var id: Swift.String?
    /// The timestamp value for the start time of the device discovery.
    public var startedAt: Foundation.Date?

    public init(
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil
    ) {
        self.id = id
        self.startedAt = startedAt
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum DisconnectReasonValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authError
        case clientError
        case clientInitiatedDisconnect
        case connectionLost
        case customauthTtlExpiration
        case duplicateClientid
        case forbiddenAccess
        case mqttKeepAliveTimeout
        case `none`
        case serverError
        case serverInitiatedDisconnect
        case throttled
        case unknown
        case websocketTtlExpiration
        case sdkUnknown(Swift.String)

        public static var allCases: [DisconnectReasonValue] {
            return [
                .authError,
                .clientError,
                .clientInitiatedDisconnect,
                .connectionLost,
                .customauthTtlExpiration,
                .duplicateClientid,
                .forbiddenAccess,
                .mqttKeepAliveTimeout,
                .none,
                .serverError,
                .serverInitiatedDisconnect,
                .throttled,
                .unknown,
                .websocketTtlExpiration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authError: return "AUTH_ERROR"
            case .clientError: return "CLIENT_ERROR"
            case .clientInitiatedDisconnect: return "CLIENT_INITIATED_DISCONNECT"
            case .connectionLost: return "CONNECTION_LOST"
            case .customauthTtlExpiration: return "CUSTOMAUTH_TTL_EXPIRATION"
            case .duplicateClientid: return "DUPLICATE_CLIENTID"
            case .forbiddenAccess: return "FORBIDDEN_ACCESS"
            case .mqttKeepAliveTimeout: return "MQTT_KEEP_ALIVE_TIMEOUT"
            case .none: return "NONE"
            case .serverError: return "SERVER_ERROR"
            case .serverInitiatedDisconnect: return "SERVER_INITIATED_DISCONNECT"
            case .throttled: return "THROTTLED"
            case .unknown: return "UNKNOWN"
            case .websocketTtlExpiration: return "WEBSOCKET_TTL_EXPIRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum EncryptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerKeyEncryption
        case managedIntegrationsDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .customerKeyEncryption,
                .managedIntegrationsDefaultEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerKeyEncryption: return "CUSTOMER_KEY_ENCRYPTION"
            case .managedIntegrationsDefaultEncryption: return "MANAGED_INTEGRATIONS_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// List of event log configurations.
    public struct EventLogConfigurationSummary: Swift.Sendable {
        /// The logging level for the event log configuration.
        public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// The identifier of the event log configuration.
        public var id: Swift.String?
        /// The identifier of the resource for the event log configuration.
        public var resourceId: Swift.String?
        /// The type of resource for the event log configuration.
        public var resourceType: Swift.String?

        public init(
            eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            id: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        ) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct GetEventLogConfigurationInput: Swift.Sendable {
    /// The identifier of the event log configuration.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    ) {
        self.id = id
    }
}

public struct GetEventLogConfigurationOutput: Swift.Sendable {
    /// The logging level for the event log configuration.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The identifier of the event log configuration.
    public var id: Swift.String?
    /// The identifier of the resource for the event log configuration.
    public var resourceId: Swift.String?
    /// The type of resource for the event log configuration.
    public var resourceType: Swift.String?

    public init(
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        id: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.eventLogLevel = eventLogLevel
        self.id = id
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct ListEventLogConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEventLogConfigurationsOutput: Swift.Sendable {
    /// A list of each event log configuration and pertinent information.
    public var eventLogConfigurationList: [IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        eventLogConfigurationList: [IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.eventLogConfigurationList = eventLogConfigurationList
        self.nextToken = nextToken
    }
}

public struct UpdateEventLogConfigurationInput: Swift.Sendable {
    /// The log level for the event in terms of severity.
    /// This member is required.
    public var eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel?
    /// The log configuration id.
    /// This member is required.
    public var id: Swift.String?

    public init(
        eventLogLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
        id: Swift.String? = nil
    ) {
        self.eventLogLevel = eventLogLevel
        self.id = id
    }
}

public struct GetCustomEndpointInput: Swift.Sendable {

    public init() { }
}

public struct GetCustomEndpointOutput: Swift.Sendable {
    /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
    /// This member is required.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    ) {
        self.endpointAddress = endpointAddress
    }
}

/// An unexpected error has occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetDefaultEncryptionConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    /// This member is required.
    public var configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct GetHubConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetHubConfigurationOutput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?
    /// The timestamp value of when the hub configuration was updated.
    public var updatedAt: Foundation.Date?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        self.updatedAt = updatedAt
    }
}

public struct GetManagedThingInput: Swift.Sendable {
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum HubNetworkMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case networkWideExclusion
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [HubNetworkMode] {
            return [
                .networkWideExclusion,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .networkWideExclusion: return "NETWORK_WIDE_EXCLUSION"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum ProvisioningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deleted
        case deleteInProgress
        case deletionFailed
        case discovered
        case isolated
        case preAssociated
        case unassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .activated,
                .deleted,
                .deleteInProgress,
                .deletionFailed,
                .discovered,
                .isolated,
                .preAssociated,
                .unassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deleted: return "DELETED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deletionFailed: return "DELETION_FAILED"
            case .discovered: return "DISCOVERED"
            case .isolated: return "ISOLATED"
            case .preAssociated: return "PRE_ASSOCIATED"
            case .unassociated: return "UNASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetManagedThingOutput: Swift.Sendable {
    /// The timestampe value of when the device was activated.
    public var activatedAt: Foundation.Date?
    /// The id of the advertised product.
    public var advertisedProductId: Swift.String?
    /// The Amazon Resource Name (ARN) of the managed thing.
    public var arn: Swift.String?
    /// The brand of the device.
    public var brand: Swift.String?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII). This parameter is used for cloud-to-cloud devices only.
    public var connectorDeviceId: Swift.String?
    /// The id of the connector policy. This parameter is used for cloud-to-cloud devices only.
    public var connectorPolicyId: Swift.String?
    /// The timestamp value of when the device creation request occurred.
    public var createdAt: Foundation.Date?
    /// The identifier of the credential locker for the managed thing.
    public var credentialLockerId: Swift.String?
    /// A Zwave device-specific key used during device activation. This parameter is used for Zwave devices only.
    public var deviceSpecificKey: Swift.String?
    /// The network mode for the hub-connected device.
    public var hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode?
    /// The id of the managed thing.
    public var id: Swift.String?
    /// The unique 13 digit number that identifies the managed thing.
    public var internationalArticleNumber: Swift.String?
    /// The media access control (MAC) address for the device represented by the managed thing. This parameter is used for Zigbee devices only.
    public var macAddress: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// Id of the controller device used for the discovery job.
    public var parentControllerId: Swift.String?
    /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
    public var provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
    /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
    public var role: IoTManagedIntegrationsClientTypes.Role?
    /// The serial number of the device.
    public var serialNumber: Swift.String?
    /// A set of key/value pairs that are used to manage the managed thing.
    public var tags: [Swift.String: Swift.String]?
    /// The universal product code (UPC) of the device model. The UPC is typically used in the United States of America and Canada.
    public var universalProductCode: Swift.String?
    /// The timestamp value of when the managed thing was last updated at.
    public var updatedAt: Foundation.Date?

    public init(
        activatedAt: Foundation.Date? = nil,
        advertisedProductId: Swift.String? = nil,
        arn: Swift.String? = nil,
        brand: Swift.String? = nil,
        classification: Swift.String? = nil,
        connectorDeviceId: Swift.String? = nil,
        connectorPolicyId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        credentialLockerId: Swift.String? = nil,
        deviceSpecificKey: Swift.String? = nil,
        hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode? = nil,
        id: Swift.String? = nil,
        internationalArticleNumber: Swift.String? = nil,
        macAddress: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        parentControllerId: Swift.String? = nil,
        provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
        role: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        universalProductCode: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.activatedAt = activatedAt
        self.advertisedProductId = advertisedProductId
        self.arn = arn
        self.brand = brand
        self.classification = classification
        self.connectorDeviceId = connectorDeviceId
        self.connectorPolicyId = connectorPolicyId
        self.createdAt = createdAt
        self.credentialLockerId = credentialLockerId
        self.deviceSpecificKey = deviceSpecificKey
        self.hubNetworkMode = hubNetworkMode
        self.id = id
        self.internationalArticleNumber = internationalArticleNumber
        self.macAddress = macAddress
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.parentControllerId = parentControllerId
        self.provisioningStatus = provisioningStatus
        self.role = role
        self.serialNumber = serialNumber
        self.tags = tags
        self.universalProductCode = universalProductCode
        self.updatedAt = updatedAt
    }
}

extension GetManagedThingOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetManagedThingOutput(activatedAt: \(Swift.String(describing: activatedAt)), advertisedProductId: \(Swift.String(describing: advertisedProductId)), arn: \(Swift.String(describing: arn)), connectorPolicyId: \(Swift.String(describing: connectorPolicyId)), createdAt: \(Swift.String(describing: createdAt)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), hubNetworkMode: \(Swift.String(describing: hubNetworkMode)), id: \(Swift.String(describing: id)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), parentControllerId: \(Swift.String(describing: parentControllerId)), provisioningStatus: \(Swift.String(describing: provisioningStatus)), role: \(Swift.String(describing: role)), updatedAt: \(Swift.String(describing: updatedAt)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", connectorDeviceId: \"CONTENT_REDACTED\", deviceSpecificKey: \"CONTENT_REDACTED\", internationalArticleNumber: \"CONTENT_REDACTED\", macAddress: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\", universalProductCode: \"CONTENT_REDACTED\")"}
}

public struct GetManagedThingCapabilitiesInput: Swift.Sendable {
    /// The id of the device.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingCapabilitiesOutput: Swift.Sendable {
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The id of the device.
    public var managedThingId: Swift.String?

    public init(
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.managedThingId = managedThingId
    }
}

public struct GetManagedThingConnectivityDataInput: Swift.Sendable {
    /// The identifier of a managed thing.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingConnectivityDataOutput: Swift.Sendable {
    /// The connectivity status for a managed thing.
    public var connected: Swift.Bool?
    /// The reason for the connectivity disconnect with the managed thing.
    public var disconnectReason: IoTManagedIntegrationsClientTypes.DisconnectReasonValue?
    /// The id of a managed thing.
    public var managedThingId: Swift.String?
    /// The timestamp value of when the connectivity status for a managed thing was last taken.
    public var timestamp: Foundation.Date?

    public init(
        connected: Swift.Bool? = nil,
        disconnectReason: IoTManagedIntegrationsClientTypes.DisconnectReasonValue? = nil,
        managedThingId: Swift.String? = nil,
        timestamp: Foundation.Date? = nil
    ) {
        self.connected = connected
        self.disconnectReason = disconnectReason
        self.managedThingId = managedThingId
        self.timestamp = timestamp
    }
}

public struct GetManagedThingMetaDataInput: Swift.Sendable {
    /// The managed thing id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetManagedThingMetaDataOutput: Swift.Sendable {
    /// The managed thing id.
    public var managedThingId: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?

    public init(
        managedThingId: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil
    ) {
        self.managedThingId = managedThingId
        self.metaData = metaData
    }
}

public struct GetManagedThingStateInput: Swift.Sendable {
    /// The id of the device.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// State capabilities added for the managed thing.
    public struct StateCapability: Swift.Sendable {
        /// The id of the managed thing in the capability report.
        /// This member is required.
        public var id: Swift.String?
        /// Name for the Amazon Web Services capability.
        /// This member is required.
        public var name: Swift.String?
        /// Describe the command capability with the properties it supports.
        public var properties: Smithy.Document?
        /// Version for the Amazon Web Services capability.
        /// This member is required.
        public var version: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: Smithy.Document? = nil,
            version: Swift.String? = nil
        ) {
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }
    }
}

extension IoTManagedIntegrationsClientTypes.StateCapability: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateCapability(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)), properties: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Describe the endpoint with an Id, a name, and the relevant capabilities for reporting state
    public struct StateEndpoint: Swift.Sendable {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for the reporting state.
        /// This member is required.
        public var capabilities: [IoTManagedIntegrationsClientTypes.StateCapability]?
        /// Numeric identifier of the endpoint
        /// This member is required.
        public var endpointId: Swift.String?

        public init(
            capabilities: [IoTManagedIntegrationsClientTypes.StateCapability]? = nil,
            endpointId: Swift.String? = nil
        ) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }
    }
}

public struct GetManagedThingStateOutput: Swift.Sendable {
    /// The device endpoint.
    /// This member is required.
    public var endpoints: [IoTManagedIntegrationsClientTypes.StateEndpoint]?

    public init(
        endpoints: [IoTManagedIntegrationsClientTypes.StateEndpoint]? = nil
    ) {
        self.endpoints = endpoints
    }
}

public struct GetNotificationConfigurationInput: Swift.Sendable {
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.eventType = eventType
    }
}

public struct GetNotificationConfigurationOutput: Swift.Sendable {
    /// The timestamp value of when the notification configuration was created.
    public var createdAt: Foundation.Date?
    /// The name of the destination for the notification configuration.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?
    /// A set of key/value pairs that are used to manage the notification configuration.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp value of when the notification configuration was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.destinationName = destinationName
        self.eventType = eventType
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension GetNotificationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNotificationConfigurationOutput(createdAt: \(Swift.String(describing: createdAt)), destinationName: \(Swift.String(describing: destinationName)), eventType: \(Swift.String(describing: eventType)), updatedAt: \(Swift.String(describing: updatedAt)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetOtaTaskInput: Swift.Sendable {
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case deletionInProgress
        case inProgress
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaStatus] {
            return [
                .canceled,
                .completed,
                .deletionInProgress,
                .inProgress,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .inProgress: return "IN_PROGRESS"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Details about the over-the-air (OTA) task process.
    public struct TaskProcessingDetails: Swift.Sendable {
        /// The number of canceled things in an over-the-air (OTA) task.
        public var numberOfCanceledThings: Swift.Int?
        /// The number of failed things in an over-the-air (OTA) task.
        public var numberOfFailedThings: Swift.Int?
        /// The number of in progress things in an over-the-air (OTA) task.
        public var numberOfInProgressThings: Swift.Int?
        /// The number of queued things in an over-the-air (OTA) task.
        public var numberOfQueuedThings: Swift.Int?
        /// The number of rejected things in an over-the-air (OTA) task.
        public var numberOfRejectedThings: Swift.Int?
        /// The number of removed things in an over-the-air (OTA) task.
        public var numberOfRemovedThings: Swift.Int?
        /// The number of succeeded things in an over-the-air (OTA) task.
        public var numberOfSucceededThings: Swift.Int?
        /// The number of timed out things in an over-the-air (OTA) task.
        public var numberOfTimedOutThings: Swift.Int?
        /// The targets of the over-the-air (OTA) task.
        public var processingTargets: [Swift.String]?

        public init(
            numberOfCanceledThings: Swift.Int? = nil,
            numberOfFailedThings: Swift.Int? = nil,
            numberOfInProgressThings: Swift.Int? = nil,
            numberOfQueuedThings: Swift.Int? = nil,
            numberOfRejectedThings: Swift.Int? = nil,
            numberOfRemovedThings: Swift.Int? = nil,
            numberOfSucceededThings: Swift.Int? = nil,
            numberOfTimedOutThings: Swift.Int? = nil,
            processingTargets: [Swift.String]? = nil
        ) {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }
    }
}

public struct GetOtaTaskOutput: Swift.Sendable {
    /// The timestamp value of when the over-the-air (OTA) task was created.
    public var createdAt: Foundation.Date?
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The timestamp value of when the over-the-air (OTA) task was last updated at.
    public var lastUpdatedAt: Foundation.Date?
    /// The deployment mechanism for the over-the-air (OTA) task.
    public var otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism?
    /// Over-the-air (OTA) task scheduling config.
    public var otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?
    /// The query string to add things to the thing group.
    public var otaTargetQueryString: Swift.String?
    /// Over-the-air (OTA) task retry config.
    public var otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?
    /// The frequency type for the over-the-air (OTA) task.
    public var otaType: IoTManagedIntegrationsClientTypes.OtaType?
    /// The connection protocol the over-the-air (OTA) task uses to update the device.
    public var `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol?
    /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
    public var s3Url: Swift.String?
    /// The status of the over-the-air (OTA) task.
    public var status: IoTManagedIntegrationsClientTypes.OtaStatus?
    /// The device targeted for the over-the-air (OTA) task.
    public var target: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task
    public var taskArn: Swift.String?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?
    /// The id of the over-the-air (OTA) task.
    public var taskId: Swift.String?
    /// The processing details of all over-the-air (OTA) tasks.
    public var taskProcessingDetails: IoTManagedIntegrationsClientTypes.TaskProcessingDetails?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        otaMechanism: IoTManagedIntegrationsClientTypes.OtaMechanism? = nil,
        otaSchedulingConfig: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig? = nil,
        otaTargetQueryString: Swift.String? = nil,
        otaTaskExecutionRetryConfig: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig? = nil,
        otaType: IoTManagedIntegrationsClientTypes.OtaType? = nil,
        `protocol`: IoTManagedIntegrationsClientTypes.OtaProtocol? = nil,
        s3Url: Swift.String? = nil,
        status: IoTManagedIntegrationsClientTypes.OtaStatus? = nil,
        target: [Swift.String]? = nil,
        taskArn: Swift.String? = nil,
        taskConfigurationId: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskProcessingDetails: IoTManagedIntegrationsClientTypes.TaskProcessingDetails? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.otaMechanism = otaMechanism
        self.otaSchedulingConfig = otaSchedulingConfig
        self.otaTargetQueryString = otaTargetQueryString
        self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
        self.otaType = otaType
        self.`protocol` = `protocol`
        self.s3Url = s3Url
        self.status = status
        self.target = target
        self.taskArn = taskArn
        self.taskConfigurationId = taskConfigurationId
        self.taskId = taskId
        self.taskProcessingDetails = taskProcessingDetails
    }
}

public struct GetOtaTaskConfigurationInput: Swift.Sendable {
    /// The over-the-air (OTA) task configuration id.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetOtaTaskConfigurationOutput: Swift.Sendable {
    /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
    public var createdAt: Foundation.Date?
    /// A description of the over-the-air (OTA) task configuration.
    public var description: Swift.String?
    /// The name of the over-the-air (OTA) task configuration.
    public var name: Swift.String?
    /// Describes the type of configuration used for the over-the-air (OTA) task.
    public var pushConfig: IoTManagedIntegrationsClientTypes.PushConfig?
    /// The over-the-air (OTA) task configuration id.
    public var taskConfigurationId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pushConfig: IoTManagedIntegrationsClientTypes.PushConfig? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.name = name
        self.pushConfig = pushConfig
        self.taskConfigurationId = taskConfigurationId
    }
}

extension GetOtaTaskConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOtaTaskConfigurationOutput(createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), pushConfig: \(Swift.String(describing: pushConfig)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), name: \"CONTENT_REDACTED\")"}
}

public struct GetProvisioningProfileInput: Swift.Sendable {
    /// The provisioning template the device uses for the provisioning process.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetProvisioningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
    public var arn: Swift.String?
    /// The id of the claim certificate.
    public var claimCertificate: Swift.String?
    /// The provisioning profile id..
    public var id: Swift.String?
    /// The name of the provisioning template.
    public var name: Swift.String?
    /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
    public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?
    /// A set of key/value pairs that are used to manage the provisioning profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        claimCertificate: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.claimCertificate = claimCertificate
        self.id = id
        self.name = name
        self.provisioningType = provisioningType
        self.tags = tags
    }
}

extension GetProvisioningProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisioningProfileOutput(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provisioningType: \(Swift.String(describing: provisioningType)), claimCertificate: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct GetRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id for a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// The different configurations for runtime logs.
    public struct RuntimeLogConfigurations: Swift.Sendable {
        /// Configuration to enable or disable deleting of runtime logs in the device once uploaded to the cloud.
        public var deleteLocalStoreAfterUpload: Swift.Bool?
        /// Configuration to set the maximum bytes of runtime logs that can be stored on the device before the oldest logs are deleted or overwritten.
        public var localStoreFileRotationMaxBytes: Swift.Int?
        /// Configuration to set the maximum number of runtime log files that can be stored on the device before the oldest files are deleted or overwritten.
        public var localStoreFileRotationMaxFiles: Swift.Int?
        /// Configuration of where to store runtime logs in the device.
        public var localStoreLocation: Swift.String?
        /// The different log levels available for configuration.
        public var logFlushLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// The different log levels available for configuration.
        public var logLevel: IoTManagedIntegrationsClientTypes.LogLevel?
        /// Configuration to enable or disable uploading of runtime logs to the cloud.
        public var uploadLog: Swift.Bool?
        /// Configuration to set the time interval in minutes between each batch of runtime logs that the device uploads to the cloud.
        public var uploadPeriodMinutes: Swift.Int?

        public init(
            deleteLocalStoreAfterUpload: Swift.Bool? = nil,
            localStoreFileRotationMaxBytes: Swift.Int? = nil,
            localStoreFileRotationMaxFiles: Swift.Int? = nil,
            localStoreLocation: Swift.String? = nil,
            logFlushLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            logLevel: IoTManagedIntegrationsClientTypes.LogLevel? = nil,
            uploadLog: Swift.Bool? = nil,
            uploadPeriodMinutes: Swift.Int? = nil
        ) {
            self.deleteLocalStoreAfterUpload = deleteLocalStoreAfterUpload
            self.localStoreFileRotationMaxBytes = localStoreFileRotationMaxBytes
            self.localStoreFileRotationMaxFiles = localStoreFileRotationMaxFiles
            self.localStoreLocation = localStoreLocation
            self.logFlushLevel = logFlushLevel
            self.logLevel = logLevel
            self.uploadLog = uploadLog
            self.uploadPeriodMinutes = uploadPeriodMinutes
        }
    }
}

public struct GetRuntimeLogConfigurationOutput: Swift.Sendable {
    /// The id for a managed thing.
    public var managedThingId: Swift.String?
    /// The runtime log configuration for a managed thing.
    public var runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?

    public init(
        managedThingId: Swift.String? = nil,
        runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations? = nil
    ) {
        self.managedThingId = managedThingId
        self.runtimeLogConfigurations = runtimeLogConfigurations
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case connector
        case zcl
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionFormat] {
            return [
                .aws,
                .connector,
                .zcl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .connector: return "CONNECTOR"
            case .zcl: return "ZCL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capability
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionType] {
            return [
                .capability,
                .definition
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capability: return "capability"
            case .definition: return "definition"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaVersionInput: Swift.Sendable {
    /// The format of the schema version.
    public var format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat?
    /// Schema id with a version specified. If the version is missing, it defaults to latest version.
    /// This member is required.
    public var schemaVersionedId: Swift.String?
    /// The type of schema version.
    /// This member is required.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?

    public init(
        format: IoTManagedIntegrationsClientTypes.SchemaVersionFormat? = nil,
        schemaVersionedId: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil
    ) {
        self.format = format
        self.schemaVersionedId = schemaVersionedId
        self.type = type
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum SchemaVersionVisibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaVersionVisibility] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSchemaVersionOutput: Swift.Sendable {
    /// The description of the schema version.
    public var description: Swift.String?
    /// The name of the schema version.
    public var namespace: Swift.String?
    /// The schema of the schema version.
    public var schema: Smithy.Document?
    /// The id of the schema version.
    public var schemaId: Swift.String?
    /// The schema version. If this is left blank, it defaults to the latest version.
    public var semanticVersion: Swift.String?
    /// The type of schema version.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
    /// The visibility of the schema version.
    public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

    public init(
        description: Swift.String? = nil,
        namespace: Swift.String? = nil,
        schema: Smithy.Document? = nil,
        schemaId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
        visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
    ) {
        self.description = description
        self.namespace = namespace
        self.schema = schema
        self.schemaId = schemaId
        self.semanticVersion = semanticVersion
        self.type = type
        self.visibility = visibility
    }
}

public struct PutHubConfigurationInput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    /// This member is required.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
    }
}

public struct PutHubConfigurationOutput: Swift.Sendable {
    /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
    public var hubTokenTimerExpirySettingInSeconds: Swift.Int?

    public init(
        hubTokenTimerExpirySettingInSeconds: Swift.Int? = nil
    ) {
        self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
    }
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Sendable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct PutDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// Provides the status of the default encryption configuration for an Amazon Web Services account.
    /// This member is required.
    public var configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType?
    /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTManagedIntegrationsClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTManagedIntegrationsClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    ) {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct SendManagedThingCommandInput: Swift.Sendable {
    /// The ID tracking the current discovery process for one connector association.
    public var connectorAssociationId: Swift.String?
    /// The device endpoint.
    /// This member is required.
    public var endpoints: [IoTManagedIntegrationsClientTypes.CommandEndpoint]?
    /// The id of the device.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        connectorAssociationId: Swift.String? = nil,
        endpoints: [IoTManagedIntegrationsClientTypes.CommandEndpoint]? = nil,
        managedThingId: Swift.String? = nil
    ) {
        self.connectorAssociationId = connectorAssociationId
        self.endpoints = endpoints
        self.managedThingId = managedThingId
    }
}

public struct SendManagedThingCommandOutput: Swift.Sendable {
    /// The trace request identifier. This is specified by the device owner, but will be generated by IoT managed integrations if not provided by the device owner.
    public var traceId: Swift.String?

    public init(
        traceId: Swift.String? = nil
    ) {
        self.traceId = traceId
    }
}

public struct ListManagedThingsInput: Swift.Sendable {
    /// Filter on a connector policy id for a managed thing.
    public var connectorPolicyIdFilter: Swift.String?
    /// Filter on a credential locker for a managed thing.
    public var credentialLockerFilter: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Filter on device owners when listing managed things.
    public var ownerFilter: Swift.String?
    /// Filter on a parent controller id for a managed thing.
    public var parentControllerIdentifierFilter: Swift.String?
    /// Filter on the status of the device.
    public var provisioningStatusFilter: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
    /// Filter on the type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
    public var roleFilter: IoTManagedIntegrationsClientTypes.Role?
    /// Filter on the serial number of the device.
    public var serialNumberFilter: Swift.String?

    public init(
        connectorPolicyIdFilter: Swift.String? = nil,
        credentialLockerFilter: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerFilter: Swift.String? = nil,
        parentControllerIdentifierFilter: Swift.String? = nil,
        provisioningStatusFilter: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
        roleFilter: IoTManagedIntegrationsClientTypes.Role? = nil,
        serialNumberFilter: Swift.String? = nil
    ) {
        self.connectorPolicyIdFilter = connectorPolicyIdFilter
        self.credentialLockerFilter = credentialLockerFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerFilter = ownerFilter
        self.parentControllerIdentifierFilter = parentControllerIdentifierFilter
        self.provisioningStatusFilter = provisioningStatusFilter
        self.roleFilter = roleFilter
        self.serialNumberFilter = serialNumberFilter
    }
}

extension ListManagedThingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListManagedThingsInput(connectorPolicyIdFilter: \(Swift.String(describing: connectorPolicyIdFilter)), credentialLockerFilter: \(Swift.String(describing: credentialLockerFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), parentControllerIdentifierFilter: \(Swift.String(describing: parentControllerIdentifierFilter)), provisioningStatusFilter: \(Swift.String(describing: provisioningStatusFilter)), roleFilter: \(Swift.String(describing: roleFilter)), ownerFilter: \"CONTENT_REDACTED\", serialNumberFilter: \"CONTENT_REDACTED\")"}
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one managed thing.
    public struct ManagedThingSummary: Swift.Sendable {
        /// The timestampe value of when the managed thing was activated at.
        public var activatedAt: Foundation.Date?
        /// The id of the advertised product.
        public var advertisedProductId: Swift.String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public var arn: Swift.String?
        /// The brand of the device.
        public var brand: Swift.String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public var classification: Swift.String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII). This parameter is used for cloud-to-cloud devices only.
        public var connectorDeviceId: Swift.String?
        /// The id of the connector policy. This parameter is used for cloud-to-cloud devices only.
        public var connectorPolicyId: Swift.String?
        /// The timestamp value of when the device creation request occurred.
        public var createdAt: Foundation.Date?
        /// The identifier of the credential locker for the managed thing.
        public var credentialLockerId: Swift.String?
        /// The id of the device.
        public var id: Swift.String?
        /// The model of the device.
        public var model: Swift.String?
        /// The name of the managed thing representing the physical device.
        public var name: Swift.String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public var owner: Swift.String?
        /// Id of the controller device used for the discovery job.
        public var parentControllerId: Swift.String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public var provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public var role: IoTManagedIntegrationsClientTypes.Role?
        /// The serial number of the device.
        public var serialNumber: Swift.String?
        /// The timestamp value of when the managed thing was last updated at.
        public var updatedAt: Foundation.Date?

        public init(
            activatedAt: Foundation.Date? = nil,
            advertisedProductId: Swift.String? = nil,
            arn: Swift.String? = nil,
            brand: Swift.String? = nil,
            classification: Swift.String? = nil,
            connectorDeviceId: Swift.String? = nil,
            connectorPolicyId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            credentialLockerId: Swift.String? = nil,
            id: Swift.String? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentControllerId: Swift.String? = nil,
            provisioningStatus: IoTManagedIntegrationsClientTypes.ProvisioningStatus? = nil,
            role: IoTManagedIntegrationsClientTypes.Role? = nil,
            serialNumber: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.id = id
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.updatedAt = updatedAt
        }
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedThingSummary(activatedAt: \(Swift.String(describing: activatedAt)), advertisedProductId: \(Swift.String(describing: advertisedProductId)), arn: \(Swift.String(describing: arn)), connectorPolicyId: \(Swift.String(describing: connectorPolicyId)), createdAt: \(Swift.String(describing: createdAt)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), parentControllerId: \(Swift.String(describing: parentControllerId)), provisioningStatus: \(Swift.String(describing: provisioningStatus)), role: \(Swift.String(describing: role)), updatedAt: \(Swift.String(describing: updatedAt)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", connectorDeviceId: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\")"}
}

public struct ListManagedThingsOutput: Swift.Sendable {
    /// The list of managed things.
    public var items: [IoTManagedIntegrationsClientTypes.ManagedThingSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ManagedThingSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListManagedThingSchemasInput: Swift.Sendable {
    /// Filter on a capability id.
    public var capabilityIdFilter: Swift.String?
    /// Filter on an endpoint id.
    public var endpointIdFilter: Swift.String?
    /// The managed thing id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        capabilityIdFilter: Swift.String? = nil,
        endpointIdFilter: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.capabilityIdFilter = capabilityIdFilter
        self.endpointIdFilter = endpointIdFilter
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one schema item associated with a managed thing.
    public struct ManagedThingSchemaListItem: Swift.Sendable {
        /// The id of the capability for a managed thing.
        public var capabilityId: Swift.String?
        /// The id of the endpoint for a managed thing.
        public var endpointId: Swift.String?
        /// The validation schema for one schema item associated with a managed thing.
        public var schema: Smithy.Document?

        public init(
            capabilityId: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            schema: Smithy.Document? = nil
        ) {
            self.capabilityId = capabilityId
            self.endpointId = endpointId
            self.schema = schema
        }
    }
}

public struct ListManagedThingSchemasOutput: Swift.Sendable {
    /// The list of managed thing schemas.
    public var items: [IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateManagedThingInput: Swift.Sendable {
    /// The brand of the device.
    public var brand: Swift.String?
    /// The capabilities of the device such as light bulb.
    public var capabilities: Swift.String?
    /// A report of the capabilities for the managed thing.
    public var capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport?
    /// The classification of the managed thing such as light bulb or thermostat.
    public var classification: Swift.String?
    /// The identifier of the credential for the managed thing.
    public var credentialLockerId: Swift.String?
    /// The network mode for the hub-connected device.
    public var hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode?
    /// The id of the managed thing.
    /// This member is required.
    public var identifier: Swift.String?
    /// The metadata for the managed thing.
    public var metaData: [Swift.String: Swift.String]?
    /// The model of the device.
    public var model: Swift.String?
    /// The name of the managed thing representing the physical device.
    public var name: Swift.String?
    /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
    public var owner: Swift.String?
    /// The serial number of the device.
    public var serialNumber: Swift.String?

    public init(
        brand: Swift.String? = nil,
        capabilities: Swift.String? = nil,
        capabilityReport: IoTManagedIntegrationsClientTypes.CapabilityReport? = nil,
        classification: Swift.String? = nil,
        credentialLockerId: Swift.String? = nil,
        hubNetworkMode: IoTManagedIntegrationsClientTypes.HubNetworkMode? = nil,
        identifier: Swift.String? = nil,
        metaData: [Swift.String: Swift.String]? = nil,
        model: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        serialNumber: Swift.String? = nil
    ) {
        self.brand = brand
        self.capabilities = capabilities
        self.capabilityReport = capabilityReport
        self.classification = classification
        self.credentialLockerId = credentialLockerId
        self.hubNetworkMode = hubNetworkMode
        self.identifier = identifier
        self.metaData = metaData
        self.model = model
        self.name = name
        self.owner = owner
        self.serialNumber = serialNumber
    }
}

extension UpdateManagedThingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateManagedThingInput(capabilities: \(Swift.String(describing: capabilities)), capabilityReport: \(Swift.String(describing: capabilityReport)), credentialLockerId: \(Swift.String(describing: credentialLockerId)), hubNetworkMode: \(Swift.String(describing: hubNetworkMode)), identifier: \(Swift.String(describing: identifier)), metaData: \(Swift.String(describing: metaData)), name: \(Swift.String(describing: name)), brand: \"CONTENT_REDACTED\", classification: \"CONTENT_REDACTED\", model: \"CONTENT_REDACTED\", owner: \"CONTENT_REDACTED\", serialNumber: \"CONTENT_REDACTED\")"}
}

public struct ListNotificationConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a notification configuration.
    public struct NotificationConfigurationSummary: Swift.Sendable {
        /// The name of the destination for the notification configuration.
        public var destinationName: Swift.String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public var eventType: IoTManagedIntegrationsClientTypes.EventType?

        public init(
            destinationName: Swift.String? = nil,
            eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
        ) {
            self.destinationName = destinationName
            self.eventType = eventType
        }
    }
}

public struct ListNotificationConfigurationsOutput: Swift.Sendable {
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of notification configurations.
    public var notificationConfigurationList: [IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationConfigurationList: [IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.notificationConfigurationList = notificationConfigurationList
    }
}

public struct UpdateNotificationConfigurationInput: Swift.Sendable {
    /// The name of the destination for the notification configuration.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The type of event triggering a device notification to the customer-managed destination.
    /// This member is required.
    public var eventType: IoTManagedIntegrationsClientTypes.EventType?

    public init(
        destinationName: Swift.String? = nil,
        eventType: IoTManagedIntegrationsClientTypes.EventType? = nil
    ) {
        self.destinationName = destinationName
        self.eventType = eventType
    }
}

public struct ListOtaTaskConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task configuration.
    public struct OtaTaskConfigurationSummary: Swift.Sendable {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public var createdAt: Foundation.Date?
        /// The name of the over-the-air (OTA) task configuration.
        public var name: Swift.String?
        /// The id of the over-the-air (OTA) task configuration
        public var taskConfigurationId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            taskConfigurationId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.name = name
            self.taskConfigurationId = taskConfigurationId
        }
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OtaTaskConfigurationSummary(createdAt: \(Swift.String(describing: createdAt)), taskConfigurationId: \(Swift.String(describing: taskConfigurationId)), name: \"CONTENT_REDACTED\")"}
}

public struct ListOtaTaskConfigurationsOutput: Swift.Sendable {
    /// The list of the over-the-air (OTA) task configurations.
    public var items: [IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListOtaTaskExecutionsInput: Swift.Sendable {
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    public enum OtaTaskExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case removed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OtaTaskExecutionStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .removed,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .removed: return "REMOVED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task execution summary.
    public struct OtaTaskExecutionSummary: Swift.Sendable {
        /// The execution number of the over-the-air (OTA) task execution summary.
        public var executionNumber: Swift.Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// The timestamp value of when the over-the-air (OTA) task execution summary is targeted to start.
        public var queuedAt: Foundation.Date?
        /// The number of retry attempts for starting the over-the-air (OTA) task execution summary after a failed attempt.
        public var retryAttempt: Swift.Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary started.
        public var startedAt: Foundation.Date?
        /// The status of the over-the-air (OTA) task execution summary.
        public var status: IoTManagedIntegrationsClientTypes.OtaTaskExecutionStatus?

        public init(
            executionNumber: Swift.Int? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            queuedAt: Foundation.Date? = nil,
            retryAttempt: Swift.Int? = nil,
            startedAt: Foundation.Date? = nil,
            status: IoTManagedIntegrationsClientTypes.OtaTaskExecutionStatus? = nil
        ) {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one execution summary.
    public struct OtaTaskExecutionSummaries: Swift.Sendable {
        /// The id of a managed thing.
        public var managedThingId: Swift.String?
        /// Structure representing one over-the-air (OTA) task execution summary
        public var taskExecutionSummary: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary?

        public init(
            managedThingId: Swift.String? = nil,
            taskExecutionSummary: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary? = nil
        ) {
            self.managedThingId = managedThingId
            self.taskExecutionSummary = taskExecutionSummary
        }
    }
}

public struct ListOtaTaskExecutionsOutput: Swift.Sendable {
    /// A list of all of the over-the-air (OTA) task executions.
    public var executionSummaries: [IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        executionSummaries: [IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.executionSummaries = executionSummaries
        self.nextToken = nextToken
    }
}

public struct ListOtaTasksInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure representing one over-the-air (OTA) task.
    public struct OtaTaskSummary: Swift.Sendable {
        /// The timestamp value of when the over-the-air (OTA) task was created at.
        public var createdAt: Foundation.Date?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public var lastUpdatedAt: Foundation.Date?
        /// The status of the over-the-air (OTA) task summary.
        public var status: IoTManagedIntegrationsClientTypes.OtaStatus?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public var taskArn: Swift.String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public var taskConfigurationId: Swift.String?
        /// The id of the over-the-air (OTA) task.
        public var taskId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: IoTManagedIntegrationsClientTypes.OtaStatus? = nil,
            taskArn: Swift.String? = nil,
            taskConfigurationId: Swift.String? = nil,
            taskId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
        }
    }
}

public struct ListOtaTasksOutput: Swift.Sendable {
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of all of the over-the-air (OTA) tasks.
    public var tasks: [IoTManagedIntegrationsClientTypes.OtaTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [IoTManagedIntegrationsClientTypes.OtaTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct UpdateOtaTaskInput: Swift.Sendable {
    /// The description of the over-the-air (OTA) task.
    public var description: Swift.String?
    /// The over-the-air (OTA) task id.
    /// This member is required.
    public var identifier: Swift.String?
    /// The identifier for the over-the-air (OTA) task configuration.
    public var taskConfigurationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        taskConfigurationId: Swift.String? = nil
    ) {
        self.description = description
        self.identifier = identifier
        self.taskConfigurationId = taskConfigurationId
    }
}

public struct ListProvisioningProfilesInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// Structure describing a provisioning profile.
    public struct ProvisioningProfileSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public var arn: Swift.String?
        /// The identifier of the provisioning profile.
        public var id: Swift.String?
        /// The name of the provisioning template.
        public var name: Swift.String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public var provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningType: IoTManagedIntegrationsClientTypes.ProvisioningType? = nil
        ) {
            self.arn = arn
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }
    }
}

public struct ListProvisioningProfilesOutput: Swift.Sendable {
    /// The list of provisioning profiles.
    public var items: [IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct RegisterCustomEndpointInput: Swift.Sendable {

    public init() { }
}

public struct RegisterCustomEndpointOutput: Swift.Sendable {
    /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
    /// This member is required.
    public var endpointAddress: Swift.String?

    public init(
        endpointAddress: Swift.String? = nil
    ) {
        self.endpointAddress = endpointAddress
    }
}

public struct PutRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id for a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?
    /// The runtime log configuration for a managed thing.
    /// This member is required.
    public var runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?

    public init(
        managedThingId: Swift.String? = nil,
        runtimeLogConfigurations: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations? = nil
    ) {
        self.managedThingId = managedThingId
        self.runtimeLogConfigurations = runtimeLogConfigurations
    }
}

public struct ResetRuntimeLogConfigurationInput: Swift.Sendable {
    /// The id of a managed thing.
    /// This member is required.
    public var managedThingId: Swift.String?

    public init(
        managedThingId: Swift.String? = nil
    ) {
        self.managedThingId = managedThingId
    }
}

public struct ListSchemaVersionsInput: Swift.Sendable {
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// Filter on the name of the schema version.
    public var namespace: Swift.String?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Filter on the id of the schema version.
    public var schemaId: Swift.String?
    /// The schema version. If this is left blank, it defaults to the latest version.
    public var semanticVersion: Swift.String?
    /// Filter on the type of schema version.
    /// This member is required.
    public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
    /// The visibility of the schema version.
    public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

    public init(
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
        visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
    ) {
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.schemaId = schemaId
        self.semanticVersion = semanticVersion
        self.type = type
        self.visibility = visibility
    }
}

extension IoTManagedIntegrationsClientTypes {

    /// List item describing a schema version.
    public struct SchemaVersionListItem: Swift.Sendable {
        /// A description of the schema version.
        public var description: Swift.String?
        /// The name of the schema version.
        public var namespace: Swift.String?
        /// The identifier of the schema version.
        public var schemaId: Swift.String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public var semanticVersion: Swift.String?
        /// The type of schema version.
        public var type: IoTManagedIntegrationsClientTypes.SchemaVersionType?
        /// The visibility of the schema version.
        public var visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility?

        public init(
            description: Swift.String? = nil,
            namespace: Swift.String? = nil,
            schemaId: Swift.String? = nil,
            semanticVersion: Swift.String? = nil,
            type: IoTManagedIntegrationsClientTypes.SchemaVersionType? = nil,
            visibility: IoTManagedIntegrationsClientTypes.SchemaVersionVisibility? = nil
        ) {
            self.description = description
            self.namespace = namespace
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }
    }
}

public struct ListSchemaVersionsOutput: Swift.Sendable {
    /// The list of schema versions.
    public var items: [IoTManagedIntegrationsClientTypes.SchemaVersionListItem]?
    /// A token that can be used to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [IoTManagedIntegrationsClientTypes.SchemaVersionListItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

extension CreateCredentialLockerInput {

    static func urlPathProvider(_ value: CreateCredentialLockerInput) -> Swift.String? {
        return "/credential-lockers"
    }
}

extension CreateDestinationInput {

    static func urlPathProvider(_ value: CreateDestinationInput) -> Swift.String? {
        return "/destinations"
    }
}

extension CreateEventLogConfigurationInput {

    static func urlPathProvider(_ value: CreateEventLogConfigurationInput) -> Swift.String? {
        return "/event-log-configurations"
    }
}

extension CreateManagedThingInput {

    static func urlPathProvider(_ value: CreateManagedThingInput) -> Swift.String? {
        return "/managed-things"
    }
}

extension CreateNotificationConfigurationInput {

    static func urlPathProvider(_ value: CreateNotificationConfigurationInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension CreateOtaTaskInput {

    static func urlPathProvider(_ value: CreateOtaTaskInput) -> Swift.String? {
        return "/ota-tasks"
    }
}

extension CreateOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: CreateOtaTaskConfigurationInput) -> Swift.String? {
        return "/ota-task-configurations"
    }
}

extension CreateProvisioningProfileInput {

    static func urlPathProvider(_ value: CreateProvisioningProfileInput) -> Swift.String? {
        return "/provisioning-profiles"
    }
}

extension DeleteCredentialLockerInput {

    static func urlPathProvider(_ value: DeleteCredentialLockerInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/credential-lockers/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteDestinationInput {

    static func urlPathProvider(_ value: DeleteDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension DeleteEventLogConfigurationInput {

    static func urlPathProvider(_ value: DeleteEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension DeleteManagedThingInput {

    static func urlPathProvider(_ value: DeleteManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteManagedThingInput {

    static func queryItemProvider(_ value: DeleteManagedThingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "Force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteNotificationConfigurationInput {

    static func urlPathProvider(_ value: DeleteNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension DeleteOtaTaskInput {

    static func urlPathProvider(_ value: DeleteOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: DeleteOtaTaskConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-task-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteProvisioningProfileInput {

    static func urlPathProvider(_ value: DeleteProvisioningProfileInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/provisioning-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension GetCredentialLockerInput {

    static func urlPathProvider(_ value: GetCredentialLockerInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/credential-lockers/\(identifier.urlPercentEncoding())"
    }
}

extension GetCustomEndpointInput {

    static func urlPathProvider(_ value: GetCustomEndpointInput) -> Swift.String? {
        return "/custom-endpoint"
    }
}

extension GetDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: GetDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension GetDestinationInput {

    static func urlPathProvider(_ value: GetDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension GetDeviceDiscoveryInput {

    static func urlPathProvider(_ value: GetDeviceDiscoveryInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/device-discoveries/\(identifier.urlPercentEncoding())"
    }
}

extension GetEventLogConfigurationInput {

    static func urlPathProvider(_ value: GetEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension GetHubConfigurationInput {

    static func urlPathProvider(_ value: GetHubConfigurationInput) -> Swift.String? {
        return "/hub-configuration"
    }
}

extension GetManagedThingInput {

    static func urlPathProvider(_ value: GetManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingCapabilitiesInput {

    static func urlPathProvider(_ value: GetManagedThingCapabilitiesInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-capabilities/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingConnectivityDataInput {

    static func urlPathProvider(_ value: GetManagedThingConnectivityDataInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-connectivity-data/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingMetaDataInput {

    static func urlPathProvider(_ value: GetManagedThingMetaDataInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things-metadata/\(identifier.urlPercentEncoding())"
    }
}

extension GetManagedThingStateInput {

    static func urlPathProvider(_ value: GetManagedThingStateInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/managed-thing-states/\(managedThingId.urlPercentEncoding())"
    }
}

extension GetNotificationConfigurationInput {

    static func urlPathProvider(_ value: GetNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension GetOtaTaskInput {

    static func urlPathProvider(_ value: GetOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension GetOtaTaskConfigurationInput {

    static func urlPathProvider(_ value: GetOtaTaskConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-task-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension GetProvisioningProfileInput {

    static func urlPathProvider(_ value: GetProvisioningProfileInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/provisioning-profiles/\(identifier.urlPercentEncoding())"
    }
}

extension GetRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: GetRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension GetSchemaVersionInput {

    static func urlPathProvider(_ value: GetSchemaVersionInput) -> Swift.String? {
        guard let type = value.type else {
            return nil
        }
        guard let schemaVersionedId = value.schemaVersionedId else {
            return nil
        }
        return "/schema-versions/\(type.rawValue.urlPercentEncoding())/\(schemaVersionedId.urlPercentEncoding())"
    }
}

extension GetSchemaVersionInput {

    static func queryItemProvider(_ value: GetSchemaVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let format = value.format {
            let formatQueryItem = Smithy.URIQueryItem(name: "Format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        return items
    }
}

extension ListCredentialLockersInput {

    static func urlPathProvider(_ value: ListCredentialLockersInput) -> Swift.String? {
        return "/credential-lockers"
    }
}

extension ListCredentialLockersInput {

    static func queryItemProvider(_ value: ListCredentialLockersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDestinationsInput {

    static func urlPathProvider(_ value: ListDestinationsInput) -> Swift.String? {
        return "/destinations"
    }
}

extension ListDestinationsInput {

    static func queryItemProvider(_ value: ListDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEventLogConfigurationsInput {

    static func urlPathProvider(_ value: ListEventLogConfigurationsInput) -> Swift.String? {
        return "/event-log-configurations"
    }
}

extension ListEventLogConfigurationsInput {

    static func queryItemProvider(_ value: ListEventLogConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListManagedThingsInput {

    static func urlPathProvider(_ value: ListManagedThingsInput) -> Swift.String? {
        return "/managed-things"
    }
}

extension ListManagedThingsInput {

    static func queryItemProvider(_ value: ListManagedThingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let parentControllerIdentifierFilter = value.parentControllerIdentifierFilter {
            let parentControllerIdentifierFilterQueryItem = Smithy.URIQueryItem(name: "ParentControllerIdentifierFilter".urlPercentEncoding(), value: Swift.String(parentControllerIdentifierFilter).urlPercentEncoding())
            items.append(parentControllerIdentifierFilterQueryItem)
        }
        if let ownerFilter = value.ownerFilter {
            let ownerFilterQueryItem = Smithy.URIQueryItem(name: "OwnerFilter".urlPercentEncoding(), value: Swift.String(ownerFilter).urlPercentEncoding())
            items.append(ownerFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let connectorPolicyIdFilter = value.connectorPolicyIdFilter {
            let connectorPolicyIdFilterQueryItem = Smithy.URIQueryItem(name: "ConnectorPolicyIdFilter".urlPercentEncoding(), value: Swift.String(connectorPolicyIdFilter).urlPercentEncoding())
            items.append(connectorPolicyIdFilterQueryItem)
        }
        if let serialNumberFilter = value.serialNumberFilter {
            let serialNumberFilterQueryItem = Smithy.URIQueryItem(name: "SerialNumberFilter".urlPercentEncoding(), value: Swift.String(serialNumberFilter).urlPercentEncoding())
            items.append(serialNumberFilterQueryItem)
        }
        if let roleFilter = value.roleFilter {
            let roleFilterQueryItem = Smithy.URIQueryItem(name: "RoleFilter".urlPercentEncoding(), value: Swift.String(roleFilter.rawValue).urlPercentEncoding())
            items.append(roleFilterQueryItem)
        }
        if let provisioningStatusFilter = value.provisioningStatusFilter {
            let provisioningStatusFilterQueryItem = Smithy.URIQueryItem(name: "ProvisioningStatusFilter".urlPercentEncoding(), value: Swift.String(provisioningStatusFilter.rawValue).urlPercentEncoding())
            items.append(provisioningStatusFilterQueryItem)
        }
        if let credentialLockerFilter = value.credentialLockerFilter {
            let credentialLockerFilterQueryItem = Smithy.URIQueryItem(name: "CredentialLockerFilter".urlPercentEncoding(), value: Swift.String(credentialLockerFilter).urlPercentEncoding())
            items.append(credentialLockerFilterQueryItem)
        }
        return items
    }
}

extension ListManagedThingSchemasInput {

    static func urlPathProvider(_ value: ListManagedThingSchemasInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-thing-schemas/\(identifier.urlPercentEncoding())"
    }
}

extension ListManagedThingSchemasInput {

    static func queryItemProvider(_ value: ListManagedThingSchemasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let endpointIdFilter = value.endpointIdFilter {
            let endpointIdFilterQueryItem = Smithy.URIQueryItem(name: "EndpointIdFilter".urlPercentEncoding(), value: Swift.String(endpointIdFilter).urlPercentEncoding())
            items.append(endpointIdFilterQueryItem)
        }
        if let capabilityIdFilter = value.capabilityIdFilter {
            let capabilityIdFilterQueryItem = Smithy.URIQueryItem(name: "CapabilityIdFilter".urlPercentEncoding(), value: Swift.String(capabilityIdFilter).urlPercentEncoding())
            items.append(capabilityIdFilterQueryItem)
        }
        return items
    }
}

extension ListNotificationConfigurationsInput {

    static func urlPathProvider(_ value: ListNotificationConfigurationsInput) -> Swift.String? {
        return "/notification-configurations"
    }
}

extension ListNotificationConfigurationsInput {

    static func queryItemProvider(_ value: ListNotificationConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTaskConfigurationsInput {

    static func urlPathProvider(_ value: ListOtaTaskConfigurationsInput) -> Swift.String? {
        return "/ota-task-configurations"
    }
}

extension ListOtaTaskConfigurationsInput {

    static func queryItemProvider(_ value: ListOtaTaskConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTaskExecutionsInput {

    static func urlPathProvider(_ value: ListOtaTaskExecutionsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())/devices"
    }
}

extension ListOtaTaskExecutionsInput {

    static func queryItemProvider(_ value: ListOtaTaskExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOtaTasksInput {

    static func urlPathProvider(_ value: ListOtaTasksInput) -> Swift.String? {
        return "/ota-tasks"
    }
}

extension ListOtaTasksInput {

    static func queryItemProvider(_ value: ListOtaTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProvisioningProfilesInput {

    static func urlPathProvider(_ value: ListProvisioningProfilesInput) -> Swift.String? {
        return "/provisioning-profiles"
    }
}

extension ListProvisioningProfilesInput {

    static func queryItemProvider(_ value: ListProvisioningProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSchemaVersionsInput {

    static func urlPathProvider(_ value: ListSchemaVersionsInput) -> Swift.String? {
        guard let type = value.type else {
            return nil
        }
        return "/schema-versions/\(type.rawValue.urlPercentEncoding())"
    }
}

extension ListSchemaVersionsInput {

    static func queryItemProvider(_ value: ListSchemaVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let schemaId = value.schemaId {
            let schemaIdQueryItem = Smithy.URIQueryItem(name: "SchemaIdFilter".urlPercentEncoding(), value: Swift.String(schemaId).urlPercentEncoding())
            items.append(schemaIdQueryItem)
        }
        if let visibility = value.visibility {
            let visibilityQueryItem = Smithy.URIQueryItem(name: "VisibilityFilter".urlPercentEncoding(), value: Swift.String(visibility.rawValue).urlPercentEncoding())
            items.append(visibilityQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "NamespaceFilter".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let semanticVersion = value.semanticVersion {
            let semanticVersionQueryItem = Smithy.URIQueryItem(name: "SemanticVersionFilter".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            items.append(semanticVersionQueryItem)
        }
        return items
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: PutDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension PutHubConfigurationInput {

    static func urlPathProvider(_ value: PutHubConfigurationInput) -> Swift.String? {
        return "/hub-configuration"
    }
}

extension PutRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: PutRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension RegisterCustomEndpointInput {

    static func urlPathProvider(_ value: RegisterCustomEndpointInput) -> Swift.String? {
        return "/custom-endpoint"
    }
}

extension ResetRuntimeLogConfigurationInput {

    static func urlPathProvider(_ value: ResetRuntimeLogConfigurationInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/runtime-log-configurations/\(managedThingId.urlPercentEncoding())"
    }
}

extension SendManagedThingCommandInput {

    static func urlPathProvider(_ value: SendManagedThingCommandInput) -> Swift.String? {
        guard let managedThingId = value.managedThingId else {
            return nil
        }
        return "/managed-things-command/\(managedThingId.urlPercentEncoding())"
    }
}

extension StartDeviceDiscoveryInput {

    static func urlPathProvider(_ value: StartDeviceDiscoveryInput) -> Swift.String? {
        return "/device-discoveries"
    }
}

extension UpdateDestinationInput {

    static func urlPathProvider(_ value: UpdateDestinationInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/destinations/\(name.urlPercentEncoding())"
    }
}

extension UpdateEventLogConfigurationInput {

    static func urlPathProvider(_ value: UpdateEventLogConfigurationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/event-log-configurations/\(id.urlPercentEncoding())"
    }
}

extension UpdateManagedThingInput {

    static func urlPathProvider(_ value: UpdateManagedThingInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/managed-things/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateNotificationConfigurationInput {

    static func urlPathProvider(_ value: UpdateNotificationConfigurationInput) -> Swift.String? {
        guard let eventType = value.eventType else {
            return nil
        }
        return "/notification-configurations/\(eventType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateOtaTaskInput {

    static func urlPathProvider(_ value: UpdateOtaTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/ota-tasks/\(identifier.urlPercentEncoding())"
    }
}

extension CreateCredentialLockerInput {

    static func write(value: CreateCredentialLockerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDestinationInput {

    static func write(value: CreateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeliveryDestinationArn"].write(value.deliveryDestinationArn)
        try writer["DeliveryDestinationType"].write(value.deliveryDestinationType)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEventLogConfigurationInput {

    static func write(value: CreateEventLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["EventLogLevel"].write(value.eventLogLevel)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension CreateManagedThingInput {

    static func write(value: CreateManagedThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationMaterial"].write(value.authenticationMaterial)
        try writer["AuthenticationMaterialType"].write(value.authenticationMaterialType)
        try writer["Brand"].write(value.brand)
        try writer["Capabilities"].write(value.capabilities)
        try writer["CapabilityReport"].write(value.capabilityReport, with: IoTManagedIntegrationsClientTypes.CapabilityReport.write(value:to:))
        try writer["Classification"].write(value.classification)
        try writer["ClientToken"].write(value.clientToken)
        try writer["CredentialLockerId"].write(value.credentialLockerId)
        try writer["MetaData"].writeMap(value.metaData, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Model"].write(value.model)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["Role"].write(value.role)
        try writer["SerialNumber"].write(value.serialNumber)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateNotificationConfigurationInput {

    static func write(value: CreateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DestinationName"].write(value.destinationName)
        try writer["EventType"].write(value.eventType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateOtaTaskInput {

    static func write(value: CreateOtaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["OtaMechanism"].write(value.otaMechanism)
        try writer["OtaSchedulingConfig"].write(value.otaSchedulingConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig.write(value:to:))
        try writer["OtaTargetQueryString"].write(value.otaTargetQueryString)
        try writer["OtaTaskExecutionRetryConfig"].write(value.otaTaskExecutionRetryConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig.write(value:to:))
        try writer["OtaType"].write(value.otaType)
        try writer["Protocol"].write(value.`protocol`)
        try writer["S3Url"].write(value.s3Url)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Target"].writeList(value.target, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskConfigurationId"].write(value.taskConfigurationId)
    }
}

extension CreateOtaTaskConfigurationInput {

    static func write(value: CreateOtaTaskConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PushConfig"].write(value.pushConfig, with: IoTManagedIntegrationsClientTypes.PushConfig.write(value:to:))
    }
}

extension CreateProvisioningProfileInput {

    static func write(value: CreateProvisioningProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CaCertificate"].write(value.caCertificate)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Name"].write(value.name)
        try writer["ProvisioningType"].write(value.provisioningType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func write(value: PutDefaultEncryptionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionType"].write(value.encryptionType)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension PutHubConfigurationInput {

    static func write(value: PutHubConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HubTokenTimerExpirySettingInSeconds"].write(value.hubTokenTimerExpirySettingInSeconds)
    }
}

extension PutRuntimeLogConfigurationInput {

    static func write(value: PutRuntimeLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuntimeLogConfigurations"].write(value.runtimeLogConfigurations, with: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations.write(value:to:))
    }
}

extension SendManagedThingCommandInput {

    static func write(value: SendManagedThingCommandInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorAssociationId"].write(value.connectorAssociationId)
        try writer["Endpoints"].writeList(value.endpoints, memberWritingClosure: IoTManagedIntegrationsClientTypes.CommandEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartDeviceDiscoveryInput {

    static func write(value: StartDeviceDiscoveryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationMaterial"].write(value.authenticationMaterial)
        try writer["AuthenticationMaterialType"].write(value.authenticationMaterialType)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectorAssociationIdentifier"].write(value.connectorAssociationIdentifier)
        try writer["ControllerIdentifier"].write(value.controllerIdentifier)
        try writer["DiscoveryType"].write(value.discoveryType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDestinationInput {

    static func write(value: UpdateDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryDestinationArn"].write(value.deliveryDestinationArn)
        try writer["DeliveryDestinationType"].write(value.deliveryDestinationType)
        try writer["Description"].write(value.description)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension UpdateEventLogConfigurationInput {

    static func write(value: UpdateEventLogConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventLogLevel"].write(value.eventLogLevel)
    }
}

extension UpdateManagedThingInput {

    static func write(value: UpdateManagedThingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Brand"].write(value.brand)
        try writer["Capabilities"].write(value.capabilities)
        try writer["CapabilityReport"].write(value.capabilityReport, with: IoTManagedIntegrationsClientTypes.CapabilityReport.write(value:to:))
        try writer["Classification"].write(value.classification)
        try writer["CredentialLockerId"].write(value.credentialLockerId)
        try writer["HubNetworkMode"].write(value.hubNetworkMode)
        try writer["MetaData"].writeMap(value.metaData, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Model"].write(value.model)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["SerialNumber"].write(value.serialNumber)
    }
}

extension UpdateNotificationConfigurationInput {

    static func write(value: UpdateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationName"].write(value.destinationName)
    }
}

extension UpdateOtaTaskInput {

    static func write(value: UpdateOtaTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["TaskConfigurationId"].write(value.taskConfigurationId)
    }
}

extension CreateCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCredentialLockerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCredentialLockerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDestinationOutput()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventLogConfigurationOutput()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateManagedThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateManagedThingOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension CreateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotificationConfigurationOutput()
        value.eventType = try reader["EventType"].readIfPresent()
        return value
    }
}

extension CreateOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOtaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOtaTaskOutput()
        value.description = try reader["Description"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        return value
    }
}

extension CreateOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOtaTaskConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOtaTaskConfigurationOutput()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        return value
    }
}

extension CreateProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.claimCertificate = try reader["ClaimCertificate"].readIfPresent()
        value.claimCertificatePrivateKey = try reader["ClaimCertificatePrivateKey"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        return value
    }
}

extension DeleteCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCredentialLockerOutput {
        return DeleteCredentialLockerOutput()
    }
}

extension DeleteDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDestinationOutput {
        return DeleteDestinationOutput()
    }
}

extension DeleteEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventLogConfigurationOutput {
        return DeleteEventLogConfigurationOutput()
    }
}

extension DeleteManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteManagedThingOutput {
        return DeleteManagedThingOutput()
    }
}

extension DeleteNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationConfigurationOutput {
        return DeleteNotificationConfigurationOutput()
    }
}

extension DeleteOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOtaTaskOutput {
        return DeleteOtaTaskOutput()
    }
}

extension DeleteOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOtaTaskConfigurationOutput {
        return DeleteOtaTaskConfigurationOutput()
    }
}

extension DeleteProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisioningProfileOutput {
        return DeleteProvisioningProfileOutput()
    }
}

extension GetCredentialLockerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCredentialLockerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCredentialLockerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCustomEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomEndpointOutput()
        value.endpointAddress = try reader["EndpointAddress"].readIfPresent() ?? ""
        return value
    }
}

extension GetDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension GetDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDestinationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deliveryDestinationArn = try reader["DeliveryDestinationArn"].readIfPresent()
        value.deliveryDestinationType = try reader["DeliveryDestinationType"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetDeviceDiscoveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceDiscoveryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDiscoveryOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.connectorAssociationId = try reader["ConnectorAssociationId"].readIfPresent()
        value.controllerId = try reader["ControllerId"].readIfPresent()
        value.discoveryType = try reader["DiscoveryType"].readIfPresent() ?? .sdkUnknown("")
        value.finishedAt = try reader["FinishedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventLogConfigurationOutput()
        value.eventLogLevel = try reader["EventLogLevel"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension GetHubConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHubConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHubConfigurationOutput()
        value.hubTokenTimerExpirySettingInSeconds = try reader["HubTokenTimerExpirySettingInSeconds"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingOutput()
        value.activatedAt = try reader["ActivatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.advertisedProductId = try reader["AdvertisedProductId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.brand = try reader["Brand"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.connectorDeviceId = try reader["ConnectorDeviceId"].readIfPresent()
        value.connectorPolicyId = try reader["ConnectorPolicyId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.credentialLockerId = try reader["CredentialLockerId"].readIfPresent()
        value.deviceSpecificKey = try reader["DeviceSpecificKey"].readIfPresent()
        value.hubNetworkMode = try reader["HubNetworkMode"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.internationalArticleNumber = try reader["InternationalArticleNumber"].readIfPresent()
        value.macAddress = try reader["MacAddress"].readIfPresent()
        value.metaData = try reader["MetaData"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.model = try reader["Model"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.parentControllerId = try reader["ParentControllerId"].readIfPresent()
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.universalProductCode = try reader["UniversalProductCode"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingCapabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingCapabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingCapabilitiesOutput()
        value.capabilities = try reader["Capabilities"].readIfPresent()
        value.capabilityReport = try reader["CapabilityReport"].readIfPresent(with: IoTManagedIntegrationsClientTypes.CapabilityReport.read(from:))
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension GetManagedThingConnectivityDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingConnectivityDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingConnectivityDataOutput()
        value.connected = try reader["Connected"].readIfPresent()
        value.disconnectReason = try reader["DisconnectReason"].readIfPresent()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetManagedThingMetaDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingMetaDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingMetaDataOutput()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.metaData = try reader["MetaData"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetManagedThingStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedThingStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedThingStateOutput()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.StateEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotificationConfigurationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinationName = try reader["DestinationName"].readIfPresent()
        value.eventType = try reader["EventType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOtaTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOtaTaskOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.otaMechanism = try reader["OtaMechanism"].readIfPresent()
        value.otaSchedulingConfig = try reader["OtaSchedulingConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig.read(from:))
        value.otaTargetQueryString = try reader["OtaTargetQueryString"].readIfPresent()
        value.otaTaskExecutionRetryConfig = try reader["OtaTaskExecutionRetryConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig.read(from:))
        value.otaType = try reader["OtaType"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.s3Url = try reader["S3Url"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.target = try reader["Target"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskProcessingDetails = try reader["TaskProcessingDetails"].readIfPresent(with: IoTManagedIntegrationsClientTypes.TaskProcessingDetails.read(from:))
        return value
    }
}

extension GetOtaTaskConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOtaTaskConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOtaTaskConfigurationOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.pushConfig = try reader["PushConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.PushConfig.read(from:))
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        return value
    }
}

extension GetProvisioningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisioningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisioningProfileOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.claimCertificate = try reader["ClaimCertificate"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuntimeLogConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuntimeLogConfigurationOutput()
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        value.runtimeLogConfigurations = try reader["RuntimeLogConfigurations"].readIfPresent(with: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations.read(from:))
        return value
    }
}

extension GetSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaVersionOutput()
        value.description = try reader["Description"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.semanticVersion = try reader["SemanticVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension ListCredentialLockersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCredentialLockersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCredentialLockersOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CredentialLockerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDestinationsOutput()
        value.destinationList = try reader["DestinationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.DestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventLogConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventLogConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventLogConfigurationsOutput()
        value.eventLogConfigurationList = try reader["EventLogConfigurationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedThingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedThingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedThingsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ManagedThingSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedThingSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedThingSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedThingSchemasOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNotificationConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notificationConfigurationList = try reader["NotificationConfigurationList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOtaTaskConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTaskConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTaskConfigurationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOtaTaskExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTaskExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTaskExecutionsOutput()
        value.executionSummaries = try reader["ExecutionSummaries"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOtaTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOtaTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOtaTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tasks = try reader["Tasks"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.OtaTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningProfilesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSchemaVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemaVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemaVersionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.SchemaVersionListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PutDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension PutHubConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutHubConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutHubConfigurationOutput()
        value.hubTokenTimerExpirySettingInSeconds = try reader["HubTokenTimerExpirySettingInSeconds"].readIfPresent()
        return value
    }
}

extension PutRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRuntimeLogConfigurationOutput {
        return PutRuntimeLogConfigurationOutput()
    }
}

extension RegisterCustomEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterCustomEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterCustomEndpointOutput()
        value.endpointAddress = try reader["EndpointAddress"].readIfPresent() ?? ""
        return value
    }
}

extension ResetRuntimeLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetRuntimeLogConfigurationOutput {
        return ResetRuntimeLogConfigurationOutput()
    }
}

extension SendManagedThingCommandOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendManagedThingCommandOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendManagedThingCommandOutput()
        value.traceId = try reader["TraceId"].readIfPresent()
        return value
    }
}

extension StartDeviceDiscoveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDeviceDiscoveryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDeviceDiscoveryOutput()
        value.id = try reader["Id"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension UpdateDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDestinationOutput {
        return UpdateDestinationOutput()
    }
}

extension UpdateEventLogConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventLogConfigurationOutput {
        return UpdateEventLogConfigurationOutput()
    }
}

extension UpdateManagedThingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateManagedThingOutput {
        return UpdateManagedThingOutput()
    }
}

extension UpdateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNotificationConfigurationOutput {
        return UpdateNotificationConfigurationOutput()
    }
}

extension UpdateOtaTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOtaTaskOutput {
        return UpdateOtaTaskOutput()
    }
}

enum CreateCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCredentialLockerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceDiscoveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHubConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingCapabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingConnectivityDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingMetaDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedThingStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOtaTaskConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisioningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCredentialLockersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventLogConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedThingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedThingSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTaskConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTaskExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOtaTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemaVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutHubConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterCustomEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetRuntimeLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendManagedThingCommandOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDeviceDiscoveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventLogConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateManagedThingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOtaTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConfigurationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConfigurationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConfigurationStatus()
        value.error = try reader["error"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ConfigurationError.read(from:))
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ConfigurationError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ConfigurationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ConfigurationError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReport {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReport?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoints"].writeList(value.endpoints, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodeId"].write(value.nodeId)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReport()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.nodeId = try reader["nodeId"].readIfPresent()
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deviceTypes"].writeList(value.deviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReportEndpoint()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.deviceTypes = try reader["deviceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.CapabilityReportCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityReportCapability {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityReportCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CapabilityReportCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CapabilityReportCapability()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.StateEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.StateEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.StateEndpoint()
        value.endpointId = try reader["endpointId"].readIfPresent() ?? ""
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.StateCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.StateCapability {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.StateCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.StateCapability()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.TaskProcessingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.TaskProcessingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.TaskProcessingDetails()
        value.numberOfCanceledThings = try reader["NumberOfCanceledThings"].readIfPresent()
        value.numberOfFailedThings = try reader["NumberOfFailedThings"].readIfPresent()
        value.numberOfInProgressThings = try reader["NumberOfInProgressThings"].readIfPresent()
        value.numberOfQueuedThings = try reader["numberOfQueuedThings"].readIfPresent()
        value.numberOfRejectedThings = try reader["numberOfRejectedThings"].readIfPresent()
        value.numberOfRemovedThings = try reader["numberOfRemovedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        value.numberOfTimedOutThings = try reader["numberOfTimedOutThings"].readIfPresent()
        value.processingTargets = try reader["processingTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndBehavior"].write(value.endBehavior)
        try writer["EndTime"].write(value.endTime)
        try writer["MaintenanceWindows"].writeList(value.maintenanceWindows, memberWritingClosure: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskSchedulingConfig()
        value.endBehavior = try reader["EndBehavior"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.maintenanceWindows = try reader["MaintenanceWindows"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow {

    static func write(value: IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInMinutes"].write(value.durationInMinutes)
        try writer["StartTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ScheduleMaintenanceWindow()
        value.durationInMinutes = try reader["DurationInMinutes"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetryConfigCriteria"].writeList(value.retryConfigCriteria, memberWritingClosure: IoTManagedIntegrationsClientTypes.RetryConfigCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionRetryConfig()
        value.retryConfigCriteria = try reader["RetryConfigCriteria"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.RetryConfigCriteria.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RetryConfigCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.RetryConfigCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureType"].write(value.failureType)
        try writer["MinNumberOfRetries"].write(value.minNumberOfRetries)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RetryConfigCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RetryConfigCriteria()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.minNumberOfRetries = try reader["MinNumberOfRetries"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.PushConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.PushConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortConfig"].write(value.abortConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig.write(value:to:))
        try writer["RolloutConfig"].write(value.rolloutConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig.write(value:to:))
        try writer["TimeoutConfig"].write(value.timeoutConfig, with: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.PushConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.PushConfig()
        value.abortConfig = try reader["AbortConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig.read(from:))
        value.rolloutConfig = try reader["RolloutConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig.read(from:))
        value.timeoutConfig = try reader["TimeoutConfig"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InProgressTimeoutInMinutes"].write(value.inProgressTimeoutInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskTimeoutConfig()
        value.inProgressTimeoutInMinutes = try reader["InProgressTimeoutInMinutes"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExponentialRolloutRate"].write(value.exponentialRolloutRate, with: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate.write(value:to:))
        try writer["MaximumPerMinute"].write(value.maximumPerMinute)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionRolloutConfig()
        value.exponentialRolloutRate = try reader["ExponentialRolloutRate"].readIfPresent(with: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate.read(from:))
        value.maximumPerMinute = try reader["MaximumPerMinute"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ExponentialRolloutRate {

    static func write(value: IoTManagedIntegrationsClientTypes.ExponentialRolloutRate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseRatePerMinute"].write(value.baseRatePerMinute)
        try writer["IncrementFactor"].write(value.incrementFactor)
        try writer["RateIncreaseCriteria"].write(value.rateIncreaseCriteria, with: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ExponentialRolloutRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ExponentialRolloutRate()
        value.baseRatePerMinute = try reader["BaseRatePerMinute"].readIfPresent()
        value.incrementFactor = try reader["IncrementFactor"].readIfPresent()
        value.rateIncreaseCriteria = try reader["RateIncreaseCriteria"].readIfPresent(with: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria.read(from:))
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfNotifiedThings"].write(value.numberOfNotifiedThings)
        try writer["numberOfSucceededThings"].write(value.numberOfSucceededThings)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RolloutRateIncreaseCriteria()
        value.numberOfNotifiedThings = try reader["numberOfNotifiedThings"].readIfPresent()
        value.numberOfSucceededThings = try reader["numberOfSucceededThings"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig {

    static func write(value: IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortConfigCriteriaList"].writeList(value.abortConfigCriteriaList, memberWritingClosure: IoTManagedIntegrationsClientTypes.AbortConfigCriteria.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskAbortConfig()
        value.abortConfigCriteriaList = try reader["AbortConfigCriteriaList"].readListIfPresent(memberReadingClosure: IoTManagedIntegrationsClientTypes.AbortConfigCriteria.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.AbortConfigCriteria {

    static func write(value: IoTManagedIntegrationsClientTypes.AbortConfigCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["FailureType"].write(value.failureType)
        try writer["MinNumberOfExecutedThings"].write(value.minNumberOfExecutedThings)
        try writer["ThresholdPercentage"].write(value.thresholdPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.AbortConfigCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.AbortConfigCriteria()
        value.action = try reader["Action"].readIfPresent()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.minNumberOfExecutedThings = try reader["MinNumberOfExecutedThings"].readIfPresent()
        value.thresholdPercentage = try reader["ThresholdPercentage"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations {

    static func write(value: IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteLocalStoreAfterUpload"].write(value.deleteLocalStoreAfterUpload)
        try writer["LocalStoreFileRotationMaxBytes"].write(value.localStoreFileRotationMaxBytes)
        try writer["LocalStoreFileRotationMaxFiles"].write(value.localStoreFileRotationMaxFiles)
        try writer["LocalStoreLocation"].write(value.localStoreLocation)
        try writer["LogFlushLevel"].write(value.logFlushLevel)
        try writer["LogLevel"].write(value.logLevel)
        try writer["UploadLog"].write(value.uploadLog)
        try writer["UploadPeriodMinutes"].write(value.uploadPeriodMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.RuntimeLogConfigurations()
        value.logLevel = try reader["LogLevel"].readIfPresent()
        value.logFlushLevel = try reader["LogFlushLevel"].readIfPresent()
        value.localStoreLocation = try reader["LocalStoreLocation"].readIfPresent()
        value.localStoreFileRotationMaxFiles = try reader["LocalStoreFileRotationMaxFiles"].readIfPresent()
        value.localStoreFileRotationMaxBytes = try reader["LocalStoreFileRotationMaxBytes"].readIfPresent()
        value.uploadLog = try reader["UploadLog"].readIfPresent()
        value.uploadPeriodMinutes = try reader["UploadPeriodMinutes"].readIfPresent()
        value.deleteLocalStoreAfterUpload = try reader["DeleteLocalStoreAfterUpload"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CredentialLockerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.CredentialLockerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.CredentialLockerSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.DestinationSummary()
        value.description = try reader["Description"].readIfPresent()
        value.deliveryDestinationArn = try reader["DeliveryDestinationArn"].readIfPresent()
        value.deliveryDestinationType = try reader["DeliveryDestinationType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.EventLogConfigurationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.eventLogLevel = try reader["EventLogLevel"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ManagedThingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ManagedThingSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.advertisedProductId = try reader["AdvertisedProductId"].readIfPresent()
        value.brand = try reader["Brand"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.connectorDeviceId = try reader["ConnectorDeviceId"].readIfPresent()
        value.connectorPolicyId = try reader["ConnectorPolicyId"].readIfPresent()
        value.model = try reader["Model"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.credentialLockerId = try reader["CredentialLockerId"].readIfPresent()
        value.parentControllerId = try reader["ParentControllerId"].readIfPresent()
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.activatedAt = try reader["ActivatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ManagedThingSchemaListItem()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.capabilityId = try reader["CapabilityId"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.NotificationConfigurationSummary()
        value.eventType = try reader["EventType"].readIfPresent()
        value.destinationName = try reader["DestinationName"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskConfigurationSummary()
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummaries()
        value.taskExecutionSummary = try reader["TaskExecutionSummary"].readIfPresent(with: IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary.read(from:))
        value.managedThingId = try reader["ManagedThingId"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskExecutionSummary()
        value.executionNumber = try reader["ExecutionNumber"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.queuedAt = try reader["QueuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.retryAttempt = try reader["RetryAttempt"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.OtaTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.OtaTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.OtaTaskSummary()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskConfigurationId = try reader["TaskConfigurationId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.ProvisioningProfileSummary()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.provisioningType = try reader["ProvisioningType"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.SchemaVersionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTManagedIntegrationsClientTypes.SchemaVersionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTManagedIntegrationsClientTypes.SchemaVersionListItem()
        value.schemaId = try reader["SchemaId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.semanticVersion = try reader["SemanticVersion"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension IoTManagedIntegrationsClientTypes.CommandEndpoint {

    static func write(value: IoTManagedIntegrationsClientTypes.CommandEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: IoTManagedIntegrationsClientTypes.CommandCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["endpointId"].write(value.endpointId)
    }
}

extension IoTManagedIntegrationsClientTypes.CommandCapability {

    static func write(value: IoTManagedIntegrationsClientTypes.CommandCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: IoTManagedIntegrationsClientTypes.CapabilityAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }
}

extension IoTManagedIntegrationsClientTypes.CapabilityAction {

    static func write(value: IoTManagedIntegrationsClientTypes.CapabilityAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionTraceId"].write(value.actionTraceId)
        try writer["name"].write(value.name)
        try writer["parameters"].write(value.parameters)
        try writer["ref"].write(value.ref)
    }
}

public enum IoTManagedIntegrationsClientTypes {}
