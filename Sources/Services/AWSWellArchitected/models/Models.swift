// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes.AccountJiraConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationStatus = "IntegrationStatus"
        case issueManagementStatus = "IssueManagementStatus"
        case issueManagementType = "IssueManagementType"
        case jiraProjectKey = "JiraProjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationStatus = self.integrationStatus {
            try encodeContainer.encode(integrationStatus.rawValue, forKey: .integrationStatus)
        }
        if let issueManagementStatus = self.issueManagementStatus {
            try encodeContainer.encode(issueManagementStatus.rawValue, forKey: .issueManagementStatus)
        }
        if let issueManagementType = self.issueManagementType {
            try encodeContainer.encode(issueManagementType.rawValue, forKey: .issueManagementType)
        }
        if let jiraProjectKey = self.jiraProjectKey {
            try encodeContainer.encode(jiraProjectKey, forKey: .jiraProjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issueManagementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AccountJiraIssueManagementStatus.self, forKey: .issueManagementStatus)
        issueManagementStatus = issueManagementStatusDecoded
        let issueManagementTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IssueManagementType.self, forKey: .issueManagementType)
        issueManagementType = issueManagementTypeDecoded
        let jiraProjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jiraProjectKey)
        jiraProjectKey = jiraProjectKeyDecoded
        let integrationStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IntegrationStatusInput.self, forKey: .integrationStatus)
        integrationStatus = integrationStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Account-level: Input for the Jira configuration.
    public struct AccountJiraConfigurationInput {
        /// Account-level: Configuration status of the Jira integration.
        public var integrationStatus: WellArchitectedClientTypes.IntegrationStatusInput?
        /// Account-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus?
        /// Account-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Account-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?

        public init(
            integrationStatus: WellArchitectedClientTypes.IntegrationStatusInput? = nil,
            issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil
        )
        {
            self.integrationStatus = integrationStatus
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
        }
    }

}

extension WellArchitectedClientTypes.AccountJiraConfigurationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case integrationStatus = "IntegrationStatus"
        case issueManagementStatus = "IssueManagementStatus"
        case issueManagementType = "IssueManagementType"
        case jiraProjectKey = "JiraProjectKey"
        case statusMessage = "StatusMessage"
        case subdomain = "Subdomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let integrationStatus = self.integrationStatus {
            try encodeContainer.encode(integrationStatus.rawValue, forKey: .integrationStatus)
        }
        if let issueManagementStatus = self.issueManagementStatus {
            try encodeContainer.encode(issueManagementStatus.rawValue, forKey: .issueManagementStatus)
        }
        if let issueManagementType = self.issueManagementType {
            try encodeContainer.encode(issueManagementType.rawValue, forKey: .issueManagementType)
        }
        if let jiraProjectKey = self.jiraProjectKey {
            try encodeContainer.encode(jiraProjectKey, forKey: .jiraProjectKey)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subdomain = self.subdomain {
            try encodeContainer.encode(subdomain, forKey: .subdomain)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integrationStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IntegrationStatus.self, forKey: .integrationStatus)
        integrationStatus = integrationStatusDecoded
        let issueManagementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AccountJiraIssueManagementStatus.self, forKey: .issueManagementStatus)
        issueManagementStatus = issueManagementStatusDecoded
        let issueManagementTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IssueManagementType.self, forKey: .issueManagementType)
        issueManagementType = issueManagementTypeDecoded
        let subdomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subdomain)
        subdomain = subdomainDecoded
        let jiraProjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jiraProjectKey)
        jiraProjectKey = jiraProjectKeyDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Account-level: Output configuration of the Jira integration.
    public struct AccountJiraConfigurationOutput {
        /// Account-level: Configuration status of the Jira integration.
        public var integrationStatus: WellArchitectedClientTypes.IntegrationStatus?
        /// Account-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus?
        /// Account-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Account-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?
        /// Account-level: Status message on configuration of the Jira integration.
        public var statusMessage: Swift.String?
        /// Account-level: Jira subdomain URL.
        public var subdomain: Swift.String?

        public init(
            integrationStatus: WellArchitectedClientTypes.IntegrationStatus? = nil,
            issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subdomain: Swift.String? = nil
        )
        {
            self.integrationStatus = integrationStatus
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
            self.statusMessage = statusMessage
            self.subdomain = subdomain
        }
    }

}

extension WellArchitectedClientTypes {
    public enum AccountJiraIssueManagementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountJiraIssueManagementStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountJiraIssueManagementStatus(rawValue: rawValue) ?? AccountJiraIssueManagementStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum AdditionalResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case helpfulResource
        case improvementPlan
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalResourceType] {
            return [
                .helpfulResource,
                .improvementPlan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .helpfulResource: return "HELPFUL_RESOURCE"
            case .improvementPlan: return "IMPROVEMENT_PLAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalResourceType(rawValue: rawValue) ?? AdditionalResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.AdditionalResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            var contentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .content)
            for choicecontent0 in content {
                try contentContainer.encode(choicecontent0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AdditionalResourceType.self, forKey: .type)
        type = typeDecoded
        let contentContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceContent?].self, forKey: .content)
        var contentDecoded0:[WellArchitectedClientTypes.ChoiceContent]? = nil
        if let contentContainer = contentContainer {
            contentDecoded0 = [WellArchitectedClientTypes.ChoiceContent]()
            for structure0 in contentContainer {
                if let structure0 = structure0 {
                    contentDecoded0?.append(structure0)
                }
            }
        }
        content = contentDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// The choice level additional resources for a custom lens. This field does not apply to Amazon Web Services official lenses.
    public struct AdditionalResources {
        /// The URLs for additional resources, either helpful resources or improvement plans, for a custom lens. Up to five additional URLs can be specified.
        public var content: [WellArchitectedClientTypes.ChoiceContent]?
        /// Type of additional resource for a custom lens.
        public var type: WellArchitectedClientTypes.AdditionalResourceType?

        public init(
            content: [WellArchitectedClientTypes.ChoiceContent]? = nil,
            type: WellArchitectedClientTypes.AdditionalResourceType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension WellArchitectedClientTypes.Answer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswers = "ChoiceAnswers"
        case choices = "Choices"
        case helpfulResourceDisplayText = "HelpfulResourceDisplayText"
        case helpfulResourceUrl = "HelpfulResourceUrl"
        case improvementPlanUrl = "ImprovementPlanUrl"
        case isApplicable = "IsApplicable"
        case jiraConfiguration = "JiraConfiguration"
        case notes = "Notes"
        case pillarId = "PillarId"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswers = choiceAnswers {
            var choiceAnswersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswers)
            for choiceanswer0 in choiceAnswers {
                try choiceAnswersContainer.encode(choiceanswer0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choice0 in choices {
                try choicesContainer.encode(choice0)
            }
        }
        if let helpfulResourceDisplayText = self.helpfulResourceDisplayText {
            try encodeContainer.encode(helpfulResourceDisplayText, forKey: .helpfulResourceDisplayText)
        }
        if let helpfulResourceUrl = self.helpfulResourceUrl {
            try encodeContainer.encode(helpfulResourceUrl, forKey: .helpfulResourceUrl)
        }
        if let improvementPlanUrl = self.improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDescription = self.questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let helpfulResourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceUrl)
        helpfulResourceUrl = helpfulResourceUrlDecoded
        let helpfulResourceDisplayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceDisplayText)
        helpfulResourceDisplayText = helpfulResourceDisplayTextDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswersContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswer?].self, forKey: .choiceAnswers)
        var choiceAnswersDecoded0:[WellArchitectedClientTypes.ChoiceAnswer]? = nil
        if let choiceAnswersContainer = choiceAnswersContainer {
            choiceAnswersDecoded0 = [WellArchitectedClientTypes.ChoiceAnswer]()
            for structure0 in choiceAnswersContainer {
                if let structure0 = structure0 {
                    choiceAnswersDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswers = choiceAnswersDecoded0
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.JiraConfiguration.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An answer of the question.
    public struct Answer {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed for a custom lens. This field does not apply to Amazon Web Services official lenses.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL. For Amazon Web Services official lenses, this is the helpful resource URL for a question or choice. For custom lenses, this is the helpful resource URL for a question and is only provided if HelpfulResourceDisplayText was specified for the question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.jiraConfiguration = jiraConfiguration
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

extension WellArchitectedClientTypes {
    public enum AnswerReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [AnswerReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnswerReason(rawValue: rawValue) ?? AnswerReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.AnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswerSummaries = "ChoiceAnswerSummaries"
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case jiraConfiguration = "JiraConfiguration"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case questionType = "QuestionType"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswerSummaries = choiceAnswerSummaries {
            var choiceAnswerSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswerSummaries)
            for choiceanswersummary0 in choiceAnswerSummaries {
                try choiceAnswerSummariesContainer.encode(choiceanswersummary0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choice0 in choices {
                try choicesContainer.encode(choice0)
            }
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let questionType = self.questionType {
            try encodeContainer.encode(questionType.rawValue, forKey: .questionType)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswerSummary?].self, forKey: .choiceAnswerSummaries)
        var choiceAnswerSummariesDecoded0:[WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil
        if let choiceAnswerSummariesContainer = choiceAnswerSummariesContainer {
            choiceAnswerSummariesDecoded0 = [WellArchitectedClientTypes.ChoiceAnswerSummary]()
            for structure0 in choiceAnswerSummariesContainer {
                if let structure0 = structure0 {
                    choiceAnswerSummariesDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswerSummaries = choiceAnswerSummariesDecoded0
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
        let questionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.QuestionType.self, forKey: .questionType)
        questionType = questionTypeDecoded
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.JiraConfiguration.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An answer summary of a lens review in a workload.
    public struct AnswerSummary {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The type of the question.
        public var questionType: WellArchitectedClientTypes.QuestionType?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            questionType: WellArchitectedClientTypes.QuestionType? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.jiraConfiguration = jiraConfiguration
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.questionType = questionType
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }

}

extension AssociateLensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensalias0 in lensAliases {
                try lensAliasesContainer.encode(lensalias0)
            }
        }
    }
}

extension AssociateLensesInput {

    static func urlPathProvider(_ value: AssociateLensesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/associateLenses"
    }
}

/// Input to associate lens reviews.
public struct AssociateLensesInput {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct AssociateLensesInputBody {
    let lensAliases: [Swift.String]?
}

extension AssociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension AssociateLensesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateLensesOutput {

    public init() { }
}

enum AssociateLensesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArns = "ProfileArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArns = profileArns {
            var profileArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileArns)
            for profilearn0 in profileArns {
                try profileArnsContainer.encode(profilearn0)
            }
        }
    }
}

extension AssociateProfilesInput {

    static func urlPathProvider(_ value: AssociateProfilesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/associateProfiles"
    }
}

public struct AssociateProfilesInput {
    /// The list of profile ARNs to associate with the workload.
    /// This member is required.
    public var profileArns: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        profileArns: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.profileArns = profileArns
        self.workloadId = workloadId
    }
}

struct AssociateProfilesInputBody {
    let profileArns: [Swift.String]?
}

extension AssociateProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArns = "ProfileArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileArns)
        var profileArnsDecoded0:[Swift.String]? = nil
        if let profileArnsContainer = profileArnsContainer {
            profileArnsDecoded0 = [Swift.String]()
            for string0 in profileArnsContainer {
                if let string0 = string0 {
                    profileArnsDecoded0?.append(string0)
                }
            }
        }
        profileArns = profileArnsDecoded0
    }
}

extension AssociateProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateProfilesOutput {

    public init() { }
}

enum AssociateProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes.BestPractice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case choiceTitle = "ChoiceTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let choiceTitle = self.choiceTitle {
            try encodeContainer.encode(choiceTitle, forKey: .choiceTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let choiceTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceTitle)
        choiceTitle = choiceTitleDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A best practice, or question choice, that has been identified as a risk in this question.
    public struct BestPractice {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }

}

extension WellArchitectedClientTypes.CheckDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case choiceId = "ChoiceId"
        case description = "Description"
        case flaggedResources = "FlaggedResources"
        case id = "Id"
        case lensArn = "LensArn"
        case name = "Name"
        case pillarId = "PillarId"
        case provider = "Provider"
        case questionId = "QuestionId"
        case reason = "Reason"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flaggedResources = self.flaggedResources {
            try encodeContainer.encode(flaggedResources, forKey: .flaggedResources)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.CheckProvider.self, forKey: .provider)
        provider = providerDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.CheckStatus.self, forKey: .status)
        status = statusDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let flaggedResourcesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .flaggedResources)
        flaggedResources = flaggedResourcesDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.CheckFailureReason.self, forKey: .reason)
        reason = reasonDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Account details for a Well-Architected best practice in relation to Trusted Advisor checks.
    public struct CheckDetail {
        /// An Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// Trusted Advisor check description.
        public var description: Swift.String?
        /// Count of flagged resources associated to the check.
        public var flaggedResources: Swift.Int?
        /// Trusted Advisor check ID.
        public var id: Swift.String?
        /// Well-Architected Lens ARN associated to the check.
        public var lensArn: Swift.String?
        /// Trusted Advisor check name.
        public var name: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Provider of the check related to the best practice.
        public var provider: WellArchitectedClientTypes.CheckProvider?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// Reason associated to the check.
        public var reason: WellArchitectedClientTypes.CheckFailureReason?
        /// Status associated to the check.
        public var status: WellArchitectedClientTypes.CheckStatus?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            flaggedResources: Swift.Int? = nil,
            id: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            name: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            provider: WellArchitectedClientTypes.CheckProvider? = nil,
            questionId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.CheckFailureReason? = nil,
            status: WellArchitectedClientTypes.CheckStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.choiceId = choiceId
            self.description = description
            self.flaggedResources = flaggedResources
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.reason = reason
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes {
    public enum CheckFailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case assumeRoleError
        case premiumSupportRequired
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckFailureReason] {
            return [
                .accessDenied,
                .assumeRoleError,
                .premiumSupportRequired,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .assumeRoleError: return "ASSUME_ROLE_ERROR"
            case .premiumSupportRequired: return "PREMIUM_SUPPORT_REQUIRED"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CheckFailureReason(rawValue: rawValue) ?? CheckFailureReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum CheckProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case trustedAdvisor
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckProvider] {
            return [
                .trustedAdvisor,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .trustedAdvisor: return "TRUSTED_ADVISOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CheckProvider(rawValue: rawValue) ?? CheckProvider.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum CheckStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case fetchFailed
        case notAvailable
        case okay
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckStatus] {
            return [
                .error,
                .fetchFailed,
                .notAvailable,
                .okay,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .fetchFailed: return "FETCH_FAILED"
            case .notAvailable: return "NOT_AVAILABLE"
            case .okay: return "OKAY"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CheckStatus(rawValue: rawValue) ?? CheckStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.CheckSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountSummary = "AccountSummary"
        case choiceId = "ChoiceId"
        case description = "Description"
        case id = "Id"
        case lensArn = "LensArn"
        case name = "Name"
        case pillarId = "PillarId"
        case provider = "Provider"
        case questionId = "QuestionId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountSummary = accountSummary {
            var accountSummaryContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .accountSummary)
            for (dictKey0, accountSummary0) in accountSummary {
                try accountSummaryContainer.encode(accountSummary0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let provider = self.provider {
            try encodeContainer.encode(provider.rawValue, forKey: .provider)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let providerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.CheckProvider.self, forKey: .provider)
        provider = providerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.CheckStatus.self, forKey: .status)
        status = statusDecoded
        let accountSummaryContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .accountSummary)
        var accountSummaryDecoded0: [Swift.String:Swift.Int]? = nil
        if let accountSummaryContainer = accountSummaryContainer {
            accountSummaryDecoded0 = [Swift.String:Swift.Int]()
            for (key0, checkstatuscount0) in accountSummaryContainer {
                if let checkstatuscount0 = checkstatuscount0 {
                    accountSummaryDecoded0?[key0] = checkstatuscount0
                }
            }
        }
        accountSummary = accountSummaryDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// Trusted Advisor check summary.
    public struct CheckSummary {
        /// Account summary associated to the check.
        public var accountSummary: [Swift.String:Swift.Int]?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// Trusted Advisor check description.
        public var description: Swift.String?
        /// Trusted Advisor check ID.
        public var id: Swift.String?
        /// Well-Architected Lens ARN associated to the check.
        public var lensArn: Swift.String?
        /// Trusted Advisor check name.
        public var name: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Provider of the check related to the best practice.
        public var provider: WellArchitectedClientTypes.CheckProvider?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// Status associated to the check.
        public var status: WellArchitectedClientTypes.CheckStatus?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountSummary: [Swift.String:Swift.Int]? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            name: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            provider: WellArchitectedClientTypes.CheckProvider? = nil,
            questionId: Swift.String? = nil,
            status: WellArchitectedClientTypes.CheckStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountSummary = accountSummary
            self.choiceId = choiceId
            self.description = description
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.Choice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalResources = "AdditionalResources"
        case choiceId = "ChoiceId"
        case description = "Description"
        case helpfulResource = "HelpfulResource"
        case improvementPlan = "ImprovementPlan"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalResources = additionalResources {
            var additionalResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalResources)
            for additionalresources0 in additionalResources {
                try additionalResourcesContainer.encode(additionalresources0)
            }
        }
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let helpfulResource = self.helpfulResource {
            try encodeContainer.encode(helpfulResource, forKey: .helpfulResource)
        }
        if let improvementPlan = self.improvementPlan {
            try encodeContainer.encode(improvementPlan, forKey: .improvementPlan)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let helpfulResourceDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .helpfulResource)
        helpfulResource = helpfulResourceDecoded
        let improvementPlanDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceContent.self, forKey: .improvementPlan)
        improvementPlan = improvementPlanDecoded
        let additionalResourcesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.AdditionalResources?].self, forKey: .additionalResources)
        var additionalResourcesDecoded0:[WellArchitectedClientTypes.AdditionalResources]? = nil
        if let additionalResourcesContainer = additionalResourcesContainer {
            additionalResourcesDecoded0 = [WellArchitectedClientTypes.AdditionalResources]()
            for structure0 in additionalResourcesContainer {
                if let structure0 = structure0 {
                    additionalResourcesDecoded0?.append(structure0)
                }
            }
        }
        additionalResources = additionalResourcesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A choice available to answer question.
    public struct Choice {
        /// The additional resources for a choice in a custom lens. A choice can have up to two additional resources: one of type HELPFUL_RESOURCE, one of type IMPROVEMENT_PLAN, or both.
        public var additionalResources: [WellArchitectedClientTypes.AdditionalResources]?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The description of a choice.
        public var description: Swift.String?
        /// The helpful resource (both text and URL) for a particular choice. This field only applies to custom lenses. Each choice can have only one helpful resource.
        public var helpfulResource: WellArchitectedClientTypes.ChoiceContent?
        /// The improvement plan (both text and URL) for a particular choice. This field only applies to custom lenses. Each choice can have only one improvement plan.
        public var improvementPlan: WellArchitectedClientTypes.ChoiceContent?
        /// The title of a choice.
        public var title: Swift.String?

        public init(
            additionalResources: [WellArchitectedClientTypes.AdditionalResources]? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            helpfulResource: WellArchitectedClientTypes.ChoiceContent? = nil,
            improvementPlan: WellArchitectedClientTypes.ChoiceContent? = nil,
            title: Swift.String? = nil
        )
        {
            self.additionalResources = additionalResources
            self.choiceId = choiceId
            self.description = description
            self.helpfulResource = helpfulResource
            self.improvementPlan = improvementPlan
            self.title = title
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A choice that has been answered on a question in your workload.
    public struct ChoiceAnswer {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            choiceId: Swift.String? = nil,
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceAnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A choice summary that has been answered on a question in your workload.
    public struct ChoiceAnswerSummary {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            choiceId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.reason = reason
            self.status = status
        }
    }

}

extension WellArchitectedClientTypes.ChoiceContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayText = "DisplayText"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayText = self.displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The choice content.
    public struct ChoiceContent {
        /// The display text for the choice content.
        public var displayText: Swift.String?
        /// The URL for the choice content.
        public var url: Swift.String?

        public init(
            displayText: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.displayText = displayText
            self.url = url
        }
    }

}

extension WellArchitectedClientTypes.ChoiceImprovementPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case displayText = "DisplayText"
        case improvementPlanUrl = "ImprovementPlanUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let displayText = self.displayText {
            try encodeContainer.encode(displayText, forKey: .displayText)
        }
        if let improvementPlanUrl = self.improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let displayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayText)
        displayText = displayTextDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The choice level improvement plan.
    public struct ChoiceImprovementPlan {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The display text for the improvement plan.
        public var displayText: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?

        public init(
            choiceId: Swift.String? = nil,
            displayText: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.displayText = displayText
            self.improvementPlanUrl = improvementPlanUrl
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ChoiceReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceReason(rawValue: rawValue) ?? ChoiceReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ChoiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notApplicable
        case selected
        case unselected
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceStatus] {
            return [
                .notApplicable,
                .selected,
                .unselected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notApplicable: return "NOT_APPLICABLE"
            case .selected: return "SELECTED"
            case .unselected: return "UNSELECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChoiceStatus(rawValue: rawValue) ?? ChoiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ChoiceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case reason = "Reason"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ChoiceReason.self, forKey: .reason)
        reason = reasonDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A list of choices to be updated.
    public struct ChoiceUpdate {
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        /// This member is required.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource has already been processed, was deleted, or is too large.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WellArchitectedClientTypes.ConsolidatedReportMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lenses = "Lenses"
        case lensesAppliedCount = "LensesAppliedCount"
        case metricType = "MetricType"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensmetric0 in lenses {
                try lensesContainer.encode(lensmetric0)
            }
        }
        if let lensesAppliedCount = self.lensesAppliedCount {
            try encodeContainer.encode(lensesAppliedCount, forKey: .lensesAppliedCount)
        }
        if let metricType = self.metricType {
            try encodeContainer.encode(metricType.rawValue, forKey: .metricType)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workloadArn = self.workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.MetricType.self, forKey: .metricType)
        metricType = metricTypeDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensMetric?].self, forKey: .lenses)
        var lensesDecoded0:[WellArchitectedClientTypes.LensMetric]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [WellArchitectedClientTypes.LensMetric]()
            for structure0 in lensesContainer {
                if let structure0 = structure0 {
                    lensesDecoded0?.append(structure0)
                }
            }
        }
        lenses = lensesDecoded0
        let lensesAppliedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lensesAppliedCount)
        lensesAppliedCount = lensesAppliedCountDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A metric that contributes to the consolidated report.
    public struct ConsolidatedReportMetric {
        /// The metrics for the lenses in the workload.
        public var lenses: [WellArchitectedClientTypes.LensMetric]?
        /// The total number of lenses applied to the workload.
        public var lensesAppliedCount: Swift.Int?
        /// The metric type of a metric in the consolidated report. Currently only WORKLOAD metric types are supported.
        public var metricType: WellArchitectedClientTypes.MetricType?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            lenses: [WellArchitectedClientTypes.LensMetric]? = nil,
            lensesAppliedCount: Swift.Int? = nil,
            metricType: WellArchitectedClientTypes.MetricType? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lenses = lenses
            self.lensesAppliedCount = lensesAppliedCount
            self.metricType = metricType
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension CreateLensShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateLensShareInput {

    static func urlPathProvider(_ value: CreateLensShareInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

public struct CreateLensShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.sharedWith = sharedWith
    }
}

struct CreateLensShareInputBody {
    let sharedWith: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateLensShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLensShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
        } else {
            self.shareId = nil
        }
    }
}

public struct CreateLensShareOutput {
    /// The ID associated with the share.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

struct CreateLensShareOutputBody {
    let shareId: Swift.String?
}

extension CreateLensShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

enum CreateLensShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLensVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let isMajorVersion = self.isMajorVersion {
            try encodeContainer.encode(isMajorVersion, forKey: .isMajorVersion)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
    }
}

extension CreateLensVersionInput {

    static func urlPathProvider(_ value: CreateLensVersionInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versions"
    }
}

public struct CreateLensVersionInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Set to true if this new major lens version.
    public var isMajorVersion: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The version of the lens being created.
    /// This member is required.
    public var lensVersion: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        isMajorVersion: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.isMajorVersion = isMajorVersion
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionInputBody {
    let lensVersion: Swift.String?
    let isMajorVersion: Swift.Bool?
    let clientRequestToken: Swift.String?
}

extension CreateLensVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case isMajorVersion = "IsMajorVersion"
        case lensVersion = "LensVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let isMajorVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMajorVersion)
        isMajorVersion = isMajorVersionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateLensVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLensVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.lensVersion = output.lensVersion
        } else {
            self.lensArn = nil
            self.lensVersion = nil
        }
    }
}

public struct CreateLensVersionOutput {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The version of the lens.
    public var lensVersion: Swift.String?

    public init(
        lensArn: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensArn = lensArn
        self.lensVersion = lensVersion
    }
}

struct CreateLensVersionOutputBody {
    let lensArn: Swift.String?
    let lensVersion: Swift.String?
}

extension CreateLensVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
    }
}

enum CreateLensVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMilestoneInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = self.milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

extension CreateMilestoneInput {

    static func urlPathProvider(_ value: CreateMilestoneInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones"
    }
}

/// Input for milestone creation.
public struct CreateMilestoneInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct CreateMilestoneInputBody {
    let milestoneName: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateMilestoneInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMilestoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMilestoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.milestoneNumber = nil
            self.workloadId = nil
        }
    }
}

/// Output of a create milestone call.
public struct CreateMilestoneOutput {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct CreateMilestoneOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
}

extension CreateMilestoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
    }
}

enum CreateMilestoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case profileDescription = "ProfileDescription"
        case profileName = "ProfileName"
        case profileQuestions = "ProfileQuestions"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let profileDescription = self.profileDescription {
            try encodeContainer.encode(profileDescription, forKey: .profileDescription)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileQuestions = profileQuestions {
            var profileQuestionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileQuestions)
            for profilequestionupdate0 in profileQuestions {
                try profileQuestionsContainer.encode(profilequestionupdate0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/profiles"
    }
}

public struct CreateProfileInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile description.
    /// This member is required.
    public var profileDescription: Swift.String?
    /// Name of the profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The profile questions.
    /// This member is required.
    public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?
    /// The tags assigned to the profile.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileDescription: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileDescription = profileDescription
        self.profileName = profileName
        self.profileQuestions = profileQuestions
        self.tags = tags
    }
}

struct CreateProfileInputBody {
    let profileName: Swift.String?
    let profileDescription: Swift.String?
    let profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case profileDescription = "ProfileDescription"
        case profileName = "ProfileName"
        case profileQuestions = "ProfileQuestions"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileDescription)
        profileDescription = profileDescriptionDecoded
        let profileQuestionsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileQuestionUpdate?].self, forKey: .profileQuestions)
        var profileQuestionsDecoded0:[WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil
        if let profileQuestionsContainer = profileQuestionsContainer {
            profileQuestionsDecoded0 = [WellArchitectedClientTypes.ProfileQuestionUpdate]()
            for structure0 in profileQuestionsContainer {
                if let structure0 = structure0 {
                    profileQuestionsDecoded0?.append(structure0)
                }
            }
        }
        profileQuestions = profileQuestionsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileArn = output.profileArn
            self.profileVersion = output.profileVersion
        } else {
            self.profileArn = nil
            self.profileVersion = nil
        }
    }
}

public struct CreateProfileOutput {
    /// The profile ARN.
    public var profileArn: Swift.String?
    /// Version of the profile.
    public var profileVersion: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        profileVersion: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.profileVersion = profileVersion
    }
}

struct CreateProfileOutputBody {
    let profileArn: Swift.String?
    let profileVersion: Swift.String?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
        case profileVersion = "ProfileVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateProfileShareInput {

    static func urlPathProvider(_ value: CreateProfileShareInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares"
    }
}

public struct CreateProfileShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
        self.sharedWith = sharedWith
    }
}

struct CreateProfileShareInputBody {
    let sharedWith: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateProfileShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateProfileShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileArn = output.profileArn
            self.shareId = output.shareId
        } else {
            self.profileArn = nil
            self.shareId = nil
        }
    }
}

public struct CreateProfileShareOutput {
    /// The profile ARN.
    public var profileArn: Swift.String?
    /// The ID associated with the share.
    public var shareId: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.shareId = shareId
    }
}

struct CreateProfileShareOutputBody {
    let shareId: Swift.String?
    let profileArn: Swift.String?
}

extension CreateProfileShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
        case shareId = "ShareId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

enum CreateProfileShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReviewTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case lenses = "Lenses"
        case notes = "Notes"
        case tags = "Tags"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension CreateReviewTemplateInput {

    static func urlPathProvider(_ value: CreateReviewTemplateInput) -> Swift.String? {
        return "/reviewTemplates"
    }
}

public struct CreateReviewTemplateInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The review template description.
    /// This member is required.
    public var description: Swift.String?
    /// Lenses applied to the review template.
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The tags assigned to the review template.
    public var tags: [Swift.String:Swift.String]?
    /// Name of the review template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        lenses: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.lenses = lenses
        self.notes = notes
        self.tags = tags
        self.templateName = templateName
    }
}

struct CreateReviewTemplateInputBody {
    let templateName: Swift.String?
    let description: Swift.String?
    let lenses: [Swift.String]?
    let notes: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientRequestToken: Swift.String?
}

extension CreateReviewTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case lenses = "Lenses"
        case notes = "Notes"
        case tags = "Tags"
        case templateName = "TemplateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateReviewTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReviewTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateArn = output.templateArn
        } else {
            self.templateArn = nil
        }
    }
}

public struct CreateReviewTemplateOutput {
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        templateArn: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
    }
}

struct CreateReviewTemplateOutputBody {
    let templateArn: Swift.String?
}

extension CreateReviewTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
    }
}

enum CreateReviewTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTemplateShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateTemplateShareInput {

    static func urlPathProvider(_ value: CreateTemplateShareInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())"
    }
}

public struct CreateTemplateShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        sharedWith: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sharedWith = sharedWith
        self.templateArn = templateArn
    }
}

struct CreateTemplateShareInputBody {
    let sharedWith: Swift.String?
    let clientRequestToken: Swift.String?
}

extension CreateTemplateShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sharedWith = "SharedWith"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateTemplateShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTemplateShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
            self.templateArn = output.templateArn
        } else {
            self.shareId = nil
            self.templateArn = nil
        }
    }
}

public struct CreateTemplateShareOutput {
    /// The ID associated with the share.
    public var shareId: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        shareId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.templateArn = templateArn
    }
}

struct CreateTemplateShareOutputBody {
    let templateArn: Swift.String?
    let shareId: Swift.String?
}

extension CreateTemplateShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

enum CreateTemplateShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case applications = "Applications"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case discoveryConfig = "DiscoveryConfig"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case jiraConfiguration = "JiraConfiguration"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case profileArns = "ProfileArns"
        case reviewOwner = "ReviewOwner"
        case reviewTemplateArns = "ReviewTemplateArns"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationarn0 in applications {
                try applicationsContainer.encode(applicationarn0)
            }
        }
        if let architecturalDesign = self.architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for awsregion0 in awsRegions {
                try awsRegionsContainer.encode(awsregion0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let discoveryConfig = self.discoveryConfig {
            try encodeContainer.encode(discoveryConfig, forKey: .discoveryConfig)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let industry = self.industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = self.industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregion0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregion0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for pillarid0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(pillarid0)
            }
        }
        if let profileArns = profileArns {
            var profileArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileArns)
            for profilearn0 in profileArns {
                try profileArnsContainer.encode(profilearn0)
            }
        }
        if let reviewOwner = self.reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let reviewTemplateArns = reviewTemplateArns {
            var reviewTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reviewTemplateArns)
            for templatearn0 in reviewTemplateArns {
                try reviewTemplateArnsContainer.encode(templatearn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension CreateWorkloadInput {

    static func urlPathProvider(_ value: CreateWorkloadInput) -> Swift.String? {
        return "/workloads"
    }
}

/// Input for workload creation.
public struct CreateWorkloadInput {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// List of AppRegistry application ARNs associated to the workload.
    public var applications: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description for the workload.
    /// This member is required.
    public var description: Swift.String?
    /// Well-Architected discovery configuration settings associated to the workload.
    public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    /// The environment for the workload.
    /// This member is required.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Jira configuration settings when creating a workload.
    public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
    /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The list of profile ARNs associated with the workload.
    public var profileArns: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The list of review template ARNs to associate with the workload.
    public var reviewTemplateArns: [Swift.String]?
    /// The tags to be associated with the workload.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        applications: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput? = nil,
        lenses: [Swift.String]? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        profileArns: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        reviewTemplateArns: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.applications = applications
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.discoveryConfig = discoveryConfig
        self.environment = environment
        self.industry = industry
        self.industryType = industryType
        self.jiraConfiguration = jiraConfiguration
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.profileArns = profileArns
        self.reviewOwner = reviewOwner
        self.reviewTemplateArns = reviewTemplateArns
        self.tags = tags
        self.workloadName = workloadName
    }
}

struct CreateWorkloadInputBody {
    let workloadName: Swift.String?
    let description: Swift.String?
    let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    let accountIds: [Swift.String]?
    let awsRegions: [Swift.String]?
    let nonAwsRegions: [Swift.String]?
    let pillarPriorities: [Swift.String]?
    let architecturalDesign: Swift.String?
    let reviewOwner: Swift.String?
    let industryType: Swift.String?
    let industry: Swift.String?
    let lenses: [Swift.String]?
    let notes: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    let applications: [Swift.String]?
    let profileArns: [Swift.String]?
    let reviewTemplateArns: [Swift.String]?
    let jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
}

extension CreateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case applications = "Applications"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case discoveryConfig = "DiscoveryConfig"
        case environment = "Environment"
        case industry = "Industry"
        case industryType = "IndustryType"
        case jiraConfiguration = "JiraConfiguration"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case profileArns = "ProfileArns"
        case reviewOwner = "ReviewOwner"
        case reviewTemplateArns = "ReviewTemplateArns"
        case tags = "Tags"
        case workloadName = "WorkloadName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let discoveryConfigDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadDiscoveryConfig.self, forKey: .discoveryConfig)
        discoveryConfig = discoveryConfigDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applications)
        var applicationsDecoded0:[Swift.String]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [Swift.String]()
            for string0 in applicationsContainer {
                if let string0 = string0 {
                    applicationsDecoded0?.append(string0)
                }
            }
        }
        applications = applicationsDecoded0
        let profileArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileArns)
        var profileArnsDecoded0:[Swift.String]? = nil
        if let profileArnsContainer = profileArnsContainer {
            profileArnsDecoded0 = [Swift.String]()
            for string0 in profileArnsContainer {
                if let string0 = string0 {
                    profileArnsDecoded0?.append(string0)
                }
            }
        }
        profileArns = profileArnsDecoded0
        let reviewTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reviewTemplateArns)
        var reviewTemplateArnsDecoded0:[Swift.String]? = nil
        if let reviewTemplateArnsContainer = reviewTemplateArnsContainer {
            reviewTemplateArnsDecoded0 = [Swift.String]()
            for string0 in reviewTemplateArnsContainer {
                if let string0 = string0 {
                    reviewTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        reviewTemplateArns = reviewTemplateArnsDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadJiraConfigurationInput.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension CreateWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workloadArn = output.workloadArn
            self.workloadId = output.workloadId
        } else {
            self.workloadArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a create workload call.
public struct CreateWorkloadOutput {
    /// The ARN for the workload.
    public var workloadArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        workloadArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
        self.workloadId = workloadId
    }
}

struct CreateWorkloadOutputBody {
    let workloadId: Swift.String?
    let workloadArn: Swift.String?
}

extension CreateWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
    }
}

enum CreateWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkloadShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
    }
}

extension CreateWorkloadShareInput {

    static func urlPathProvider(_ value: CreateWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Permission granted on a share request.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        sharedWith: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.permissionType = permissionType
        self.sharedWith = sharedWith
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareInputBody {
    let sharedWith: Swift.String?
    let permissionType: WellArchitectedClientTypes.PermissionType?
    let clientRequestToken: Swift.String?
}

extension CreateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case permissionType = "PermissionType"
        case sharedWith = "SharedWith"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWorkloadShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkloadShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareId = output.shareId
            self.workloadId = output.workloadId
        } else {
            self.shareId = nil
            self.workloadId = nil
        }
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareOutput {
    /// The ID associated with the share.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct CreateWorkloadShareOutputBody {
    let workloadId: Swift.String?
    let shareId: Swift.String?
}

extension CreateWorkloadShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
    }
}

enum CreateWorkloadShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum DefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appRegistry
        case workloadMetadata
        case sdkUnknown(Swift.String)

        public static var allCases: [DefinitionType] {
            return [
                .appRegistry,
                .workloadMetadata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appRegistry: return "APP_REGISTRY"
            case .workloadMetadata: return "WORKLOAD_METADATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DefinitionType(rawValue: rawValue) ?? DefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteLensInput {

    static func queryItemProvider(_ value: DeleteLensInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        guard let lensStatus = value.lensStatus else {
            let message = "Creating a URL Query Item failed. lensStatus is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let lensStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
        items.append(lensStatusQueryItem)
        return items
    }
}

extension DeleteLensInput {

    static func urlPathProvider(_ value: DeleteLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

public struct DeleteLensInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The status of the lens to be deleted.
    /// This member is required.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.lensStatus = lensStatus
    }
}

struct DeleteLensInputBody {
}

extension DeleteLensInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLensOutput {

    public init() { }
}

enum DeleteLensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLensShareInput {

    static func queryItemProvider(_ value: DeleteLensShareInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteLensShareInput {

    static func urlPathProvider(_ value: DeleteLensShareInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteLensShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.shareId = shareId
    }
}

struct DeleteLensShareInputBody {
}

extension DeleteLensShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLensShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLensShareOutput {

    public init() { }
}

enum DeleteLensShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput {

    static func queryItemProvider(_ value: DeleteProfileInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

public struct DeleteProfileInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
    }
}

struct DeleteProfileInputBody {
}

extension DeleteProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProfileOutput {

    public init() { }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileShareInput {

    static func queryItemProvider(_ value: DeleteProfileShareInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteProfileShareInput {

    static func urlPathProvider(_ value: DeleteProfileShareInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteProfileShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
        self.shareId = shareId
    }
}

struct DeleteProfileShareInputBody {
}

extension DeleteProfileShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProfileShareOutput {

    public init() { }
}

enum DeleteProfileShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReviewTemplateInput {

    static func queryItemProvider(_ value: DeleteReviewTemplateInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteReviewTemplateInput {

    static func urlPathProvider(_ value: DeleteReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

public struct DeleteReviewTemplateInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.templateArn = templateArn
    }
}

struct DeleteReviewTemplateInputBody {
}

extension DeleteReviewTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReviewTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReviewTemplateOutput {

    public init() { }
}

enum DeleteReviewTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTemplateShareInput {

    static func queryItemProvider(_ value: DeleteTemplateShareInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteTemplateShareInput {

    static func urlPathProvider(_ value: DeleteTemplateShareInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())/\(shareId.urlPercentEncoding())"
    }
}

public struct DeleteTemplateShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.templateArn = templateArn
    }
}

struct DeleteTemplateShareInputBody {
}

extension DeleteTemplateShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTemplateShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTemplateShareOutput {

    public init() { }
}

enum DeleteTemplateShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkloadInput {

    static func queryItemProvider(_ value: DeleteWorkloadInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteWorkloadInput {

    static func urlPathProvider(_ value: DeleteWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input for workload deletion.
public struct DeleteWorkloadInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadInputBody {
}

extension DeleteWorkloadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkloadOutput {

    public init() { }
}

enum DeleteWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkloadShareInput {

    static func queryItemProvider(_ value: DeleteWorkloadShareInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteWorkloadShareInput {

    static func urlPathProvider(_ value: DeleteWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

/// Input for Delete Workload Share
public struct DeleteWorkloadShareInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct DeleteWorkloadShareInputBody {
}

extension DeleteWorkloadShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkloadShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkloadShareOutput {

    public init() { }
}

enum DeleteWorkloadShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum DifferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case new
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferenceStatus] {
            return [
                .deleted,
                .new,
                .updated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .new: return "NEW"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DifferenceStatus(rawValue: rawValue) ?? DifferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateLensesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAliases = lensAliases {
            var lensAliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensAliases)
            for lensalias0 in lensAliases {
                try lensAliasesContainer.encode(lensalias0)
            }
        }
    }
}

extension DisassociateLensesInput {

    static func urlPathProvider(_ value: DisassociateLensesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/disassociateLenses"
    }
}

/// Input to disassociate lens reviews.
public struct DisassociateLensesInput {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

struct DisassociateLensesInputBody {
    let lensAliases: [Swift.String]?
}

extension DisassociateLensesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAliases = "LensAliases"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensAliases)
        var lensAliasesDecoded0:[Swift.String]? = nil
        if let lensAliasesContainer = lensAliasesContainer {
            lensAliasesDecoded0 = [Swift.String]()
            for string0 in lensAliasesContainer {
                if let string0 = string0 {
                    lensAliasesDecoded0?.append(string0)
                }
            }
        }
        lensAliases = lensAliasesDecoded0
    }
}

extension DisassociateLensesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateLensesOutput {

    public init() { }
}

enum DisassociateLensesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArns = "ProfileArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArns = profileArns {
            var profileArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileArns)
            for profilearn0 in profileArns {
                try profileArnsContainer.encode(profilearn0)
            }
        }
    }
}

extension DisassociateProfilesInput {

    static func urlPathProvider(_ value: DisassociateProfilesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/disassociateProfiles"
    }
}

public struct DisassociateProfilesInput {
    /// The list of profile ARNs to disassociate from the workload.
    /// This member is required.
    public var profileArns: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        profileArns: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.profileArns = profileArns
        self.workloadId = workloadId
    }
}

struct DisassociateProfilesInputBody {
    let profileArns: [Swift.String]?
}

extension DisassociateProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArns = "ProfileArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profileArns)
        var profileArnsDecoded0:[Swift.String]? = nil
        if let profileArnsContainer = profileArnsContainer {
            profileArnsDecoded0 = [Swift.String]()
            for string0 in profileArnsContainer {
                if let string0 = string0 {
                    profileArnsDecoded0?.append(string0)
                }
            }
        }
        profileArns = profileArnsDecoded0
    }
}

extension DisassociateProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateProfilesOutput {

    public init() { }
}

enum DisassociateProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum DiscoveryIntegrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryIntegrationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiscoveryIntegrationStatus(rawValue: rawValue) ?? DiscoveryIntegrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ExportLensInput {

    static func queryItemProvider(_ value: ExportLensInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let lensVersion = value.lensVersion {
            let lensVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension ExportLensInput {

    static func urlPathProvider(_ value: ExportLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/export"
    }
}

public struct ExportLensInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be exported.
    public var lensVersion: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct ExportLensInputBody {
}

extension ExportLensInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportLensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportLensOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensJSON = output.lensJSON
        } else {
            self.lensJSON = nil
        }
    }
}

public struct ExportLensOutput {
    /// The JSON representation of a lens.
    public var lensJSON: Swift.String?

    public init(
        lensJSON: Swift.String? = nil
    )
    {
        self.lensJSON = lensJSON
    }
}

struct ExportLensOutputBody {
    let lensJSON: Swift.String?
}

extension ExportLensOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensJSON = "LensJSON"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensJSON)
        lensJSON = lensJSONDecoded
    }
}

enum ExportLensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAnswerInput {

    static func queryItemProvider(_ value: GetAnswerInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetAnswerInput {

    static func urlPathProvider(_ value: GetAnswerInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

/// Input to get answer.
public struct GetAnswerInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct GetAnswerInputBody {
}

extension GetAnswerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAnswerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnswerOutputBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get answer call.
public struct GetAnswerOutput {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetAnswerOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answer: WellArchitectedClientTypes.Answer?
}

extension GetAnswerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

enum GetAnswerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConsolidatedReportInput {

    static func queryItemProvider(_ value: GetConsolidatedReportInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let formatQueryItem = ClientRuntime.SDKURLQueryItem(name: "Format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let includeSharedResources = value.includeSharedResources {
            let includeSharedResourcesQueryItem = ClientRuntime.SDKURLQueryItem(name: "IncludeSharedResources".urlPercentEncoding(), value: Swift.String(includeSharedResources).urlPercentEncoding())
            items.append(includeSharedResourcesQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetConsolidatedReportInput {

    static func urlPathProvider(_ value: GetConsolidatedReportInput) -> Swift.String? {
        return "/consolidatedReport"
    }
}

public struct GetConsolidatedReportInput {
    /// The format of the consolidated report. For PDF, Base64String is returned. For JSON, Metrics is returned.
    /// This member is required.
    public var format: WellArchitectedClientTypes.ReportFormat?
    /// Set to true to have shared resources included in the report.
    public var includeSharedResources: Swift.Bool?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        format: WellArchitectedClientTypes.ReportFormat? = nil,
        includeSharedResources: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.format = format
        self.includeSharedResources = includeSharedResources
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConsolidatedReportInputBody {
}

extension GetConsolidatedReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConsolidatedReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConsolidatedReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.base64String = output.base64String
            self.metrics = output.metrics
            self.nextToken = output.nextToken
        } else {
            self.base64String = nil
            self.metrics = nil
            self.nextToken = nil
        }
    }
}

public struct GetConsolidatedReportOutput {
    /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file. Only returned by [GetConsolidatedReport] when PDF format is requested.
    public var base64String: Swift.String?
    /// The metrics that make up the consolidated report. Only returned when JSON format is requested.
    public var metrics: [WellArchitectedClientTypes.ConsolidatedReportMetric]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        base64String: Swift.String? = nil,
        metrics: [WellArchitectedClientTypes.ConsolidatedReportMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.base64String = base64String
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

struct GetConsolidatedReportOutputBody {
    let metrics: [WellArchitectedClientTypes.ConsolidatedReportMetric]?
    let nextToken: Swift.String?
    let base64String: Swift.String?
}

extension GetConsolidatedReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base64String = "Base64String"
        case metrics = "Metrics"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ConsolidatedReportMetric?].self, forKey: .metrics)
        var metricsDecoded0:[WellArchitectedClientTypes.ConsolidatedReportMetric]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [WellArchitectedClientTypes.ConsolidatedReportMetric]()
            for structure0 in metricsContainer {
                if let structure0 = structure0 {
                    metricsDecoded0?.append(structure0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let base64StringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .base64String)
        base64String = base64StringDecoded
    }
}

enum GetConsolidatedReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGlobalSettingsInput {

    static func urlPathProvider(_ value: GetGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

public struct GetGlobalSettingsInput {

    public init() { }
}

struct GetGlobalSettingsInputBody {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlobalSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.discoveryIntegrationStatus = output.discoveryIntegrationStatus
            self.jiraConfiguration = output.jiraConfiguration
            self.organizationSharingStatus = output.organizationSharingStatus
        } else {
            self.discoveryIntegrationStatus = nil
            self.jiraConfiguration = nil
            self.organizationSharingStatus = nil
        }
    }
}

public struct GetGlobalSettingsOutput {
    /// Discovery integration status.
    public var discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    /// Jira configuration status.
    public var jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationOutput?
    /// Amazon Web Services Organizations sharing status.
    public var organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?

    public init(
        discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus? = nil,
        jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationOutput? = nil,
        organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus? = nil
    )
    {
        self.discoveryIntegrationStatus = discoveryIntegrationStatus
        self.jiraConfiguration = jiraConfiguration
        self.organizationSharingStatus = organizationSharingStatus
    }
}

struct GetGlobalSettingsOutputBody {
    let organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?
    let discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    let jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationOutput?
}

extension GetGlobalSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveryIntegrationStatus = "DiscoveryIntegrationStatus"
        case jiraConfiguration = "JiraConfiguration"
        case organizationSharingStatus = "OrganizationSharingStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSharingStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.OrganizationSharingStatus.self, forKey: .organizationSharingStatus)
        organizationSharingStatus = organizationSharingStatusDecoded
        let discoveryIntegrationStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DiscoveryIntegrationStatus.self, forKey: .discoveryIntegrationStatus)
        discoveryIntegrationStatus = discoveryIntegrationStatusDecoded
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AccountJiraConfigurationOutput.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

enum GetGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLensInput {

    static func queryItemProvider(_ value: GetLensInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let lensVersion = value.lensVersion {
            let lensVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension GetLensInput {

    static func urlPathProvider(_ value: GetLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

public struct GetLensInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be retrieved.
    public var lensVersion: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

struct GetLensInputBody {
}

extension GetLensInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLensOutputBody = try responseDecoder.decode(responseBody: data)
            self.lens = output.lens
        } else {
            self.lens = nil
        }
    }
}

public struct GetLensOutput {
    /// A lens return object.
    public var lens: WellArchitectedClientTypes.Lens?

    public init(
        lens: WellArchitectedClientTypes.Lens? = nil
    )
    {
        self.lens = lens
    }
}

struct GetLensOutputBody {
    let lens: WellArchitectedClientTypes.Lens?
}

extension GetLensOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lens = "Lens"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Lens.self, forKey: .lens)
        lens = lensDecoded
    }
}

enum GetLensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLensReviewInput {

    static func queryItemProvider(_ value: GetLensReviewInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensReviewInput {

    static func urlPathProvider(_ value: GetLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

/// Input to get lens review.
public struct GetLensReviewInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewInputBody {
}

extension GetLensReviewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLensReviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.milestoneNumber = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review call.
public struct GetLensReviewOutput {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensReview: WellArchitectedClientTypes.LensReview?
}

extension GetLensReviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

enum GetLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLensReviewReportInput {

    static func queryItemProvider(_ value: GetLensReviewReportInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensReviewReportInput {

    static func urlPathProvider(_ value: GetLensReviewReportInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/report"
    }
}

/// Input to get lens review report.
public struct GetLensReviewReportInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportInputBody {
}

extension GetLensReviewReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLensReviewReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLensReviewReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewReport = output.lensReviewReport
            self.milestoneNumber = output.milestoneNumber
            self.workloadId = output.workloadId
        } else {
            self.lensReviewReport = nil
            self.milestoneNumber = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get lens review report call.
public struct GetLensReviewReportOutput {
    /// A report of a lens review.
    public var lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReviewReport: WellArchitectedClientTypes.LensReviewReport? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewReport = lensReviewReport
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetLensReviewReportOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
}

extension GetLensReviewReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewReport = "LensReviewReport"
        case milestoneNumber = "MilestoneNumber"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewReportDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReviewReport.self, forKey: .lensReviewReport)
        lensReviewReport = lensReviewReportDecoded
    }
}

enum GetLensReviewReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLensVersionDifferenceInput {

    static func queryItemProvider(_ value: GetLensVersionDifferenceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let baseLensVersion = value.baseLensVersion {
            let baseLensVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "BaseLensVersion".urlPercentEncoding(), value: Swift.String(baseLensVersion).urlPercentEncoding())
            items.append(baseLensVersionQueryItem)
        }
        if let targetLensVersion = value.targetLensVersion {
            let targetLensVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "TargetLensVersion".urlPercentEncoding(), value: Swift.String(targetLensVersion).urlPercentEncoding())
            items.append(targetLensVersionQueryItem)
        }
        return items
    }
}

extension GetLensVersionDifferenceInput {

    static func urlPathProvider(_ value: GetLensVersionDifferenceInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versionDifference"
    }
}

public struct GetLensVersionDifferenceInput {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to target a difference for.
    public var targetLensVersion: Swift.String?

    public init(
        baseLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.lensAlias = lensAlias
        self.targetLensVersion = targetLensVersion
    }
}

struct GetLensVersionDifferenceInputBody {
}

extension GetLensVersionDifferenceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLensVersionDifferenceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLensVersionDifferenceOutputBody = try responseDecoder.decode(responseBody: data)
            self.baseLensVersion = output.baseLensVersion
            self.latestLensVersion = output.latestLensVersion
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.targetLensVersion = output.targetLensVersion
            self.versionDifferences = output.versionDifferences
        } else {
            self.baseLensVersion = nil
            self.latestLensVersion = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.targetLensVersion = nil
            self.versionDifferences = nil
        }
    }
}

public struct GetLensVersionDifferenceOutput {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The latest version of the lens.
    public var latestLensVersion: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The target lens version for the lens.
    public var targetLensVersion: Swift.String?
    /// The differences between the base and latest versions of the lens.
    public var versionDifferences: WellArchitectedClientTypes.VersionDifferences?

    public init(
        baseLensVersion: Swift.String? = nil,
        latestLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil,
        versionDifferences: WellArchitectedClientTypes.VersionDifferences? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.targetLensVersion = targetLensVersion
        self.versionDifferences = versionDifferences
    }
}

struct GetLensVersionDifferenceOutputBody {
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let baseLensVersion: Swift.String?
    let targetLensVersion: Swift.String?
    let latestLensVersion: Swift.String?
    let versionDifferences: WellArchitectedClientTypes.VersionDifferences?
}

extension GetLensVersionDifferenceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseLensVersion = "BaseLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case targetLensVersion = "TargetLensVersion"
        case versionDifferences = "VersionDifferences"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let baseLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseLensVersion)
        baseLensVersion = baseLensVersionDecoded
        let targetLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLensVersion)
        targetLensVersion = targetLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
        let versionDifferencesDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.VersionDifferences.self, forKey: .versionDifferences)
        versionDifferences = versionDifferencesDecoded
    }
}

enum GetLensVersionDifferenceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMilestoneInput {

    static func urlPathProvider(_ value: GetMilestoneInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let milestoneNumber = value.milestoneNumber else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones/\(milestoneNumber)"
    }
}

/// Input to get a milestone.
public struct GetMilestoneInput {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    /// This member is required.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

struct GetMilestoneInputBody {
}

extension GetMilestoneInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMilestoneOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMilestoneOutputBody = try responseDecoder.decode(responseBody: data)
            self.milestone = output.milestone
            self.workloadId = output.workloadId
        } else {
            self.milestone = nil
            self.workloadId = nil
        }
    }
}

/// Output of a get milestone call.
public struct GetMilestoneOutput {
    /// A milestone return object.
    public var milestone: WellArchitectedClientTypes.Milestone?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestone: WellArchitectedClientTypes.Milestone? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestone = milestone
        self.workloadId = workloadId
    }
}

struct GetMilestoneOutputBody {
    let workloadId: Swift.String?
    let milestone: WellArchitectedClientTypes.Milestone?
}

extension GetMilestoneOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestone = "Milestone"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Milestone.self, forKey: .milestone)
        milestone = milestoneDecoded
    }
}

enum GetMilestoneOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileInput {

    static func queryItemProvider(_ value: GetProfileInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let profileVersion = value.profileVersion {
            let profileVersionQueryItem = ClientRuntime.SDKURLQueryItem(name: "ProfileVersion".urlPercentEncoding(), value: Swift.String(profileVersion).urlPercentEncoding())
            items.append(profileVersionQueryItem)
        }
        return items
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

public struct GetProfileInput {
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The profile version.
    public var profileVersion: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        profileVersion: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.profileVersion = profileVersion
    }
}

struct GetProfileInputBody {
}

extension GetProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutput {
    /// The profile.
    public var profile: WellArchitectedClientTypes.Profile?

    public init(
        profile: WellArchitectedClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputBody {
    let profile: WellArchitectedClientTypes.Profile?
}

extension GetProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum GetProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileTemplateInput {

    static func urlPathProvider(_ value: GetProfileTemplateInput) -> Swift.String? {
        return "/profileTemplate"
    }
}

public struct GetProfileTemplateInput {

    public init() { }
}

struct GetProfileTemplateInputBody {
}

extension GetProfileTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.profileTemplate = output.profileTemplate
        } else {
            self.profileTemplate = nil
        }
    }
}

public struct GetProfileTemplateOutput {
    /// The profile template.
    public var profileTemplate: WellArchitectedClientTypes.ProfileTemplate?

    public init(
        profileTemplate: WellArchitectedClientTypes.ProfileTemplate? = nil
    )
    {
        self.profileTemplate = profileTemplate
    }
}

struct GetProfileTemplateOutputBody {
    let profileTemplate: WellArchitectedClientTypes.ProfileTemplate?
}

extension GetProfileTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileTemplate = "ProfileTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileTemplateDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ProfileTemplate.self, forKey: .profileTemplate)
        profileTemplate = profileTemplateDecoded
    }
}

enum GetProfileTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReviewTemplateAnswerInput {

    static func urlPathProvider(_ value: GetReviewTemplateAnswerInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

public struct GetReviewTemplateAnswerInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        questionId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.questionId = questionId
        self.templateArn = templateArn
    }
}

struct GetReviewTemplateAnswerInputBody {
}

extension GetReviewTemplateAnswerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReviewTemplateAnswerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReviewTemplateAnswerOutputBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.templateArn = output.templateArn
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.templateArn = nil
        }
    }
}

public struct GetReviewTemplateAnswerOutput {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.ReviewTemplateAnswer? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

struct GetReviewTemplateAnswerOutputBody {
    let templateArn: Swift.String?
    let lensAlias: Swift.String?
    let answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
}

extension GetReviewTemplateAnswerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateAnswer.self, forKey: .answer)
        answer = answerDecoded
    }
}

enum GetReviewTemplateAnswerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReviewTemplateInput {

    static func urlPathProvider(_ value: GetReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

public struct GetReviewTemplateInput {
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        templateArn: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
    }
}

struct GetReviewTemplateInputBody {
}

extension GetReviewTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: GetReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

public struct GetReviewTemplateLensReviewInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

struct GetReviewTemplateLensReviewInputBody {
}

extension GetReviewTemplateLensReviewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReviewTemplateLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReviewTemplateLensReviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.templateArn = output.templateArn
        } else {
            self.lensReview = nil
            self.templateArn = nil
        }
    }
}

public struct GetReviewTemplateLensReviewOutput {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.templateArn = templateArn
    }
}

struct GetReviewTemplateLensReviewOutputBody {
    let templateArn: Swift.String?
    let lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
}

extension GetReviewTemplateLensReviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateLensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

enum GetReviewTemplateLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReviewTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReviewTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.reviewTemplate = output.reviewTemplate
        } else {
            self.reviewTemplate = nil
        }
    }
}

public struct GetReviewTemplateOutput {
    /// The review template.
    public var reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?

    public init(
        reviewTemplate: WellArchitectedClientTypes.ReviewTemplate? = nil
    )
    {
        self.reviewTemplate = reviewTemplate
    }
}

struct GetReviewTemplateOutputBody {
    let reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?
}

extension GetReviewTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewTemplate = "ReviewTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewTemplateDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplate.self, forKey: .reviewTemplate)
        reviewTemplate = reviewTemplateDecoded
    }
}

enum GetReviewTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkloadInput {

    static func urlPathProvider(_ value: GetWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input to get a workload.
public struct GetWorkloadInput {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        workloadId: Swift.String? = nil
    )
    {
        self.workloadId = workloadId
    }
}

struct GetWorkloadInputBody {
}

extension GetWorkloadInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of a get workload call.
public struct GetWorkloadOutput {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init(
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct GetWorkloadOutputBody {
    let workload: WellArchitectedClientTypes.Workload?
}

extension GetWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

enum GetWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportLensInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jsonString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let jsonString = self.jsonString {
            try encodeContainer.encode(jsonString, forKey: .jsonString)
        }
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ImportLensInput {

    static func urlPathProvider(_ value: ImportLensInput) -> Swift.String? {
        return "/importLens"
    }
}

public struct ImportLensInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The JSON representation of a lens.
    /// This member is required.
    public var jsonString: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// Tags to associate to a lens.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        jsonString: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.jsonString = jsonString
        self.lensAlias = lensAlias
        self.tags = tags
    }
}

struct ImportLensInputBody {
    let lensAlias: Swift.String?
    let jsonString: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ImportLensInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case jsonString = "JSONString"
        case lensAlias = "LensAlias"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let jsonStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonString)
        jsonString = jsonStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportLensOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportLensOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensArn = output.lensArn
            self.status = output.status
        } else {
            self.lensArn = nil
            self.status = nil
        }
    }
}

public struct ImportLensOutput {
    /// The ARN for the lens that was created or updated.
    public var lensArn: Swift.String?
    /// The status of the imported lens.
    public var status: WellArchitectedClientTypes.ImportLensStatus?

    public init(
        lensArn: Swift.String? = nil,
        status: WellArchitectedClientTypes.ImportLensStatus? = nil
    )
    {
        self.lensArn = lensArn
        self.status = status
    }
}

struct ImportLensOutputBody {
    let lensArn: Swift.String?
    let status: WellArchitectedClientTypes.ImportLensStatus?
}

extension ImportLensOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ImportLensStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum ImportLensOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ImportLensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportLensStatus] {
            return [
                .complete,
                .error,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportLensStatus(rawValue: rawValue) ?? ImportLensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ImprovementSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementPlanUrl = "ImprovementPlanUrl"
        case improvementPlans = "ImprovementPlans"
        case jiraConfiguration = "JiraConfiguration"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case risk = "Risk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementPlanUrl = self.improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let improvementPlans = improvementPlans {
            var improvementPlansContainer = encodeContainer.nestedUnkeyedContainer(forKey: .improvementPlans)
            for choiceimprovementplan0 in improvementPlans {
                try improvementPlansContainer.encode(choiceimprovementplan0)
            }
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let improvementPlansContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceImprovementPlan?].self, forKey: .improvementPlans)
        var improvementPlansDecoded0:[WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil
        if let improvementPlansContainer = improvementPlansContainer {
            improvementPlansDecoded0 = [WellArchitectedClientTypes.ChoiceImprovementPlan]()
            for structure0 in improvementPlansContainer {
                if let structure0 = structure0 {
                    improvementPlansDecoded0?.append(structure0)
                }
            }
        }
        improvementPlans = improvementPlansDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.JiraConfiguration.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An improvement summary of a lens review in a workload.
    public struct ImprovementSummary {
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// The improvement plan details.
        public var improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init(
            improvementPlanUrl: Swift.String? = nil,
            improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.improvementPlanUrl = improvementPlanUrl
            self.improvementPlans = improvementPlans
            self.jiraConfiguration = jiraConfiguration
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.risk = risk
        }
    }

}

extension WellArchitectedClientTypes {
    public enum IntegratingService: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jira
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegratingService] {
            return [
                .jira,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jira: return "JIRA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegratingService(rawValue: rawValue) ?? IntegratingService.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum IntegrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configured
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationStatus] {
            return [
                .configured,
                .notConfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationStatus(rawValue: rawValue) ?? IntegrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum IntegrationStatusInput: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationStatusInput] {
            return [
                .notConfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationStatusInput(rawValue: rawValue) ?? IntegrationStatusInput.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is a problem with the Well-Architected Tool API service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes {
    public enum IssueManagementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [IssueManagementType] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IssueManagementType(rawValue: rawValue) ?? IssueManagementType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.JiraConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jiraIssueUrl = "JiraIssueUrl"
        case lastSyncedTime = "LastSyncedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jiraIssueUrl = self.jiraIssueUrl {
            try encodeContainer.encode(jiraIssueUrl, forKey: .jiraIssueUrl)
        }
        if let lastSyncedTime = self.lastSyncedTime {
            try encodeContainer.encodeTimestamp(lastSyncedTime, format: .epochSeconds, forKey: .lastSyncedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jiraIssueUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jiraIssueUrl)
        jiraIssueUrl = jiraIssueUrlDecoded
        let lastSyncedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastSyncedTime)
        lastSyncedTime = lastSyncedTimeDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Configuration of the Jira integration.
    public struct JiraConfiguration {
        /// The URL of the associated Jira issue.
        public var jiraIssueUrl: Swift.String?
        /// The date and time recorded.
        public var lastSyncedTime: ClientRuntime.Date?

        public init(
            jiraIssueUrl: Swift.String? = nil,
            lastSyncedTime: ClientRuntime.Date? = nil
        )
        {
            self.jiraIssueUrl = jiraIssueUrl
            self.lastSyncedTime = lastSyncedTime
        }
    }

}

extension WellArchitectedClientTypes.JiraSelectedQuestionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedPillars = "SelectedPillars"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedPillars = selectedPillars {
            var selectedPillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedPillars)
            for selectedpillar0 in selectedPillars {
                try selectedPillarsContainer.encode(selectedpillar0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedPillarsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.SelectedPillar?].self, forKey: .selectedPillars)
        var selectedPillarsDecoded0:[WellArchitectedClientTypes.SelectedPillar]? = nil
        if let selectedPillarsContainer = selectedPillarsContainer {
            selectedPillarsDecoded0 = [WellArchitectedClientTypes.SelectedPillar]()
            for structure0 in selectedPillarsContainer {
                if let structure0 = structure0 {
                    selectedPillarsDecoded0?.append(structure0)
                }
            }
        }
        selectedPillars = selectedPillarsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// Selected questions in the workload.
    public struct JiraSelectedQuestionConfiguration {
        /// Selected pillars in the workload.
        public var selectedPillars: [WellArchitectedClientTypes.SelectedPillar]?

        public init(
            selectedPillars: [WellArchitectedClientTypes.SelectedPillar]? = nil
        )
        {
            self.selectedPillars = selectedPillars
        }
    }

}

extension WellArchitectedClientTypes.Lens: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lensArn = "LensArn"
        case lensVersion = "LensVersion"
        case name = "Name"
        case owner = "Owner"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A lens return object.
    public struct Lens {
        /// The description of the lens.
        public var description: Swift.String?
        /// The ARN of a lens.
        public var lensArn: Swift.String?
        /// The version of a lens.
        public var lensVersion: Swift.String?
        /// The full name of the lens.
        public var name: Swift.String?
        /// The Amazon Web Services account ID that owns the lens.
        public var owner: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the lens.
        public var tags: [Swift.String:Swift.String]?

        public init(
            description: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.lensArn = lensArn
            self.lensVersion = lensVersion
            self.name = name
            self.owner = owner
            self.shareInvitationId = shareInvitationId
            self.tags = tags
        }
    }

}

extension WellArchitectedClientTypes.LensMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case pillars = "Pillars"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for pillarmetric0 in pillars {
                try pillarsContainer.encode(pillarmetric0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarMetric?].self, forKey: .pillars)
        var pillarsDecoded0:[WellArchitectedClientTypes.PillarMetric]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [WellArchitectedClientTypes.PillarMetric]()
            for structure0 in pillarsContainer {
                if let structure0 = structure0 {
                    pillarsDecoded0?.append(structure0)
                }
            }
        }
        pillars = pillarsDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A metric for a particular lens in a workload.
    public struct LensMetric {
        /// The lens ARN.
        public var lensArn: Swift.String?
        /// The metrics for the pillars in a lens.
        public var pillars: [WellArchitectedClientTypes.PillarMetric]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?

        public init(
            lensArn: Swift.String? = nil,
            pillars: [WellArchitectedClientTypes.PillarMetric]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.lensArn = lensArn
            self.pillars = pillars
            self.riskCounts = riskCounts
        }
    }

}

extension WellArchitectedClientTypes.LensReview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jiraConfiguration = "JiraConfiguration"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case nextToken = "NextToken"
        case notes = "Notes"
        case pillarReviewSummaries = "PillarReviewSummaries"
        case prioritizedRiskCounts = "PrioritizedRiskCounts"
        case profiles = "Profiles"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = self.lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = self.lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarReviewSummaries = pillarReviewSummaries {
            var pillarReviewSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarReviewSummaries)
            for pillarreviewsummary0 in pillarReviewSummaries {
                try pillarReviewSummariesContainer.encode(pillarreviewsummary0)
            }
        }
        if let prioritizedRiskCounts = prioritizedRiskCounts {
            var prioritizedRiskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .prioritizedRiskCounts)
            for (dictKey0, riskCounts0) in prioritizedRiskCounts {
                try prioritizedRiskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let profiles = profiles {
            var profilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profiles)
            for workloadprofile0 in profiles {
                try profilesContainer.encode(workloadprofile0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let pillarReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarReviewSummary?].self, forKey: .pillarReviewSummaries)
        var pillarReviewSummariesDecoded0:[WellArchitectedClientTypes.PillarReviewSummary]? = nil
        if let pillarReviewSummariesContainer = pillarReviewSummariesContainer {
            pillarReviewSummariesDecoded0 = [WellArchitectedClientTypes.PillarReviewSummary]()
            for structure0 in pillarReviewSummariesContainer {
                if let structure0 = structure0 {
                    pillarReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        pillarReviewSummaries = pillarReviewSummariesDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.JiraSelectedQuestionConfiguration.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let profilesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadProfile?].self, forKey: .profiles)
        var profilesDecoded0:[WellArchitectedClientTypes.WorkloadProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [WellArchitectedClientTypes.WorkloadProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let prioritizedRiskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .prioritizedRiskCounts)
        var prioritizedRiskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let prioritizedRiskCountsContainer = prioritizedRiskCountsContainer {
            prioritizedRiskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in prioritizedRiskCountsContainer {
                if let count0 = count0 {
                    prioritizedRiskCountsDecoded0?[key0] = count0
                }
            }
        }
        prioritizedRiskCounts = prioritizedRiskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A lens review of a question.
    public struct LensReview {
        /// Jira configuration status of the Lens review.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// List of pillar review summaries of lens review in a workload.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String:Swift.Int]?
        /// The profiles associated with the workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]? = nil,
            prioritizedRiskCounts: [Swift.String:Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.jiraConfiguration = jiraConfiguration
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensReviewReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base64String = "Base64String"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base64String = self.base64String {
            try encodeContainer.encode(base64String, forKey: .base64String)
        }
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let base64StringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .base64String)
        base64String = base64StringDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A report of a lens review.
    public struct LensReviewReport {
        /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file. Only returned by [GetConsolidatedReport] when PDF format is requested.
        public var base64String: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?

        public init(
            base64String: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil
        )
        {
            self.base64String = base64String
            self.lensAlias = lensAlias
            self.lensArn = lensArn
        }
    }

}

extension WellArchitectedClientTypes.LensReviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case prioritizedRiskCounts = "PrioritizedRiskCounts"
        case profiles = "Profiles"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = self.lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = self.lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let prioritizedRiskCounts = prioritizedRiskCounts {
            var prioritizedRiskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .prioritizedRiskCounts)
            for (dictKey0, riskCounts0) in prioritizedRiskCounts {
                try prioritizedRiskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let profiles = profiles {
            var profilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profiles)
            for workloadprofile0 in profiles {
                try profilesContainer.encode(workloadprofile0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let profilesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadProfile?].self, forKey: .profiles)
        var profilesDecoded0:[WellArchitectedClientTypes.WorkloadProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [WellArchitectedClientTypes.WorkloadProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let prioritizedRiskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .prioritizedRiskCounts)
        var prioritizedRiskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let prioritizedRiskCountsContainer = prioritizedRiskCountsContainer {
            prioritizedRiskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in prioritizedRiskCountsContainer {
                if let count0 = count0 {
                    prioritizedRiskCountsDecoded0?[key0] = count0
                }
            }
        }
        prioritizedRiskCounts = prioritizedRiskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A lens review summary of a workload.
    public struct LensReviewSummary {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String:Swift.Int]?
        /// The profiles associated with the workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String:Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.LensShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens share summary return object.
    public struct LensShareSummary {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Optional message to compliment the Status field.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case deleted
        case deprecated
        case notCurrent
        case unshared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatus] {
            return [
                .current,
                .deleted,
                .deprecated,
                .notCurrent,
                .unshared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .notCurrent: return "NOT_CURRENT"
            case .unshared: return "UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatus(rawValue: rawValue) ?? LensStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum LensStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatusType] {
            return [
                .all,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensStatusType(rawValue: rawValue) ?? LensStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensType = "LensType"
        case lensVersion = "LensVersion"
        case owner = "Owner"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = self.lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = self.lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensType = self.lensType {
            try encodeContainer.encode(lensType.rawValue, forKey: .lensType)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensType.self, forKey: .lensType)
        lensType = lensTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A lens summary of a lens.
    public struct LensSummary {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// The description of the lens.
        public var description: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN of the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The type of the lens.
        public var lensType: WellArchitectedClientTypes.LensType?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensType: WellArchitectedClientTypes.LensType? = nil,
            lensVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.lensVersion = lensVersion
            self.owner = owner
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes {
    public enum LensType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOfficial
        case customSelf
        case customShared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensType] {
            return [
                .awsOfficial,
                .customSelf,
                .customShared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOfficial: return "AWS_OFFICIAL"
            case .customSelf: return "CUSTOM_SELF"
            case .customShared: return "CUSTOM_SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LensType(rawValue: rawValue) ?? LensType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.LensUpgradeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLensVersion = "CurrentLensVersion"
        case latestLensVersion = "LatestLensVersion"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case resourceArn = "ResourceArn"
        case resourceName = "ResourceName"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLensVersion = self.currentLensVersion {
            try encodeContainer.encode(currentLensVersion, forKey: .currentLensVersion)
        }
        if let latestLensVersion = self.latestLensVersion {
            try encodeContainer.encode(latestLensVersion, forKey: .latestLensVersion)
        }
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let currentLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLensVersion)
        currentLensVersion = currentLensVersionDecoded
        let latestLensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestLensVersion)
        latestLensVersion = latestLensVersionDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Lens upgrade summary return object.
    public struct LensUpgradeSummary {
        /// The current version of the lens.
        public var currentLensVersion: Swift.String?
        /// The latest version of the lens.
        public var latestLensVersion: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// ResourceArn of the lens being upgraded
        public var resourceArn: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var resourceName: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            currentLensVersion: Swift.String? = nil,
            latestLensVersion: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentLensVersion = currentLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension ListAnswersInput {

    static func queryItemProvider(_ value: ListAnswersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let questionPriority = value.questionPriority {
            let questionPriorityQueryItem = ClientRuntime.SDKURLQueryItem(name: "QuestionPriority".urlPercentEncoding(), value: Swift.String(questionPriority.rawValue).urlPercentEncoding())
            items.append(questionPriorityQueryItem)
        }
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListAnswersInput {

    static func urlPathProvider(_ value: ListAnswersInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
    }
}

/// Input to list answers.
public struct ListAnswersInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The priority of the question.
    public var questionPriority: WellArchitectedClientTypes.QuestionPriority?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionPriority: WellArchitectedClientTypes.QuestionPriority? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionPriority = questionPriority
        self.workloadId = workloadId
    }
}

struct ListAnswersInputBody {
}

extension ListAnswersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAnswersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnswersOutputBody = try responseDecoder.decode(responseBody: data)
            self.answerSummaries = output.answerSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.answerSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list answers call.
public struct ListAnswersOutput {
    /// List of answer summaries of lens review in a workload.
    public var answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answerSummaries: [WellArchitectedClientTypes.AnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListAnswersOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    let nextToken: Swift.String?
}

extension ListAnswersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerSummaries = "AnswerSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.AnswerSummary?].self, forKey: .answerSummaries)
        var answerSummariesDecoded0:[WellArchitectedClientTypes.AnswerSummary]? = nil
        if let answerSummariesContainer = answerSummariesContainer {
            answerSummariesDecoded0 = [WellArchitectedClientTypes.AnswerSummary]()
            for structure0 in answerSummariesContainer {
                if let structure0 = structure0 {
                    answerSummariesDecoded0?.append(structure0)
                }
            }
        }
        answerSummaries = answerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAnswersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCheckDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case lensArn = "LensArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
    }
}

extension ListCheckDetailsInput {

    static func urlPathProvider(_ value: ListCheckDetailsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/checks"
    }
}

public struct ListCheckDetailsInput {
    /// The ID of a choice.
    /// This member is required.
    public var choiceId: Swift.String?
    /// Well-Architected Lens ARN.
    /// This member is required.
    public var lensArn: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    /// This member is required.
    public var pillarId: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceId: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceId = choiceId
        self.lensArn = lensArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct ListCheckDetailsInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let lensArn: Swift.String?
    let pillarId: Swift.String?
    let questionId: Swift.String?
    let choiceId: Swift.String?
}

extension ListCheckDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case lensArn = "LensArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
    }
}

extension ListCheckDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCheckDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkDetails = output.checkDetails
            self.nextToken = output.nextToken
        } else {
            self.checkDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListCheckDetailsOutput {
    /// The details about the Trusted Advisor checks related to the Well-Architected best practice.
    public var checkDetails: [WellArchitectedClientTypes.CheckDetail]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkDetails: [WellArchitectedClientTypes.CheckDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkDetails = checkDetails
        self.nextToken = nextToken
    }
}

struct ListCheckDetailsOutputBody {
    let checkDetails: [WellArchitectedClientTypes.CheckDetail]?
    let nextToken: Swift.String?
}

extension ListCheckDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkDetails = "CheckDetails"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkDetailsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.CheckDetail?].self, forKey: .checkDetails)
        var checkDetailsDecoded0:[WellArchitectedClientTypes.CheckDetail]? = nil
        if let checkDetailsContainer = checkDetailsContainer {
            checkDetailsDecoded0 = [WellArchitectedClientTypes.CheckDetail]()
            for structure0 in checkDetailsContainer {
                if let structure0 = structure0 {
                    checkDetailsDecoded0?.append(structure0)
                }
            }
        }
        checkDetails = checkDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCheckDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCheckSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case lensArn = "LensArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
    }
}

extension ListCheckSummariesInput {

    static func urlPathProvider(_ value: ListCheckSummariesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/checkSummaries"
    }
}

public struct ListCheckSummariesInput {
    /// The ID of a choice.
    /// This member is required.
    public var choiceId: Swift.String?
    /// Well-Architected Lens ARN.
    /// This member is required.
    public var lensArn: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    /// This member is required.
    public var pillarId: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceId: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceId = choiceId
        self.lensArn = lensArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

struct ListCheckSummariesInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let lensArn: Swift.String?
    let pillarId: Swift.String?
    let questionId: Swift.String?
    let choiceId: Swift.String?
}

extension ListCheckSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceId = "ChoiceId"
        case lensArn = "LensArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
    }
}

extension ListCheckSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCheckSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkSummaries = output.checkSummaries
            self.nextToken = output.nextToken
        } else {
            self.checkSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCheckSummariesOutput {
    /// List of Trusted Advisor summaries related to the Well-Architected best practice.
    public var checkSummaries: [WellArchitectedClientTypes.CheckSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkSummaries: [WellArchitectedClientTypes.CheckSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkSummaries = checkSummaries
        self.nextToken = nextToken
    }
}

struct ListCheckSummariesOutputBody {
    let checkSummaries: [WellArchitectedClientTypes.CheckSummary]?
    let nextToken: Swift.String?
}

extension ListCheckSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkSummaries = "CheckSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.CheckSummary?].self, forKey: .checkSummaries)
        var checkSummariesDecoded0:[WellArchitectedClientTypes.CheckSummary]? = nil
        if let checkSummariesContainer = checkSummariesContainer {
            checkSummariesDecoded0 = [WellArchitectedClientTypes.CheckSummary]()
            for structure0 in checkSummariesContainer {
                if let structure0 = structure0 {
                    checkSummariesDecoded0?.append(structure0)
                }
            }
        }
        checkSummaries = checkSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCheckSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLensReviewImprovementsInput {

    static func queryItemProvider(_ value: ListLensReviewImprovementsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let questionPriority = value.questionPriority {
            let questionPriorityQueryItem = ClientRuntime.SDKURLQueryItem(name: "QuestionPriority".urlPercentEncoding(), value: Swift.String(questionPriority.rawValue).urlPercentEncoding())
            items.append(questionPriorityQueryItem)
        }
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensReviewImprovementsInput {

    static func urlPathProvider(_ value: ListLensReviewImprovementsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/improvements"
    }
}

/// Input to list lens review improvements.
public struct ListLensReviewImprovementsInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The priority of the question.
    public var questionPriority: WellArchitectedClientTypes.QuestionPriority?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionPriority: WellArchitectedClientTypes.QuestionPriority? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionPriority = questionPriority
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsInputBody {
}

extension ListLensReviewImprovementsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewImprovementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLensReviewImprovementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.improvementSummaries = output.improvementSummaries
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.improvementSummaries = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.milestoneNumber = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens review improvements call.
public struct ListLensReviewImprovementsOutput {
    /// List of improvement summaries of lens review in a workload.
    public var improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.improvementSummaries = improvementSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewImprovementsOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    let nextToken: Swift.String?
}

extension ListLensReviewImprovementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementSummaries = "ImprovementSummaries"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let improvementSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ImprovementSummary?].self, forKey: .improvementSummaries)
        var improvementSummariesDecoded0:[WellArchitectedClientTypes.ImprovementSummary]? = nil
        if let improvementSummariesContainer = improvementSummariesContainer {
            improvementSummariesDecoded0 = [WellArchitectedClientTypes.ImprovementSummary]()
            for structure0 in improvementSummariesContainer {
                if let structure0 = structure0 {
                    improvementSummariesDecoded0?.append(structure0)
                }
            }
        }
        improvementSummaries = improvementSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLensReviewImprovementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLensReviewsInput {

    static func queryItemProvider(_ value: ListLensReviewsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = ClientRuntime.SDKURLQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensReviewsInput {

    static func urlPathProvider(_ value: ListLensReviewsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews"
    }
}

/// Input to list lens reviews.
public struct ListLensReviewsInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsInputBody {
}

extension ListLensReviewsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLensReviewsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLensReviewsOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReviewSummaries = output.lensReviewSummaries
            self.milestoneNumber = output.milestoneNumber
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.lensReviewSummaries = nil
            self.milestoneNumber = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list lens reviews call.
public struct ListLensReviewsOutput {
    /// List of lens summaries of lens reviews of a workload.
    public var lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewSummaries = lensReviewSummaries
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListLensReviewsOutputBody {
    let workloadId: Swift.String?
    let milestoneNumber: Swift.Int?
    let lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    let nextToken: Swift.String?
}

extension ListLensReviewsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReviewSummaries = "LensReviewSummaries"
        case milestoneNumber = "MilestoneNumber"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let lensReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensReviewSummary?].self, forKey: .lensReviewSummaries)
        var lensReviewSummariesDecoded0:[WellArchitectedClientTypes.LensReviewSummary]? = nil
        if let lensReviewSummariesContainer = lensReviewSummariesContainer {
            lensReviewSummariesDecoded0 = [WellArchitectedClientTypes.LensReviewSummary]()
            for structure0 in lensReviewSummariesContainer {
                if let structure0 = structure0 {
                    lensReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensReviewSummaries = lensReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLensReviewsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLensSharesInput {

    static func queryItemProvider(_ value: ListLensSharesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLensSharesInput {

    static func urlPathProvider(_ value: ListLensSharesInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

public struct ListLensSharesInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the lens is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
    }
}

struct ListLensSharesInputBody {
}

extension ListLensSharesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLensSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLensSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensShareSummaries = output.lensShareSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensShareSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLensSharesOutput {
    /// A list of lens share summaries.
    public var lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensShareSummaries = lensShareSummaries
        self.nextToken = nextToken
    }
}

struct ListLensSharesOutputBody {
    let lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    let nextToken: Swift.String?
}

extension ListLensSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensShareSummaries = "LensShareSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensShareSummary?].self, forKey: .lensShareSummaries)
        var lensShareSummariesDecoded0:[WellArchitectedClientTypes.LensShareSummary]? = nil
        if let lensShareSummariesContainer = lensShareSummariesContainer {
            lensShareSummariesDecoded0 = [WellArchitectedClientTypes.LensShareSummary]()
            for structure0 in lensShareSummariesContainer {
                if let structure0 = structure0 {
                    lensShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensShareSummaries = lensShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLensSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLensesInput {

    static func queryItemProvider(_ value: ListLensesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let lensName = value.lensName {
            let lensNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensName".urlPercentEncoding(), value: Swift.String(lensName).urlPercentEncoding())
            items.append(lensNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let lensType = value.lensType {
            let lensTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensType".urlPercentEncoding(), value: Swift.String(lensType.rawValue).urlPercentEncoding())
            items.append(lensTypeQueryItem)
        }
        if let lensStatus = value.lensStatus {
            let lensStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            items.append(lensStatusQueryItem)
        }
        return items
    }
}

extension ListLensesInput {

    static func urlPathProvider(_ value: ListLensesInput) -> Swift.String? {
        return "/lenses"
    }
}

/// Input to list lenses.
public struct ListLensesInput {
    /// The full name of the lens.
    public var lensName: Swift.String?
    /// The status of lenses to be returned.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?
    /// The type of lenses to be returned.
    public var lensType: WellArchitectedClientTypes.LensType?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensName: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil,
        lensType: WellArchitectedClientTypes.LensType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensType = lensType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLensesInputBody {
}

extension ListLensesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLensesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLensesOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensSummaries = output.lensSummaries
            self.nextToken = output.nextToken
        } else {
            self.lensSummaries = nil
            self.nextToken = nil
        }
    }
}

/// Output of a list lenses call.
public struct ListLensesOutput {
    /// List of lens summaries of available lenses.
    public var lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensSummaries: [WellArchitectedClientTypes.LensSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensSummaries = lensSummaries
        self.nextToken = nextToken
    }
}

struct ListLensesOutputBody {
    let lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    let nextToken: Swift.String?
}

extension ListLensesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensSummaries = "LensSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.LensSummary?].self, forKey: .lensSummaries)
        var lensSummariesDecoded0:[WellArchitectedClientTypes.LensSummary]? = nil
        if let lensSummariesContainer = lensSummariesContainer {
            lensSummariesDecoded0 = [WellArchitectedClientTypes.LensSummary]()
            for structure0 in lensSummariesContainer {
                if let structure0 = structure0 {
                    lensSummariesDecoded0?.append(structure0)
                }
            }
        }
        lensSummaries = lensSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLensesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMilestonesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListMilestonesInput {

    static func urlPathProvider(_ value: ListMilestonesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestonesSummaries"
    }
}

/// Input to list all milestones for a workload.
public struct ListMilestonesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesInputBody {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListMilestonesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMilestonesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMilestonesOutputBody = try responseDecoder.decode(responseBody: data)
            self.milestoneSummaries = output.milestoneSummaries
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
        } else {
            self.milestoneSummaries = nil
            self.nextToken = nil
            self.workloadId = nil
        }
    }
}

/// Output of a list milestones call.
public struct ListMilestonesOutput {
    /// A list of milestone summaries.
    public var milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneSummaries = milestoneSummaries
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListMilestonesOutputBody {
    let workloadId: Swift.String?
    let milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    let nextToken: Swift.String?
}

extension ListMilestonesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneSummaries = "MilestoneSummaries"
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let milestoneSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.MilestoneSummary?].self, forKey: .milestoneSummaries)
        var milestoneSummariesDecoded0:[WellArchitectedClientTypes.MilestoneSummary]? = nil
        if let milestoneSummariesContainer = milestoneSummariesContainer {
            milestoneSummariesDecoded0 = [WellArchitectedClientTypes.MilestoneSummary]()
            for structure0 in milestoneSummariesContainer {
                if let structure0 = structure0 {
                    milestoneSummariesDecoded0?.append(structure0)
                }
            }
        }
        milestoneSummaries = milestoneSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMilestonesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNotificationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }
}

extension ListNotificationsInput {

    static func urlPathProvider(_ value: ListNotificationsInput) -> Swift.String? {
        return "/notifications"
    }
}

public struct ListNotificationsInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ARN for the related resource for the notification. Only one of WorkloadID or ResourceARN should be specified.
    public var resourceArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.workloadId = workloadId
    }
}

struct ListNotificationsInputBody {
    let workloadId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceArn: Swift.String?
}

extension ListNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNotificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notificationSummaries = output.notificationSummaries
        } else {
            self.nextToken = nil
            self.notificationSummaries = nil
        }
    }
}

public struct ListNotificationsOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of lens notification summaries in a workload.
    public var notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

struct ListNotificationsOutputBody {
    let notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?
    let nextToken: Swift.String?
}

extension ListNotificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notificationSummaries = "NotificationSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.NotificationSummary?].self, forKey: .notificationSummaries)
        var notificationSummariesDecoded0:[WellArchitectedClientTypes.NotificationSummary]? = nil
        if let notificationSummariesContainer = notificationSummariesContainer {
            notificationSummariesDecoded0 = [WellArchitectedClientTypes.NotificationSummary]()
            for structure0 in notificationSummariesContainer {
                if let structure0 = structure0 {
                    notificationSummariesDecoded0?.append(structure0)
                }
            }
        }
        notificationSummaries = notificationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfileNotificationsInput {

    static func queryItemProvider(_ value: ListProfileNotificationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let workloadId = value.workloadId {
            let workloadIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "WorkloadId".urlPercentEncoding(), value: Swift.String(workloadId).urlPercentEncoding())
            items.append(workloadIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileNotificationsInput {

    static func urlPathProvider(_ value: ListProfileNotificationsInput) -> Swift.String? {
        return "/profileNotifications"
    }
}

public struct ListProfileNotificationsInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

struct ListProfileNotificationsInputBody {
}

extension ListProfileNotificationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileNotificationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileNotificationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notificationSummaries = output.notificationSummaries
        } else {
            self.nextToken = nil
            self.notificationSummaries = nil
        }
    }
}

public struct ListProfileNotificationsOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Notification summaries.
    public var notificationSummaries: [WellArchitectedClientTypes.ProfileNotificationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.ProfileNotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

struct ListProfileNotificationsOutputBody {
    let notificationSummaries: [WellArchitectedClientTypes.ProfileNotificationSummary]?
    let nextToken: Swift.String?
}

extension ListProfileNotificationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notificationSummaries = "NotificationSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileNotificationSummary?].self, forKey: .notificationSummaries)
        var notificationSummariesDecoded0:[WellArchitectedClientTypes.ProfileNotificationSummary]? = nil
        if let notificationSummariesContainer = notificationSummariesContainer {
            notificationSummariesDecoded0 = [WellArchitectedClientTypes.ProfileNotificationSummary]()
            for structure0 in notificationSummariesContainer {
                if let structure0 = structure0 {
                    notificationSummariesDecoded0?.append(structure0)
                }
            }
        }
        notificationSummaries = notificationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileNotificationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfileSharesInput {

    static func queryItemProvider(_ value: ListProfileSharesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfileSharesInput {

    static func urlPathProvider(_ value: ListProfileSharesInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares"
    }
}

public struct ListProfileSharesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileArn = profileArn
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
    }
}

struct ListProfileSharesInputBody {
}

extension ListProfileSharesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profileShareSummaries = output.profileShareSummaries
        } else {
            self.nextToken = nil
            self.profileShareSummaries = nil
        }
    }
}

public struct ListProfileSharesOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Profile share summaries.
    public var profileShareSummaries: [WellArchitectedClientTypes.ProfileShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profileShareSummaries: [WellArchitectedClientTypes.ProfileShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileShareSummaries = profileShareSummaries
    }
}

struct ListProfileSharesOutputBody {
    let profileShareSummaries: [WellArchitectedClientTypes.ProfileShareSummary]?
    let nextToken: Swift.String?
}

extension ListProfileSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profileShareSummaries = "ProfileShareSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileShareSummary?].self, forKey: .profileShareSummaries)
        var profileShareSummariesDecoded0:[WellArchitectedClientTypes.ProfileShareSummary]? = nil
        if let profileShareSummariesContainer = profileShareSummariesContainer {
            profileShareSummariesDecoded0 = [WellArchitectedClientTypes.ProfileShareSummary]()
            for structure0 in profileShareSummariesContainer {
                if let structure0 = structure0 {
                    profileShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        profileShareSummaries = profileShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let profileNamePrefix = value.profileNamePrefix {
            let profileNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "ProfileNamePrefix".urlPercentEncoding(), value: Swift.String(profileNamePrefix).urlPercentEncoding())
            items.append(profileNamePrefixQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let profileOwnerType = value.profileOwnerType {
            let profileOwnerTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "ProfileOwnerType".urlPercentEncoding(), value: Swift.String(profileOwnerType.rawValue).urlPercentEncoding())
            items.append(profileOwnerTypeQueryItem)
        }
        return items
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/profileSummaries"
    }
}

public struct ListProfilesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each profile name returned in the results.
    public var profileNamePrefix: Swift.String?
    /// Profile owner type.
    public var profileOwnerType: WellArchitectedClientTypes.ProfileOwnerType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileNamePrefix: Swift.String? = nil,
        profileOwnerType: WellArchitectedClientTypes.ProfileOwnerType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileNamePrefix = profileNamePrefix
        self.profileOwnerType = profileOwnerType
    }
}

struct ListProfilesInputBody {
}

extension ListProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profileSummaries = output.profileSummaries
        } else {
            self.nextToken = nil
            self.profileSummaries = nil
        }
    }
}

public struct ListProfilesOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Profile summaries.
    public var profileSummaries: [WellArchitectedClientTypes.ProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profileSummaries: [WellArchitectedClientTypes.ProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileSummaries = profileSummaries
    }
}

struct ListProfilesOutputBody {
    let profileSummaries: [WellArchitectedClientTypes.ProfileSummary]?
    let nextToken: Swift.String?
}

extension ListProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profileSummaries = "ProfileSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileSummary?].self, forKey: .profileSummaries)
        var profileSummariesDecoded0:[WellArchitectedClientTypes.ProfileSummary]? = nil
        if let profileSummariesContainer = profileSummariesContainer {
            profileSummariesDecoded0 = [WellArchitectedClientTypes.ProfileSummary]()
            for structure0 in profileSummariesContainer {
                if let structure0 = structure0 {
                    profileSummariesDecoded0?.append(structure0)
                }
            }
        }
        profileSummaries = profileSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReviewTemplateAnswersInput {

    static func queryItemProvider(_ value: ListReviewTemplateAnswersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReviewTemplateAnswersInput {

    static func urlPathProvider(_ value: ListReviewTemplateAnswersInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
    }
}

public struct ListReviewTemplateAnswersInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ARN of the review template.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.templateArn = templateArn
    }
}

struct ListReviewTemplateAnswersInputBody {
}

extension ListReviewTemplateAnswersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReviewTemplateAnswersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReviewTemplateAnswersOutputBody = try responseDecoder.decode(responseBody: data)
            self.answerSummaries = output.answerSummaries
            self.lensAlias = output.lensAlias
            self.nextToken = output.nextToken
            self.templateArn = output.templateArn
        } else {
            self.answerSummaries = nil
            self.lensAlias = nil
            self.nextToken = nil
            self.templateArn = nil
        }
    }
}

public struct ListReviewTemplateAnswersOutput {
    /// List of answer summaries of a lens review in a review template.
    public var answerSummaries: [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ARN of the review template.
    public var templateArn: Swift.String?

    public init(
        answerSummaries: [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.nextToken = nextToken
        self.templateArn = templateArn
    }
}

struct ListReviewTemplateAnswersOutputBody {
    let templateArn: Swift.String?
    let lensAlias: Swift.String?
    let answerSummaries: [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]?
    let nextToken: Swift.String?
}

extension ListReviewTemplateAnswersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerSummaries = "AnswerSummaries"
        case lensAlias = "LensAlias"
        case nextToken = "NextToken"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ReviewTemplateAnswerSummary?].self, forKey: .answerSummaries)
        var answerSummariesDecoded0:[WellArchitectedClientTypes.ReviewTemplateAnswerSummary]? = nil
        if let answerSummariesContainer = answerSummariesContainer {
            answerSummariesDecoded0 = [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]()
            for structure0 in answerSummariesContainer {
                if let structure0 = structure0 {
                    answerSummariesDecoded0?.append(structure0)
                }
            }
        }
        answerSummaries = answerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReviewTemplateAnswersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReviewTemplatesInput {

    static func queryItemProvider(_ value: ListReviewTemplatesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReviewTemplatesInput {

    static func urlPathProvider(_ value: ListReviewTemplatesInput) -> Swift.String? {
        return "/reviewTemplates"
    }
}

public struct ListReviewTemplatesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReviewTemplatesInputBody {
}

extension ListReviewTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReviewTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReviewTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reviewTemplates = output.reviewTemplates
        } else {
            self.nextToken = nil
            self.reviewTemplates = nil
        }
    }
}

public struct ListReviewTemplatesOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of review templates.
    public var reviewTemplates: [WellArchitectedClientTypes.ReviewTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        reviewTemplates: [WellArchitectedClientTypes.ReviewTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reviewTemplates = reviewTemplates
    }
}

struct ListReviewTemplatesOutputBody {
    let reviewTemplates: [WellArchitectedClientTypes.ReviewTemplateSummary]?
    let nextToken: Swift.String?
}

extension ListReviewTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reviewTemplates = "ReviewTemplates"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewTemplatesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ReviewTemplateSummary?].self, forKey: .reviewTemplates)
        var reviewTemplatesDecoded0:[WellArchitectedClientTypes.ReviewTemplateSummary]? = nil
        if let reviewTemplatesContainer = reviewTemplatesContainer {
            reviewTemplatesDecoded0 = [WellArchitectedClientTypes.ReviewTemplateSummary]()
            for structure0 in reviewTemplatesContainer {
                if let structure0 = structure0 {
                    reviewTemplatesDecoded0?.append(structure0)
                }
            }
        }
        reviewTemplates = reviewTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReviewTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListShareInvitationsInput {

    static func queryItemProvider(_ value: ListShareInvitationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let lensNamePrefix = value.lensNamePrefix {
            let lensNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "LensNamePrefix".urlPercentEncoding(), value: Swift.String(lensNamePrefix).urlPercentEncoding())
            items.append(lensNamePrefixQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let profileNamePrefix = value.profileNamePrefix {
            let profileNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "ProfileNamePrefix".urlPercentEncoding(), value: Swift.String(profileNamePrefix).urlPercentEncoding())
            items.append(profileNamePrefixQueryItem)
        }
        if let shareResourceType = value.shareResourceType {
            let shareResourceTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "ShareResourceType".urlPercentEncoding(), value: Swift.String(shareResourceType.rawValue).urlPercentEncoding())
            items.append(shareResourceTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let workloadNamePrefix = value.workloadNamePrefix {
            let workloadNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "WorkloadNamePrefix".urlPercentEncoding(), value: Swift.String(workloadNamePrefix).urlPercentEncoding())
            items.append(workloadNamePrefixQueryItem)
        }
        if let templateNamePrefix = value.templateNamePrefix {
            let templateNamePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "TemplateNamePrefix".urlPercentEncoding(), value: Swift.String(templateNamePrefix).urlPercentEncoding())
            items.append(templateNamePrefixQueryItem)
        }
        return items
    }
}

extension ListShareInvitationsInput {

    static func urlPathProvider(_ value: ListShareInvitationsInput) -> Swift.String? {
        return "/shareInvitations"
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsInput {
    /// An optional string added to the beginning of each lens name returned in the results.
    public var lensNamePrefix: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each profile name returned in the results.
    public var profileNamePrefix: Swift.String?
    /// The type of share invitations to be returned.
    public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
    /// An optional string added to the beginning of each review template name returned in the results.
    public var templateNamePrefix: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init(
        lensNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileNamePrefix: Swift.String? = nil,
        shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
        templateNamePrefix: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.lensNamePrefix = lensNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileNamePrefix = profileNamePrefix
        self.shareResourceType = shareResourceType
        self.templateNamePrefix = templateNamePrefix
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListShareInvitationsInputBody {
}

extension ListShareInvitationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListShareInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListShareInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.shareInvitationSummaries = output.shareInvitationSummaries
        } else {
            self.nextToken = nil
            self.shareInvitationSummaries = nil
        }
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of share invitation summaries in a workload.
    public var shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.shareInvitationSummaries = shareInvitationSummaries
    }
}

struct ListShareInvitationsOutputBody {
    let shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?
    let nextToken: Swift.String?
}

extension ListShareInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case shareInvitationSummaries = "ShareInvitationSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ShareInvitationSummary?].self, forKey: .shareInvitationSummaries)
        var shareInvitationSummariesDecoded0:[WellArchitectedClientTypes.ShareInvitationSummary]? = nil
        if let shareInvitationSummariesContainer = shareInvitationSummariesContainer {
            shareInvitationSummariesDecoded0 = [WellArchitectedClientTypes.ShareInvitationSummary]()
            for structure0 in shareInvitationSummariesContainer {
                if let structure0 = structure0 {
                    shareInvitationSummariesDecoded0?.append(structure0)
                }
            }
        }
        shareInvitationSummaries = shareInvitationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListShareInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        workloadArn: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplateSharesInput {

    static func queryItemProvider(_ value: ListTemplateSharesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplateSharesInput {

    static func urlPathProvider(_ value: ListTemplateSharesInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())"
    }
}

public struct ListTemplateSharesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
        self.templateArn = templateArn
    }
}

struct ListTemplateSharesInputBody {
}

extension ListTemplateSharesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplateSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplateSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templateArn = output.templateArn
            self.templateShareSummaries = output.templateShareSummaries
        } else {
            self.nextToken = nil
            self.templateArn = nil
            self.templateShareSummaries = nil
        }
    }
}

public struct ListTemplateSharesOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?
    /// A review template share summary return object.
    public var templateShareSummaries: [WellArchitectedClientTypes.TemplateShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateShareSummaries: [WellArchitectedClientTypes.TemplateShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateArn = templateArn
        self.templateShareSummaries = templateShareSummaries
    }
}

struct ListTemplateSharesOutputBody {
    let templateArn: Swift.String?
    let templateShareSummaries: [WellArchitectedClientTypes.TemplateShareSummary]?
    let nextToken: Swift.String?
}

extension ListTemplateSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case templateArn = "TemplateArn"
        case templateShareSummaries = "TemplateShareSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.TemplateShareSummary?].self, forKey: .templateShareSummaries)
        var templateShareSummariesDecoded0:[WellArchitectedClientTypes.TemplateShareSummary]? = nil
        if let templateShareSummariesContainer = templateShareSummariesContainer {
            templateShareSummariesDecoded0 = [WellArchitectedClientTypes.TemplateShareSummary]()
            for structure0 in templateShareSummariesContainer {
                if let structure0 = structure0 {
                    templateShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        templateShareSummaries = templateShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTemplateSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkloadSharesInput {

    static func queryItemProvider(_ value: ListWorkloadSharesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkloadSharesInput {

    static func urlPathProvider(_ value: ListWorkloadSharesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
        self.workloadId = workloadId
    }
}

struct ListWorkloadSharesInputBody {
}

extension ListWorkloadSharesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkloadSharesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkloadSharesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadId = output.workloadId
            self.workloadShareSummaries = output.workloadShareSummaries
        } else {
            self.nextToken = nil
            self.workloadId = nil
            self.workloadShareSummaries = nil
        }
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A list of workload share summaries.
    public var workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadId = workloadId
        self.workloadShareSummaries = workloadShareSummaries
    }
}

struct ListWorkloadSharesOutputBody {
    let workloadId: Swift.String?
    let workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadSharesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadId = "WorkloadId"
        case workloadShareSummaries = "WorkloadShareSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadShareSummary?].self, forKey: .workloadShareSummaries)
        var workloadShareSummariesDecoded0:[WellArchitectedClientTypes.WorkloadShareSummary]? = nil
        if let workloadShareSummariesContainer = workloadShareSummariesContainer {
            workloadShareSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadShareSummary]()
            for structure0 in workloadShareSummariesContainer {
                if let structure0 = structure0 {
                    workloadShareSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadShareSummaries = workloadShareSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkloadSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkloadsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadNamePrefix = self.workloadNamePrefix {
            try encodeContainer.encode(workloadNamePrefix, forKey: .workloadNamePrefix)
        }
    }
}

extension ListWorkloadsInput {

    static func urlPathProvider(_ value: ListWorkloadsInput) -> Swift.String? {
        return "/workloadsSummaries"
    }
}

/// Input to list all workloads.
public struct ListWorkloadsInput {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

struct ListWorkloadsInputBody {
    let workloadNamePrefix: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListWorkloadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workloadNamePrefix = "WorkloadNamePrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadNamePrefix)
        workloadNamePrefix = workloadNamePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkloadsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkloadsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadSummaries = output.workloadSummaries
        } else {
            self.nextToken = nil
            self.workloadSummaries = nil
        }
    }
}

/// Output of a list workloads call.
public struct ListWorkloadsOutput {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of workload summaries.
    public var workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadSummaries = workloadSummaries
    }
}

struct ListWorkloadsOutputBody {
    let workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case workloadSummaries = "WorkloadSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadSummary?].self, forKey: .workloadSummaries)
        var workloadSummariesDecoded0:[WellArchitectedClientTypes.WorkloadSummary]? = nil
        if let workloadSummariesContainer = workloadSummariesContainer {
            workloadSummariesDecoded0 = [WellArchitectedClientTypes.WorkloadSummary]()
            for structure0 in workloadSummariesContainer {
                if let structure0 = structure0 {
                    workloadSummariesDecoded0?.append(structure0)
                }
            }
        }
        workloadSummaries = workloadSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkloadsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum MetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricType] {
            return [
                .workload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricType(rawValue: rawValue) ?? MetricType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.Milestone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workload = "Workload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = self.milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if let milestoneNumber = self.milestoneNumber {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = self.recordedAt {
            try encodeContainer.encodeTimestamp(recordedAt, format: .epochSeconds, forKey: .recordedAt)
        }
        if let workload = self.workload {
            try encodeContainer.encode(workload, forKey: .workload)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A milestone return object.
    public struct Milestone {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int?
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload return object.
        public var workload: WellArchitectedClientTypes.Workload?

        public init(
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int? = nil,
            recordedAt: ClientRuntime.Date? = nil,
            workload: WellArchitectedClientTypes.Workload? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workload = workload
        }
    }

}

extension WellArchitectedClientTypes.MilestoneSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case milestoneName = "MilestoneName"
        case milestoneNumber = "MilestoneNumber"
        case recordedAt = "RecordedAt"
        case workloadSummary = "WorkloadSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let milestoneName = self.milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
        if let milestoneNumber = self.milestoneNumber {
            try encodeContainer.encode(milestoneNumber, forKey: .milestoneNumber)
        }
        if let recordedAt = self.recordedAt {
            try encodeContainer.encodeTimestamp(recordedAt, format: .epochSeconds, forKey: .recordedAt)
        }
        if let workloadSummary = self.workloadSummary {
            try encodeContainer.encode(workloadSummary, forKey: .workloadSummary)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .milestoneNumber)
        milestoneNumber = milestoneNumberDecoded
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let recordedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .recordedAt)
        recordedAt = recordedAtDecoded
        let workloadSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadSummary.self, forKey: .workloadSummary)
        workloadSummary = workloadSummaryDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A milestone summary return object.
    public struct MilestoneSummary {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int?
        /// The date and time recorded.
        public var recordedAt: ClientRuntime.Date?
        /// A workload summary return object.
        public var workloadSummary: WellArchitectedClientTypes.WorkloadSummary?

        public init(
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int? = nil,
            recordedAt: ClientRuntime.Date? = nil,
            workloadSummary: WellArchitectedClientTypes.WorkloadSummary? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workloadSummary = workloadSummary
        }
    }

}

extension WellArchitectedClientTypes.NotificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensUpgradeSummary = "LensUpgradeSummary"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensUpgradeSummary = self.lensUpgradeSummary {
            try encodeContainer.encode(lensUpgradeSummary, forKey: .lensUpgradeSummary)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.NotificationType.self, forKey: .type)
        type = typeDecoded
        let lensUpgradeSummaryDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensUpgradeSummary.self, forKey: .lensUpgradeSummary)
        lensUpgradeSummary = lensUpgradeSummaryDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A notification summary return object.
    public struct NotificationSummary {
        /// Summary of lens upgrade.
        public var lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary?
        /// The type of notification.
        public var type: WellArchitectedClientTypes.NotificationType?

        public init(
            lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary? = nil,
            type: WellArchitectedClientTypes.NotificationType? = nil
        )
        {
            self.lensUpgradeSummary = lensUpgradeSummary
            self.type = type
        }
    }

}

extension WellArchitectedClientTypes {
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lensVersionDeprecated
        case lensVersionUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .lensVersionDeprecated,
                .lensVersionUpgraded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lensVersionDeprecated: return "LENS_VERSION_DEPRECATED"
            case .lensVersionUpgraded: return "LENS_VERSION_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum OrganizationSharingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationSharingStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationSharingStatus(rawValue: rawValue) ?? OrganizationSharingStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// Permission granted on a share request.
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .contributor,
                .readonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.PillarDifference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case questionDifferences = "QuestionDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = self.differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = self.pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let questionDifferences = questionDifferences {
            var questionDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionDifferences)
            for questiondifference0 in questionDifferences {
                try questionDifferencesContainer.encode(questiondifference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
        let questionDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.QuestionDifference?].self, forKey: .questionDifferences)
        var questionDifferencesDecoded0:[WellArchitectedClientTypes.QuestionDifference]? = nil
        if let questionDifferencesContainer = questionDifferencesContainer {
            questionDifferencesDecoded0 = [WellArchitectedClientTypes.QuestionDifference]()
            for structure0 in questionDifferencesContainer {
                if let structure0 = structure0 {
                    questionDifferencesDecoded0?.append(structure0)
                }
            }
        }
        questionDifferences = questionDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A pillar difference return object.
    public struct PillarDifference {
        /// Indicates the type of change to the pillar.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// List of question differences.
        public var questionDifferences: [WellArchitectedClientTypes.QuestionDifference]?

        public init(
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionDifferences: [WellArchitectedClientTypes.QuestionDifference]? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionDifferences = questionDifferences
        }
    }

}

extension WellArchitectedClientTypes.PillarMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pillarId = "PillarId"
        case questions = "Questions"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questions = questions {
            var questionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questions)
            for questionmetric0 in questions {
                try questionsContainer.encode(questionmetric0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let questionsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.QuestionMetric?].self, forKey: .questions)
        var questionsDecoded0:[WellArchitectedClientTypes.QuestionMetric]? = nil
        if let questionsContainer = questionsContainer {
            questionsDecoded0 = [WellArchitectedClientTypes.QuestionMetric]()
            for structure0 in questionsContainer {
                if let structure0 = structure0 {
                    questionsDecoded0?.append(structure0)
                }
            }
        }
        questions = questionsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A metric for a particular pillar in a lens.
    public struct PillarMetric {
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The questions that have been identified as risks in the pillar.
        public var questions: [WellArchitectedClientTypes.QuestionMetric]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?

        public init(
            pillarId: Swift.String? = nil,
            questions: [WellArchitectedClientTypes.QuestionMetric]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.pillarId = pillarId
            self.questions = questions
            self.riskCounts = riskCounts
        }
    }

}

extension WellArchitectedClientTypes.PillarReviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case prioritizedRiskCounts = "PrioritizedRiskCounts"
        case riskCounts = "RiskCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = self.pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let prioritizedRiskCounts = prioritizedRiskCounts {
            var prioritizedRiskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .prioritizedRiskCounts)
            for (dictKey0, riskCounts0) in prioritizedRiskCounts {
                try prioritizedRiskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let prioritizedRiskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .prioritizedRiskCounts)
        var prioritizedRiskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let prioritizedRiskCountsContainer = prioritizedRiskCountsContainer {
            prioritizedRiskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in prioritizedRiskCountsContainer {
                if let count0 = count0 {
                    prioritizedRiskCountsDecoded0?[key0] = count0
                }
            }
        }
        prioritizedRiskCounts = prioritizedRiskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A pillar review summary of a lens review.
    public struct PillarReviewSummary {
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String:Swift.Int]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?

        public init(
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String:Swift.Int]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.riskCounts = riskCounts
        }
    }

}

extension WellArchitectedClientTypes.Profile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case owner = "Owner"
        case profileArn = "ProfileArn"
        case profileDescription = "ProfileDescription"
        case profileName = "ProfileName"
        case profileQuestions = "ProfileQuestions"
        case profileVersion = "ProfileVersion"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileDescription = self.profileDescription {
            try encodeContainer.encode(profileDescription, forKey: .profileDescription)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileQuestions = profileQuestions {
            var profileQuestionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileQuestions)
            for profilequestion0 in profileQuestions {
                try profileQuestionsContainer.encode(profilequestion0)
            }
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileDescription)
        profileDescription = profileDescriptionDecoded
        let profileQuestionsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileQuestion?].self, forKey: .profileQuestions)
        var profileQuestionsDecoded0:[WellArchitectedClientTypes.ProfileQuestion]? = nil
        if let profileQuestionsContainer = profileQuestionsContainer {
            profileQuestionsDecoded0 = [WellArchitectedClientTypes.ProfileQuestion]()
            for structure0 in profileQuestionsContainer {
                if let structure0 = structure0 {
                    profileQuestionsDecoded0?.append(structure0)
                }
            }
        }
        profileQuestions = profileQuestionsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A profile.
    public struct Profile {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile description.
        public var profileDescription: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// Profile questions.
        public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestion]?
        /// The profile version.
        public var profileVersion: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the profile.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileDescription: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileQuestions: [WellArchitectedClientTypes.ProfileQuestion]? = nil,
            profileVersion: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.owner = owner
            self.profileArn = profileArn
            self.profileDescription = profileDescription
            self.profileName = profileName
            self.profileQuestions = profileQuestions
            self.profileVersion = profileVersion
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.ProfileChoice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceDescription = "ChoiceDescription"
        case choiceId = "ChoiceId"
        case choiceTitle = "ChoiceTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceDescription = self.choiceDescription {
            try encodeContainer.encode(choiceDescription, forKey: .choiceDescription)
        }
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let choiceTitle = self.choiceTitle {
            try encodeContainer.encode(choiceTitle, forKey: .choiceTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let choiceTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceTitle)
        choiceTitle = choiceTitleDecoded
        let choiceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceDescription)
        choiceDescription = choiceDescriptionDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The profile choice.
    public struct ProfileChoice {
        /// The description of a choice.
        public var choiceDescription: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceDescription: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceDescription = choiceDescription
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }

}

extension WellArchitectedClientTypes.ProfileNotificationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentProfileVersion = "CurrentProfileVersion"
        case latestProfileVersion = "LatestProfileVersion"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case type = "Type"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentProfileVersion = self.currentProfileVersion {
            try encodeContainer.encode(currentProfileVersion, forKey: .currentProfileVersion)
        }
        if let latestProfileVersion = self.latestProfileVersion {
            try encodeContainer.encode(latestProfileVersion, forKey: .latestProfileVersion)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentProfileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentProfileVersion)
        currentProfileVersion = currentProfileVersionDecoded
        let latestProfileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestProfileVersion)
        latestProfileVersion = latestProfileVersionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ProfileNotificationType.self, forKey: .type)
        type = typeDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The profile notification summary.
    public struct ProfileNotificationSummary {
        /// The current profile version.
        public var currentProfileVersion: Swift.String?
        /// The latest profile version.
        public var latestProfileVersion: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// Type of notification.
        public var type: WellArchitectedClientTypes.ProfileNotificationType?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            currentProfileVersion: Swift.String? = nil,
            latestProfileVersion: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            type: WellArchitectedClientTypes.ProfileNotificationType? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentProfileVersion = currentProfileVersion
            self.latestProfileVersion = latestProfileVersion
            self.profileArn = profileArn
            self.profileName = profileName
            self.type = type
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ProfileNotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case profileAnswersUpdated
        case profileDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileNotificationType] {
            return [
                .profileAnswersUpdated,
                .profileDeleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .profileAnswersUpdated: return "PROFILE_ANSWERS_UPDATED"
            case .profileDeleted: return "PROFILE_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProfileNotificationType(rawValue: rawValue) ?? ProfileNotificationType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ProfileOwnerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileOwnerType] {
            return [
                .self,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .self: return "SELF"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProfileOwnerType(rawValue: rawValue) ?? ProfileOwnerType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ProfileQuestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSelectedChoices = "MaxSelectedChoices"
        case minSelectedChoices = "MinSelectedChoices"
        case questionChoices = "QuestionChoices"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case selectedChoiceIds = "SelectedChoiceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxSelectedChoices = self.maxSelectedChoices {
            try encodeContainer.encode(maxSelectedChoices, forKey: .maxSelectedChoices)
        }
        if let minSelectedChoices = self.minSelectedChoices {
            try encodeContainer.encode(minSelectedChoices, forKey: .minSelectedChoices)
        }
        if let questionChoices = questionChoices {
            var questionChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionChoices)
            for profilechoice0 in questionChoices {
                try questionChoicesContainer.encode(profilechoice0)
            }
        }
        if let questionDescription = self.questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let selectedChoiceIds = selectedChoiceIds {
            var selectedChoiceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoiceIds)
            for choiceid0 in selectedChoiceIds {
                try selectedChoiceIdsContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let questionChoicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileChoice?].self, forKey: .questionChoices)
        var questionChoicesDecoded0:[WellArchitectedClientTypes.ProfileChoice]? = nil
        if let questionChoicesContainer = questionChoicesContainer {
            questionChoicesDecoded0 = [WellArchitectedClientTypes.ProfileChoice]()
            for structure0 in questionChoicesContainer {
                if let structure0 = structure0 {
                    questionChoicesDecoded0?.append(structure0)
                }
            }
        }
        questionChoices = questionChoicesDecoded0
        let selectedChoiceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoiceIds)
        var selectedChoiceIdsDecoded0:[Swift.String]? = nil
        if let selectedChoiceIdsContainer = selectedChoiceIdsContainer {
            selectedChoiceIdsDecoded0 = [Swift.String]()
            for string0 in selectedChoiceIdsContainer {
                if let string0 = string0 {
                    selectedChoiceIdsDecoded0?.append(string0)
                }
            }
        }
        selectedChoiceIds = selectedChoiceIdsDecoded0
        let minSelectedChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSelectedChoices)
        minSelectedChoices = minSelectedChoicesDecoded
        let maxSelectedChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSelectedChoices)
        maxSelectedChoices = maxSelectedChoicesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A profile question.
    public struct ProfileQuestion {
        /// The maximum number of selected choices.
        public var maxSelectedChoices: Swift.Int?
        /// The minimum number of selected choices.
        public var minSelectedChoices: Swift.Int?
        /// The question choices.
        public var questionChoices: [WellArchitectedClientTypes.ProfileChoice]?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The selected choices.
        public var selectedChoiceIds: [Swift.String]?

        public init(
            maxSelectedChoices: Swift.Int? = nil,
            minSelectedChoices: Swift.Int? = nil,
            questionChoices: [WellArchitectedClientTypes.ProfileChoice]? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            selectedChoiceIds: [Swift.String]? = nil
        )
        {
            self.maxSelectedChoices = maxSelectedChoices
            self.minSelectedChoices = minSelectedChoices
            self.questionChoices = questionChoices
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.selectedChoiceIds = selectedChoiceIds
        }
    }

}

extension WellArchitectedClientTypes.ProfileQuestionUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case questionId = "QuestionId"
        case selectedChoiceIds = "SelectedChoiceIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let selectedChoiceIds = selectedChoiceIds {
            var selectedChoiceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoiceIds)
            for choiceid0 in selectedChoiceIds {
                try selectedChoiceIdsContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let selectedChoiceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoiceIds)
        var selectedChoiceIdsDecoded0:[Swift.String]? = nil
        if let selectedChoiceIdsContainer = selectedChoiceIdsContainer {
            selectedChoiceIdsDecoded0 = [Swift.String]()
            for string0 in selectedChoiceIdsContainer {
                if let string0 = string0 {
                    selectedChoiceIdsDecoded0?.append(string0)
                }
            }
        }
        selectedChoiceIds = selectedChoiceIdsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// An update to a profile question.
    public struct ProfileQuestionUpdate {
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The selected choices.
        public var selectedChoiceIds: [Swift.String]?

        public init(
            questionId: Swift.String? = nil,
            selectedChoiceIds: [Swift.String]? = nil
        )
        {
            self.questionId = questionId
            self.selectedChoiceIds = selectedChoiceIds
        }
    }

}

extension WellArchitectedClientTypes.ProfileShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Summary of a profile share.
    public struct ProfileShareSummary {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Profile share invitation status message.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension WellArchitectedClientTypes.ProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case owner = "Owner"
        case profileArn = "ProfileArn"
        case profileDescription = "ProfileDescription"
        case profileName = "ProfileName"
        case profileVersion = "ProfileVersion"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileDescription = self.profileDescription {
            try encodeContainer.encode(profileDescription, forKey: .profileDescription)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileDescription)
        profileDescription = profileDescriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Summary of a profile.
    public struct ProfileSummary {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile description.
        public var profileDescription: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// The profile version.
        public var profileVersion: Swift.String?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            owner: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileDescription: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.owner = owner
            self.profileArn = profileArn
            self.profileDescription = profileDescription
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.ProfileTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case templateName = "TemplateName"
        case templateQuestions = "TemplateQuestions"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateQuestions = templateQuestions {
            var templateQuestionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .templateQuestions)
            for profiletemplatequestion0 in templateQuestions {
                try templateQuestionsContainer.encode(profiletemplatequestion0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateQuestionsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileTemplateQuestion?].self, forKey: .templateQuestions)
        var templateQuestionsDecoded0:[WellArchitectedClientTypes.ProfileTemplateQuestion]? = nil
        if let templateQuestionsContainer = templateQuestionsContainer {
            templateQuestionsDecoded0 = [WellArchitectedClientTypes.ProfileTemplateQuestion]()
            for structure0 in templateQuestionsContainer {
                if let structure0 = structure0 {
                    templateQuestionsDecoded0?.append(structure0)
                }
            }
        }
        templateQuestions = templateQuestionsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The profile template.
    public struct ProfileTemplate {
        /// The date and time recorded.
        public var createdAt: ClientRuntime.Date?
        /// The name of the profile template.
        public var templateName: Swift.String?
        /// Profile template questions.
        public var templateQuestions: [WellArchitectedClientTypes.ProfileTemplateQuestion]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            templateName: Swift.String? = nil,
            templateQuestions: [WellArchitectedClientTypes.ProfileTemplateQuestion]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.templateName = templateName
            self.templateQuestions = templateQuestions
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.ProfileTemplateChoice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceDescription = "ChoiceDescription"
        case choiceId = "ChoiceId"
        case choiceTitle = "ChoiceTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceDescription = self.choiceDescription {
            try encodeContainer.encode(choiceDescription, forKey: .choiceDescription)
        }
        if let choiceId = self.choiceId {
            try encodeContainer.encode(choiceId, forKey: .choiceId)
        }
        if let choiceTitle = self.choiceTitle {
            try encodeContainer.encode(choiceTitle, forKey: .choiceTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let choiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceId)
        choiceId = choiceIdDecoded
        let choiceTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceTitle)
        choiceTitle = choiceTitleDecoded
        let choiceDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .choiceDescription)
        choiceDescription = choiceDescriptionDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A profile template choice.
    public struct ProfileTemplateChoice {
        /// The description of a choice.
        public var choiceDescription: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceDescription: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceDescription = choiceDescription
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }

}

extension WellArchitectedClientTypes.ProfileTemplateQuestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSelectedChoices = "MaxSelectedChoices"
        case minSelectedChoices = "MinSelectedChoices"
        case questionChoices = "QuestionChoices"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxSelectedChoices = self.maxSelectedChoices {
            try encodeContainer.encode(maxSelectedChoices, forKey: .maxSelectedChoices)
        }
        if let minSelectedChoices = self.minSelectedChoices {
            try encodeContainer.encode(minSelectedChoices, forKey: .minSelectedChoices)
        }
        if let questionChoices = questionChoices {
            var questionChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .questionChoices)
            for profiletemplatechoice0 in questionChoices {
                try questionChoicesContainer.encode(profiletemplatechoice0)
            }
        }
        if let questionDescription = self.questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let questionChoicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileTemplateChoice?].self, forKey: .questionChoices)
        var questionChoicesDecoded0:[WellArchitectedClientTypes.ProfileTemplateChoice]? = nil
        if let questionChoicesContainer = questionChoicesContainer {
            questionChoicesDecoded0 = [WellArchitectedClientTypes.ProfileTemplateChoice]()
            for structure0 in questionChoicesContainer {
                if let structure0 = structure0 {
                    questionChoicesDecoded0?.append(structure0)
                }
            }
        }
        questionChoices = questionChoicesDecoded0
        let minSelectedChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSelectedChoices)
        minSelectedChoices = minSelectedChoicesDecoded
        let maxSelectedChoicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSelectedChoices)
        maxSelectedChoices = maxSelectedChoicesDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A profile template question.
    public struct ProfileTemplateQuestion {
        /// The maximum number of choices selected.
        public var maxSelectedChoices: Swift.Int?
        /// The minimum number of choices selected.
        public var minSelectedChoices: Swift.Int?
        /// The question choices.
        public var questionChoices: [WellArchitectedClientTypes.ProfileTemplateChoice]?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init(
            maxSelectedChoices: Swift.Int? = nil,
            minSelectedChoices: Swift.Int? = nil,
            questionChoices: [WellArchitectedClientTypes.ProfileTemplateChoice]? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.maxSelectedChoices = maxSelectedChoices
            self.minSelectedChoices = minSelectedChoices
            self.questionChoices = questionChoices
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }

}

extension WellArchitectedClientTypes {
    public enum Question: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case answered
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Question] {
            return [
                .answered,
                .unanswered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Question(rawValue: rawValue) ?? Question.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.QuestionDifference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differenceStatus = "DifferenceStatus"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let differenceStatus = self.differenceStatus {
            try encodeContainer.encode(differenceStatus.rawValue, forKey: .differenceStatus)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let differenceStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DifferenceStatus.self, forKey: .differenceStatus)
        differenceStatus = differenceStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A question difference return object.
    public struct QuestionDifference {
        /// Indicates the type of change to the question.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init(
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }

}

extension WellArchitectedClientTypes.QuestionMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bestPractices = "BestPractices"
        case questionId = "QuestionId"
        case risk = "Risk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bestPractices = bestPractices {
            var bestPracticesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bestPractices)
            for bestpractice0 in bestPractices {
                try bestPracticesContainer.encode(bestpractice0)
            }
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let bestPracticesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.BestPractice?].self, forKey: .bestPractices)
        var bestPracticesDecoded0:[WellArchitectedClientTypes.BestPractice]? = nil
        if let bestPracticesContainer = bestPracticesContainer {
            bestPracticesDecoded0 = [WellArchitectedClientTypes.BestPractice]()
            for structure0 in bestPracticesContainer {
                if let structure0 = structure0 {
                    bestPracticesDecoded0?.append(structure0)
                }
            }
        }
        bestPractices = bestPracticesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A metric for a particular question in the pillar.
    public struct QuestionMetric {
        /// The best practices, or choices, that have been identified as contributing to risk in a question.
        public var bestPractices: [WellArchitectedClientTypes.BestPractice]?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init(
            bestPractices: [WellArchitectedClientTypes.BestPractice]? = nil,
            questionId: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.bestPractices = bestPractices
            self.questionId = questionId
            self.risk = risk
        }
    }

}

extension WellArchitectedClientTypes {
    public enum QuestionPriority: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case prioritized
        case sdkUnknown(Swift.String)

        public static var allCases: [QuestionPriority] {
            return [
                .none,
                .prioritized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .prioritized: return "PRIORITIZED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuestionPriority(rawValue: rawValue) ?? QuestionPriority.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum QuestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPrioritized
        case prioritized
        case sdkUnknown(Swift.String)

        public static var allCases: [QuestionType] {
            return [
                .nonPrioritized,
                .prioritized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPrioritized: return "NON_PRIORITIZED"
            case .prioritized: return "PRIORITIZED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuestionType(rawValue: rawValue) ?? QuestionType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .json,
                .pdf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension WellArchitectedClientTypes.ReviewTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lenses = "Lenses"
        case notes = "Notes"
        case owner = "Owner"
        case questionCounts = "QuestionCounts"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case templateArn = "TemplateArn"
        case templateName = "TemplateName"
        case updateStatus = "UpdateStatus"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let questionCounts = questionCounts {
            var questionCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .questionCounts)
            for (dictKey0, questionCounts0) in questionCounts {
                try questionCountsContainer.encode(questionCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let questionCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .questionCounts)
        var questionCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let questionCountsContainer = questionCountsContainer {
            questionCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in questionCountsContainer {
                if let count0 = count0 {
                    questionCountsDecoded0?[key0] = count0
                }
            }
        }
        questionCounts = questionCountsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let updateStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateUpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A review template.
    public struct ReviewTemplate {
        /// The review template description.
        public var description: Swift.String?
        /// The lenses applied to the review template.
        public var lenses: [Swift.String]?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A count of how many total questions are answered and unanswered in the review template.
        public var questionCounts: [Swift.String:Swift.Int]?
        /// The ID assigned to the template share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the review template.
        public var tags: [Swift.String:Swift.String]?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The latest status of a review template.
        public var updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            lenses: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            questionCounts: [Swift.String:Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.lenses = lenses
            self.notes = notes
            self.owner = owner
            self.questionCounts = questionCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.templateArn = templateArn
            self.templateName = templateName
            self.updateStatus = updateStatus
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.ReviewTemplateAnswer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerStatus = "AnswerStatus"
        case choiceAnswers = "ChoiceAnswers"
        case choices = "Choices"
        case helpfulResourceDisplayText = "HelpfulResourceDisplayText"
        case helpfulResourceUrl = "HelpfulResourceUrl"
        case improvementPlanUrl = "ImprovementPlanUrl"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case pillarId = "PillarId"
        case questionDescription = "QuestionDescription"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerStatus = self.answerStatus {
            try encodeContainer.encode(answerStatus.rawValue, forKey: .answerStatus)
        }
        if let choiceAnswers = choiceAnswers {
            var choiceAnswersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswers)
            for choiceanswer0 in choiceAnswers {
                try choiceAnswersContainer.encode(choiceanswer0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choice0 in choices {
                try choicesContainer.encode(choice0)
            }
        }
        if let helpfulResourceDisplayText = self.helpfulResourceDisplayText {
            try encodeContainer.encode(helpfulResourceDisplayText, forKey: .helpfulResourceDisplayText)
        }
        if let helpfulResourceUrl = self.helpfulResourceUrl {
            try encodeContainer.encode(helpfulResourceUrl, forKey: .helpfulResourceUrl)
        }
        if let improvementPlanUrl = self.improvementPlanUrl {
            try encodeContainer.encode(improvementPlanUrl, forKey: .improvementPlanUrl)
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionDescription = self.questionDescription {
            try encodeContainer.encode(questionDescription, forKey: .questionDescription)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let questionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionDescription)
        questionDescription = questionDescriptionDecoded
        let improvementPlanUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .improvementPlanUrl)
        improvementPlanUrl = improvementPlanUrlDecoded
        let helpfulResourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceUrl)
        helpfulResourceUrl = helpfulResourceUrlDecoded
        let helpfulResourceDisplayTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .helpfulResourceDisplayText)
        helpfulResourceDisplayText = helpfulResourceDisplayTextDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswersContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswer?].self, forKey: .choiceAnswers)
        var choiceAnswersDecoded0:[WellArchitectedClientTypes.ChoiceAnswer]? = nil
        if let choiceAnswersContainer = choiceAnswersContainer {
            choiceAnswersDecoded0 = [WellArchitectedClientTypes.ChoiceAnswer]()
            for structure0 in choiceAnswersContainer {
                if let structure0 = structure0 {
                    choiceAnswersDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswers = choiceAnswersDecoded0
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let answerStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateAnswerStatus.self, forKey: .answerStatus)
        answerStatus = answerStatusDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WellArchitectedClientTypes {
    /// An answer of the question.
    public struct ReviewTemplateAnswer {
        /// The status of whether or not this question has been answered.
        public var answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus?
        /// A list of selected choices to a question in your review template.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed for a custom lens. This field does not apply to Amazon Web Services official lenses.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL. For Amazon Web Services official lenses, this is the helpful resource URL for a question or choice. For custom lenses, this is the helpful resource URL for a question and is only provided if HelpfulResourceDisplayText was specified for the question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your review template.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus? = nil,
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool? = nil,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.answerStatus = answerStatus
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.selectedChoices = selectedChoices
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ReviewTemplateAnswerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case answered
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewTemplateAnswerStatus] {
            return [
                .answered,
                .unanswered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewTemplateAnswerStatus(rawValue: rawValue) ?? ReviewTemplateAnswerStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ReviewTemplateAnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerStatus = "AnswerStatus"
        case choiceAnswerSummaries = "ChoiceAnswerSummaries"
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case questionType = "QuestionType"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerStatus = self.answerStatus {
            try encodeContainer.encode(answerStatus.rawValue, forKey: .answerStatus)
        }
        if let choiceAnswerSummaries = choiceAnswerSummaries {
            var choiceAnswerSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswerSummaries)
            for choiceanswersummary0 in choiceAnswerSummaries {
                try choiceAnswerSummariesContainer.encode(choiceanswersummary0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choice0 in choices {
                try choicesContainer.encode(choice0)
            }
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let questionType = self.questionType {
            try encodeContainer.encode(questionType.rawValue, forKey: .questionType)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswerSummary?].self, forKey: .choiceAnswerSummaries)
        var choiceAnswerSummariesDecoded0:[WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil
        if let choiceAnswerSummariesContainer = choiceAnswerSummariesContainer {
            choiceAnswerSummariesDecoded0 = [WellArchitectedClientTypes.ChoiceAnswerSummary]()
            for structure0 in choiceAnswerSummariesContainer {
                if let structure0 = structure0 {
                    choiceAnswerSummariesDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswerSummaries = choiceAnswerSummariesDecoded0
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let answerStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateAnswerStatus.self, forKey: .answerStatus)
        answerStatus = answerStatusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
        let questionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.QuestionType.self, forKey: .questionType)
        questionType = questionTypeDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The summary of review template answers.
    public struct ReviewTemplateAnswerSummary {
        /// The status of whether or not this question has been answered.
        public var answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus?
        /// A list of selected choices to a question in the review template.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The type of question.
        public var questionType: WellArchitectedClientTypes.QuestionType?
        /// The reason why a choice is not-applicable to a question in the review template.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus? = nil,
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            questionType: WellArchitectedClientTypes.QuestionType? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.answerStatus = answerStatus
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.questionType = questionType
            self.reason = reason
            self.selectedChoices = selectedChoices
        }
    }

}

extension WellArchitectedClientTypes.ReviewTemplateLensReview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case lensName = "LensName"
        case lensStatus = "LensStatus"
        case lensVersion = "LensVersion"
        case nextToken = "NextToken"
        case notes = "Notes"
        case pillarReviewSummaries = "PillarReviewSummaries"
        case questionCounts = "QuestionCounts"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = self.lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let lensStatus = self.lensStatus {
            try encodeContainer.encode(lensStatus.rawValue, forKey: .lensStatus)
        }
        if let lensVersion = self.lensVersion {
            try encodeContainer.encode(lensVersion, forKey: .lensVersion)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarReviewSummaries = pillarReviewSummaries {
            var pillarReviewSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarReviewSummaries)
            for reviewtemplatepillarreviewsummary0 in pillarReviewSummaries {
                try pillarReviewSummariesContainer.encode(reviewtemplatepillarreviewsummary0)
            }
        }
        if let questionCounts = questionCounts {
            var questionCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .questionCounts)
            for (dictKey0, questionCounts0) in questionCounts {
                try questionCountsContainer.encode(questionCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let lensVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensVersion)
        lensVersion = lensVersionDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensStatus.self, forKey: .lensStatus)
        lensStatus = lensStatusDecoded
        let pillarReviewSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary?].self, forKey: .pillarReviewSummaries)
        var pillarReviewSummariesDecoded0:[WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]? = nil
        if let pillarReviewSummariesContainer = pillarReviewSummariesContainer {
            pillarReviewSummariesDecoded0 = [WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]()
            for structure0 in pillarReviewSummariesContainer {
                if let structure0 = structure0 {
                    pillarReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        pillarReviewSummaries = pillarReviewSummariesDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let questionCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .questionCounts)
        var questionCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let questionCountsContainer = questionCountsContainer {
            questionCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in questionCountsContainer {
                if let count0 = count0 {
                    questionCountsDecoded0?[key0] = count0
                }
            }
        }
        questionCounts = questionCountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The lens review of a review template.
    public struct ReviewTemplateLensReview {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The lens ARN.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// Pillar review summaries of a lens review.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]?
        /// A count of how many questions are answered and unanswered in the lens review.
        public var questionCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]? = nil,
            questionCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.questionCounts = questionCounts
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notes = "Notes"
        case pillarId = "PillarId"
        case pillarName = "PillarName"
        case questionCounts = "QuestionCounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let pillarName = self.pillarName {
            try encodeContainer.encode(pillarName, forKey: .pillarName)
        }
        if let questionCounts = questionCounts {
            var questionCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .questionCounts)
            for (dictKey0, questionCounts0) in questionCounts {
                try questionCountsContainer.encode(questionCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let pillarNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarName)
        pillarName = pillarNameDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let questionCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .questionCounts)
        var questionCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let questionCountsContainer = questionCountsContainer {
            questionCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in questionCountsContainer {
                if let count0 = count0 {
                    questionCountsDecoded0?[key0] = count0
                }
            }
        }
        questionCounts = questionCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// Summary of a review template.
    public struct ReviewTemplatePillarReviewSummary {
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A count of how many questions are answered and unanswered in the requested pillar of the lens review.
        public var questionCounts: [Swift.String:Swift.Int]?

        public init(
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionCounts: [Swift.String:Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionCounts = questionCounts
        }
    }

}

extension WellArchitectedClientTypes.ReviewTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lenses = "Lenses"
        case owner = "Owner"
        case templateArn = "TemplateArn"
        case templateName = "TemplateName"
        case updateStatus = "UpdateStatus"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateUpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Summary of a review template.
    public struct ReviewTemplateSummary {
        /// Description of the review template.
        public var description: Swift.String?
        /// Lenses associated with the review template.
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The latest status of a review template.
        public var updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.lenses = lenses
            self.owner = owner
            self.templateArn = templateArn
            self.templateName = templateName
            self.updateStatus = updateStatus
            self.updatedAt = updatedAt
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ReviewTemplateUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case lensNotCurrent
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewTemplateUpdateStatus] {
            return [
                .current,
                .lensNotCurrent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .lensNotCurrent: return "LENS_NOT_CURRENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReviewTemplateUpdateStatus(rawValue: rawValue) ?? ReviewTemplateUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The risk for a given workload, lens review, pillar, or question.
    public enum Risk: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case medium
        case `none`
        case notApplicable
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Risk] {
            return [
                .high,
                .medium,
                .none,
                .notApplicable,
                .unanswered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .notApplicable: return "NOT_APPLICABLE"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Risk(rawValue: rawValue) ?? Risk.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.SelectedPillar: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pillarId = "PillarId"
        case selectedQuestionIds = "SelectedQuestionIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let selectedQuestionIds = selectedQuestionIds {
            var selectedQuestionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedQuestionIds)
            for selectedquestionid0 in selectedQuestionIds {
                try selectedQuestionIdsContainer.encode(selectedquestionid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let selectedQuestionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedQuestionIds)
        var selectedQuestionIdsDecoded0:[Swift.String]? = nil
        if let selectedQuestionIdsContainer = selectedQuestionIdsContainer {
            selectedQuestionIdsDecoded0 = [Swift.String]()
            for string0 in selectedQuestionIdsContainer {
                if let string0 = string0 {
                    selectedQuestionIdsDecoded0?.append(string0)
                }
            }
        }
        selectedQuestionIds = selectedQuestionIdsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// The selected pillar.
    public struct SelectedPillar {
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Selected question IDs in the selected pillar.
        public var selectedQuestionIds: [Swift.String]?

        public init(
            pillarId: Swift.String? = nil,
            selectedQuestionIds: [Swift.String]? = nil
        )
        {
            self.pillarId = pillarId
            self.selectedQuestionIds = selectedQuestionIds
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user has reached their resource quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension WellArchitectedClientTypes.ShareInvitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case profileArn = "ProfileArn"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case templateArn = "TemplateArn"
        case workloadId = "WorkloadId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensAlias = self.lensAlias {
            try encodeContainer.encode(lensAlias, forKey: .lensAlias)
        }
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = self.shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The share invitation.
    public struct ShareInvitation {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            templateArn: Swift.String? = nil,
            workloadId: Swift.String? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.profileArn = profileArn
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.templateArn = templateArn
            self.workloadId = workloadId
        }
    }

}

extension WellArchitectedClientTypes {
    /// Share invitation action taken by contributor.
    public enum ShareInvitationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareInvitationAction] {
            return [
                .accept,
                .reject,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareInvitationAction(rawValue: rawValue) ?? ShareInvitationAction.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.ShareInvitationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensArn = "LensArn"
        case lensName = "LensName"
        case permissionType = "PermissionType"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case shareInvitationId = "ShareInvitationId"
        case shareResourceType = "ShareResourceType"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case templateArn = "TemplateArn"
        case templateName = "TemplateName"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensArn = self.lensArn {
            try encodeContainer.encode(lensArn, forKey: .lensArn)
        }
        if let lensName = self.lensName {
            try encodeContainer.encode(lensName, forKey: .lensName)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = self.profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let shareResourceType = self.shareResourceType {
            try encodeContainer.encode(shareResourceType.rawValue, forKey: .shareResourceType)
        }
        if let sharedBy = self.sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let shareResourceTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareResourceType.self, forKey: .shareResourceType)
        shareResourceType = shareResourceTypeDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensName)
        lensName = lensNameDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A share invitation summary return object.
    public struct ShareInvitationSummary {
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lensArn = lensArn
            self.lensName = lensName
            self.permissionType = permissionType
            self.profileArn = profileArn
            self.profileName = profileName
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.templateArn = templateArn
            self.templateName = templateName
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes {
    public enum ShareResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lens
        case profile
        case template
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareResourceType] {
            return [
                .lens,
                .profile,
                .template,
                .workload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lens: return "LENS"
            case .profile: return "PROFILE"
            case .template: return "TEMPLATE"
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareResourceType(rawValue: rawValue) ?? ShareResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The status of the share request.
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case associated
        case associating
        case expired
        case failed
        case pending
        case rejected
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .accepted,
                .associated,
                .associating,
                .expired,
                .failed,
                .pending,
                .rejected,
                .revoked,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        tags: [Swift.String:Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tags = tags
        self.workloadArn = workloadArn
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WellArchitectedClientTypes.TemplateShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Summary of a review template share.
    public struct TemplateShareSummary {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Review template share invitation status message.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension WellArchitectedClientTypes {
    public enum TrustedAdvisorIntegrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustedAdvisorIntegrationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustedAdvisorIntegrationStatus(rawValue: rawValue) ?? TrustedAdvisorIntegrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.workloadArn = workloadArn
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnswerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceUpdates = choiceUpdates {
            var choiceUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .choiceUpdates)
            for (dictKey0, choiceUpdates0) in choiceUpdates {
                try choiceUpdatesContainer.encode(choiceUpdates0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }
}

extension UpdateAnswerInput {

    static func urlPathProvider(_ value: UpdateAnswerInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

/// Input to update answer.
public struct UpdateAnswerInput {
    /// A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.
    public var choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The reason why a question is not applicable to your workload.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.workloadId = workloadId
    }
}

struct UpdateAnswerInputBody {
    let selectedChoices: [Swift.String]?
    let choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    let notes: Swift.String?
    let isApplicable: Swift.Bool?
    let reason: WellArchitectedClientTypes.AnswerReason?
}

extension UpdateAnswerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: WellArchitectedClientTypes.ChoiceUpdate?].self, forKey: .choiceUpdates)
        var choiceUpdatesDecoded0: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil
        if let choiceUpdatesContainer = choiceUpdatesContainer {
            choiceUpdatesDecoded0 = [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]()
            for (key0, choiceupdate0) in choiceUpdatesContainer {
                if let choiceupdate0 = choiceupdate0 {
                    choiceUpdatesDecoded0?[key0] = choiceupdate0
                }
            }
        }
        choiceUpdates = choiceUpdatesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UpdateAnswerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnswerOutputBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.lensArn = output.lensArn
            self.workloadId = output.workloadId
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.lensArn = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update answer call.
public struct UpdateAnswerOutput {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.workloadId = workloadId
    }
}

struct UpdateAnswerOutputBody {
    let workloadId: Swift.String?
    let lensAlias: Swift.String?
    let lensArn: Swift.String?
    let answer: WellArchitectedClientTypes.Answer?
}

extension UpdateAnswerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case lensArn = "LensArn"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let lensArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensArn)
        lensArn = lensArnDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Answer.self, forKey: .answer)
        answer = answerDecoded
    }
}

enum UpdateAnswerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveryIntegrationStatus = "DiscoveryIntegrationStatus"
        case jiraConfiguration = "JiraConfiguration"
        case organizationSharingStatus = "OrganizationSharingStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveryIntegrationStatus = self.discoveryIntegrationStatus {
            try encodeContainer.encode(discoveryIntegrationStatus.rawValue, forKey: .discoveryIntegrationStatus)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let organizationSharingStatus = self.organizationSharingStatus {
            try encodeContainer.encode(organizationSharingStatus.rawValue, forKey: .organizationSharingStatus)
        }
    }
}

extension UpdateGlobalSettingsInput {

    static func urlPathProvider(_ value: UpdateGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

public struct UpdateGlobalSettingsInput {
    /// The status of discovery support settings.
    public var discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    /// The status of Jira integration settings.
    public var jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationInput?
    /// The status of organization sharing settings.
    public var organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?

    public init(
        discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus? = nil,
        jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationInput? = nil,
        organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus? = nil
    )
    {
        self.discoveryIntegrationStatus = discoveryIntegrationStatus
        self.jiraConfiguration = jiraConfiguration
        self.organizationSharingStatus = organizationSharingStatus
    }
}

struct UpdateGlobalSettingsInputBody {
    let organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?
    let discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    let jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationInput?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveryIntegrationStatus = "DiscoveryIntegrationStatus"
        case jiraConfiguration = "JiraConfiguration"
        case organizationSharingStatus = "OrganizationSharingStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSharingStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.OrganizationSharingStatus.self, forKey: .organizationSharingStatus)
        organizationSharingStatus = organizationSharingStatusDecoded
        let discoveryIntegrationStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.DiscoveryIntegrationStatus.self, forKey: .discoveryIntegrationStatus)
        discoveryIntegrationStatus = discoveryIntegrationStatusDecoded
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AccountJiraConfigurationInput.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension UpdateGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGlobalSettingsOutput {

    public init() { }
}

enum UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case integratingService = "IntegratingService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let integratingService = self.integratingService {
            try encodeContainer.encode(integratingService.rawValue, forKey: .integratingService)
        }
    }
}

extension UpdateIntegrationInput {

    static func urlPathProvider(_ value: UpdateIntegrationInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/updateIntegration"
    }
}

public struct UpdateIntegrationInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Which integrated service to update.
    /// This member is required.
    public var integratingService: WellArchitectedClientTypes.IntegratingService?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        integratingService: WellArchitectedClientTypes.IntegratingService? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.integratingService = integratingService
        self.workloadId = workloadId
    }
}

struct UpdateIntegrationInputBody {
    let clientRequestToken: Swift.String?
    let integratingService: WellArchitectedClientTypes.IntegratingService?
}

extension UpdateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case integratingService = "IntegratingService"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let integratingServiceDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IntegratingService.self, forKey: .integratingService)
        integratingService = integratingServiceDecoded
    }
}

extension UpdateIntegrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateIntegrationOutput {

    public init() { }
}

enum UpdateIntegrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jiraConfiguration = "JiraConfiguration"
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let lensNotes = self.lensNotes {
            try encodeContainer.encode(lensNotes, forKey: .lensNotes)
        }
        if let pillarNotes = pillarNotes {
            var pillarNotesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pillarNotes)
            for (dictKey0, pillarNotes0) in pillarNotes {
                try pillarNotesContainer.encode(pillarNotes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateLensReviewInput {

    static func urlPathProvider(_ value: UpdateLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

/// Input for update lens review.
public struct UpdateLensReviewInput {
    /// Configuration of the Jira integration.
    public var jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var pillarNotes: [Swift.String:Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration? = nil,
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String:Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.jiraConfiguration = jiraConfiguration
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewInputBody {
    let lensNotes: Swift.String?
    let pillarNotes: [Swift.String:Swift.String]?
    let jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?
}

extension UpdateLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jiraConfiguration = "JiraConfiguration"
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensNotes)
        lensNotes = lensNotesDecoded
        let pillarNotesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pillarNotes)
        var pillarNotesDecoded0: [Swift.String:Swift.String]? = nil
        if let pillarNotesContainer = pillarNotesContainer {
            pillarNotesDecoded0 = [Swift.String:Swift.String]()
            for (key0, notes0) in pillarNotesContainer {
                if let notes0 = notes0 {
                    pillarNotesDecoded0?[key0] = notes0
                }
            }
        }
        pillarNotes = pillarNotesDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.JiraSelectedQuestionConfiguration.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension UpdateLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLensReviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.workloadId = output.workloadId
        } else {
            self.lensReview = nil
            self.workloadId = nil
        }
    }
}

/// Output of a update lens review call.
public struct UpdateLensReviewOutput {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.workloadId = workloadId
    }
}

struct UpdateLensReviewOutputBody {
    let workloadId: Swift.String?
    let lensReview: WellArchitectedClientTypes.LensReview?
}

extension UpdateLensReviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case workloadId = "WorkloadId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.LensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

enum UpdateLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileDescription = "ProfileDescription"
        case profileQuestions = "ProfileQuestions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileDescription = self.profileDescription {
            try encodeContainer.encode(profileDescription, forKey: .profileDescription)
        }
        if let profileQuestions = profileQuestions {
            var profileQuestionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profileQuestions)
            for profilequestionupdate0 in profileQuestions {
                try profileQuestionsContainer.encode(profilequestionupdate0)
            }
        }
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

public struct UpdateProfileInput {
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The profile description.
    public var profileDescription: Swift.String?
    /// Profile questions.
    public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?

    public init(
        profileArn: Swift.String? = nil,
        profileDescription: Swift.String? = nil,
        profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil
    )
    {
        self.profileArn = profileArn
        self.profileDescription = profileDescription
        self.profileQuestions = profileQuestions
    }
}

struct UpdateProfileInputBody {
    let profileDescription: Swift.String?
    let profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileDescription = "ProfileDescription"
        case profileQuestions = "ProfileQuestions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileDescription)
        profileDescription = profileDescriptionDecoded
        let profileQuestionsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ProfileQuestionUpdate?].self, forKey: .profileQuestions)
        var profileQuestionsDecoded0:[WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil
        if let profileQuestionsContainer = profileQuestionsContainer {
            profileQuestionsDecoded0 = [WellArchitectedClientTypes.ProfileQuestionUpdate]()
            for structure0 in profileQuestionsContainer {
                if let structure0 = structure0 {
                    profileQuestionsDecoded0?.append(structure0)
                }
            }
        }
        profileQuestions = profileQuestionsDecoded0
    }
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct UpdateProfileOutput {
    /// The profile.
    public var profile: WellArchitectedClientTypes.Profile?

    public init(
        profile: WellArchitectedClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

struct UpdateProfileOutputBody {
    let profile: WellArchitectedClientTypes.Profile?
}

extension UpdateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReviewTemplateAnswerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceUpdates = choiceUpdates {
            var choiceUpdatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .choiceUpdates)
            for (dictKey0, choiceUpdates0) in choiceUpdates {
                try choiceUpdatesContainer.encode(choiceUpdates0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isApplicable = self.isApplicable {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for choiceid0 in selectedChoices {
                try selectedChoicesContainer.encode(choiceid0)
            }
        }
    }
}

extension UpdateReviewTemplateAnswerInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateAnswerInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

public struct UpdateReviewTemplateAnswerInput {
    /// A list of choices to be updated.
    public var choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The update reason.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.templateArn = templateArn
    }
}

struct UpdateReviewTemplateAnswerInputBody {
    let selectedChoices: [Swift.String]?
    let choiceUpdates: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]?
    let notes: Swift.String?
    let isApplicable: Swift.Bool?
    let reason: WellArchitectedClientTypes.AnswerReason?
}

extension UpdateReviewTemplateAnswerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceUpdates = "ChoiceUpdates"
        case isApplicable = "IsApplicable"
        case notes = "Notes"
        case reason = "Reason"
        case selectedChoices = "SelectedChoices"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceUpdatesContainer = try containerValues.decodeIfPresent([Swift.String: WellArchitectedClientTypes.ChoiceUpdate?].self, forKey: .choiceUpdates)
        var choiceUpdatesDecoded0: [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]? = nil
        if let choiceUpdatesContainer = choiceUpdatesContainer {
            choiceUpdatesDecoded0 = [Swift.String:WellArchitectedClientTypes.ChoiceUpdate]()
            for (key0, choiceupdate0) in choiceUpdatesContainer {
                if let choiceupdate0 = choiceupdate0 {
                    choiceUpdatesDecoded0?[key0] = choiceupdate0
                }
            }
        }
        choiceUpdates = choiceUpdatesDecoded0
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable)
        isApplicable = isApplicableDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UpdateReviewTemplateAnswerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReviewTemplateAnswerOutputBody = try responseDecoder.decode(responseBody: data)
            self.answer = output.answer
            self.lensAlias = output.lensAlias
            self.templateArn = output.templateArn
        } else {
            self.answer = nil
            self.lensAlias = nil
            self.templateArn = nil
        }
    }
}

public struct UpdateReviewTemplateAnswerOutput {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.ReviewTemplateAnswer? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

struct UpdateReviewTemplateAnswerOutputBody {
    let templateArn: Swift.String?
    let lensAlias: Swift.String?
    let answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
}

extension UpdateReviewTemplateAnswerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answer = "Answer"
        case lensAlias = "LensAlias"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let lensAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensAlias)
        lensAlias = lensAliasDecoded
        let answerDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateAnswer.self, forKey: .answer)
        answer = answerDecoded
    }
}

enum UpdateReviewTemplateAnswerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReviewTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lensesToAssociate = "LensesToAssociate"
        case lensesToDisassociate = "LensesToDisassociate"
        case notes = "Notes"
        case templateName = "TemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lensesToAssociate = lensesToAssociate {
            var lensesToAssociateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensesToAssociate)
            for lensalias0 in lensesToAssociate {
                try lensesToAssociateContainer.encode(lensalias0)
            }
        }
        if let lensesToDisassociate = lensesToDisassociate {
            var lensesToDisassociateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lensesToDisassociate)
            for lensalias0 in lensesToDisassociate {
                try lensesToDisassociateContainer.encode(lensalias0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let templateName = self.templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
    }
}

extension UpdateReviewTemplateInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

public struct UpdateReviewTemplateInput {
    /// The review template description.
    public var description: Swift.String?
    /// A list of lens aliases or ARNs to apply to the review template.
    public var lensesToAssociate: [Swift.String]?
    /// A list of lens aliases or ARNs to unapply to the review template. The wellarchitected lens cannot be unapplied.
    public var lensesToDisassociate: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?
    /// The review template name.
    public var templateName: Swift.String?

    public init(
        description: Swift.String? = nil,
        lensesToAssociate: [Swift.String]? = nil,
        lensesToDisassociate: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.description = description
        self.lensesToAssociate = lensesToAssociate
        self.lensesToDisassociate = lensesToDisassociate
        self.notes = notes
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

struct UpdateReviewTemplateInputBody {
    let templateName: Swift.String?
    let description: Swift.String?
    let notes: Swift.String?
    let lensesToAssociate: [Swift.String]?
    let lensesToDisassociate: [Swift.String]?
}

extension UpdateReviewTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lensesToAssociate = "LensesToAssociate"
        case lensesToDisassociate = "LensesToDisassociate"
        case notes = "Notes"
        case templateName = "TemplateName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let lensesToAssociateContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensesToAssociate)
        var lensesToAssociateDecoded0:[Swift.String]? = nil
        if let lensesToAssociateContainer = lensesToAssociateContainer {
            lensesToAssociateDecoded0 = [Swift.String]()
            for string0 in lensesToAssociateContainer {
                if let string0 = string0 {
                    lensesToAssociateDecoded0?.append(string0)
                }
            }
        }
        lensesToAssociate = lensesToAssociateDecoded0
        let lensesToDisassociateContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lensesToDisassociate)
        var lensesToDisassociateDecoded0:[Swift.String]? = nil
        if let lensesToDisassociateContainer = lensesToDisassociateContainer {
            lensesToDisassociateDecoded0 = [Swift.String]()
            for string0 in lensesToDisassociateContainer {
                if let string0 = string0 {
                    lensesToDisassociateDecoded0?.append(string0)
                }
            }
        }
        lensesToDisassociate = lensesToDisassociateDecoded0
    }
}

extension UpdateReviewTemplateLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lensNotes = self.lensNotes {
            try encodeContainer.encode(lensNotes, forKey: .lensNotes)
        }
        if let pillarNotes = pillarNotes {
            var pillarNotesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .pillarNotes)
            for (dictKey0, pillarNotes0) in pillarNotes {
                try pillarNotesContainer.encode(pillarNotes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

public struct UpdateReviewTemplateLensReviewInput {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var pillarNotes: [Swift.String:Swift.String]?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String:Swift.String]? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.templateArn = templateArn
    }
}

struct UpdateReviewTemplateLensReviewInputBody {
    let lensNotes: Swift.String?
    let pillarNotes: [Swift.String:Swift.String]?
}

extension UpdateReviewTemplateLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensNotes = "LensNotes"
        case pillarNotes = "PillarNotes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lensNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lensNotes)
        lensNotes = lensNotesDecoded
        let pillarNotesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .pillarNotes)
        var pillarNotesDecoded0: [Swift.String:Swift.String]? = nil
        if let pillarNotesContainer = pillarNotesContainer {
            pillarNotesDecoded0 = [Swift.String:Swift.String]()
            for (key0, notes0) in pillarNotesContainer {
                if let notes0 = notes0 {
                    pillarNotesDecoded0?[key0] = notes0
                }
            }
        }
        pillarNotes = pillarNotesDecoded0
    }
}

extension UpdateReviewTemplateLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReviewTemplateLensReviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lensReview = output.lensReview
            self.templateArn = output.templateArn
        } else {
            self.lensReview = nil
            self.templateArn = nil
        }
    }
}

public struct UpdateReviewTemplateLensReviewOutput {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.templateArn = templateArn
    }
}

struct UpdateReviewTemplateLensReviewOutputBody {
    let templateArn: Swift.String?
    let lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
}

extension UpdateReviewTemplateLensReviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lensReview = "LensReview"
        case templateArn = "TemplateArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let lensReviewDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplateLensReview.self, forKey: .lensReview)
        lensReview = lensReviewDecoded
    }
}

enum UpdateReviewTemplateLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReviewTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReviewTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.reviewTemplate = output.reviewTemplate
        } else {
            self.reviewTemplate = nil
        }
    }
}

public struct UpdateReviewTemplateOutput {
    /// A review template.
    public var reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?

    public init(
        reviewTemplate: WellArchitectedClientTypes.ReviewTemplate? = nil
    )
    {
        self.reviewTemplate = reviewTemplate
    }
}

struct UpdateReviewTemplateOutputBody {
    let reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?
}

extension UpdateReviewTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reviewTemplate = "ReviewTemplate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reviewTemplateDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ReviewTemplate.self, forKey: .reviewTemplate)
        reviewTemplate = reviewTemplateDecoded
    }
}

enum UpdateReviewTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareInvitationAction = self.shareInvitationAction {
            try encodeContainer.encode(shareInvitationAction.rawValue, forKey: .shareInvitationAction)
        }
    }
}

extension UpdateShareInvitationInput {

    static func urlPathProvider(_ value: UpdateShareInvitationInput) -> Swift.String? {
        guard let shareInvitationId = value.shareInvitationId else {
            return nil
        }
        return "/shareInvitations/\(shareInvitationId.urlPercentEncoding())"
    }
}

/// Input for Update Share Invitation
public struct UpdateShareInvitationInput {
    /// Share invitation action taken by contributor.
    /// This member is required.
    public var shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
    /// The ID assigned to the share invitation.
    /// This member is required.
    public var shareInvitationId: Swift.String?

    public init(
        shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction? = nil,
        shareInvitationId: Swift.String? = nil
    )
    {
        self.shareInvitationAction = shareInvitationAction
        self.shareInvitationId = shareInvitationId
    }
}

struct UpdateShareInvitationInputBody {
    let shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
}

extension UpdateShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitationAction = "ShareInvitationAction"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationActionDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitationAction.self, forKey: .shareInvitationAction)
        shareInvitationAction = shareInvitationActionDecoded
    }
}

extension UpdateShareInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateShareInvitationOutputBody = try responseDecoder.decode(responseBody: data)
            self.shareInvitation = output.shareInvitation
        } else {
            self.shareInvitation = nil
        }
    }
}

public struct UpdateShareInvitationOutput {
    /// The updated workload or custom lens share invitation.
    public var shareInvitation: WellArchitectedClientTypes.ShareInvitation?

    public init(
        shareInvitation: WellArchitectedClientTypes.ShareInvitation? = nil
    )
    {
        self.shareInvitation = shareInvitation
    }
}

struct UpdateShareInvitationOutputBody {
    let shareInvitation: WellArchitectedClientTypes.ShareInvitation?
}

extension UpdateShareInvitationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareInvitation = "ShareInvitation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareInvitationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareInvitation.self, forKey: .shareInvitation)
        shareInvitation = shareInvitationDecoded
    }
}

enum UpdateShareInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case applications = "Applications"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case discoveryConfig = "DiscoveryConfig"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case jiraConfiguration = "JiraConfiguration"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationarn0 in applications {
                try applicationsContainer.encode(applicationarn0)
            }
        }
        if let architecturalDesign = self.architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for awsregion0 in awsRegions {
                try awsRegionsContainer.encode(awsregion0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let discoveryConfig = self.discoveryConfig {
            try encodeContainer.encode(discoveryConfig, forKey: .discoveryConfig)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = self.improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = self.industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = self.industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let isReviewOwnerUpdateAcknowledged = self.isReviewOwnerUpdateAcknowledged {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregion0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregion0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for pillarid0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(pillarid0)
            }
        }
        if let reviewOwner = self.reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension UpdateWorkloadInput {

    static func urlPathProvider(_ value: UpdateWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

/// Input to update a workload.
public struct UpdateWorkloadInput {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// List of AppRegistry application ARNs to associate to the workload.
    public var applications: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// The description for the workload.
    public var description: Swift.String?
    /// Well-Architected discovery configuration settings to associate to the workload.
    public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    /// The environment for the workload.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The improvement status for a workload.
    public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
    public var isReviewOwnerUpdateAcknowledged: Swift.Bool?
    /// Configuration of the Jira integration.
    public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    public var workloadName: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        applications: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        isReviewOwnerUpdateAcknowledged: Swift.Bool? = nil,
        jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.applications = applications
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.discoveryConfig = discoveryConfig
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.jiraConfiguration = jiraConfiguration
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

struct UpdateWorkloadInputBody {
    let workloadName: Swift.String?
    let description: Swift.String?
    let environment: WellArchitectedClientTypes.WorkloadEnvironment?
    let accountIds: [Swift.String]?
    let awsRegions: [Swift.String]?
    let nonAwsRegions: [Swift.String]?
    let pillarPriorities: [Swift.String]?
    let architecturalDesign: Swift.String?
    let reviewOwner: Swift.String?
    let isReviewOwnerUpdateAcknowledged: Swift.Bool?
    let industryType: Swift.String?
    let industry: Swift.String?
    let notes: Swift.String?
    let improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
    let discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    let applications: [Swift.String]?
    let jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
}

extension UpdateWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case applications = "Applications"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case discoveryConfig = "DiscoveryConfig"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case jiraConfiguration = "JiraConfiguration"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case pillarPriorities = "PillarPriorities"
        case reviewOwner = "ReviewOwner"
        case workloadName = "WorkloadName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let discoveryConfigDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadDiscoveryConfig.self, forKey: .discoveryConfig)
        discoveryConfig = discoveryConfigDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applications)
        var applicationsDecoded0:[Swift.String]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [Swift.String]()
            for string0 in applicationsContainer {
                if let string0 = string0 {
                    applicationsDecoded0?.append(string0)
                }
            }
        }
        applications = applicationsDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadJiraConfigurationInput.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension UpdateWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

/// Output of an update workload call.
public struct UpdateWorkloadOutput {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init(
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

struct UpdateWorkloadOutputBody {
    let workload: WellArchitectedClientTypes.Workload?
}

extension UpdateWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload = "Workload"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Workload.self, forKey: .workload)
        workload = workloadDecoded
    }
}

enum UpdateWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkloadShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
    }
}

extension UpdateWorkloadShareInput {

    static func urlPathProvider(_ value: UpdateWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareInput {
    /// Permission granted on a share request.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

struct UpdateWorkloadShareInputBody {
    let permissionType: WellArchitectedClientTypes.PermissionType?
}

extension UpdateWorkloadShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
    }
}

extension UpdateWorkloadShareOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkloadShareOutputBody = try responseDecoder.decode(responseBody: data)
            self.workloadId = output.workloadId
            self.workloadShare = output.workloadShare
        } else {
            self.workloadId = nil
            self.workloadShare = nil
        }
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareOutput {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A workload share return object.
    public var workloadShare: WellArchitectedClientTypes.WorkloadShare?

    public init(
        workloadId: Swift.String? = nil,
        workloadShare: WellArchitectedClientTypes.WorkloadShare? = nil
    )
    {
        self.workloadId = workloadId
        self.workloadShare = workloadShare
    }
}

struct UpdateWorkloadShareOutputBody {
    let workloadId: Swift.String?
    let workloadShare: WellArchitectedClientTypes.WorkloadShare?
}

extension UpdateWorkloadShareOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadId = "WorkloadId"
        case workloadShare = "WorkloadShare"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadShareDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadShare.self, forKey: .workloadShare)
        workloadShare = workloadShareDecoded
    }
}

enum UpdateWorkloadShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradeLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = self.milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

extension UpgradeLensReviewInput {

    static func urlPathProvider(_ value: UpgradeLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
    }
}

public struct UpgradeLensReviewInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

struct UpgradeLensReviewInputBody {
    let milestoneName: Swift.String?
    let clientRequestToken: Swift.String?
}

extension UpgradeLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpgradeLensReviewOutput {

    public init() { }
}

enum UpgradeLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradeProfileVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let milestoneName = self.milestoneName {
            try encodeContainer.encode(milestoneName, forKey: .milestoneName)
        }
    }
}

extension UpgradeProfileVersionInput {

    static func urlPathProvider(_ value: UpgradeProfileVersionInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/profiles/\(profileArn.urlPercentEncoding())/upgrade"
    }
}

public struct UpgradeProfileVersionInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    public var milestoneName: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.profileArn = profileArn
        self.workloadId = workloadId
    }
}

struct UpgradeProfileVersionInputBody {
    let milestoneName: Swift.String?
    let clientRequestToken: Swift.String?
}

extension UpgradeProfileVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case milestoneName = "MilestoneName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let milestoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .milestoneName)
        milestoneName = milestoneNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeProfileVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpgradeProfileVersionOutput {

    public init() { }
}

enum UpgradeProfileVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradeReviewTemplateLensReviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
    }
}

extension UpgradeReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: UpgradeReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
    }
}

public struct UpgradeReviewTemplateLensReviewInput {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ARN of the review template.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

struct UpgradeReviewTemplateLensReviewInputBody {
    let clientRequestToken: Swift.String?
}

extension UpgradeReviewTemplateLensReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension UpgradeReviewTemplateLensReviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpgradeReviewTemplateLensReviewOutput {

    public init() { }
}

enum UpgradeReviewTemplateLensReviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user input is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why the request failed validation.
        public internal(set) var reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let reason: WellArchitectedClientTypes.ValidationExceptionReason?
    let fields: [WellArchitectedClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[WellArchitectedClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [WellArchitectedClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension WellArchitectedClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField {
        /// Description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name for which validation failed.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WellArchitectedClientTypes {
    /// The reason why the request failed validation.
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.VersionDifferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pillarDifferences = "PillarDifferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pillarDifferences = pillarDifferences {
            var pillarDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarDifferences)
            for pillardifference0 in pillarDifferences {
                try pillarDifferencesContainer.encode(pillardifference0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pillarDifferencesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.PillarDifference?].self, forKey: .pillarDifferences)
        var pillarDifferencesDecoded0:[WellArchitectedClientTypes.PillarDifference]? = nil
        if let pillarDifferencesContainer = pillarDifferencesContainer {
            pillarDifferencesDecoded0 = [WellArchitectedClientTypes.PillarDifference]()
            for structure0 in pillarDifferencesContainer {
                if let structure0 = structure0 {
                    pillarDifferencesDecoded0?.append(structure0)
                }
            }
        }
        pillarDifferences = pillarDifferencesDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// The differences between the base and latest versions of the lens.
    public struct VersionDifferences {
        /// The differences between the base and latest versions of the lens.
        public var pillarDifferences: [WellArchitectedClientTypes.PillarDifference]?

        public init(
            pillarDifferences: [WellArchitectedClientTypes.PillarDifference]? = nil
        )
        {
            self.pillarDifferences = pillarDifferences
        }
    }

}

public enum WellArchitectedClientTypes {}

extension WellArchitectedClientTypes.Workload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case applications = "Applications"
        case architecturalDesign = "ArchitecturalDesign"
        case awsRegions = "AwsRegions"
        case description = "Description"
        case discoveryConfig = "DiscoveryConfig"
        case environment = "Environment"
        case improvementStatus = "ImprovementStatus"
        case industry = "Industry"
        case industryType = "IndustryType"
        case isReviewOwnerUpdateAcknowledged = "IsReviewOwnerUpdateAcknowledged"
        case jiraConfiguration = "JiraConfiguration"
        case lenses = "Lenses"
        case nonAwsRegions = "NonAwsRegions"
        case notes = "Notes"
        case owner = "Owner"
        case pillarPriorities = "PillarPriorities"
        case prioritizedRiskCounts = "PrioritizedRiskCounts"
        case profiles = "Profiles"
        case reviewOwner = "ReviewOwner"
        case reviewRestrictionDate = "ReviewRestrictionDate"
        case riskCounts = "RiskCounts"
        case shareInvitationId = "ShareInvitationId"
        case tags = "Tags"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for awsaccountid0 in accountIds {
                try accountIdsContainer.encode(awsaccountid0)
            }
        }
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applicationarn0 in applications {
                try applicationsContainer.encode(applicationarn0)
            }
        }
        if let architecturalDesign = self.architecturalDesign {
            try encodeContainer.encode(architecturalDesign, forKey: .architecturalDesign)
        }
        if let awsRegions = awsRegions {
            var awsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsRegions)
            for awsregion0 in awsRegions {
                try awsRegionsContainer.encode(awsregion0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let discoveryConfig = self.discoveryConfig {
            try encodeContainer.encode(discoveryConfig, forKey: .discoveryConfig)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment.rawValue, forKey: .environment)
        }
        if let improvementStatus = self.improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let industry = self.industry {
            try encodeContainer.encode(industry, forKey: .industry)
        }
        if let industryType = self.industryType {
            try encodeContainer.encode(industryType, forKey: .industryType)
        }
        if let isReviewOwnerUpdateAcknowledged = self.isReviewOwnerUpdateAcknowledged {
            try encodeContainer.encode(isReviewOwnerUpdateAcknowledged, forKey: .isReviewOwnerUpdateAcknowledged)
        }
        if let jiraConfiguration = self.jiraConfiguration {
            try encodeContainer.encode(jiraConfiguration, forKey: .jiraConfiguration)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let nonAwsRegions = nonAwsRegions {
            var nonAwsRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonAwsRegions)
            for workloadnonawsregion0 in nonAwsRegions {
                try nonAwsRegionsContainer.encode(workloadnonawsregion0)
            }
        }
        if let notes = self.notes {
            try encodeContainer.encode(notes, forKey: .notes)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let pillarPriorities = pillarPriorities {
            var pillarPrioritiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillarPriorities)
            for pillarid0 in pillarPriorities {
                try pillarPrioritiesContainer.encode(pillarid0)
            }
        }
        if let prioritizedRiskCounts = prioritizedRiskCounts {
            var prioritizedRiskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .prioritizedRiskCounts)
            for (dictKey0, riskCounts0) in prioritizedRiskCounts {
                try prioritizedRiskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let profiles = profiles {
            var profilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profiles)
            for workloadprofile0 in profiles {
                try profilesContainer.encode(workloadprofile0)
            }
        }
        if let reviewOwner = self.reviewOwner {
            try encodeContainer.encode(reviewOwner, forKey: .reviewOwner)
        }
        if let reviewRestrictionDate = self.reviewRestrictionDate {
            try encodeContainer.encodeTimestamp(reviewRestrictionDate, format: .epochSeconds, forKey: .reviewRestrictionDate)
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let shareInvitationId = self.shareInvitationId {
            try encodeContainer.encode(shareInvitationId, forKey: .shareInvitationId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workloadArn = self.workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let awsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsRegions)
        var awsRegionsDecoded0:[Swift.String]? = nil
        if let awsRegionsContainer = awsRegionsContainer {
            awsRegionsDecoded0 = [Swift.String]()
            for string0 in awsRegionsContainer {
                if let string0 = string0 {
                    awsRegionsDecoded0?.append(string0)
                }
            }
        }
        awsRegions = awsRegionsDecoded0
        let nonAwsRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonAwsRegions)
        var nonAwsRegionsDecoded0:[Swift.String]? = nil
        if let nonAwsRegionsContainer = nonAwsRegionsContainer {
            nonAwsRegionsDecoded0 = [Swift.String]()
            for string0 in nonAwsRegionsContainer {
                if let string0 = string0 {
                    nonAwsRegionsDecoded0?.append(string0)
                }
            }
        }
        nonAwsRegions = nonAwsRegionsDecoded0
        let architecturalDesignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecturalDesign)
        architecturalDesign = architecturalDesignDecoded
        let reviewOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reviewOwner)
        reviewOwner = reviewOwnerDecoded
        let reviewRestrictionDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .reviewRestrictionDate)
        reviewRestrictionDate = reviewRestrictionDateDecoded
        let isReviewOwnerUpdateAcknowledgedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReviewOwnerUpdateAcknowledged)
        isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledgedDecoded
        let industryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industryType)
        industryType = industryTypeDecoded
        let industryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .industry)
        industry = industryDecoded
        let notesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notes)
        notes = notesDecoded
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let pillarPrioritiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pillarPriorities)
        var pillarPrioritiesDecoded0:[Swift.String]? = nil
        if let pillarPrioritiesContainer = pillarPrioritiesContainer {
            pillarPrioritiesDecoded0 = [Swift.String]()
            for string0 in pillarPrioritiesContainer {
                if let string0 = string0 {
                    pillarPrioritiesDecoded0?.append(string0)
                }
            }
        }
        pillarPriorities = pillarPrioritiesDecoded0
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shareInvitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareInvitationId)
        shareInvitationId = shareInvitationIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let discoveryConfigDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadDiscoveryConfig.self, forKey: .discoveryConfig)
        discoveryConfig = discoveryConfigDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applications)
        var applicationsDecoded0:[Swift.String]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [Swift.String]()
            for string0 in applicationsContainer {
                if let string0 = string0 {
                    applicationsDecoded0?.append(string0)
                }
            }
        }
        applications = applicationsDecoded0
        let profilesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadProfile?].self, forKey: .profiles)
        var profilesDecoded0:[WellArchitectedClientTypes.WorkloadProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [WellArchitectedClientTypes.WorkloadProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let prioritizedRiskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .prioritizedRiskCounts)
        var prioritizedRiskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let prioritizedRiskCountsContainer = prioritizedRiskCountsContainer {
            prioritizedRiskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in prioritizedRiskCountsContainer {
                if let count0 = count0 {
                    prioritizedRiskCountsDecoded0?[key0] = count0
                }
            }
        }
        prioritizedRiskCounts = prioritizedRiskCountsDecoded0
        let jiraConfigurationDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadJiraConfigurationOutput.self, forKey: .jiraConfiguration)
        jiraConfiguration = jiraConfigurationDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload return object.
    public struct Workload {
        /// The list of Amazon Web Services account IDs associated with the workload.
        public var accountIds: [Swift.String]?
        /// List of AppRegistry application ARNs associated to the workload.
        public var applications: [Swift.String]?
        /// The URL of the architectural design for the workload.
        public var architecturalDesign: Swift.String?
        /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
        public var awsRegions: [Swift.String]?
        /// The description for the workload.
        public var description: Swift.String?
        /// Discovery configuration associated to the workload.
        public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
        /// The environment for the workload.
        public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The industry for the workload.
        public var industry: Swift.String?
        /// The industry type for the workload. If specified, must be one of the following:
        ///
        /// * Agriculture
        ///
        /// * Automobile
        ///
        /// * Defense
        ///
        /// * Design and Engineering
        ///
        /// * Digital Advertising
        ///
        /// * Education
        ///
        /// * Environmental Protection
        ///
        /// * Financial Services
        ///
        /// * Gaming
        ///
        /// * General Public Services
        ///
        /// * Healthcare
        ///
        /// * Hospitality
        ///
        /// * InfoTech
        ///
        /// * Justice and Public Safety
        ///
        /// * Life Sciences
        ///
        /// * Manufacturing
        ///
        /// * Media & Entertainment
        ///
        /// * Mining & Resources
        ///
        /// * Oil & Gas
        ///
        /// * Power & Utilities
        ///
        /// * Professional Services
        ///
        /// * Real Estate & Construction
        ///
        /// * Retail & Wholesale
        ///
        /// * Social Protection
        ///
        /// * Telecommunications
        ///
        /// * Travel, Transportation & Logistics
        ///
        /// * Other
        public var industryType: Swift.String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public var isReviewOwnerUpdateAcknowledged: Swift.Bool?
        /// Jira configuration for a specific workload.
        public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationOutput?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
        public var lenses: [Swift.String]?
        /// The list of non-Amazon Web Services Regions associated with the workload.
        public var nonAwsRegions: [Swift.String]?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
        public var pillarPriorities: [Swift.String]?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String:Swift.Int]?
        /// Profile associated with a workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
        public var reviewOwner: Swift.String?
        /// The date and time recorded.
        public var reviewRestrictionDate: ClientRuntime.Date?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags associated with the workload.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            accountIds: [Swift.String]? = nil,
            applications: [Swift.String]? = nil,
            architecturalDesign: Swift.String? = nil,
            awsRegions: [Swift.String]? = nil,
            description: Swift.String? = nil,
            discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
            environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            industry: Swift.String? = nil,
            industryType: Swift.String? = nil,
            isReviewOwnerUpdateAcknowledged: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationOutput? = nil,
            lenses: [Swift.String]? = nil,
            nonAwsRegions: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            pillarPriorities: [Swift.String]? = nil,
            prioritizedRiskCounts: [Swift.String:Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            reviewOwner: Swift.String? = nil,
            reviewRestrictionDate: ClientRuntime.Date? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.accountIds = accountIds
            self.applications = applications
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.discoveryConfig = discoveryConfig
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.jiraConfiguration = jiraConfiguration
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.owner = owner
            self.pillarPriorities = pillarPriorities
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.reviewOwner = reviewOwner
            self.reviewRestrictionDate = reviewRestrictionDate
            self.riskCounts = riskCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes.WorkloadDiscoveryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedAdvisorIntegrationStatus = "TrustedAdvisorIntegrationStatus"
        case workloadResourceDefinition = "WorkloadResourceDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustedAdvisorIntegrationStatus = self.trustedAdvisorIntegrationStatus {
            try encodeContainer.encode(trustedAdvisorIntegrationStatus.rawValue, forKey: .trustedAdvisorIntegrationStatus)
        }
        if let workloadResourceDefinition = workloadResourceDefinition {
            var workloadResourceDefinitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workloadResourceDefinition)
            for definitiontype0 in workloadResourceDefinition {
                try workloadResourceDefinitionContainer.encode(definitiontype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedAdvisorIntegrationStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.TrustedAdvisorIntegrationStatus.self, forKey: .trustedAdvisorIntegrationStatus)
        trustedAdvisorIntegrationStatus = trustedAdvisorIntegrationStatusDecoded
        let workloadResourceDefinitionContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.DefinitionType?].self, forKey: .workloadResourceDefinition)
        var workloadResourceDefinitionDecoded0:[WellArchitectedClientTypes.DefinitionType]? = nil
        if let workloadResourceDefinitionContainer = workloadResourceDefinitionContainer {
            workloadResourceDefinitionDecoded0 = [WellArchitectedClientTypes.DefinitionType]()
            for enum0 in workloadResourceDefinitionContainer {
                if let enum0 = enum0 {
                    workloadResourceDefinitionDecoded0?.append(enum0)
                }
            }
        }
        workloadResourceDefinition = workloadResourceDefinitionDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// Discovery configuration associated to the workload.
    public struct WorkloadDiscoveryConfig {
        /// Discovery integration status in respect to Trusted Advisor for the workload.
        public var trustedAdvisorIntegrationStatus: WellArchitectedClientTypes.TrustedAdvisorIntegrationStatus?
        /// The mode to use for identifying resources associated with the workload. You can specify WORKLOAD_METADATA, APP_REGISTRY, or both.
        public var workloadResourceDefinition: [WellArchitectedClientTypes.DefinitionType]?

        public init(
            trustedAdvisorIntegrationStatus: WellArchitectedClientTypes.TrustedAdvisorIntegrationStatus? = nil,
            workloadResourceDefinition: [WellArchitectedClientTypes.DefinitionType]? = nil
        )
        {
            self.trustedAdvisorIntegrationStatus = trustedAdvisorIntegrationStatus
            self.workloadResourceDefinition = workloadResourceDefinition
        }
    }

}

extension WellArchitectedClientTypes {
    /// The environment for the workload.
    public enum WorkloadEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preproduction
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEnvironment] {
            return [
                .preproduction,
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preproduction: return "PREPRODUCTION"
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadEnvironment(rawValue: rawValue) ?? WorkloadEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    /// The improvement status for a workload.
    public enum WorkloadImprovementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case inProgress
        case notApplicable
        case notStarted
        case riskAcknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadImprovementStatus] {
            return [
                .complete,
                .inProgress,
                .notApplicable,
                .notStarted,
                .riskAcknowledged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .notApplicable: return "NOT_APPLICABLE"
            case .notStarted: return "NOT_STARTED"
            case .riskAcknowledged: return "RISK_ACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadImprovementStatus(rawValue: rawValue) ?? WorkloadImprovementStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes {
    public enum WorkloadIssueManagementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case inherit
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadIssueManagementStatus] {
            return [
                .disabled,
                .enabled,
                .inherit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .inherit: return "INHERIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadIssueManagementStatus(rawValue: rawValue) ?? WorkloadIssueManagementStatus.sdkUnknown(rawValue)
        }
    }
}

extension WellArchitectedClientTypes.WorkloadJiraConfigurationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issueManagementStatus = "IssueManagementStatus"
        case issueManagementType = "IssueManagementType"
        case jiraProjectKey = "JiraProjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issueManagementStatus = self.issueManagementStatus {
            try encodeContainer.encode(issueManagementStatus.rawValue, forKey: .issueManagementStatus)
        }
        if let issueManagementType = self.issueManagementType {
            try encodeContainer.encode(issueManagementType.rawValue, forKey: .issueManagementType)
        }
        if let jiraProjectKey = self.jiraProjectKey {
            try encodeContainer.encode(jiraProjectKey, forKey: .jiraProjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issueManagementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadIssueManagementStatus.self, forKey: .issueManagementStatus)
        issueManagementStatus = issueManagementStatusDecoded
        let issueManagementTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IssueManagementType.self, forKey: .issueManagementType)
        issueManagementType = issueManagementTypeDecoded
        let jiraProjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jiraProjectKey)
        jiraProjectKey = jiraProjectKeyDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Workload-level: Input for the Jira configuration.
    public struct WorkloadJiraConfigurationInput {
        /// Workload-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus?
        /// Workload-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Workload-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?

        public init(
            issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil
        )
        {
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
        }
    }

}

extension WellArchitectedClientTypes.WorkloadJiraConfigurationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issueManagementStatus = "IssueManagementStatus"
        case issueManagementType = "IssueManagementType"
        case jiraProjectKey = "JiraProjectKey"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issueManagementStatus = self.issueManagementStatus {
            try encodeContainer.encode(issueManagementStatus.rawValue, forKey: .issueManagementStatus)
        }
        if let issueManagementType = self.issueManagementType {
            try encodeContainer.encode(issueManagementType.rawValue, forKey: .issueManagementType)
        }
        if let jiraProjectKey = self.jiraProjectKey {
            try encodeContainer.encode(jiraProjectKey, forKey: .jiraProjectKey)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issueManagementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadIssueManagementStatus.self, forKey: .issueManagementStatus)
        issueManagementStatus = issueManagementStatusDecoded
        let issueManagementTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.IssueManagementType.self, forKey: .issueManagementType)
        issueManagementType = issueManagementTypeDecoded
        let jiraProjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jiraProjectKey)
        jiraProjectKey = jiraProjectKeyDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// Workload-level: Output configuration of the Jira integration.
    public struct WorkloadJiraConfigurationOutput {
        /// Workload-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus?
        /// Workload-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Workload-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?
        /// Workload-level: Status message on configuration of the Jira integration.
        public var statusMessage: Swift.String?

        public init(
            issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
            self.statusMessage = statusMessage
        }
    }

}

extension WellArchitectedClientTypes.WorkloadProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
        case profileVersion = "ProfileVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = self.profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileVersion = self.profileVersion {
            try encodeContainer.encode(profileVersion, forKey: .profileVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileVersion)
        profileVersion = profileVersionDecoded
    }
}

extension WellArchitectedClientTypes {
    /// The profile associated with a workload.
    public struct WorkloadProfile {
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile version.
        public var profileVersion: Swift.String?

        public init(
            profileArn: Swift.String? = nil,
            profileVersion: Swift.String? = nil
        )
        {
            self.profileArn = profileArn
            self.profileVersion = profileVersion
        }
    }

}

extension WellArchitectedClientTypes.WorkloadShare: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedBy = "SharedBy"
        case sharedWith = "SharedWith"
        case status = "Status"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedBy = self.sharedBy {
            try encodeContainer.encode(sharedBy, forKey: .sharedBy)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedBy)
        sharedBy = sharedByDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload share return object.
    public struct WorkloadShare {
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.status = status
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}

extension WellArchitectedClientTypes.WorkloadShareSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionType = "PermissionType"
        case shareId = "ShareId"
        case sharedWith = "SharedWith"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let shareId = self.shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let sharedWith = self.sharedWith {
            try encodeContainer.encode(sharedWith, forKey: .sharedWith)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let sharedWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedWith)
        sharedWith = sharedWithDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WellArchitectedClientTypes {
    /// A workload share summary return object.
    public struct WorkloadShareSummary {
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Optional message to compliment the Status field.
        public var statusMessage: Swift.String?

        public init(
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension WellArchitectedClientTypes.WorkloadSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case improvementStatus = "ImprovementStatus"
        case lenses = "Lenses"
        case owner = "Owner"
        case prioritizedRiskCounts = "PrioritizedRiskCounts"
        case profiles = "Profiles"
        case riskCounts = "RiskCounts"
        case updatedAt = "UpdatedAt"
        case workloadArn = "WorkloadArn"
        case workloadId = "WorkloadId"
        case workloadName = "WorkloadName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let improvementStatus = self.improvementStatus {
            try encodeContainer.encode(improvementStatus.rawValue, forKey: .improvementStatus)
        }
        if let lenses = lenses {
            var lensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lenses)
            for lensalias0 in lenses {
                try lensesContainer.encode(lensalias0)
            }
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let prioritizedRiskCounts = prioritizedRiskCounts {
            var prioritizedRiskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .prioritizedRiskCounts)
            for (dictKey0, riskCounts0) in prioritizedRiskCounts {
                try prioritizedRiskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let profiles = profiles {
            var profilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .profiles)
            for workloadprofile0 in profiles {
                try profilesContainer.encode(workloadprofile0)
            }
        }
        if let riskCounts = riskCounts {
            var riskCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .riskCounts)
            for (dictKey0, riskCounts0) in riskCounts {
                try riskCountsContainer.encode(riskCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let workloadArn = self.workloadArn {
            try encodeContainer.encode(workloadArn, forKey: .workloadArn)
        }
        if let workloadId = self.workloadId {
            try encodeContainer.encode(workloadId, forKey: .workloadId)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadId)
        workloadId = workloadIdDecoded
        let workloadArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadArn)
        workloadArn = workloadArnDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lensesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .lenses)
        var lensesDecoded0:[Swift.String]? = nil
        if let lensesContainer = lensesContainer {
            lensesDecoded0 = [Swift.String]()
            for string0 in lensesContainer {
                if let string0 = string0 {
                    lensesDecoded0?.append(string0)
                }
            }
        }
        lenses = lensesDecoded0
        let riskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .riskCounts)
        var riskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let riskCountsContainer = riskCountsContainer {
            riskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in riskCountsContainer {
                if let count0 = count0 {
                    riskCountsDecoded0?[key0] = count0
                }
            }
        }
        riskCounts = riskCountsDecoded0
        let improvementStatusDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.WorkloadImprovementStatus.self, forKey: .improvementStatus)
        improvementStatus = improvementStatusDecoded
        let profilesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.WorkloadProfile?].self, forKey: .profiles)
        var profilesDecoded0:[WellArchitectedClientTypes.WorkloadProfile]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [WellArchitectedClientTypes.WorkloadProfile]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let prioritizedRiskCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .prioritizedRiskCounts)
        var prioritizedRiskCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let prioritizedRiskCountsContainer = prioritizedRiskCountsContainer {
            prioritizedRiskCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in prioritizedRiskCountsContainer {
                if let count0 = count0 {
                    prioritizedRiskCountsDecoded0?[key0] = count0
                }
            }
        }
        prioritizedRiskCounts = prioritizedRiskCountsDecoded0
    }
}

extension WellArchitectedClientTypes {
    /// A workload summary return object.
    public struct WorkloadSummary {
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String:Swift.Int]?
        /// Profile associated with a workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String:Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: ClientRuntime.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String:Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String:Swift.Int]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.improvementStatus = improvementStatus
            self.lenses = lenses
            self.owner = owner
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }

}
