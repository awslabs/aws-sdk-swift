//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct AssociateLensesOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateProfilesOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLensOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLensShareOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProfileShareOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteReviewTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTemplateShareOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkloadOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkloadShareOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateLensesOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateProfilesOutput: Swift.Sendable {

    public init() { }
}

public struct GetGlobalSettingsInput: Swift.Sendable {

    public init() { }
}

public struct UpdateGlobalSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateIntegrationOutput: Swift.Sendable {

    public init() { }
}

public struct UpgradeLensReviewOutput: Swift.Sendable {

    public init() { }
}

public struct UpgradeProfileVersionOutput: Swift.Sendable {

    public init() { }
}

public struct UpgradeReviewTemplateLensReviewOutput: Swift.Sendable {

    public init() { }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WellArchitectedClientTypes {

    public enum IntegrationStatusInput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationStatusInput] {
            return [
                .notConfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum AccountJiraIssueManagementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountJiraIssueManagementStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum IssueManagementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [IssueManagementType] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Account-level: Input for the Jira configuration.
    public struct AccountJiraConfigurationInput: Swift.Sendable {
        /// Account-level: Configuration status of the Jira integration.
        public var integrationStatus: WellArchitectedClientTypes.IntegrationStatusInput?
        /// Account-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus?
        /// Account-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Account-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?

        public init(
            integrationStatus: WellArchitectedClientTypes.IntegrationStatusInput? = nil,
            issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil
        )
        {
            self.integrationStatus = integrationStatus
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
        }
    }
}

extension WellArchitectedClientTypes {

    public enum IntegrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configured
        case notConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationStatus] {
            return [
                .configured,
                .notConfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notConfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Account-level: Output configuration of the Jira integration.
    public struct AccountJiraConfigurationOutput: Swift.Sendable {
        /// Account-level: Configuration status of the Jira integration.
        public var integrationStatus: WellArchitectedClientTypes.IntegrationStatus?
        /// Account-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus?
        /// Account-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Account-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?
        /// Account-level: Status message on configuration of the Jira integration.
        public var statusMessage: Swift.String?
        /// Account-level: Jira subdomain URL.
        public var subdomain: Swift.String?

        public init(
            integrationStatus: WellArchitectedClientTypes.IntegrationStatus? = nil,
            issueManagementStatus: WellArchitectedClientTypes.AccountJiraIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            subdomain: Swift.String? = nil
        )
        {
            self.integrationStatus = integrationStatus
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
            self.statusMessage = statusMessage
            self.subdomain = subdomain
        }
    }
}

extension WellArchitectedClientTypes {

    public enum CheckStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case fetchFailed
        case notAvailable
        case okay
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckStatus] {
            return [
                .error,
                .fetchFailed,
                .notAvailable,
                .okay,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .fetchFailed: return "FETCH_FAILED"
            case .notAvailable: return "NOT_AVAILABLE"
            case .okay: return "OKAY"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// The choice content.
    public struct ChoiceContent: Swift.Sendable {
        /// The display text for the choice content.
        public var displayText: Swift.String?
        /// The URL for the choice content.
        public var url: Swift.String?

        public init(
            displayText: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.displayText = displayText
            self.url = url
        }
    }
}

extension WellArchitectedClientTypes {

    public enum AdditionalResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case helpfulResource
        case improvementPlan
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalResourceType] {
            return [
                .helpfulResource,
                .improvementPlan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .helpfulResource: return "HELPFUL_RESOURCE"
            case .improvementPlan: return "IMPROVEMENT_PLAN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// The choice level additional resources for a custom lens. This field does not apply to Amazon Web Services official lenses.
    public struct AdditionalResources: Swift.Sendable {
        /// The URLs for additional resources, either helpful resources or improvement plans, for a custom lens. Up to five additional URLs can be specified.
        public var content: [WellArchitectedClientTypes.ChoiceContent]?
        /// Type of additional resource for a custom lens.
        public var type: WellArchitectedClientTypes.AdditionalResourceType?

        public init(
            content: [WellArchitectedClientTypes.ChoiceContent]? = nil,
            type: WellArchitectedClientTypes.AdditionalResourceType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }
}

extension WellArchitectedClientTypes {

    public enum ChoiceReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum ChoiceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notApplicable
        case selected
        case unselected
        case sdkUnknown(Swift.String)

        public static var allCases: [ChoiceStatus] {
            return [
                .notApplicable,
                .selected,
                .unselected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notApplicable: return "NOT_APPLICABLE"
            case .selected: return "SELECTED"
            case .unselected: return "UNSELECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A choice that has been answered on a question in your workload.
    public struct ChoiceAnswer: Swift.Sendable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            choiceId: Swift.String? = nil,
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }
}

extension WellArchitectedClientTypes {

    /// A choice available to answer question.
    public struct Choice: Swift.Sendable {
        /// The additional resources for a choice in a custom lens. A choice can have up to two additional resources: one of type HELPFUL_RESOURCE, one of type IMPROVEMENT_PLAN, or both.
        public var additionalResources: [WellArchitectedClientTypes.AdditionalResources]?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The description of a choice.
        public var description: Swift.String?
        /// The helpful resource (both text and URL) for a particular choice. This field only applies to custom lenses. Each choice can have only one helpful resource.
        public var helpfulResource: WellArchitectedClientTypes.ChoiceContent?
        /// The improvement plan (both text and URL) for a particular choice. This field only applies to custom lenses. Each choice can have only one improvement plan.
        public var improvementPlan: WellArchitectedClientTypes.ChoiceContent?
        /// The title of a choice.
        public var title: Swift.String?

        public init(
            additionalResources: [WellArchitectedClientTypes.AdditionalResources]? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            helpfulResource: WellArchitectedClientTypes.ChoiceContent? = nil,
            improvementPlan: WellArchitectedClientTypes.ChoiceContent? = nil,
            title: Swift.String? = nil
        )
        {
            self.additionalResources = additionalResources
            self.choiceId = choiceId
            self.description = description
            self.helpfulResource = helpfulResource
            self.improvementPlan = improvementPlan
            self.title = title
        }
    }
}

extension WellArchitectedClientTypes {

    /// Configuration of the Jira integration.
    public struct JiraConfiguration: Swift.Sendable {
        /// The URL of the associated Jira issue.
        public var jiraIssueUrl: Swift.String?
        /// The date and time recorded.
        public var lastSyncedTime: Foundation.Date?

        public init(
            jiraIssueUrl: Swift.String? = nil,
            lastSyncedTime: Foundation.Date? = nil
        )
        {
            self.jiraIssueUrl = jiraIssueUrl
            self.lastSyncedTime = lastSyncedTime
        }
    }
}

extension WellArchitectedClientTypes {

    public enum AnswerReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case architectureConstraints
        case businessPriorities
        case `none`
        case other
        case outOfScope
        case sdkUnknown(Swift.String)

        public static var allCases: [AnswerReason] {
            return [
                .architectureConstraints,
                .businessPriorities,
                .none,
                .other,
                .outOfScope
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .architectureConstraints: return "ARCHITECTURE_CONSTRAINTS"
            case .businessPriorities: return "BUSINESS_PRIORITIES"
            case .none: return "NONE"
            case .other: return "OTHER"
            case .outOfScope: return "OUT_OF_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// The risk for a given workload, lens review, pillar, or question.
    public enum Risk: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case medium
        case `none`
        case notApplicable
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Risk] {
            return [
                .high,
                .medium,
                .none,
                .notApplicable,
                .unanswered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .notApplicable: return "NOT_APPLICABLE"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// An answer of the question.
    public struct Answer: Swift.Sendable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed for a custom lens. This field does not apply to Amazon Web Services official lenses.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL. For Amazon Web Services official lenses, this is the helpful resource URL for a question or choice. For custom lenses, this is the helpful resource URL for a question and is only provided if HelpfulResourceDisplayText was specified for the question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.jiraConfiguration = jiraConfiguration
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }
}

extension WellArchitectedClientTypes {

    /// A choice summary that has been answered on a question in your workload.
    public struct ChoiceAnswerSummary: Swift.Sendable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            choiceId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.choiceId = choiceId
            self.reason = reason
            self.status = status
        }
    }
}

extension WellArchitectedClientTypes {

    public enum QuestionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonPrioritized
        case prioritized
        case sdkUnknown(Swift.String)

        public static var allCases: [QuestionType] {
            return [
                .nonPrioritized,
                .prioritized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonPrioritized: return "NON_PRIORITIZED"
            case .prioritized: return "PRIORITIZED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// An answer summary of a lens review in a workload.
    public struct AnswerSummary: Swift.Sendable {
        /// A list of selected choices to a question in your workload.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The type of the question.
        public var questionType: WellArchitectedClientTypes.QuestionType?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            questionType: WellArchitectedClientTypes.QuestionType? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.jiraConfiguration = jiraConfiguration
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.questionType = questionType
            self.reason = reason
            self.risk = risk
            self.selectedChoices = selectedChoices
        }
    }
}

/// The resource has already been processed, was deleted, or is too large.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// There is a problem with the Well-Architected Tool API service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension WellArchitectedClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// The field name for which validation failed.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension WellArchitectedClientTypes {

    /// The reason why the request failed validation.
    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The user input is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why the request failed validation.
        public internal(set) var reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [WellArchitectedClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WellArchitectedClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// Input to associate lens reviews.
public struct AssociateLensesInput: Swift.Sendable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

public struct AssociateProfilesInput: Swift.Sendable {
    /// The list of profile ARNs to associate with the workload.
    /// This member is required.
    public var profileArns: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        profileArns: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.profileArns = profileArns
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// A best practice, or question choice, that has been identified as a risk in this question.
    public struct BestPractice: Swift.Sendable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }
}

extension WellArchitectedClientTypes {

    public enum CheckProvider: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case trustedAdvisor
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckProvider] {
            return [
                .trustedAdvisor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .trustedAdvisor: return "TRUSTED_ADVISOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum CheckFailureReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case assumeRoleError
        case premiumSupportRequired
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckFailureReason] {
            return [
                .accessDenied,
                .assumeRoleError,
                .premiumSupportRequired,
                .unknownError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .assumeRoleError: return "ASSUME_ROLE_ERROR"
            case .premiumSupportRequired: return "PREMIUM_SUPPORT_REQUIRED"
            case .unknownError: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Account details for a Well-Architected best practice in relation to Trusted Advisor checks.
    public struct CheckDetail: Swift.Sendable {
        /// An Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// Trusted Advisor check description.
        public var description: Swift.String?
        /// Count of flagged resources associated to the check.
        public var flaggedResources: Swift.Int?
        /// Trusted Advisor check ID.
        public var id: Swift.String?
        /// Well-Architected Lens ARN associated to the check.
        public var lensArn: Swift.String?
        /// Trusted Advisor check name.
        public var name: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Provider of the check related to the best practice.
        public var provider: WellArchitectedClientTypes.CheckProvider?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// Reason associated to the check.
        public var reason: WellArchitectedClientTypes.CheckFailureReason?
        /// Status associated to the check.
        public var status: WellArchitectedClientTypes.CheckStatus?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            flaggedResources: Swift.Int? = nil,
            id: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            name: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            provider: WellArchitectedClientTypes.CheckProvider? = nil,
            questionId: Swift.String? = nil,
            reason: WellArchitectedClientTypes.CheckFailureReason? = nil,
            status: WellArchitectedClientTypes.CheckStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.accountId = accountId
            self.choiceId = choiceId
            self.description = description
            self.flaggedResources = flaggedResources
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.reason = reason
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension WellArchitectedClientTypes {

    /// Trusted Advisor check summary.
    public struct CheckSummary: Swift.Sendable {
        /// Account summary associated to the check.
        public var accountSummary: [Swift.String: Swift.Int]?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// Trusted Advisor check description.
        public var description: Swift.String?
        /// Trusted Advisor check ID.
        public var id: Swift.String?
        /// Well-Architected Lens ARN associated to the check.
        public var lensArn: Swift.String?
        /// Trusted Advisor check name.
        public var name: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Provider of the check related to the best practice.
        public var provider: WellArchitectedClientTypes.CheckProvider?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// Status associated to the check.
        public var status: WellArchitectedClientTypes.CheckStatus?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            accountSummary: [Swift.String: Swift.Int]? = nil,
            choiceId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            name: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            provider: WellArchitectedClientTypes.CheckProvider? = nil,
            questionId: Swift.String? = nil,
            status: WellArchitectedClientTypes.CheckStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.accountSummary = accountSummary
            self.choiceId = choiceId
            self.description = description
            self.id = id
            self.lensArn = lensArn
            self.name = name
            self.pillarId = pillarId
            self.provider = provider
            self.questionId = questionId
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension WellArchitectedClientTypes {

    /// The choice level improvement plan.
    public struct ChoiceImprovementPlan: Swift.Sendable {
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The display text for the improvement plan.
        public var displayText: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?

        public init(
            choiceId: Swift.String? = nil,
            displayText: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil
        )
        {
            self.choiceId = choiceId
            self.displayText = displayText
            self.improvementPlanUrl = improvementPlanUrl
        }
    }
}

extension WellArchitectedClientTypes {

    /// A list of choices to be updated.
    public struct ChoiceUpdate: Swift.Sendable {
        /// The notes associated with a choice.
        public var notes: Swift.String?
        /// The reason why a choice is non-applicable to a question in your workload.
        public var reason: WellArchitectedClientTypes.ChoiceReason?
        /// The status of a choice.
        /// This member is required.
        public var status: WellArchitectedClientTypes.ChoiceStatus?

        public init(
            notes: Swift.String? = nil,
            reason: WellArchitectedClientTypes.ChoiceReason? = nil,
            status: WellArchitectedClientTypes.ChoiceStatus? = nil
        )
        {
            self.notes = notes
            self.reason = reason
            self.status = status
        }
    }
}

extension WellArchitectedClientTypes {

    /// A metric for a particular question in the pillar.
    public struct QuestionMetric: Swift.Sendable {
        /// The best practices, or choices, that have been identified as contributing to risk in a question.
        public var bestPractices: [WellArchitectedClientTypes.BestPractice]?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init(
            bestPractices: [WellArchitectedClientTypes.BestPractice]? = nil,
            questionId: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.bestPractices = bestPractices
            self.questionId = questionId
            self.risk = risk
        }
    }
}

extension WellArchitectedClientTypes {

    /// A metric for a particular pillar in a lens.
    public struct PillarMetric: Swift.Sendable {
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The questions that have been identified as risks in the pillar.
        public var questions: [WellArchitectedClientTypes.QuestionMetric]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?

        public init(
            pillarId: Swift.String? = nil,
            questions: [WellArchitectedClientTypes.QuestionMetric]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.pillarId = pillarId
            self.questions = questions
            self.riskCounts = riskCounts
        }
    }
}

extension WellArchitectedClientTypes {

    /// A metric for a particular lens in a workload.
    public struct LensMetric: Swift.Sendable {
        /// The lens ARN.
        public var lensArn: Swift.String?
        /// The metrics for the pillars in a lens.
        public var pillars: [WellArchitectedClientTypes.PillarMetric]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?

        public init(
            lensArn: Swift.String? = nil,
            pillars: [WellArchitectedClientTypes.PillarMetric]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.lensArn = lensArn
            self.pillars = pillars
            self.riskCounts = riskCounts
        }
    }
}

extension WellArchitectedClientTypes {

    public enum MetricType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricType] {
            return [
                .workload
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A metric that contributes to the consolidated report.
    public struct ConsolidatedReportMetric: Swift.Sendable {
        /// The metrics for the lenses in the workload.
        public var lenses: [WellArchitectedClientTypes.LensMetric]?
        /// The total number of lenses applied to the workload.
        public var lensesAppliedCount: Swift.Int?
        /// The metric type of a metric in the consolidated report. Currently only WORKLOAD metric types are supported.
        public var metricType: WellArchitectedClientTypes.MetricType?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            lenses: [WellArchitectedClientTypes.LensMetric]? = nil,
            lensesAppliedCount: Swift.Int? = nil,
            metricType: WellArchitectedClientTypes.MetricType? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lenses = lenses
            self.lensesAppliedCount = lensesAppliedCount
            self.metricType = metricType
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

/// The user has reached their resource quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct CreateLensShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.sharedWith = sharedWith
    }
}

public struct CreateLensShareOutput: Swift.Sendable {
    /// The ID associated with the share.
    public var shareId: Swift.String?

    public init(
        shareId: Swift.String? = nil
    )
    {
        self.shareId = shareId
    }
}

public struct CreateLensVersionInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Set to true if this new major lens version.
    public var isMajorVersion: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The version of the lens being created.
    /// This member is required.
    public var lensVersion: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        isMajorVersion: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.isMajorVersion = isMajorVersion
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

public struct CreateLensVersionOutput: Swift.Sendable {
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The version of the lens.
    public var lensVersion: Swift.String?

    public init(
        lensArn: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensArn = lensArn
        self.lensVersion = lensVersion
    }
}

/// Input for milestone creation.
public struct CreateMilestoneInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

/// Output of a create milestone call.
public struct CreateMilestoneOutput: Swift.Sendable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// An update to a profile question.
    public struct ProfileQuestionUpdate: Swift.Sendable {
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The selected choices.
        public var selectedChoiceIds: [Swift.String]?

        public init(
            questionId: Swift.String? = nil,
            selectedChoiceIds: [Swift.String]? = nil
        )
        {
            self.questionId = questionId
            self.selectedChoiceIds = selectedChoiceIds
        }
    }
}

public struct CreateProfileInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile description.
    /// This member is required.
    public var profileDescription: Swift.String?
    /// Name of the profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The profile questions.
    /// This member is required.
    public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?
    /// The tags assigned to the profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileDescription: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileDescription = profileDescription
        self.profileName = profileName
        self.profileQuestions = profileQuestions
        self.tags = tags
    }
}

public struct CreateProfileOutput: Swift.Sendable {
    /// The profile ARN.
    public var profileArn: Swift.String?
    /// Version of the profile.
    public var profileVersion: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        profileVersion: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.profileVersion = profileVersion
    }
}

public struct CreateProfileShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        sharedWith: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
        self.sharedWith = sharedWith
    }
}

public struct CreateProfileShareOutput: Swift.Sendable {
    /// The profile ARN.
    public var profileArn: Swift.String?
    /// The ID associated with the share.
    public var shareId: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.shareId = shareId
    }
}

public struct CreateReviewTemplateInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The review template description.
    /// This member is required.
    public var description: Swift.String?
    /// Lenses applied to the review template.
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The tags assigned to the review template.
    public var tags: [Swift.String: Swift.String]?
    /// Name of the review template.
    /// This member is required.
    public var templateName: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        lenses: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.lenses = lenses
        self.notes = notes
        self.tags = tags
        self.templateName = templateName
    }
}

public struct CreateReviewTemplateOutput: Swift.Sendable {
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        templateArn: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
    }
}

public struct CreateTemplateShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        sharedWith: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sharedWith = sharedWith
        self.templateArn = templateArn
    }
}

public struct CreateTemplateShareOutput: Swift.Sendable {
    /// The ID associated with the share.
    public var shareId: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        shareId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    public enum TrustedAdvisorIntegrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustedAdvisorIntegrationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum DefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appRegistry
        case workloadMetadata
        case sdkUnknown(Swift.String)

        public static var allCases: [DefinitionType] {
            return [
                .appRegistry,
                .workloadMetadata
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appRegistry: return "APP_REGISTRY"
            case .workloadMetadata: return "WORKLOAD_METADATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Discovery configuration associated to the workload.
    public struct WorkloadDiscoveryConfig: Swift.Sendable {
        /// Discovery integration status in respect to Trusted Advisor for the workload.
        public var trustedAdvisorIntegrationStatus: WellArchitectedClientTypes.TrustedAdvisorIntegrationStatus?
        /// The mode to use for identifying resources associated with the workload. You can specify WORKLOAD_METADATA, APP_REGISTRY, or both.
        public var workloadResourceDefinition: [WellArchitectedClientTypes.DefinitionType]?

        public init(
            trustedAdvisorIntegrationStatus: WellArchitectedClientTypes.TrustedAdvisorIntegrationStatus? = nil,
            workloadResourceDefinition: [WellArchitectedClientTypes.DefinitionType]? = nil
        )
        {
            self.trustedAdvisorIntegrationStatus = trustedAdvisorIntegrationStatus
            self.workloadResourceDefinition = workloadResourceDefinition
        }
    }
}

extension WellArchitectedClientTypes {

    /// The environment for the workload.
    public enum WorkloadEnvironment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case preproduction
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEnvironment] {
            return [
                .preproduction,
                .production
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .preproduction: return "PREPRODUCTION"
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum WorkloadIssueManagementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case inherit
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadIssueManagementStatus] {
            return [
                .disabled,
                .enabled,
                .inherit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .inherit: return "INHERIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Workload-level: Input for the Jira configuration.
    public struct WorkloadJiraConfigurationInput: Swift.Sendable {
        /// Workload-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus?
        /// Workload-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Workload-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?

        public init(
            issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil
        )
        {
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
        }
    }
}

/// Input for workload creation.
public struct CreateWorkloadInput: Swift.Sendable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// List of AppRegistry application ARNs associated to the workload.
    public var applications: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description for the workload.
    /// This member is required.
    public var description: Swift.String?
    /// Well-Architected discovery configuration settings associated to the workload.
    public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    /// The environment for the workload.
    /// This member is required.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Jira configuration settings when creating a workload.
    public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
    /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
    /// This member is required.
    public var lenses: [Swift.String]?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The list of profile ARNs associated with the workload.
    public var profileArns: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The list of review template ARNs to associate with the workload.
    public var reviewTemplateArns: [Swift.String]?
    /// The tags to be associated with the workload.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        applications: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput? = nil,
        lenses: [Swift.String]? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        profileArns: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        reviewTemplateArns: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.applications = applications
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.discoveryConfig = discoveryConfig
        self.environment = environment
        self.industry = industry
        self.industryType = industryType
        self.jiraConfiguration = jiraConfiguration
        self.lenses = lenses
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.profileArns = profileArns
        self.reviewOwner = reviewOwner
        self.reviewTemplateArns = reviewTemplateArns
        self.tags = tags
        self.workloadName = workloadName
    }
}

/// Output of a create workload call.
public struct CreateWorkloadOutput: Swift.Sendable {
    /// The ARN for the workload.
    public var workloadArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        workloadArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// Permission granted on a share request.
    public enum PermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contributor
        case readonly
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .contributor,
                .readonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .readonly: return "READONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Permission granted on a share request.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
    /// This member is required.
    public var sharedWith: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        sharedWith: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.permissionType = permissionType
        self.sharedWith = sharedWith
        self.workloadId = workloadId
    }
}

/// Input for Create Workload Share
public struct CreateWorkloadShareOutput: Swift.Sendable {
    /// The ID associated with the share.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum LensStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatusType] {
            return [
                .all,
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteLensInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The status of the lens to be deleted.
    /// This member is required.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.lensStatus = lensStatus
    }
}

public struct DeleteLensShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.shareId = shareId
    }
}

public struct DeleteProfileInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
    }
}

public struct DeleteProfileShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        shareId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.profileArn = profileArn
        self.shareId = shareId
    }
}

public struct DeleteReviewTemplateInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.templateArn = templateArn
    }
}

public struct DeleteTemplateShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.templateArn = templateArn
    }
}

/// Input for workload deletion.
public struct DeleteWorkloadInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.workloadId = workloadId
    }
}

/// Input for Delete Workload Share
public struct DeleteWorkloadShareInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum DifferenceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case new
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferenceStatus] {
            return [
                .deleted,
                .new,
                .updated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .new: return "NEW"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Input to disassociate lens reviews.
public struct DisassociateLensesInput: Swift.Sendable {
    /// List of lens aliases to associate or disassociate with a workload. Up to 10 lenses can be specified. Identify a lens using its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAliases: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAliases: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAliases = lensAliases
        self.workloadId = workloadId
    }
}

public struct DisassociateProfilesInput: Swift.Sendable {
    /// The list of profile ARNs to disassociate from the workload.
    /// This member is required.
    public var profileArns: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        profileArns: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.profileArns = profileArns
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum DiscoveryIntegrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DiscoveryIntegrationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ExportLensInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be exported.
    public var lensVersion: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

public struct ExportLensOutput: Swift.Sendable {
    /// The JSON representation of a lens.
    public var lensJSON: Swift.String?

    public init(
        lensJSON: Swift.String? = nil
    )
    {
        self.lensJSON = lensJSON
    }
}

/// Input to get answer.
public struct GetAnswerInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

/// Output of a get answer call.
public struct GetAnswerOutput: Swift.Sendable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum ReportFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .json,
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetConsolidatedReportInput: Swift.Sendable {
    /// The format of the consolidated report. For PDF, Base64String is returned. For JSON, Metrics is returned.
    /// This member is required.
    public var format: WellArchitectedClientTypes.ReportFormat?
    /// Set to true to have shared resources included in the report.
    public var includeSharedResources: Swift.Bool?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        format: WellArchitectedClientTypes.ReportFormat? = nil,
        includeSharedResources: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.format = format
        self.includeSharedResources = includeSharedResources
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct GetConsolidatedReportOutput: Swift.Sendable {
    /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file. Only returned by [GetConsolidatedReport] when PDF format is requested.
    public var base64String: Swift.String?
    /// The metrics that make up the consolidated report. Only returned when JSON format is requested.
    public var metrics: [WellArchitectedClientTypes.ConsolidatedReportMetric]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        base64String: Swift.String? = nil,
        metrics: [WellArchitectedClientTypes.ConsolidatedReportMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.base64String = base64String
        self.metrics = metrics
        self.nextToken = nextToken
    }
}

extension WellArchitectedClientTypes {

    public enum OrganizationSharingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationSharingStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetGlobalSettingsOutput: Swift.Sendable {
    /// Discovery integration status.
    public var discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    /// Jira configuration status.
    public var jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationOutput?
    /// Amazon Web Services Organizations sharing status.
    public var organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?

    public init(
        discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus? = nil,
        jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationOutput? = nil,
        organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus? = nil
    )
    {
        self.discoveryIntegrationStatus = discoveryIntegrationStatus
        self.jiraConfiguration = jiraConfiguration
        self.organizationSharingStatus = organizationSharingStatus
    }
}

public struct GetLensInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to be retrieved.
    public var lensVersion: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensVersion: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensVersion = lensVersion
    }
}

extension WellArchitectedClientTypes {

    /// A lens return object.
    public struct Lens: Swift.Sendable {
        /// The description of the lens.
        public var description: Swift.String?
        /// The ARN of a lens.
        public var lensArn: Swift.String?
        /// The version of a lens.
        public var lensVersion: Swift.String?
        /// The full name of the lens.
        public var name: Swift.String?
        /// The Amazon Web Services account ID that owns the lens.
        public var owner: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the lens.
        public var tags: [Swift.String: Swift.String]?

        public init(
            description: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.description = description
            self.lensArn = lensArn
            self.lensVersion = lensVersion
            self.name = name
            self.owner = owner
            self.shareInvitationId = shareInvitationId
            self.tags = tags
        }
    }
}

public struct GetLensOutput: Swift.Sendable {
    /// A lens return object.
    public var lens: WellArchitectedClientTypes.Lens?

    public init(
        lens: WellArchitectedClientTypes.Lens? = nil
    )
    {
        self.lens = lens
    }
}

/// Input to get lens review.
public struct GetLensReviewInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// The selected pillar.
    public struct SelectedPillar: Swift.Sendable {
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// Selected question IDs in the selected pillar.
        public var selectedQuestionIds: [Swift.String]?

        public init(
            pillarId: Swift.String? = nil,
            selectedQuestionIds: [Swift.String]? = nil
        )
        {
            self.pillarId = pillarId
            self.selectedQuestionIds = selectedQuestionIds
        }
    }
}

extension WellArchitectedClientTypes {

    /// Selected questions in the workload.
    public struct JiraSelectedQuestionConfiguration: Swift.Sendable {
        /// Selected pillars in the workload.
        public var selectedPillars: [WellArchitectedClientTypes.SelectedPillar]?

        public init(
            selectedPillars: [WellArchitectedClientTypes.SelectedPillar]? = nil
        )
        {
            self.selectedPillars = selectedPillars
        }
    }
}

extension WellArchitectedClientTypes {

    public enum LensStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case current
        case deleted
        case deprecated
        case notCurrent
        case unshared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensStatus] {
            return [
                .current,
                .deleted,
                .deprecated,
                .notCurrent,
                .unshared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .notCurrent: return "NOT_CURRENT"
            case .unshared: return "UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A pillar review summary of a lens review.
    public struct PillarReviewSummary: Swift.Sendable {
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String: Swift.Int]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?

        public init(
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String: Swift.Int]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.riskCounts = riskCounts
        }
    }
}

extension WellArchitectedClientTypes {

    /// The profile associated with a workload.
    public struct WorkloadProfile: Swift.Sendable {
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile version.
        public var profileVersion: Swift.String?

        public init(
            profileArn: Swift.String? = nil,
            profileVersion: Swift.String? = nil
        )
        {
            self.profileArn = profileArn
            self.profileVersion = profileVersion
        }
    }
}

extension WellArchitectedClientTypes {

    /// A lens review of a question.
    public struct LensReview: Swift.Sendable {
        /// Jira configuration status of the Lens review.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// List of pillar review summaries of lens review in a workload.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String: Swift.Int]?
        /// The profiles associated with the workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.PillarReviewSummary]? = nil,
            prioritizedRiskCounts: [Swift.String: Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.jiraConfiguration = jiraConfiguration
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }
}

/// Output of a get lens review call.
public struct GetLensReviewOutput: Swift.Sendable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

/// Input to get lens review report.
public struct GetLensReviewReportInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// A report of a lens review.
    public struct LensReviewReport: Swift.Sendable {
        /// The Base64-encoded string representation of a lens review report. This data can be used to create a PDF file. Only returned by [GetConsolidatedReport] when PDF format is requested.
        public var base64String: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?

        public init(
            base64String: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil
        )
        {
            self.base64String = base64String
            self.lensAlias = lensAlias
            self.lensArn = lensArn
        }
    }
}

/// Output of a get lens review report call.
public struct GetLensReviewReportOutput: Swift.Sendable {
    /// A report of a lens review.
    public var lensReviewReport: WellArchitectedClientTypes.LensReviewReport?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReviewReport: WellArchitectedClientTypes.LensReviewReport? = nil,
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewReport = lensReviewReport
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

public struct GetLensVersionDifferenceInput: Swift.Sendable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The lens version to target a difference for.
    public var targetLensVersion: Swift.String?

    public init(
        baseLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.lensAlias = lensAlias
        self.targetLensVersion = targetLensVersion
    }
}

extension WellArchitectedClientTypes {

    /// A question difference return object.
    public struct QuestionDifference: Swift.Sendable {
        /// Indicates the type of change to the question.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init(
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }
}

extension WellArchitectedClientTypes {

    /// A pillar difference return object.
    public struct PillarDifference: Swift.Sendable {
        /// Indicates the type of change to the pillar.
        public var differenceStatus: WellArchitectedClientTypes.DifferenceStatus?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// List of question differences.
        public var questionDifferences: [WellArchitectedClientTypes.QuestionDifference]?

        public init(
            differenceStatus: WellArchitectedClientTypes.DifferenceStatus? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionDifferences: [WellArchitectedClientTypes.QuestionDifference]? = nil
        )
        {
            self.differenceStatus = differenceStatus
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionDifferences = questionDifferences
        }
    }
}

extension WellArchitectedClientTypes {

    /// The differences between the base and latest versions of the lens.
    public struct VersionDifferences: Swift.Sendable {
        /// The differences between the base and latest versions of the lens.
        public var pillarDifferences: [WellArchitectedClientTypes.PillarDifference]?

        public init(
            pillarDifferences: [WellArchitectedClientTypes.PillarDifference]? = nil
        )
        {
            self.pillarDifferences = pillarDifferences
        }
    }
}

public struct GetLensVersionDifferenceOutput: Swift.Sendable {
    /// The base version of the lens.
    public var baseLensVersion: Swift.String?
    /// The latest version of the lens.
    public var latestLensVersion: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The target lens version for the lens.
    public var targetLensVersion: Swift.String?
    /// The differences between the base and latest versions of the lens.
    public var versionDifferences: WellArchitectedClientTypes.VersionDifferences?

    public init(
        baseLensVersion: Swift.String? = nil,
        latestLensVersion: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        targetLensVersion: Swift.String? = nil,
        versionDifferences: WellArchitectedClientTypes.VersionDifferences? = nil
    )
    {
        self.baseLensVersion = baseLensVersion
        self.latestLensVersion = latestLensVersion
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.targetLensVersion = targetLensVersion
        self.versionDifferences = versionDifferences
    }
}

/// Input to get a milestone.
public struct GetMilestoneInput: Swift.Sendable {
    /// The milestone number. A workload can have a maximum of 100 milestones.
    /// This member is required.
    public var milestoneNumber: Swift.Int?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        milestoneNumber: Swift.Int? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneNumber = milestoneNumber
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// The improvement status for a workload.
    public enum WorkloadImprovementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case inProgress
        case notApplicable
        case notStarted
        case riskAcknowledged
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadImprovementStatus] {
            return [
                .complete,
                .inProgress,
                .notApplicable,
                .notStarted,
                .riskAcknowledged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .inProgress: return "IN_PROGRESS"
            case .notApplicable: return "NOT_APPLICABLE"
            case .notStarted: return "NOT_STARTED"
            case .riskAcknowledged: return "RISK_ACKNOWLEDGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// Workload-level: Output configuration of the Jira integration.
    public struct WorkloadJiraConfigurationOutput: Swift.Sendable {
        /// Workload-level: Jira issue management status.
        public var issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus?
        /// Workload-level: Jira issue management type.
        public var issueManagementType: WellArchitectedClientTypes.IssueManagementType?
        /// Workload-level: Jira project key to sync workloads to.
        public var jiraProjectKey: Swift.String?
        /// Workload-level: Status message on configuration of the Jira integration.
        public var statusMessage: Swift.String?

        public init(
            issueManagementStatus: WellArchitectedClientTypes.WorkloadIssueManagementStatus? = nil,
            issueManagementType: WellArchitectedClientTypes.IssueManagementType? = nil,
            jiraProjectKey: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.issueManagementStatus = issueManagementStatus
            self.issueManagementType = issueManagementType
            self.jiraProjectKey = jiraProjectKey
            self.statusMessage = statusMessage
        }
    }
}

extension WellArchitectedClientTypes {

    /// A workload return object.
    public struct Workload: Swift.Sendable {
        /// The list of Amazon Web Services account IDs associated with the workload.
        public var accountIds: [Swift.String]?
        /// List of AppRegistry application ARNs associated to the workload.
        public var applications: [Swift.String]?
        /// The URL of the architectural design for the workload.
        public var architecturalDesign: Swift.String?
        /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
        public var awsRegions: [Swift.String]?
        /// The description for the workload.
        public var description: Swift.String?
        /// Discovery configuration associated to the workload.
        public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
        /// The environment for the workload.
        public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The industry for the workload.
        public var industry: Swift.String?
        /// The industry type for the workload. If specified, must be one of the following:
        ///
        /// * Agriculture
        ///
        /// * Automobile
        ///
        /// * Defense
        ///
        /// * Design and Engineering
        ///
        /// * Digital Advertising
        ///
        /// * Education
        ///
        /// * Environmental Protection
        ///
        /// * Financial Services
        ///
        /// * Gaming
        ///
        /// * General Public Services
        ///
        /// * Healthcare
        ///
        /// * Hospitality
        ///
        /// * InfoTech
        ///
        /// * Justice and Public Safety
        ///
        /// * Life Sciences
        ///
        /// * Manufacturing
        ///
        /// * Media & Entertainment
        ///
        /// * Mining & Resources
        ///
        /// * Oil & Gas
        ///
        /// * Power & Utilities
        ///
        /// * Professional Services
        ///
        /// * Real Estate & Construction
        ///
        /// * Retail & Wholesale
        ///
        /// * Social Protection
        ///
        /// * Telecommunications
        ///
        /// * Travel, Transportation & Logistics
        ///
        /// * Other
        public var industryType: Swift.String?
        /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
        public var isReviewOwnerUpdateAcknowledged: Swift.Bool?
        /// Jira configuration for a specific workload.
        public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationOutput?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
        public var lenses: [Swift.String]?
        /// The list of non-Amazon Web Services Regions associated with the workload.
        public var nonAwsRegions: [Swift.String]?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
        public var pillarPriorities: [Swift.String]?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String: Swift.Int]?
        /// Profile associated with a workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
        public var reviewOwner: Swift.String?
        /// The date and time recorded.
        public var reviewRestrictionDate: Foundation.Date?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags associated with the workload.
        public var tags: [Swift.String: Swift.String]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            accountIds: [Swift.String]? = nil,
            applications: [Swift.String]? = nil,
            architecturalDesign: Swift.String? = nil,
            awsRegions: [Swift.String]? = nil,
            description: Swift.String? = nil,
            discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
            environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            industry: Swift.String? = nil,
            industryType: Swift.String? = nil,
            isReviewOwnerUpdateAcknowledged: Swift.Bool? = nil,
            jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationOutput? = nil,
            lenses: [Swift.String]? = nil,
            nonAwsRegions: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            pillarPriorities: [Swift.String]? = nil,
            prioritizedRiskCounts: [Swift.String: Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            reviewOwner: Swift.String? = nil,
            reviewRestrictionDate: Foundation.Date? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.accountIds = accountIds
            self.applications = applications
            self.architecturalDesign = architecturalDesign
            self.awsRegions = awsRegions
            self.description = description
            self.discoveryConfig = discoveryConfig
            self.environment = environment
            self.improvementStatus = improvementStatus
            self.industry = industry
            self.industryType = industryType
            self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
            self.jiraConfiguration = jiraConfiguration
            self.lenses = lenses
            self.nonAwsRegions = nonAwsRegions
            self.notes = notes
            self.owner = owner
            self.pillarPriorities = pillarPriorities
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.reviewOwner = reviewOwner
            self.reviewRestrictionDate = reviewRestrictionDate
            self.riskCounts = riskCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

extension WellArchitectedClientTypes {

    /// A milestone return object.
    public struct Milestone: Swift.Sendable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int?
        /// The date and time recorded.
        public var recordedAt: Foundation.Date?
        /// A workload return object.
        public var workload: WellArchitectedClientTypes.Workload?

        public init(
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int? = nil,
            recordedAt: Foundation.Date? = nil,
            workload: WellArchitectedClientTypes.Workload? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workload = workload
        }
    }
}

/// Output of a get milestone call.
public struct GetMilestoneOutput: Swift.Sendable {
    /// A milestone return object.
    public var milestone: WellArchitectedClientTypes.Milestone?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestone: WellArchitectedClientTypes.Milestone? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestone = milestone
        self.workloadId = workloadId
    }
}

public struct GetProfileInput: Swift.Sendable {
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The profile version.
    public var profileVersion: Swift.String?

    public init(
        profileArn: Swift.String? = nil,
        profileVersion: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
        self.profileVersion = profileVersion
    }
}

extension WellArchitectedClientTypes {

    /// The profile choice.
    public struct ProfileChoice: Swift.Sendable {
        /// The description of a choice.
        public var choiceDescription: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceDescription: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceDescription = choiceDescription
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }
}

extension WellArchitectedClientTypes {

    /// A profile question.
    public struct ProfileQuestion: Swift.Sendable {
        /// The maximum number of selected choices.
        public var maxSelectedChoices: Swift.Int?
        /// The minimum number of selected choices.
        public var minSelectedChoices: Swift.Int?
        /// The question choices.
        public var questionChoices: [WellArchitectedClientTypes.ProfileChoice]?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The selected choices.
        public var selectedChoiceIds: [Swift.String]?

        public init(
            maxSelectedChoices: Swift.Int? = nil,
            minSelectedChoices: Swift.Int? = nil,
            questionChoices: [WellArchitectedClientTypes.ProfileChoice]? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            selectedChoiceIds: [Swift.String]? = nil
        )
        {
            self.maxSelectedChoices = maxSelectedChoices
            self.minSelectedChoices = minSelectedChoices
            self.questionChoices = questionChoices
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.selectedChoiceIds = selectedChoiceIds
        }
    }
}

extension WellArchitectedClientTypes {

    /// A profile.
    public struct Profile: Swift.Sendable {
        /// The date and time recorded.
        public var createdAt: Foundation.Date?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile description.
        public var profileDescription: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// Profile questions.
        public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestion]?
        /// The profile version.
        public var profileVersion: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the profile.
        public var tags: [Swift.String: Swift.String]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            owner: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileDescription: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileQuestions: [WellArchitectedClientTypes.ProfileQuestion]? = nil,
            profileVersion: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.owner = owner
            self.profileArn = profileArn
            self.profileDescription = profileDescription
            self.profileName = profileName
            self.profileQuestions = profileQuestions
            self.profileVersion = profileVersion
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }
}

public struct GetProfileOutput: Swift.Sendable {
    /// The profile.
    public var profile: WellArchitectedClientTypes.Profile?

    public init(
        profile: WellArchitectedClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

public struct GetProfileTemplateInput: Swift.Sendable {

    public init() { }
}

extension WellArchitectedClientTypes {

    /// A profile template choice.
    public struct ProfileTemplateChoice: Swift.Sendable {
        /// The description of a choice.
        public var choiceDescription: Swift.String?
        /// The ID of a choice.
        public var choiceId: Swift.String?
        /// The title of a choice.
        public var choiceTitle: Swift.String?

        public init(
            choiceDescription: Swift.String? = nil,
            choiceId: Swift.String? = nil,
            choiceTitle: Swift.String? = nil
        )
        {
            self.choiceDescription = choiceDescription
            self.choiceId = choiceId
            self.choiceTitle = choiceTitle
        }
    }
}

extension WellArchitectedClientTypes {

    /// A profile template question.
    public struct ProfileTemplateQuestion: Swift.Sendable {
        /// The maximum number of choices selected.
        public var maxSelectedChoices: Swift.Int?
        /// The minimum number of choices selected.
        public var minSelectedChoices: Swift.Int?
        /// The question choices.
        public var questionChoices: [WellArchitectedClientTypes.ProfileTemplateChoice]?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?

        public init(
            maxSelectedChoices: Swift.Int? = nil,
            minSelectedChoices: Swift.Int? = nil,
            questionChoices: [WellArchitectedClientTypes.ProfileTemplateChoice]? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil
        )
        {
            self.maxSelectedChoices = maxSelectedChoices
            self.minSelectedChoices = minSelectedChoices
            self.questionChoices = questionChoices
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
        }
    }
}

extension WellArchitectedClientTypes {

    /// The profile template.
    public struct ProfileTemplate: Swift.Sendable {
        /// The date and time recorded.
        public var createdAt: Foundation.Date?
        /// The name of the profile template.
        public var templateName: Swift.String?
        /// Profile template questions.
        public var templateQuestions: [WellArchitectedClientTypes.ProfileTemplateQuestion]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            templateName: Swift.String? = nil,
            templateQuestions: [WellArchitectedClientTypes.ProfileTemplateQuestion]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.templateName = templateName
            self.templateQuestions = templateQuestions
            self.updatedAt = updatedAt
        }
    }
}

public struct GetProfileTemplateOutput: Swift.Sendable {
    /// The profile template.
    public var profileTemplate: WellArchitectedClientTypes.ProfileTemplate?

    public init(
        profileTemplate: WellArchitectedClientTypes.ProfileTemplate? = nil
    )
    {
        self.profileTemplate = profileTemplate
    }
}

public struct GetReviewTemplateInput: Swift.Sendable {
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        templateArn: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    public enum Question: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case answered
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [Question] {
            return [
                .answered,
                .unanswered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    public enum ReviewTemplateUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case current
        case lensNotCurrent
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewTemplateUpdateStatus] {
            return [
                .current,
                .lensNotCurrent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .lensNotCurrent: return "LENS_NOT_CURRENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A review template.
    public struct ReviewTemplate: Swift.Sendable {
        /// The review template description.
        public var description: Swift.String?
        /// The lenses applied to the review template.
        public var lenses: [Swift.String]?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A count of how many total questions are answered and unanswered in the review template.
        public var questionCounts: [Swift.String: Swift.Int]?
        /// The ID assigned to the template share invitation.
        public var shareInvitationId: Swift.String?
        /// The tags assigned to the review template.
        public var tags: [Swift.String: Swift.String]?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The latest status of a review template.
        public var updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            lenses: [Swift.String]? = nil,
            notes: Swift.String? = nil,
            owner: Swift.String? = nil,
            questionCounts: [Swift.String: Swift.Int]? = nil,
            shareInvitationId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.description = description
            self.lenses = lenses
            self.notes = notes
            self.owner = owner
            self.questionCounts = questionCounts
            self.shareInvitationId = shareInvitationId
            self.tags = tags
            self.templateArn = templateArn
            self.templateName = templateName
            self.updateStatus = updateStatus
            self.updatedAt = updatedAt
        }
    }
}

public struct GetReviewTemplateOutput: Swift.Sendable {
    /// The review template.
    public var reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?

    public init(
        reviewTemplate: WellArchitectedClientTypes.ReviewTemplate? = nil
    )
    {
        self.reviewTemplate = reviewTemplate
    }
}

public struct GetReviewTemplateAnswerInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        questionId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.questionId = questionId
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    public enum ReviewTemplateAnswerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case answered
        case unanswered
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewTemplateAnswerStatus] {
            return [
                .answered,
                .unanswered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .unanswered: return "UNANSWERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// An answer of the question.
    public struct ReviewTemplateAnswer: Swift.Sendable {
        /// The status of whether or not this question has been answered.
        public var answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus?
        /// A list of selected choices to a question in your review template.
        public var choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// The helpful resource text to be displayed for a custom lens. This field does not apply to Amazon Web Services official lenses.
        public var helpfulResourceDisplayText: Swift.String?
        /// The helpful resource URL. For Amazon Web Services official lenses, this is the helpful resource URL for a question or choice. For custom lenses, this is the helpful resource URL for a question and is only provided if HelpfulResourceDisplayText was specified for the question.
        public var helpfulResourceUrl: Swift.String?
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The description of the question.
        public var questionDescription: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The reason why the question is not applicable to your review template.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus? = nil,
            choiceAnswers: [WellArchitectedClientTypes.ChoiceAnswer]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            helpfulResourceDisplayText: Swift.String? = nil,
            helpfulResourceUrl: Swift.String? = nil,
            improvementPlanUrl: Swift.String? = nil,
            isApplicable: Swift.Bool? = nil,
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            questionDescription: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.answerStatus = answerStatus
            self.choiceAnswers = choiceAnswers
            self.choices = choices
            self.helpfulResourceDisplayText = helpfulResourceDisplayText
            self.helpfulResourceUrl = helpfulResourceUrl
            self.improvementPlanUrl = improvementPlanUrl
            self.isApplicable = isApplicable
            self.notes = notes
            self.pillarId = pillarId
            self.questionDescription = questionDescription
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.reason = reason
            self.selectedChoices = selectedChoices
        }
    }
}

public struct GetReviewTemplateAnswerOutput: Swift.Sendable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.ReviewTemplateAnswer? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

public struct GetReviewTemplateLensReviewInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    /// Summary of a review template.
    public struct ReviewTemplatePillarReviewSummary: Swift.Sendable {
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The name of the pillar.
        public var pillarName: Swift.String?
        /// A count of how many questions are answered and unanswered in the requested pillar of the lens review.
        public var questionCounts: [Swift.String: Swift.Int]?

        public init(
            notes: Swift.String? = nil,
            pillarId: Swift.String? = nil,
            pillarName: Swift.String? = nil,
            questionCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.notes = notes
            self.pillarId = pillarId
            self.pillarName = pillarName
            self.questionCounts = questionCounts
        }
    }
}

extension WellArchitectedClientTypes {

    /// The lens review of a review template.
    public struct ReviewTemplateLensReview: Swift.Sendable {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The lens ARN.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// The token to use to retrieve the next set of results.
        public var nextToken: Swift.String?
        /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
        public var notes: Swift.String?
        /// Pillar review summaries of a lens review.
        public var pillarReviewSummaries: [WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]?
        /// A count of how many questions are answered and unanswered in the lens review.
        public var questionCounts: [Swift.String: Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            nextToken: Swift.String? = nil,
            notes: Swift.String? = nil,
            pillarReviewSummaries: [WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary]? = nil,
            questionCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.nextToken = nextToken
            self.notes = notes
            self.pillarReviewSummaries = pillarReviewSummaries
            self.questionCounts = questionCounts
            self.updatedAt = updatedAt
        }
    }
}

public struct GetReviewTemplateLensReviewOutput: Swift.Sendable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.templateArn = templateArn
    }
}

/// Input to get a workload.
public struct GetWorkloadInput: Swift.Sendable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        workloadId: Swift.String? = nil
    )
    {
        self.workloadId = workloadId
    }
}

/// Output of a get workload call.
public struct GetWorkloadOutput: Swift.Sendable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init(
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

public struct ImportLensInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The JSON representation of a lens.
    /// This member is required.
    public var jsonString: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// Tags to associate to a lens.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientRequestToken: Swift.String? = nil,
        jsonString: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.jsonString = jsonString
        self.lensAlias = lensAlias
        self.tags = tags
    }
}

extension WellArchitectedClientTypes {

    public enum ImportLensStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case error
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportLensStatus] {
            return [
                .complete,
                .error,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ImportLensOutput: Swift.Sendable {
    /// The ARN for the lens that was created or updated.
    public var lensArn: Swift.String?
    /// The status of the imported lens.
    public var status: WellArchitectedClientTypes.ImportLensStatus?

    public init(
        lensArn: Swift.String? = nil,
        status: WellArchitectedClientTypes.ImportLensStatus? = nil
    )
    {
        self.lensArn = lensArn
        self.status = status
    }
}

extension WellArchitectedClientTypes {

    /// An improvement summary of a lens review in a workload.
    public struct ImprovementSummary: Swift.Sendable {
        /// The improvement plan URL for a question in an Amazon Web Services official lenses. This value is only available if the question has been answered. This value does not apply to custom lenses.
        public var improvementPlanUrl: Swift.String?
        /// The improvement plan details.
        public var improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]?
        /// Configuration of the Jira integration.
        public var jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The risk for a given workload, lens review, pillar, or question.
        public var risk: WellArchitectedClientTypes.Risk?

        public init(
            improvementPlanUrl: Swift.String? = nil,
            improvementPlans: [WellArchitectedClientTypes.ChoiceImprovementPlan]? = nil,
            jiraConfiguration: WellArchitectedClientTypes.JiraConfiguration? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            risk: WellArchitectedClientTypes.Risk? = nil
        )
        {
            self.improvementPlanUrl = improvementPlanUrl
            self.improvementPlans = improvementPlans
            self.jiraConfiguration = jiraConfiguration
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.risk = risk
        }
    }
}

extension WellArchitectedClientTypes {

    public enum IntegratingService: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jira
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegratingService] {
            return [
                .jira
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jira: return "JIRA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A lens review summary of a workload.
    public struct LensReviewSummary: Swift.Sendable {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String: Swift.Int]?
        /// The profiles associated with the workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensVersion: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String: Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensVersion = lensVersion
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
        }
    }
}

extension WellArchitectedClientTypes {

    /// The status of the share request.
    public enum ShareStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case associated
        case associating
        case expired
        case failed
        case pending
        case rejected
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .accepted,
                .associated,
                .associating,
                .expired,
                .failed,
                .pending,
                .rejected,
                .revoked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case .revoked: return "REVOKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A lens share summary return object.
    public struct LensShareSummary: Swift.Sendable {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Optional message to compliment the Status field.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

extension WellArchitectedClientTypes {

    public enum LensType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOfficial
        case customSelf
        case customShared
        case sdkUnknown(Swift.String)

        public static var allCases: [LensType] {
            return [
                .awsOfficial,
                .customSelf,
                .customShared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOfficial: return "AWS_OFFICIAL"
            case .customSelf: return "CUSTOM_SELF"
            case .customShared: return "CUSTOM_SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A lens summary of a lens.
    public struct LensSummary: Swift.Sendable {
        /// The date and time recorded.
        public var createdAt: Foundation.Date?
        /// The description of the lens.
        public var description: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN of the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// The status of the lens.
        public var lensStatus: WellArchitectedClientTypes.LensStatus?
        /// The type of the lens.
        public var lensType: WellArchitectedClientTypes.LensType?
        /// The version of the lens.
        public var lensVersion: Swift.String?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            lensStatus: WellArchitectedClientTypes.LensStatus? = nil,
            lensType: WellArchitectedClientTypes.LensType? = nil,
            lensVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.lensName = lensName
            self.lensStatus = lensStatus
            self.lensType = lensType
            self.lensVersion = lensVersion
            self.owner = owner
            self.updatedAt = updatedAt
        }
    }
}

extension WellArchitectedClientTypes {

    /// Lens upgrade summary return object.
    public struct LensUpgradeSummary: Swift.Sendable {
        /// The current version of the lens.
        public var currentLensVersion: Swift.String?
        /// The latest version of the lens.
        public var latestLensVersion: Swift.String?
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// ResourceArn of the lens being upgraded
        public var resourceArn: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var resourceName: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            currentLensVersion: Swift.String? = nil,
            latestLensVersion: Swift.String? = nil,
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentLensVersion = currentLensVersion
            self.latestLensVersion = latestLensVersion
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.resourceArn = resourceArn
            self.resourceName = resourceName
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

extension WellArchitectedClientTypes {

    public enum QuestionPriority: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case prioritized
        case sdkUnknown(Swift.String)

        public static var allCases: [QuestionPriority] {
            return [
                .none,
                .prioritized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .prioritized: return "PRIORITIZED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Input to list answers.
public struct ListAnswersInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The priority of the question.
    public var questionPriority: WellArchitectedClientTypes.QuestionPriority?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionPriority: WellArchitectedClientTypes.QuestionPriority? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionPriority = questionPriority
        self.workloadId = workloadId
    }
}

/// Output of a list answers call.
public struct ListAnswersOutput: Swift.Sendable {
    /// List of answer summaries of lens review in a workload.
    public var answerSummaries: [WellArchitectedClientTypes.AnswerSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answerSummaries: [WellArchitectedClientTypes.AnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

public struct ListCheckDetailsInput: Swift.Sendable {
    /// The ID of a choice.
    /// This member is required.
    public var choiceId: Swift.String?
    /// Well-Architected Lens ARN.
    /// This member is required.
    public var lensArn: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    /// This member is required.
    public var pillarId: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceId: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceId = choiceId
        self.lensArn = lensArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

public struct ListCheckDetailsOutput: Swift.Sendable {
    /// The details about the Trusted Advisor checks related to the Well-Architected best practice.
    public var checkDetails: [WellArchitectedClientTypes.CheckDetail]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkDetails: [WellArchitectedClientTypes.CheckDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkDetails = checkDetails
        self.nextToken = nextToken
    }
}

public struct ListCheckSummariesInput: Swift.Sendable {
    /// The ID of a choice.
    /// This member is required.
    public var choiceId: Swift.String?
    /// Well-Architected Lens ARN.
    /// This member is required.
    public var lensArn: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    /// This member is required.
    public var pillarId: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceId: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceId = choiceId
        self.lensArn = lensArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionId = questionId
        self.workloadId = workloadId
    }
}

public struct ListCheckSummariesOutput: Swift.Sendable {
    /// List of Trusted Advisor summaries related to the Well-Architected best practice.
    public var checkSummaries: [WellArchitectedClientTypes.CheckSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkSummaries: [WellArchitectedClientTypes.CheckSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkSummaries = checkSummaries
        self.nextToken = nextToken
    }
}

/// Input to list lenses.
public struct ListLensesInput: Swift.Sendable {
    /// The full name of the lens.
    public var lensName: Swift.String?
    /// The status of lenses to be returned.
    public var lensStatus: WellArchitectedClientTypes.LensStatusType?
    /// The type of lenses to be returned.
    public var lensType: WellArchitectedClientTypes.LensType?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensName: Swift.String? = nil,
        lensStatus: WellArchitectedClientTypes.LensStatusType? = nil,
        lensType: WellArchitectedClientTypes.LensType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensName = lensName
        self.lensStatus = lensStatus
        self.lensType = lensType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Output of a list lenses call.
public struct ListLensesOutput: Swift.Sendable {
    /// List of lens summaries of available lenses.
    public var lensSummaries: [WellArchitectedClientTypes.LensSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensSummaries: [WellArchitectedClientTypes.LensSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensSummaries = lensSummaries
        self.nextToken = nextToken
    }
}

/// Input to list lens review improvements.
public struct ListLensReviewImprovementsInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The priority of the question.
    public var questionPriority: WellArchitectedClientTypes.QuestionPriority?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        questionPriority: WellArchitectedClientTypes.QuestionPriority? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.questionPriority = questionPriority
        self.workloadId = workloadId
    }
}

/// Output of a list lens review improvements call.
public struct ListLensReviewImprovementsOutput: Swift.Sendable {
    /// List of improvement summaries of lens review in a workload.
    public var improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        improvementSummaries: [WellArchitectedClientTypes.ImprovementSummary]? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.improvementSummaries = improvementSummaries
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

/// Input to list lens reviews.
public struct ListLensReviewsInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

/// Output of a list lens reviews call.
public struct ListLensReviewsOutput: Swift.Sendable {
    /// List of lens summaries of lens reviews of a workload.
    public var lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]?
    /// The milestone number. A workload can have a maximum of 100 milestones.
    public var milestoneNumber: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReviewSummaries: [WellArchitectedClientTypes.LensReviewSummary]? = nil,
        milestoneNumber: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReviewSummaries = lensReviewSummaries
        self.milestoneNumber = milestoneNumber
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

public struct ListLensSharesInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the lens is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
    }
}

public struct ListLensSharesOutput: Swift.Sendable {
    /// A list of lens share summaries.
    public var lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        lensShareSummaries: [WellArchitectedClientTypes.LensShareSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lensShareSummaries = lensShareSummaries
        self.nextToken = nextToken
    }
}

/// Input to list all milestones for a workload.
public struct ListMilestonesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// A workload summary return object.
    public struct WorkloadSummary: Swift.Sendable {
        /// The improvement status for a workload.
        public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
        /// The list of lenses associated with the workload. Each lens is identified by its [LensSummary$LensAlias]. If a review template that specifies lenses is applied to the workload, those lenses are applied to the workload in addition to these lenses.
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// A map from risk names to the count of how many questions have that rating.
        public var prioritizedRiskCounts: [Swift.String: Swift.Int]?
        /// Profile associated with a workload.
        public var profiles: [WellArchitectedClientTypes.WorkloadProfile]?
        /// A map from risk names to the count of how many questions have that rating.
        public var riskCounts: [Swift.String: Swift.Int]?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?
        /// The ARN for the workload.
        public var workloadArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            prioritizedRiskCounts: [Swift.String: Swift.Int]? = nil,
            profiles: [WellArchitectedClientTypes.WorkloadProfile]? = nil,
            riskCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil,
            workloadArn: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.improvementStatus = improvementStatus
            self.lenses = lenses
            self.owner = owner
            self.prioritizedRiskCounts = prioritizedRiskCounts
            self.profiles = profiles
            self.riskCounts = riskCounts
            self.updatedAt = updatedAt
            self.workloadArn = workloadArn
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

extension WellArchitectedClientTypes {

    /// A milestone summary return object.
    public struct MilestoneSummary: Swift.Sendable {
        /// The name of the milestone in a workload. Milestone names must be unique within a workload.
        public var milestoneName: Swift.String?
        /// The milestone number. A workload can have a maximum of 100 milestones.
        public var milestoneNumber: Swift.Int?
        /// The date and time recorded.
        public var recordedAt: Foundation.Date?
        /// A workload summary return object.
        public var workloadSummary: WellArchitectedClientTypes.WorkloadSummary?

        public init(
            milestoneName: Swift.String? = nil,
            milestoneNumber: Swift.Int? = nil,
            recordedAt: Foundation.Date? = nil,
            workloadSummary: WellArchitectedClientTypes.WorkloadSummary? = nil
        )
        {
            self.milestoneName = milestoneName
            self.milestoneNumber = milestoneNumber
            self.recordedAt = recordedAt
            self.workloadSummary = workloadSummary
        }
    }
}

/// Output of a list milestones call.
public struct ListMilestonesOutput: Swift.Sendable {
    /// A list of milestone summaries.
    public var milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        milestoneSummaries: [WellArchitectedClientTypes.MilestoneSummary]? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.milestoneSummaries = milestoneSummaries
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

public struct ListNotificationsInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ARN for the related resource for the notification. Only one of WorkloadID or ResourceARN should be specified.
    public var resourceArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum NotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lensVersionDeprecated
        case lensVersionUpgraded
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .lensVersionDeprecated,
                .lensVersionUpgraded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lensVersionDeprecated: return "LENS_VERSION_DEPRECATED"
            case .lensVersionUpgraded: return "LENS_VERSION_UPGRADED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// A notification summary return object.
    public struct NotificationSummary: Swift.Sendable {
        /// Summary of lens upgrade.
        public var lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary?
        /// The type of notification.
        public var type: WellArchitectedClientTypes.NotificationType?

        public init(
            lensUpgradeSummary: WellArchitectedClientTypes.LensUpgradeSummary? = nil,
            type: WellArchitectedClientTypes.NotificationType? = nil
        )
        {
            self.lensUpgradeSummary = lensUpgradeSummary
            self.type = type
        }
    }
}

public struct ListNotificationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of lens notification summaries in a workload.
    public var notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.NotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

public struct ListProfileNotificationsInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    public enum ProfileNotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profileAnswersUpdated
        case profileDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileNotificationType] {
            return [
                .profileAnswersUpdated,
                .profileDeleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profileAnswersUpdated: return "PROFILE_ANSWERS_UPDATED"
            case .profileDeleted: return "PROFILE_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WellArchitectedClientTypes {

    /// The profile notification summary.
    public struct ProfileNotificationSummary: Swift.Sendable {
        /// The current profile version.
        public var currentProfileVersion: Swift.String?
        /// The latest profile version.
        public var latestProfileVersion: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// Type of notification.
        public var type: WellArchitectedClientTypes.ProfileNotificationType?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            currentProfileVersion: Swift.String? = nil,
            latestProfileVersion: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            type: WellArchitectedClientTypes.ProfileNotificationType? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.currentProfileVersion = currentProfileVersion
            self.latestProfileVersion = latestProfileVersion
            self.profileArn = profileArn
            self.profileName = profileName
            self.type = type
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

public struct ListProfileNotificationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Notification summaries.
    public var notificationSummaries: [WellArchitectedClientTypes.ProfileNotificationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationSummaries: [WellArchitectedClientTypes.ProfileNotificationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationSummaries = notificationSummaries
    }
}

extension WellArchitectedClientTypes {

    public enum ProfileOwnerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileOwnerType] {
            return [
                .self,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .self: return "SELF"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProfilesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each profile name returned in the results.
    public var profileNamePrefix: Swift.String?
    /// Profile owner type.
    public var profileOwnerType: WellArchitectedClientTypes.ProfileOwnerType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileNamePrefix: Swift.String? = nil,
        profileOwnerType: WellArchitectedClientTypes.ProfileOwnerType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileNamePrefix = profileNamePrefix
        self.profileOwnerType = profileOwnerType
    }
}

extension WellArchitectedClientTypes {

    /// Summary of a profile.
    public struct ProfileSummary: Swift.Sendable {
        /// The date and time recorded.
        public var createdAt: Foundation.Date?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile description.
        public var profileDescription: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// The profile version.
        public var profileVersion: Swift.String?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            owner: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileDescription: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.owner = owner
            self.profileArn = profileArn
            self.profileDescription = profileDescription
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.updatedAt = updatedAt
        }
    }
}

public struct ListProfilesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Profile summaries.
    public var profileSummaries: [WellArchitectedClientTypes.ProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profileSummaries: [WellArchitectedClientTypes.ProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileSummaries = profileSummaries
    }
}

public struct ListProfileSharesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileArn = profileArn
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
    }
}

extension WellArchitectedClientTypes {

    /// Summary of a profile share.
    public struct ProfileShareSummary: Swift.Sendable {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Profile share invitation status message.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListProfileSharesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Profile share summaries.
    public var profileShareSummaries: [WellArchitectedClientTypes.ProfileShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profileShareSummaries: [WellArchitectedClientTypes.ProfileShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileShareSummaries = profileShareSummaries
    }
}

public struct ListReviewTemplateAnswersInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
    public var pillarId: Swift.String?
    /// The ARN of the review template.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillarId: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillarId = pillarId
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    /// The summary of review template answers.
    public struct ReviewTemplateAnswerSummary: Swift.Sendable {
        /// The status of whether or not this question has been answered.
        public var answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus?
        /// A list of selected choices to a question in the review template.
        public var choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]?
        /// List of choices available for a question.
        public var choices: [WellArchitectedClientTypes.Choice]?
        /// Defines whether this question is applicable to a lens review.
        public var isApplicable: Swift.Bool?
        /// The ID used to identify a pillar, for example, security. A pillar is identified by its [PillarReviewSummary$PillarId].
        public var pillarId: Swift.String?
        /// The ID of the question.
        public var questionId: Swift.String?
        /// The title of the question.
        public var questionTitle: Swift.String?
        /// The type of question.
        public var questionType: WellArchitectedClientTypes.QuestionType?
        /// The reason why a choice is not-applicable to a question in the review template.
        public var reason: WellArchitectedClientTypes.AnswerReason?
        /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
        public var selectedChoices: [Swift.String]?

        public init(
            answerStatus: WellArchitectedClientTypes.ReviewTemplateAnswerStatus? = nil,
            choiceAnswerSummaries: [WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil,
            choices: [WellArchitectedClientTypes.Choice]? = nil,
            isApplicable: Swift.Bool? = nil,
            pillarId: Swift.String? = nil,
            questionId: Swift.String? = nil,
            questionTitle: Swift.String? = nil,
            questionType: WellArchitectedClientTypes.QuestionType? = nil,
            reason: WellArchitectedClientTypes.AnswerReason? = nil,
            selectedChoices: [Swift.String]? = nil
        )
        {
            self.answerStatus = answerStatus
            self.choiceAnswerSummaries = choiceAnswerSummaries
            self.choices = choices
            self.isApplicable = isApplicable
            self.pillarId = pillarId
            self.questionId = questionId
            self.questionTitle = questionTitle
            self.questionType = questionType
            self.reason = reason
            self.selectedChoices = selectedChoices
        }
    }
}

public struct ListReviewTemplateAnswersOutput: Swift.Sendable {
    /// List of answer summaries of a lens review in a review template.
    public var answerSummaries: [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ARN of the review template.
    public var templateArn: Swift.String?

    public init(
        answerSummaries: [WellArchitectedClientTypes.ReviewTemplateAnswerSummary]? = nil,
        lensAlias: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answerSummaries = answerSummaries
        self.lensAlias = lensAlias
        self.nextToken = nextToken
        self.templateArn = templateArn
    }
}

public struct ListReviewTemplatesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WellArchitectedClientTypes {

    /// Summary of a review template.
    public struct ReviewTemplateSummary: Swift.Sendable {
        /// Description of the review template.
        public var description: Swift.String?
        /// Lenses associated with the review template.
        public var lenses: [Swift.String]?
        /// An Amazon Web Services account ID.
        public var owner: Swift.String?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The latest status of a review template.
        public var updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus?
        /// The date and time recorded.
        public var updatedAt: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            lenses: [Swift.String]? = nil,
            owner: Swift.String? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            updateStatus: WellArchitectedClientTypes.ReviewTemplateUpdateStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.description = description
            self.lenses = lenses
            self.owner = owner
            self.templateArn = templateArn
            self.templateName = templateName
            self.updateStatus = updateStatus
            self.updatedAt = updatedAt
        }
    }
}

public struct ListReviewTemplatesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of review templates.
    public var reviewTemplates: [WellArchitectedClientTypes.ReviewTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        reviewTemplates: [WellArchitectedClientTypes.ReviewTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reviewTemplates = reviewTemplates
    }
}

extension WellArchitectedClientTypes {

    public enum ShareResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lens
        case profile
        case template
        case workload
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareResourceType] {
            return [
                .lens,
                .profile,
                .template,
                .workload
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lens: return "LENS"
            case .profile: return "PROFILE"
            case .template: return "TEMPLATE"
            case .workload: return "WORKLOAD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsInput: Swift.Sendable {
    /// An optional string added to the beginning of each lens name returned in the results.
    public var lensNamePrefix: Swift.String?
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each profile name returned in the results.
    public var profileNamePrefix: Swift.String?
    /// The type of share invitations to be returned.
    public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
    /// An optional string added to the beginning of each review template name returned in the results.
    public var templateNamePrefix: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init(
        lensNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileNamePrefix: Swift.String? = nil,
        shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
        templateNamePrefix: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.lensNamePrefix = lensNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileNamePrefix = profileNamePrefix
        self.shareResourceType = shareResourceType
        self.templateNamePrefix = templateNamePrefix
        self.workloadNamePrefix = workloadNamePrefix
    }
}

extension WellArchitectedClientTypes {

    /// A share invitation summary return object.
    public struct ShareInvitationSummary: Swift.Sendable {
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The full name of the lens.
        public var lensName: Swift.String?
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The profile name.
        public var profileName: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The name of the review template.
        public var templateName: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            lensArn: Swift.String? = nil,
            lensName: Swift.String? = nil,
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            templateArn: Swift.String? = nil,
            templateName: Swift.String? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.lensArn = lensArn
            self.lensName = lensName
            self.permissionType = permissionType
            self.profileArn = profileArn
            self.profileName = profileName
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.templateArn = templateArn
            self.templateName = templateName
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

/// Input for List Share Invitations
public struct ListShareInvitationsOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// List of share invitation summaries in a workload.
    public var shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        shareInvitationSummaries: [WellArchitectedClientTypes.ShareInvitationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.shareInvitationSummaries = shareInvitationSummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        workloadArn: Swift.String? = nil
    )
    {
        self.workloadArn = workloadArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTemplateSharesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the profile is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
        self.templateArn = templateArn
    }
}

extension WellArchitectedClientTypes {

    /// Summary of a review template share.
    public struct TemplateShareSummary: Swift.Sendable {
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Review template share invitation status message.
        public var statusMessage: Swift.String?

        public init(
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListTemplateSharesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?
    /// A review template share summary return object.
    public var templateShareSummaries: [WellArchitectedClientTypes.TemplateShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateShareSummaries: [WellArchitectedClientTypes.TemplateShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templateArn = templateArn
        self.templateShareSummaries = templateShareSummaries
    }
}

/// Input to list all workloads.
public struct ListWorkloadsInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An optional string added to the beginning of each workload name returned in the results.
    public var workloadNamePrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadNamePrefix = workloadNamePrefix
    }
}

/// Output of a list workloads call.
public struct ListWorkloadsOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of workload summaries.
    public var workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadSummaries: [WellArchitectedClientTypes.WorkloadSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadSummaries = workloadSummaries
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesInput: Swift.Sendable {
    /// The maximum number of results to return for this request.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload is shared.
    public var sharedWithPrefix: Swift.String?
    /// The status of the share request.
    public var status: WellArchitectedClientTypes.ShareStatus?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sharedWithPrefix: Swift.String? = nil,
        status: WellArchitectedClientTypes.ShareStatus? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sharedWithPrefix = sharedWithPrefix
        self.status = status
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// A workload share summary return object.
    public struct WorkloadShareSummary: Swift.Sendable {
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// Optional message to compliment the Status field.
        public var statusMessage: Swift.String?

        public init(
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedWith = sharedWith
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

/// Input for List Workload Share
public struct ListWorkloadSharesOutput: Swift.Sendable {
    /// The token to use to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A list of workload share summaries.
    public var workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadShareSummaries: [WellArchitectedClientTypes.WorkloadShareSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadId = workloadId
        self.workloadShareSummaries = workloadShareSummaries
    }
}

extension WellArchitectedClientTypes {

    /// The share invitation.
    public struct ShareInvitation: Swift.Sendable {
        /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
        public var lensAlias: Swift.String?
        /// The ARN for the lens.
        public var lensArn: Swift.String?
        /// The profile ARN.
        public var profileArn: Swift.String?
        /// The ID assigned to the share invitation.
        public var shareInvitationId: Swift.String?
        /// The resource type of the share invitation.
        public var shareResourceType: WellArchitectedClientTypes.ShareResourceType?
        /// The review template ARN.
        public var templateArn: Swift.String?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?

        public init(
            lensAlias: Swift.String? = nil,
            lensArn: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            shareInvitationId: Swift.String? = nil,
            shareResourceType: WellArchitectedClientTypes.ShareResourceType? = nil,
            templateArn: Swift.String? = nil,
            workloadId: Swift.String? = nil
        )
        {
            self.lensAlias = lensAlias
            self.lensArn = lensArn
            self.profileArn = profileArn
            self.shareInvitationId = shareInvitationId
            self.shareResourceType = shareResourceType
            self.templateArn = templateArn
            self.workloadId = workloadId
        }
    }
}

extension WellArchitectedClientTypes {

    /// Share invitation action taken by contributor.
    public enum ShareInvitationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accept
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareInvitationAction] {
            return [
                .accept,
                .reject
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        tags: [Swift.String: Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tags = tags
        self.workloadArn = workloadArn
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// A list of tag keys. Existing tags of the resource whose keys are members of this list are removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// The ARN for the workload.
    /// This member is required.
    public var workloadArn: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        workloadArn: Swift.String? = nil
    )
    {
        self.tagKeys = tagKeys
        self.workloadArn = workloadArn
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Input to update answer.
public struct UpdateAnswerInput: Swift.Sendable {
    /// A list of choices to update on a question in your workload. The String key corresponds to the choice ID to be updated.
    public var choiceUpdates: [Swift.String: WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The reason why a question is not applicable to your workload.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        choiceUpdates: [Swift.String: WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.workloadId = workloadId
    }
}

/// Output of a update answer call.
public struct UpdateAnswerOutput: Swift.Sendable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.Answer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The ARN for the lens.
    public var lensArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.Answer? = nil,
        lensAlias: Swift.String? = nil,
        lensArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.lensArn = lensArn
        self.workloadId = workloadId
    }
}

public struct UpdateGlobalSettingsInput: Swift.Sendable {
    /// The status of discovery support settings.
    public var discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus?
    /// The status of Jira integration settings.
    public var jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationInput?
    /// The status of organization sharing settings.
    public var organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus?

    public init(
        discoveryIntegrationStatus: WellArchitectedClientTypes.DiscoveryIntegrationStatus? = nil,
        jiraConfiguration: WellArchitectedClientTypes.AccountJiraConfigurationInput? = nil,
        organizationSharingStatus: WellArchitectedClientTypes.OrganizationSharingStatus? = nil
    )
    {
        self.discoveryIntegrationStatus = discoveryIntegrationStatus
        self.jiraConfiguration = jiraConfiguration
        self.organizationSharingStatus = organizationSharingStatus
    }
}

public struct UpdateIntegrationInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Which integrated service to update.
    /// This member is required.
    public var integratingService: WellArchitectedClientTypes.IntegratingService?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        integratingService: WellArchitectedClientTypes.IntegratingService? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.integratingService = integratingService
        self.workloadId = workloadId
    }
}

/// Input for update lens review.
public struct UpdateLensReviewInput: Swift.Sendable {
    /// Configuration of the Jira integration.
    public var jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var pillarNotes: [Swift.String: Swift.String]?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        jiraConfiguration: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration? = nil,
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String: Swift.String]? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.jiraConfiguration = jiraConfiguration
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.workloadId = workloadId
    }
}

/// Output of a update lens review call.
public struct UpdateLensReviewOutput: Swift.Sendable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.LensReview?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.LensReview? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.workloadId = workloadId
    }
}

public struct UpdateProfileInput: Swift.Sendable {
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The profile description.
    public var profileDescription: Swift.String?
    /// Profile questions.
    public var profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]?

    public init(
        profileArn: Swift.String? = nil,
        profileDescription: Swift.String? = nil,
        profileQuestions: [WellArchitectedClientTypes.ProfileQuestionUpdate]? = nil
    )
    {
        self.profileArn = profileArn
        self.profileDescription = profileDescription
        self.profileQuestions = profileQuestions
    }
}

public struct UpdateProfileOutput: Swift.Sendable {
    /// The profile.
    public var profile: WellArchitectedClientTypes.Profile?

    public init(
        profile: WellArchitectedClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

public struct UpdateReviewTemplateInput: Swift.Sendable {
    /// The review template description.
    public var description: Swift.String?
    /// A list of lens aliases or ARNs to apply to the review template.
    public var lensesToAssociate: [Swift.String]?
    /// A list of lens aliases or ARNs to unapply to the review template. The wellarchitected lens cannot be unapplied.
    public var lensesToDisassociate: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?
    /// The review template name.
    public var templateName: Swift.String?

    public init(
        description: Swift.String? = nil,
        lensesToAssociate: [Swift.String]? = nil,
        lensesToDisassociate: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        templateArn: Swift.String? = nil,
        templateName: Swift.String? = nil
    )
    {
        self.description = description
        self.lensesToAssociate = lensesToAssociate
        self.lensesToDisassociate = lensesToDisassociate
        self.notes = notes
        self.templateArn = templateArn
        self.templateName = templateName
    }
}

public struct UpdateReviewTemplateOutput: Swift.Sendable {
    /// A review template.
    public var reviewTemplate: WellArchitectedClientTypes.ReviewTemplate?

    public init(
        reviewTemplate: WellArchitectedClientTypes.ReviewTemplate? = nil
    )
    {
        self.reviewTemplate = reviewTemplate
    }
}

public struct UpdateReviewTemplateAnswerInput: Swift.Sendable {
    /// A list of choices to be updated.
    public var choiceUpdates: [Swift.String: WellArchitectedClientTypes.ChoiceUpdate]?
    /// Defines whether this question is applicable to a lens review.
    public var isApplicable: Swift.Bool?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The ID of the question.
    /// This member is required.
    public var questionId: Swift.String?
    /// The update reason.
    public var reason: WellArchitectedClientTypes.AnswerReason?
    /// List of selected choice IDs in a question answer. The values entered replace the previously selected choices.
    public var selectedChoices: [Swift.String]?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        choiceUpdates: [Swift.String: WellArchitectedClientTypes.ChoiceUpdate]? = nil,
        isApplicable: Swift.Bool? = nil,
        lensAlias: Swift.String? = nil,
        notes: Swift.String? = nil,
        questionId: Swift.String? = nil,
        reason: WellArchitectedClientTypes.AnswerReason? = nil,
        selectedChoices: [Swift.String]? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.choiceUpdates = choiceUpdates
        self.isApplicable = isApplicable
        self.lensAlias = lensAlias
        self.notes = notes
        self.questionId = questionId
        self.reason = reason
        self.selectedChoices = selectedChoices
        self.templateArn = templateArn
    }
}

public struct UpdateReviewTemplateAnswerOutput: Swift.Sendable {
    /// An answer of the question.
    public var answer: WellArchitectedClientTypes.ReviewTemplateAnswer?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    public var lensAlias: Swift.String?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        answer: WellArchitectedClientTypes.ReviewTemplateAnswer? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.answer = answer
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

public struct UpdateReviewTemplateLensReviewInput: Swift.Sendable {
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var lensNotes: Swift.String?
    /// List of pillar notes of a lens review in a workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var pillarNotes: [Swift.String: Swift.String]?
    /// The review template ARN.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        lensAlias: Swift.String? = nil,
        lensNotes: Swift.String? = nil,
        pillarNotes: [Swift.String: Swift.String]? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensAlias = lensAlias
        self.lensNotes = lensNotes
        self.pillarNotes = pillarNotes
        self.templateArn = templateArn
    }
}

public struct UpdateReviewTemplateLensReviewOutput: Swift.Sendable {
    /// A lens review of a question.
    public var lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview?
    /// The review template ARN.
    public var templateArn: Swift.String?

    public init(
        lensReview: WellArchitectedClientTypes.ReviewTemplateLensReview? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.lensReview = lensReview
        self.templateArn = templateArn
    }
}

/// Input for Update Share Invitation
public struct UpdateShareInvitationInput: Swift.Sendable {
    /// Share invitation action taken by contributor.
    /// This member is required.
    public var shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction?
    /// The ID assigned to the share invitation.
    /// This member is required.
    public var shareInvitationId: Swift.String?

    public init(
        shareInvitationAction: WellArchitectedClientTypes.ShareInvitationAction? = nil,
        shareInvitationId: Swift.String? = nil
    )
    {
        self.shareInvitationAction = shareInvitationAction
        self.shareInvitationId = shareInvitationId
    }
}

public struct UpdateShareInvitationOutput: Swift.Sendable {
    /// The updated workload or custom lens share invitation.
    public var shareInvitation: WellArchitectedClientTypes.ShareInvitation?

    public init(
        shareInvitation: WellArchitectedClientTypes.ShareInvitation? = nil
    )
    {
        self.shareInvitation = shareInvitation
    }
}

/// Input to update a workload.
public struct UpdateWorkloadInput: Swift.Sendable {
    /// The list of Amazon Web Services account IDs associated with the workload.
    public var accountIds: [Swift.String]?
    /// List of AppRegistry application ARNs to associate to the workload.
    public var applications: [Swift.String]?
    /// The URL of the architectural design for the workload.
    public var architecturalDesign: Swift.String?
    /// The list of Amazon Web Services Regions associated with the workload, for example, us-east-2, or ca-central-1.
    public var awsRegions: [Swift.String]?
    /// The description for the workload.
    public var description: Swift.String?
    /// Well-Architected discovery configuration settings to associate to the workload.
    public var discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig?
    /// The environment for the workload.
    public var environment: WellArchitectedClientTypes.WorkloadEnvironment?
    /// The improvement status for a workload.
    public var improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus?
    /// The industry for the workload.
    public var industry: Swift.String?
    /// The industry type for the workload. If specified, must be one of the following:
    ///
    /// * Agriculture
    ///
    /// * Automobile
    ///
    /// * Defense
    ///
    /// * Design and Engineering
    ///
    /// * Digital Advertising
    ///
    /// * Education
    ///
    /// * Environmental Protection
    ///
    /// * Financial Services
    ///
    /// * Gaming
    ///
    /// * General Public Services
    ///
    /// * Healthcare
    ///
    /// * Hospitality
    ///
    /// * InfoTech
    ///
    /// * Justice and Public Safety
    ///
    /// * Life Sciences
    ///
    /// * Manufacturing
    ///
    /// * Media & Entertainment
    ///
    /// * Mining & Resources
    ///
    /// * Oil & Gas
    ///
    /// * Power & Utilities
    ///
    /// * Professional Services
    ///
    /// * Real Estate & Construction
    ///
    /// * Retail & Wholesale
    ///
    /// * Social Protection
    ///
    /// * Telecommunications
    ///
    /// * Travel, Transportation & Logistics
    ///
    /// * Other
    public var industryType: Swift.String?
    /// Flag indicating whether the workload owner has acknowledged that the Review owner field is required. If a Review owner is not added to the workload within 60 days of acknowledgement, access to the workload is restricted until an owner is added.
    public var isReviewOwnerUpdateAcknowledged: Swift.Bool?
    /// Configuration of the Jira integration.
    public var jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?
    /// The list of non-Amazon Web Services Regions associated with the workload.
    public var nonAwsRegions: [Swift.String]?
    /// The notes associated with the workload. For a review template, these are the notes that will be associated with the workload when the template is applied.
    public var notes: Swift.String?
    /// The priorities of the pillars, which are used to order items in the improvement plan. Each pillar is represented by its [PillarReviewSummary$PillarId].
    public var pillarPriorities: [Swift.String]?
    /// The review owner of the workload. The name, email address, or identifier for the primary group or individual that owns the workload review process.
    public var reviewOwner: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?
    /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
    public var workloadName: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        applications: [Swift.String]? = nil,
        architecturalDesign: Swift.String? = nil,
        awsRegions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        discoveryConfig: WellArchitectedClientTypes.WorkloadDiscoveryConfig? = nil,
        environment: WellArchitectedClientTypes.WorkloadEnvironment? = nil,
        improvementStatus: WellArchitectedClientTypes.WorkloadImprovementStatus? = nil,
        industry: Swift.String? = nil,
        industryType: Swift.String? = nil,
        isReviewOwnerUpdateAcknowledged: Swift.Bool? = nil,
        jiraConfiguration: WellArchitectedClientTypes.WorkloadJiraConfigurationInput? = nil,
        nonAwsRegions: [Swift.String]? = nil,
        notes: Swift.String? = nil,
        pillarPriorities: [Swift.String]? = nil,
        reviewOwner: Swift.String? = nil,
        workloadId: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.applications = applications
        self.architecturalDesign = architecturalDesign
        self.awsRegions = awsRegions
        self.description = description
        self.discoveryConfig = discoveryConfig
        self.environment = environment
        self.improvementStatus = improvementStatus
        self.industry = industry
        self.industryType = industryType
        self.isReviewOwnerUpdateAcknowledged = isReviewOwnerUpdateAcknowledged
        self.jiraConfiguration = jiraConfiguration
        self.nonAwsRegions = nonAwsRegions
        self.notes = notes
        self.pillarPriorities = pillarPriorities
        self.reviewOwner = reviewOwner
        self.workloadId = workloadId
        self.workloadName = workloadName
    }
}

/// Output of an update workload call.
public struct UpdateWorkloadOutput: Swift.Sendable {
    /// A workload return object.
    public var workload: WellArchitectedClientTypes.Workload?

    public init(
        workload: WellArchitectedClientTypes.Workload? = nil
    )
    {
        self.workload = workload
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareInput: Swift.Sendable {
    /// Permission granted on a share request.
    /// This member is required.
    public var permissionType: WellArchitectedClientTypes.PermissionType?
    /// The ID associated with the share.
    /// This member is required.
    public var shareId: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        permissionType: WellArchitectedClientTypes.PermissionType? = nil,
        shareId: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.permissionType = permissionType
        self.shareId = shareId
        self.workloadId = workloadId
    }
}

extension WellArchitectedClientTypes {

    /// A workload share return object.
    public struct WorkloadShare: Swift.Sendable {
        /// Permission granted on a share request.
        public var permissionType: WellArchitectedClientTypes.PermissionType?
        /// The ID associated with the share.
        public var shareId: Swift.String?
        /// An Amazon Web Services account ID.
        public var sharedBy: Swift.String?
        /// The Amazon Web Services account ID, organization ID, or organizational unit (OU) ID with which the workload, lens, profile, or review template is shared.
        public var sharedWith: Swift.String?
        /// The status of the share request.
        public var status: WellArchitectedClientTypes.ShareStatus?
        /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
        public var workloadId: Swift.String?
        /// The name of the workload. The name must be unique within an account within an Amazon Web Services Region. Spaces and capitalization are ignored when checking for uniqueness.
        public var workloadName: Swift.String?

        public init(
            permissionType: WellArchitectedClientTypes.PermissionType? = nil,
            shareId: Swift.String? = nil,
            sharedBy: Swift.String? = nil,
            sharedWith: Swift.String? = nil,
            status: WellArchitectedClientTypes.ShareStatus? = nil,
            workloadId: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.permissionType = permissionType
            self.shareId = shareId
            self.sharedBy = sharedBy
            self.sharedWith = sharedWith
            self.status = status
            self.workloadId = workloadId
            self.workloadName = workloadName
        }
    }
}

/// Input for Update Workload Share
public struct UpdateWorkloadShareOutput: Swift.Sendable {
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    public var workloadId: Swift.String?
    /// A workload share return object.
    public var workloadShare: WellArchitectedClientTypes.WorkloadShare?

    public init(
        workloadId: Swift.String? = nil,
        workloadShare: WellArchitectedClientTypes.WorkloadShare? = nil
    )
    {
        self.workloadId = workloadId
        self.workloadShare = workloadShare
    }
}

public struct UpgradeLensReviewInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    /// This member is required.
    public var milestoneName: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.milestoneName = milestoneName
        self.workloadId = workloadId
    }
}

public struct UpgradeProfileVersionInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The name of the milestone in a workload. Milestone names must be unique within a workload.
    public var milestoneName: Swift.String?
    /// The profile ARN.
    /// This member is required.
    public var profileArn: Swift.String?
    /// The ID assigned to the workload. This ID is unique within an Amazon Web Services Region.
    /// This member is required.
    public var workloadId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        milestoneName: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        workloadId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.milestoneName = milestoneName
        self.profileArn = profileArn
        self.workloadId = workloadId
    }
}

public struct UpgradeReviewTemplateLensReviewInput: Swift.Sendable {
    /// A unique case-sensitive string used to ensure that this request is idempotent (executes only once). You should not reuse the same token for other requests. If you retry a request with the same client request token and the same parameters after the original request has completed successfully, the result of the original request is returned. This token is listed as required, however, if you do not specify it, the Amazon Web Services SDKs automatically generate one for you. If you are not using the Amazon Web Services SDK or the CLI, you must provide this token or the request will fail.
    public var clientRequestToken: Swift.String?
    /// The alias of the lens. For Amazon Web Services official lenses, this is either the lens alias, such as serverless, or the lens ARN, such as arn:aws:wellarchitected:us-east-1::lens/serverless. Note that some operations (such as ExportLens and CreateLensShare) are not permitted on Amazon Web Services official lenses. For custom lenses, this is the lens ARN, such as arn:aws:wellarchitected:us-west-2:123456789012:lens/0123456789abcdef01234567890abcdef. Each lens is identified by its [LensSummary$LensAlias].
    /// This member is required.
    public var lensAlias: Swift.String?
    /// The ARN of the review template.
    /// This member is required.
    public var templateArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        lensAlias: Swift.String? = nil,
        templateArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.lensAlias = lensAlias
        self.templateArn = templateArn
    }
}

extension AssociateLensesInput {

    static func urlPathProvider(_ value: AssociateLensesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/associateLenses"
    }
}

extension AssociateProfilesInput {

    static func urlPathProvider(_ value: AssociateProfilesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/associateProfiles"
    }
}

extension CreateLensShareInput {

    static func urlPathProvider(_ value: CreateLensShareInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

extension CreateLensVersionInput {

    static func urlPathProvider(_ value: CreateLensVersionInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versions"
    }
}

extension CreateMilestoneInput {

    static func urlPathProvider(_ value: CreateMilestoneInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/profiles"
    }
}

extension CreateProfileShareInput {

    static func urlPathProvider(_ value: CreateProfileShareInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares"
    }
}

extension CreateReviewTemplateInput {

    static func urlPathProvider(_ value: CreateReviewTemplateInput) -> Swift.String? {
        return "/reviewTemplates"
    }
}

extension CreateTemplateShareInput {

    static func urlPathProvider(_ value: CreateTemplateShareInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())"
    }
}

extension CreateWorkloadInput {

    static func urlPathProvider(_ value: CreateWorkloadInput) -> Swift.String? {
        return "/workloads"
    }
}

extension CreateWorkloadShareInput {

    static func urlPathProvider(_ value: CreateWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

extension DeleteLensInput {

    static func urlPathProvider(_ value: DeleteLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

extension DeleteLensInput {

    static func queryItemProvider(_ value: DeleteLensInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        guard let lensStatus = value.lensStatus else {
            let message = "Creating a URL Query Item failed. lensStatus is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lensStatusQueryItem = Smithy.URIQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
        items.append(lensStatusQueryItem)
        return items
    }
}

extension DeleteLensShareInput {

    static func urlPathProvider(_ value: DeleteLensShareInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

extension DeleteLensShareInput {

    static func queryItemProvider(_ value: DeleteLensShareInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

extension DeleteProfileInput {

    static func queryItemProvider(_ value: DeleteProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteProfileShareInput {

    static func urlPathProvider(_ value: DeleteProfileShareInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

extension DeleteProfileShareInput {

    static func queryItemProvider(_ value: DeleteProfileShareInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteReviewTemplateInput {

    static func urlPathProvider(_ value: DeleteReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

extension DeleteReviewTemplateInput {

    static func queryItemProvider(_ value: DeleteReviewTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteTemplateShareInput {

    static func urlPathProvider(_ value: DeleteTemplateShareInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())/\(shareId.urlPercentEncoding())"
    }
}

extension DeleteTemplateShareInput {

    static func queryItemProvider(_ value: DeleteTemplateShareInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteWorkloadInput {

    static func urlPathProvider(_ value: DeleteWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

extension DeleteWorkloadInput {

    static func queryItemProvider(_ value: DeleteWorkloadInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DeleteWorkloadShareInput {

    static func urlPathProvider(_ value: DeleteWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

extension DeleteWorkloadShareInput {

    static func queryItemProvider(_ value: DeleteWorkloadShareInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let clientRequestToken = value.clientRequestToken else {
            let message = "Creating a URL Query Item failed. clientRequestToken is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let clientRequestTokenQueryItem = Smithy.URIQueryItem(name: "ClientRequestToken".urlPercentEncoding(), value: Swift.String(clientRequestToken).urlPercentEncoding())
        items.append(clientRequestTokenQueryItem)
        return items
    }
}

extension DisassociateLensesInput {

    static func urlPathProvider(_ value: DisassociateLensesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/disassociateLenses"
    }
}

extension DisassociateProfilesInput {

    static func urlPathProvider(_ value: DisassociateProfilesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/disassociateProfiles"
    }
}

extension ExportLensInput {

    static func urlPathProvider(_ value: ExportLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/export"
    }
}

extension ExportLensInput {

    static func queryItemProvider(_ value: ExportLensInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let lensVersion = value.lensVersion {
            let lensVersionQueryItem = Smithy.URIQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension GetAnswerInput {

    static func urlPathProvider(_ value: GetAnswerInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

extension GetAnswerInput {

    static func queryItemProvider(_ value: GetAnswerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetConsolidatedReportInput {

    static func urlPathProvider(_ value: GetConsolidatedReportInput) -> Swift.String? {
        return "/consolidatedReport"
    }
}

extension GetConsolidatedReportInput {

    static func queryItemProvider(_ value: GetConsolidatedReportInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let format = value.format else {
            let message = "Creating a URL Query Item failed. format is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let formatQueryItem = Smithy.URIQueryItem(name: "Format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
        items.append(formatQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let includeSharedResources = value.includeSharedResources {
            let includeSharedResourcesQueryItem = Smithy.URIQueryItem(name: "IncludeSharedResources".urlPercentEncoding(), value: Swift.String(includeSharedResources).urlPercentEncoding())
            items.append(includeSharedResourcesQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetGlobalSettingsInput {

    static func urlPathProvider(_ value: GetGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

extension GetLensInput {

    static func urlPathProvider(_ value: GetLensInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())"
    }
}

extension GetLensInput {

    static func queryItemProvider(_ value: GetLensInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let lensVersion = value.lensVersion {
            let lensVersionQueryItem = Smithy.URIQueryItem(name: "LensVersion".urlPercentEncoding(), value: Swift.String(lensVersion).urlPercentEncoding())
            items.append(lensVersionQueryItem)
        }
        return items
    }
}

extension GetLensReviewInput {

    static func urlPathProvider(_ value: GetLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

extension GetLensReviewInput {

    static func queryItemProvider(_ value: GetLensReviewInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensReviewReportInput {

    static func urlPathProvider(_ value: GetLensReviewReportInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/report"
    }
}

extension GetLensReviewReportInput {

    static func queryItemProvider(_ value: GetLensReviewReportInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension GetLensVersionDifferenceInput {

    static func urlPathProvider(_ value: GetLensVersionDifferenceInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/versionDifference"
    }
}

extension GetLensVersionDifferenceInput {

    static func queryItemProvider(_ value: GetLensVersionDifferenceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let baseLensVersion = value.baseLensVersion {
            let baseLensVersionQueryItem = Smithy.URIQueryItem(name: "BaseLensVersion".urlPercentEncoding(), value: Swift.String(baseLensVersion).urlPercentEncoding())
            items.append(baseLensVersionQueryItem)
        }
        if let targetLensVersion = value.targetLensVersion {
            let targetLensVersionQueryItem = Smithy.URIQueryItem(name: "TargetLensVersion".urlPercentEncoding(), value: Swift.String(targetLensVersion).urlPercentEncoding())
            items.append(targetLensVersionQueryItem)
        }
        return items
    }
}

extension GetMilestoneInput {

    static func urlPathProvider(_ value: GetMilestoneInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let milestoneNumber = value.milestoneNumber else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestones/\(milestoneNumber)"
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

extension GetProfileInput {

    static func queryItemProvider(_ value: GetProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let profileVersion = value.profileVersion {
            let profileVersionQueryItem = Smithy.URIQueryItem(name: "ProfileVersion".urlPercentEncoding(), value: Swift.String(profileVersion).urlPercentEncoding())
            items.append(profileVersionQueryItem)
        }
        return items
    }
}

extension GetProfileTemplateInput {

    static func urlPathProvider(_ value: GetProfileTemplateInput) -> Swift.String? {
        return "/profileTemplate"
    }
}

extension GetReviewTemplateInput {

    static func urlPathProvider(_ value: GetReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

extension GetReviewTemplateAnswerInput {

    static func urlPathProvider(_ value: GetReviewTemplateAnswerInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

extension GetReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: GetReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

extension GetWorkloadInput {

    static func urlPathProvider(_ value: GetWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

extension ImportLensInput {

    static func urlPathProvider(_ value: ImportLensInput) -> Swift.String? {
        return "/importLens"
    }
}

extension ListAnswersInput {

    static func urlPathProvider(_ value: ListAnswersInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
    }
}

extension ListAnswersInput {

    static func queryItemProvider(_ value: ListAnswersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let questionPriority = value.questionPriority {
            let questionPriorityQueryItem = Smithy.URIQueryItem(name: "QuestionPriority".urlPercentEncoding(), value: Swift.String(questionPriority.rawValue).urlPercentEncoding())
            items.append(questionPriorityQueryItem)
        }
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = Smithy.URIQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListCheckDetailsInput {

    static func urlPathProvider(_ value: ListCheckDetailsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/checks"
    }
}

extension ListCheckSummariesInput {

    static func urlPathProvider(_ value: ListCheckSummariesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/checkSummaries"
    }
}

extension ListLensesInput {

    static func urlPathProvider(_ value: ListLensesInput) -> Swift.String? {
        return "/lenses"
    }
}

extension ListLensesInput {

    static func queryItemProvider(_ value: ListLensesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let lensName = value.lensName {
            let lensNameQueryItem = Smithy.URIQueryItem(name: "LensName".urlPercentEncoding(), value: Swift.String(lensName).urlPercentEncoding())
            items.append(lensNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let lensType = value.lensType {
            let lensTypeQueryItem = Smithy.URIQueryItem(name: "LensType".urlPercentEncoding(), value: Swift.String(lensType.rawValue).urlPercentEncoding())
            items.append(lensTypeQueryItem)
        }
        if let lensStatus = value.lensStatus {
            let lensStatusQueryItem = Smithy.URIQueryItem(name: "LensStatus".urlPercentEncoding(), value: Swift.String(lensStatus.rawValue).urlPercentEncoding())
            items.append(lensStatusQueryItem)
        }
        return items
    }
}

extension ListLensReviewImprovementsInput {

    static func urlPathProvider(_ value: ListLensReviewImprovementsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/improvements"
    }
}

extension ListLensReviewImprovementsInput {

    static func queryItemProvider(_ value: ListLensReviewImprovementsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let questionPriority = value.questionPriority {
            let questionPriorityQueryItem = Smithy.URIQueryItem(name: "QuestionPriority".urlPercentEncoding(), value: Swift.String(questionPriority.rawValue).urlPercentEncoding())
            items.append(questionPriorityQueryItem)
        }
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = Smithy.URIQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensReviewsInput {

    static func urlPathProvider(_ value: ListLensReviewsInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews"
    }
}

extension ListLensReviewsInput {

    static func queryItemProvider(_ value: ListLensReviewsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let milestoneNumber = value.milestoneNumber {
            let milestoneNumberQueryItem = Smithy.URIQueryItem(name: "MilestoneNumber".urlPercentEncoding(), value: Swift.String(milestoneNumber).urlPercentEncoding())
            items.append(milestoneNumberQueryItem)
        }
        return items
    }
}

extension ListLensSharesInput {

    static func urlPathProvider(_ value: ListLensSharesInput) -> Swift.String? {
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/lenses/\(lensAlias.urlPercentEncoding())/shares"
    }
}

extension ListLensSharesInput {

    static func queryItemProvider(_ value: ListLensSharesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = Smithy.URIQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMilestonesInput {

    static func urlPathProvider(_ value: ListMilestonesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/milestonesSummaries"
    }
}

extension ListNotificationsInput {

    static func urlPathProvider(_ value: ListNotificationsInput) -> Swift.String? {
        return "/notifications"
    }
}

extension ListProfileNotificationsInput {

    static func urlPathProvider(_ value: ListProfileNotificationsInput) -> Swift.String? {
        return "/profileNotifications"
    }
}

extension ListProfileNotificationsInput {

    static func queryItemProvider(_ value: ListProfileNotificationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let workloadId = value.workloadId {
            let workloadIdQueryItem = Smithy.URIQueryItem(name: "WorkloadId".urlPercentEncoding(), value: Swift.String(workloadId).urlPercentEncoding())
            items.append(workloadIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/profileSummaries"
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let profileNamePrefix = value.profileNamePrefix {
            let profileNamePrefixQueryItem = Smithy.URIQueryItem(name: "ProfileNamePrefix".urlPercentEncoding(), value: Swift.String(profileNamePrefix).urlPercentEncoding())
            items.append(profileNamePrefixQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let profileOwnerType = value.profileOwnerType {
            let profileOwnerTypeQueryItem = Smithy.URIQueryItem(name: "ProfileOwnerType".urlPercentEncoding(), value: Swift.String(profileOwnerType.rawValue).urlPercentEncoding())
            items.append(profileOwnerTypeQueryItem)
        }
        return items
    }
}

extension ListProfileSharesInput {

    static func urlPathProvider(_ value: ListProfileSharesInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())/shares"
    }
}

extension ListProfileSharesInput {

    static func queryItemProvider(_ value: ListProfileSharesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = Smithy.URIQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReviewTemplateAnswersInput {

    static func urlPathProvider(_ value: ListReviewTemplateAnswersInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers"
    }
}

extension ListReviewTemplateAnswersInput {

    static func queryItemProvider(_ value: ListReviewTemplateAnswersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let pillarId = value.pillarId {
            let pillarIdQueryItem = Smithy.URIQueryItem(name: "PillarId".urlPercentEncoding(), value: Swift.String(pillarId).urlPercentEncoding())
            items.append(pillarIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReviewTemplatesInput {

    static func urlPathProvider(_ value: ListReviewTemplatesInput) -> Swift.String? {
        return "/reviewTemplates"
    }
}

extension ListReviewTemplatesInput {

    static func queryItemProvider(_ value: ListReviewTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListShareInvitationsInput {

    static func urlPathProvider(_ value: ListShareInvitationsInput) -> Swift.String? {
        return "/shareInvitations"
    }
}

extension ListShareInvitationsInput {

    static func queryItemProvider(_ value: ListShareInvitationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let lensNamePrefix = value.lensNamePrefix {
            let lensNamePrefixQueryItem = Smithy.URIQueryItem(name: "LensNamePrefix".urlPercentEncoding(), value: Swift.String(lensNamePrefix).urlPercentEncoding())
            items.append(lensNamePrefixQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let profileNamePrefix = value.profileNamePrefix {
            let profileNamePrefixQueryItem = Smithy.URIQueryItem(name: "ProfileNamePrefix".urlPercentEncoding(), value: Swift.String(profileNamePrefix).urlPercentEncoding())
            items.append(profileNamePrefixQueryItem)
        }
        if let shareResourceType = value.shareResourceType {
            let shareResourceTypeQueryItem = Smithy.URIQueryItem(name: "ShareResourceType".urlPercentEncoding(), value: Swift.String(shareResourceType.rawValue).urlPercentEncoding())
            items.append(shareResourceTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let workloadNamePrefix = value.workloadNamePrefix {
            let workloadNamePrefixQueryItem = Smithy.URIQueryItem(name: "WorkloadNamePrefix".urlPercentEncoding(), value: Swift.String(workloadNamePrefix).urlPercentEncoding())
            items.append(workloadNamePrefixQueryItem)
        }
        if let templateNamePrefix = value.templateNamePrefix {
            let templateNamePrefixQueryItem = Smithy.URIQueryItem(name: "TemplateNamePrefix".urlPercentEncoding(), value: Swift.String(templateNamePrefix).urlPercentEncoding())
            items.append(templateNamePrefixQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

extension ListTemplateSharesInput {

    static func urlPathProvider(_ value: ListTemplateSharesInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/templates/shares/\(templateArn.urlPercentEncoding())"
    }
}

extension ListTemplateSharesInput {

    static func queryItemProvider(_ value: ListTemplateSharesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = Smithy.URIQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkloadsInput {

    static func urlPathProvider(_ value: ListWorkloadsInput) -> Swift.String? {
        return "/workloadsSummaries"
    }
}

extension ListWorkloadSharesInput {

    static func urlPathProvider(_ value: ListWorkloadSharesInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares"
    }
}

extension ListWorkloadSharesInput {

    static func queryItemProvider(_ value: ListWorkloadSharesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sharedWithPrefix = value.sharedWithPrefix {
            let sharedWithPrefixQueryItem = Smithy.URIQueryItem(name: "SharedWithPrefix".urlPercentEncoding(), value: Swift.String(sharedWithPrefix).urlPercentEncoding())
            items.append(sharedWithPrefixQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let workloadArn = value.workloadArn else {
            return nil
        }
        return "/tags/\(workloadArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAnswerInput {

    static func urlPathProvider(_ value: UpdateAnswerInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

extension UpdateGlobalSettingsInput {

    static func urlPathProvider(_ value: UpdateGlobalSettingsInput) -> Swift.String? {
        return "/global-settings"
    }
}

extension UpdateIntegrationInput {

    static func urlPathProvider(_ value: UpdateIntegrationInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/updateIntegration"
    }
}

extension UpdateLensReviewInput {

    static func urlPathProvider(_ value: UpdateLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/profiles/\(profileArn.urlPercentEncoding())"
    }
}

extension UpdateReviewTemplateInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())"
    }
}

extension UpdateReviewTemplateAnswerInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateAnswerInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        guard let questionId = value.questionId else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/answers/\(questionId.urlPercentEncoding())"
    }
}

extension UpdateReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: UpdateReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())"
    }
}

extension UpdateShareInvitationInput {

    static func urlPathProvider(_ value: UpdateShareInvitationInput) -> Swift.String? {
        guard let shareInvitationId = value.shareInvitationId else {
            return nil
        }
        return "/shareInvitations/\(shareInvitationId.urlPercentEncoding())"
    }
}

extension UpdateWorkloadInput {

    static func urlPathProvider(_ value: UpdateWorkloadInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())"
    }
}

extension UpdateWorkloadShareInput {

    static func urlPathProvider(_ value: UpdateWorkloadShareInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let shareId = value.shareId else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/shares/\(shareId.urlPercentEncoding())"
    }
}

extension UpgradeLensReviewInput {

    static func urlPathProvider(_ value: UpgradeLensReviewInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
    }
}

extension UpgradeProfileVersionInput {

    static func urlPathProvider(_ value: UpgradeProfileVersionInput) -> Swift.String? {
        guard let workloadId = value.workloadId else {
            return nil
        }
        guard let profileArn = value.profileArn else {
            return nil
        }
        return "/workloads/\(workloadId.urlPercentEncoding())/profiles/\(profileArn.urlPercentEncoding())/upgrade"
    }
}

extension UpgradeReviewTemplateLensReviewInput {

    static func urlPathProvider(_ value: UpgradeReviewTemplateLensReviewInput) -> Swift.String? {
        guard let templateArn = value.templateArn else {
            return nil
        }
        guard let lensAlias = value.lensAlias else {
            return nil
        }
        return "/reviewTemplates/\(templateArn.urlPercentEncoding())/lensReviews/\(lensAlias.urlPercentEncoding())/upgrade"
    }
}

extension AssociateLensesInput {

    static func write(value: AssociateLensesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LensAliases"].writeList(value.lensAliases, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateProfilesInput {

    static func write(value: AssociateProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileArns"].writeList(value.profileArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLensShareInput {

    static func write(value: CreateLensShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["SharedWith"].write(value.sharedWith)
    }
}

extension CreateLensVersionInput {

    static func write(value: CreateLensVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["IsMajorVersion"].write(value.isMajorVersion)
        try writer["LensVersion"].write(value.lensVersion)
    }
}

extension CreateMilestoneInput {

    static func write(value: CreateMilestoneInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["MilestoneName"].write(value.milestoneName)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ProfileDescription"].write(value.profileDescription)
        try writer["ProfileName"].write(value.profileName)
        try writer["ProfileQuestions"].writeList(value.profileQuestions, memberWritingClosure: WellArchitectedClientTypes.ProfileQuestionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateProfileShareInput {

    static func write(value: CreateProfileShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["SharedWith"].write(value.sharedWith)
    }
}

extension CreateReviewTemplateInput {

    static func write(value: CreateReviewTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["Lenses"].writeList(value.lenses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Notes"].write(value.notes)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TemplateName"].write(value.templateName)
    }
}

extension CreateTemplateShareInput {

    static func write(value: CreateTemplateShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["SharedWith"].write(value.sharedWith)
    }
}

extension CreateWorkloadInput {

    static func write(value: CreateWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Applications"].writeList(value.applications, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ArchitecturalDesign"].write(value.architecturalDesign)
        try writer["AwsRegions"].writeList(value.awsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Description"].write(value.description)
        try writer["DiscoveryConfig"].write(value.discoveryConfig, with: WellArchitectedClientTypes.WorkloadDiscoveryConfig.write(value:to:))
        try writer["Environment"].write(value.environment)
        try writer["Industry"].write(value.industry)
        try writer["IndustryType"].write(value.industryType)
        try writer["JiraConfiguration"].write(value.jiraConfiguration, with: WellArchitectedClientTypes.WorkloadJiraConfigurationInput.write(value:to:))
        try writer["Lenses"].writeList(value.lenses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NonAwsRegions"].writeList(value.nonAwsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Notes"].write(value.notes)
        try writer["PillarPriorities"].writeList(value.pillarPriorities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProfileArns"].writeList(value.profileArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReviewOwner"].write(value.reviewOwner)
        try writer["ReviewTemplateArns"].writeList(value.reviewTemplateArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WorkloadName"].write(value.workloadName)
    }
}

extension CreateWorkloadShareInput {

    static func write(value: CreateWorkloadShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["PermissionType"].write(value.permissionType)
        try writer["SharedWith"].write(value.sharedWith)
    }
}

extension DisassociateLensesInput {

    static func write(value: DisassociateLensesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LensAliases"].writeList(value.lensAliases, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateProfilesInput {

    static func write(value: DisassociateProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileArns"].writeList(value.profileArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImportLensInput {

    static func write(value: ImportLensInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["JSONString"].write(value.jsonString)
        try writer["LensAlias"].write(value.lensAlias)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListCheckDetailsInput {

    static func write(value: ListCheckDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChoiceId"].write(value.choiceId)
        try writer["LensArn"].write(value.lensArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PillarId"].write(value.pillarId)
        try writer["QuestionId"].write(value.questionId)
    }
}

extension ListCheckSummariesInput {

    static func write(value: ListCheckSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChoiceId"].write(value.choiceId)
        try writer["LensArn"].write(value.lensArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PillarId"].write(value.pillarId)
        try writer["QuestionId"].write(value.questionId)
    }
}

extension ListMilestonesInput {

    static func write(value: ListMilestonesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListNotificationsInput {

    static func write(value: ListNotificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["WorkloadId"].write(value.workloadId)
    }
}

extension ListWorkloadsInput {

    static func write(value: ListWorkloadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WorkloadNamePrefix"].write(value.workloadNamePrefix)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAnswerInput {

    static func write(value: UpdateAnswerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChoiceUpdates"].writeMap(value.choiceUpdates, valueWritingClosure: WellArchitectedClientTypes.ChoiceUpdate.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["IsApplicable"].write(value.isApplicable)
        try writer["Notes"].write(value.notes)
        try writer["Reason"].write(value.reason)
        try writer["SelectedChoices"].writeList(value.selectedChoices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGlobalSettingsInput {

    static func write(value: UpdateGlobalSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DiscoveryIntegrationStatus"].write(value.discoveryIntegrationStatus)
        try writer["JiraConfiguration"].write(value.jiraConfiguration, with: WellArchitectedClientTypes.AccountJiraConfigurationInput.write(value:to:))
        try writer["OrganizationSharingStatus"].write(value.organizationSharingStatus)
    }
}

extension UpdateIntegrationInput {

    static func write(value: UpdateIntegrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["IntegratingService"].write(value.integratingService)
    }
}

extension UpdateLensReviewInput {

    static func write(value: UpdateLensReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JiraConfiguration"].write(value.jiraConfiguration, with: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration.write(value:to:))
        try writer["LensNotes"].write(value.lensNotes)
        try writer["PillarNotes"].writeMap(value.pillarNotes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProfileDescription"].write(value.profileDescription)
        try writer["ProfileQuestions"].writeList(value.profileQuestions, memberWritingClosure: WellArchitectedClientTypes.ProfileQuestionUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateReviewTemplateInput {

    static func write(value: UpdateReviewTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["LensesToAssociate"].writeList(value.lensesToAssociate, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LensesToDisassociate"].writeList(value.lensesToDisassociate, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Notes"].write(value.notes)
        try writer["TemplateName"].write(value.templateName)
    }
}

extension UpdateReviewTemplateAnswerInput {

    static func write(value: UpdateReviewTemplateAnswerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChoiceUpdates"].writeMap(value.choiceUpdates, valueWritingClosure: WellArchitectedClientTypes.ChoiceUpdate.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["IsApplicable"].write(value.isApplicable)
        try writer["Notes"].write(value.notes)
        try writer["Reason"].write(value.reason)
        try writer["SelectedChoices"].writeList(value.selectedChoices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateReviewTemplateLensReviewInput {

    static func write(value: UpdateReviewTemplateLensReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LensNotes"].write(value.lensNotes)
        try writer["PillarNotes"].writeMap(value.pillarNotes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateShareInvitationInput {

    static func write(value: UpdateShareInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ShareInvitationAction"].write(value.shareInvitationAction)
    }
}

extension UpdateWorkloadInput {

    static func write(value: UpdateWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Applications"].writeList(value.applications, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ArchitecturalDesign"].write(value.architecturalDesign)
        try writer["AwsRegions"].writeList(value.awsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["DiscoveryConfig"].write(value.discoveryConfig, with: WellArchitectedClientTypes.WorkloadDiscoveryConfig.write(value:to:))
        try writer["Environment"].write(value.environment)
        try writer["ImprovementStatus"].write(value.improvementStatus)
        try writer["Industry"].write(value.industry)
        try writer["IndustryType"].write(value.industryType)
        try writer["IsReviewOwnerUpdateAcknowledged"].write(value.isReviewOwnerUpdateAcknowledged)
        try writer["JiraConfiguration"].write(value.jiraConfiguration, with: WellArchitectedClientTypes.WorkloadJiraConfigurationInput.write(value:to:))
        try writer["NonAwsRegions"].writeList(value.nonAwsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Notes"].write(value.notes)
        try writer["PillarPriorities"].writeList(value.pillarPriorities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReviewOwner"].write(value.reviewOwner)
        try writer["WorkloadName"].write(value.workloadName)
    }
}

extension UpdateWorkloadShareInput {

    static func write(value: UpdateWorkloadShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PermissionType"].write(value.permissionType)
    }
}

extension UpgradeLensReviewInput {

    static func write(value: UpgradeLensReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["MilestoneName"].write(value.milestoneName)
    }
}

extension UpgradeProfileVersionInput {

    static func write(value: UpgradeProfileVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["MilestoneName"].write(value.milestoneName)
    }
}

extension UpgradeReviewTemplateLensReviewInput {

    static func write(value: UpgradeReviewTemplateLensReviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
    }
}

extension AssociateLensesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateLensesOutput {
        return AssociateLensesOutput()
    }
}

extension AssociateProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateProfilesOutput {
        return AssociateProfilesOutput()
    }
}

extension CreateLensShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLensShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLensShareOutput()
        value.shareId = try reader["ShareId"].readIfPresent()
        return value
    }
}

extension CreateLensVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLensVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLensVersionOutput()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        return value
    }
}

extension CreateMilestoneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMilestoneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMilestoneOutput()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileVersion = try reader["ProfileVersion"].readIfPresent()
        return value
    }
}

extension CreateProfileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileShareOutput()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.shareId = try reader["ShareId"].readIfPresent()
        return value
    }
}

extension CreateReviewTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReviewTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReviewTemplateOutput()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension CreateTemplateShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTemplateShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTemplateShareOutput()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension CreateWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkloadOutput()
        value.workloadArn = try reader["WorkloadArn"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension CreateWorkloadShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkloadShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkloadShareOutput()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension DeleteLensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLensOutput {
        return DeleteLensOutput()
    }
}

extension DeleteLensShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLensShareOutput {
        return DeleteLensShareOutput()
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        return DeleteProfileOutput()
    }
}

extension DeleteProfileShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileShareOutput {
        return DeleteProfileShareOutput()
    }
}

extension DeleteReviewTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReviewTemplateOutput {
        return DeleteReviewTemplateOutput()
    }
}

extension DeleteTemplateShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTemplateShareOutput {
        return DeleteTemplateShareOutput()
    }
}

extension DeleteWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkloadOutput {
        return DeleteWorkloadOutput()
    }
}

extension DeleteWorkloadShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkloadShareOutput {
        return DeleteWorkloadShareOutput()
    }
}

extension DisassociateLensesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateLensesOutput {
        return DisassociateLensesOutput()
    }
}

extension DisassociateProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateProfilesOutput {
        return DisassociateProfilesOutput()
    }
}

extension ExportLensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportLensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportLensOutput()
        value.lensJSON = try reader["LensJSON"].readIfPresent()
        return value
    }
}

extension GetAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnswerOutput()
        value.answer = try reader["Answer"].readIfPresent(with: WellArchitectedClientTypes.Answer.read(from:))
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension GetConsolidatedReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConsolidatedReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConsolidatedReportOutput()
        value.base64String = try reader["Base64String"].readIfPresent()
        value.metrics = try reader["Metrics"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ConsolidatedReportMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlobalSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlobalSettingsOutput()
        value.discoveryIntegrationStatus = try reader["DiscoveryIntegrationStatus"].readIfPresent()
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.AccountJiraConfigurationOutput.read(from:))
        value.organizationSharingStatus = try reader["OrganizationSharingStatus"].readIfPresent()
        return value
    }
}

extension GetLensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLensOutput()
        value.lens = try reader["Lens"].readIfPresent(with: WellArchitectedClientTypes.Lens.read(from:))
        return value
    }
}

extension GetLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLensReviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLensReviewOutput()
        value.lensReview = try reader["LensReview"].readIfPresent(with: WellArchitectedClientTypes.LensReview.read(from:))
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension GetLensReviewReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLensReviewReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLensReviewReportOutput()
        value.lensReviewReport = try reader["LensReviewReport"].readIfPresent(with: WellArchitectedClientTypes.LensReviewReport.read(from:))
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension GetLensVersionDifferenceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLensVersionDifferenceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLensVersionDifferenceOutput()
        value.baseLensVersion = try reader["BaseLensVersion"].readIfPresent()
        value.latestLensVersion = try reader["LatestLensVersion"].readIfPresent()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.targetLensVersion = try reader["TargetLensVersion"].readIfPresent()
        value.versionDifferences = try reader["VersionDifferences"].readIfPresent(with: WellArchitectedClientTypes.VersionDifferences.read(from:))
        return value
    }
}

extension GetMilestoneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMilestoneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMilestoneOutput()
        value.milestone = try reader["Milestone"].readIfPresent(with: WellArchitectedClientTypes.Milestone.read(from:))
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.profile = try reader["Profile"].readIfPresent(with: WellArchitectedClientTypes.Profile.read(from:))
        return value
    }
}

extension GetProfileTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileTemplateOutput()
        value.profileTemplate = try reader["ProfileTemplate"].readIfPresent(with: WellArchitectedClientTypes.ProfileTemplate.read(from:))
        return value
    }
}

extension GetReviewTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReviewTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReviewTemplateOutput()
        value.reviewTemplate = try reader["ReviewTemplate"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplate.read(from:))
        return value
    }
}

extension GetReviewTemplateAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReviewTemplateAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReviewTemplateAnswerOutput()
        value.answer = try reader["Answer"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplateAnswer.read(from:))
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension GetReviewTemplateLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReviewTemplateLensReviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReviewTemplateLensReviewOutput()
        value.lensReview = try reader["LensReview"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplateLensReview.read(from:))
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension GetWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadOutput()
        value.workload = try reader["Workload"].readIfPresent(with: WellArchitectedClientTypes.Workload.read(from:))
        return value
    }
}

extension ImportLensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportLensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportLensOutput()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ListAnswersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnswersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnswersOutput()
        value.answerSummaries = try reader["AnswerSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.AnswerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension ListCheckDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCheckDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCheckDetailsOutput()
        value.checkDetails = try reader["CheckDetails"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.CheckDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCheckSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCheckSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCheckSummariesOutput()
        value.checkSummaries = try reader["CheckSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.CheckSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLensesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLensesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLensesOutput()
        value.lensSummaries = try reader["LensSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.LensSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLensReviewImprovementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLensReviewImprovementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLensReviewImprovementsOutput()
        value.improvementSummaries = try reader["ImprovementSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ImprovementSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension ListLensReviewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLensReviewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLensReviewsOutput()
        value.lensReviewSummaries = try reader["LensReviewSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.LensReviewSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension ListLensSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLensSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLensSharesOutput()
        value.lensShareSummaries = try reader["LensShareSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.LensShareSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMilestonesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMilestonesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMilestonesOutput()
        value.milestoneSummaries = try reader["MilestoneSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.MilestoneSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension ListNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notificationSummaries = try reader["NotificationSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.NotificationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProfileNotificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileNotificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileNotificationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notificationSummaries = try reader["NotificationSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileNotificationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profileSummaries = try reader["ProfileSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProfileSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfileSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfileSharesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profileShareSummaries = try reader["ProfileShareSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileShareSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListReviewTemplateAnswersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReviewTemplateAnswersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReviewTemplateAnswersOutput()
        value.answerSummaries = try reader["AnswerSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ReviewTemplateAnswerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension ListReviewTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListReviewTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListReviewTemplatesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reviewTemplates = try reader["ReviewTemplates"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ReviewTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListShareInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListShareInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListShareInvitationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.shareInvitationSummaries = try reader["ShareInvitationSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ShareInvitationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTemplateSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplateSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplateSharesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        value.templateShareSummaries = try reader["TemplateShareSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.TemplateShareSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkloadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadSummaries = try reader["WorkloadSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkloadSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadSharesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadShareSummaries = try reader["WorkloadShareSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadShareSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnswerOutput()
        value.answer = try reader["Answer"].readIfPresent(with: WellArchitectedClientTypes.Answer.read(from:))
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension UpdateGlobalSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlobalSettingsOutput {
        return UpdateGlobalSettingsOutput()
    }
}

extension UpdateIntegrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIntegrationOutput {
        return UpdateIntegrationOutput()
    }
}

extension UpdateLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLensReviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLensReviewOutput()
        value.lensReview = try reader["LensReview"].readIfPresent(with: WellArchitectedClientTypes.LensReview.read(from:))
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.profile = try reader["Profile"].readIfPresent(with: WellArchitectedClientTypes.Profile.read(from:))
        return value
    }
}

extension UpdateReviewTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReviewTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReviewTemplateOutput()
        value.reviewTemplate = try reader["ReviewTemplate"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplate.read(from:))
        return value
    }
}

extension UpdateReviewTemplateAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReviewTemplateAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReviewTemplateAnswerOutput()
        value.answer = try reader["Answer"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplateAnswer.read(from:))
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension UpdateReviewTemplateLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReviewTemplateLensReviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateReviewTemplateLensReviewOutput()
        value.lensReview = try reader["LensReview"].readIfPresent(with: WellArchitectedClientTypes.ReviewTemplateLensReview.read(from:))
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension UpdateShareInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateShareInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateShareInvitationOutput()
        value.shareInvitation = try reader["ShareInvitation"].readIfPresent(with: WellArchitectedClientTypes.ShareInvitation.read(from:))
        return value
    }
}

extension UpdateWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkloadOutput()
        value.workload = try reader["Workload"].readIfPresent(with: WellArchitectedClientTypes.Workload.read(from:))
        return value
    }
}

extension UpdateWorkloadShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkloadShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkloadShareOutput()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadShare = try reader["WorkloadShare"].readIfPresent(with: WellArchitectedClientTypes.WorkloadShare.read(from:))
        return value
    }
}

extension UpgradeLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeLensReviewOutput {
        return UpgradeLensReviewOutput()
    }
}

extension UpgradeProfileVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeProfileVersionOutput {
        return UpgradeProfileVersionOutput()
    }
}

extension UpgradeReviewTemplateLensReviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeReviewTemplateLensReviewOutput {
        return UpgradeReviewTemplateLensReviewOutput()
    }
}

enum AssociateLensesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLensShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLensVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMilestoneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReviewTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTemplateShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkloadShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLensShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReviewTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTemplateShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkloadShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateLensesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportLensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConsolidatedReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLensReviewReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLensVersionDifferenceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMilestoneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReviewTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReviewTemplateAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReviewTemplateLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportLensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnswersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCheckDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCheckSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLensesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLensReviewImprovementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLensReviewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLensSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMilestonesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileNotificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfileSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReviewTemplateAnswersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListReviewTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListShareInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplateSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlobalSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIntegrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReviewTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReviewTemplateAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReviewTemplateLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateShareInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkloadShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeProfileVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeReviewTemplateLensReviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WellArchitectedClientTypes.Answer {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Answer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Answer()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.questionDescription = try reader["QuestionDescription"].readIfPresent()
        value.improvementPlanUrl = try reader["ImprovementPlanUrl"].readIfPresent()
        value.helpfulResourceUrl = try reader["HelpfulResourceUrl"].readIfPresent()
        value.helpfulResourceDisplayText = try reader["HelpfulResourceDisplayText"].readIfPresent()
        value.choices = try reader["Choices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.Choice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedChoices = try reader["SelectedChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.choiceAnswers = try reader["ChoiceAnswers"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isApplicable = try reader["IsApplicable"].readIfPresent()
        value.risk = try reader["Risk"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.JiraConfiguration.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.JiraConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.JiraConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.JiraConfiguration()
        value.jiraIssueUrl = try reader["JiraIssueUrl"].readIfPresent()
        value.lastSyncedTime = try reader["LastSyncedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WellArchitectedClientTypes.ChoiceAnswer {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ChoiceAnswer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ChoiceAnswer()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.Choice {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Choice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Choice()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.helpfulResource = try reader["HelpfulResource"].readIfPresent(with: WellArchitectedClientTypes.ChoiceContent.read(from:))
        value.improvementPlan = try reader["ImprovementPlan"].readIfPresent(with: WellArchitectedClientTypes.ChoiceContent.read(from:))
        value.additionalResources = try reader["AdditionalResources"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.AdditionalResources.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.AdditionalResources {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.AdditionalResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.AdditionalResources()
        value.type = try reader["Type"].readIfPresent()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.ChoiceContent {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ChoiceContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ChoiceContent()
        value.displayText = try reader["DisplayText"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ConsolidatedReportMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ConsolidatedReportMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ConsolidatedReportMetric()
        value.metricType = try reader["MetricType"].readIfPresent()
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.workloadArn = try reader["WorkloadArn"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lenses = try reader["Lenses"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.LensMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lensesAppliedCount = try reader["LensesAppliedCount"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.LensMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensMetric()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.pillars = try reader["Pillars"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.PillarMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.PillarMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.PillarMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.PillarMetric()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.questions = try reader["Questions"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.QuestionMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.QuestionMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.QuestionMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.QuestionMetric()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.risk = try reader["Risk"].readIfPresent()
        value.bestPractices = try reader["BestPractices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.BestPractice.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.BestPractice {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.BestPractice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.BestPractice()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.choiceTitle = try reader["ChoiceTitle"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.AccountJiraConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.AccountJiraConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.AccountJiraConfigurationOutput()
        value.integrationStatus = try reader["IntegrationStatus"].readIfPresent()
        value.issueManagementStatus = try reader["IssueManagementStatus"].readIfPresent()
        value.issueManagementType = try reader["IssueManagementType"].readIfPresent()
        value.subdomain = try reader["Subdomain"].readIfPresent()
        value.jiraProjectKey = try reader["JiraProjectKey"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.Lens {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Lens {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Lens()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.LensReview {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensReview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensReview()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        value.lensName = try reader["LensName"].readIfPresent()
        value.lensStatus = try reader["LensStatus"].readIfPresent()
        value.pillarReviewSummaries = try reader["PillarReviewSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.PillarReviewSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration.read(from:))
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notes = try reader["Notes"].readIfPresent()
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prioritizedRiskCounts = try reader["PrioritizedRiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadProfile()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileVersion = try reader["ProfileVersion"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.JiraSelectedQuestionConfiguration {

    static func write(value: WellArchitectedClientTypes.JiraSelectedQuestionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectedPillars"].writeList(value.selectedPillars, memberWritingClosure: WellArchitectedClientTypes.SelectedPillar.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.JiraSelectedQuestionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.JiraSelectedQuestionConfiguration()
        value.selectedPillars = try reader["SelectedPillars"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.SelectedPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.SelectedPillar {

    static func write(value: WellArchitectedClientTypes.SelectedPillar?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PillarId"].write(value.pillarId)
        try writer["SelectedQuestionIds"].writeList(value.selectedQuestionIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.SelectedPillar {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.SelectedPillar()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.selectedQuestionIds = try reader["SelectedQuestionIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.PillarReviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.PillarReviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.PillarReviewSummary()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.pillarName = try reader["PillarName"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.prioritizedRiskCounts = try reader["PrioritizedRiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.LensReviewReport {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensReviewReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensReviewReport()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.base64String = try reader["Base64String"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.VersionDifferences {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.VersionDifferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.VersionDifferences()
        value.pillarDifferences = try reader["PillarDifferences"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.PillarDifference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.PillarDifference {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.PillarDifference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.PillarDifference()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.pillarName = try reader["PillarName"].readIfPresent()
        value.differenceStatus = try reader["DifferenceStatus"].readIfPresent()
        value.questionDifferences = try reader["QuestionDifferences"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.QuestionDifference.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.QuestionDifference {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.QuestionDifference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.QuestionDifference()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.differenceStatus = try reader["DifferenceStatus"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.Milestone {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Milestone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Milestone()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.milestoneName = try reader["MilestoneName"].readIfPresent()
        value.recordedAt = try reader["RecordedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.workload = try reader["Workload"].readIfPresent(with: WellArchitectedClientTypes.Workload.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.Workload {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Workload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Workload()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadArn = try reader["WorkloadArn"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsRegions = try reader["AwsRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nonAwsRegions = try reader["NonAwsRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.architecturalDesign = try reader["ArchitecturalDesign"].readIfPresent()
        value.reviewOwner = try reader["ReviewOwner"].readIfPresent()
        value.reviewRestrictionDate = try reader["ReviewRestrictionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isReviewOwnerUpdateAcknowledged = try reader["IsReviewOwnerUpdateAcknowledged"].readIfPresent()
        value.industryType = try reader["IndustryType"].readIfPresent()
        value.industry = try reader["Industry"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.improvementStatus = try reader["ImprovementStatus"].readIfPresent()
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.pillarPriorities = try reader["PillarPriorities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lenses = try reader["Lenses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.owner = try reader["Owner"].readIfPresent()
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.discoveryConfig = try reader["DiscoveryConfig"].readIfPresent(with: WellArchitectedClientTypes.WorkloadDiscoveryConfig.read(from:))
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prioritizedRiskCounts = try reader["PrioritizedRiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.WorkloadJiraConfigurationOutput.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadJiraConfigurationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadJiraConfigurationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadJiraConfigurationOutput()
        value.issueManagementStatus = try reader["IssueManagementStatus"].readIfPresent()
        value.issueManagementType = try reader["IssueManagementType"].readIfPresent()
        value.jiraProjectKey = try reader["JiraProjectKey"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadDiscoveryConfig {

    static func write(value: WellArchitectedClientTypes.WorkloadDiscoveryConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrustedAdvisorIntegrationStatus"].write(value.trustedAdvisorIntegrationStatus)
        try writer["WorkloadResourceDefinition"].writeList(value.workloadResourceDefinition, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WellArchitectedClientTypes.DefinitionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadDiscoveryConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadDiscoveryConfig()
        value.trustedAdvisorIntegrationStatus = try reader["TrustedAdvisorIntegrationStatus"].readIfPresent()
        value.workloadResourceDefinition = try reader["WorkloadResourceDefinition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WellArchitectedClientTypes.DefinitionType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.Profile {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.Profile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.Profile()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileVersion = try reader["ProfileVersion"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.profileDescription = try reader["ProfileDescription"].readIfPresent()
        value.profileQuestions = try reader["ProfileQuestions"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileQuestion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.owner = try reader["Owner"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.ProfileQuestion {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileQuestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileQuestion()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.questionDescription = try reader["QuestionDescription"].readIfPresent()
        value.questionChoices = try reader["QuestionChoices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileChoice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedChoiceIds = try reader["SelectedChoiceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minSelectedChoices = try reader["MinSelectedChoices"].readIfPresent()
        value.maxSelectedChoices = try reader["MaxSelectedChoices"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ProfileChoice {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileChoice()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.choiceTitle = try reader["ChoiceTitle"].readIfPresent()
        value.choiceDescription = try reader["ChoiceDescription"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ProfileTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileTemplate()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateQuestions = try reader["TemplateQuestions"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileTemplateQuestion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WellArchitectedClientTypes.ProfileTemplateQuestion {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileTemplateQuestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileTemplateQuestion()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.questionDescription = try reader["QuestionDescription"].readIfPresent()
        value.questionChoices = try reader["QuestionChoices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ProfileTemplateChoice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.minSelectedChoices = try reader["MinSelectedChoices"].readIfPresent()
        value.maxSelectedChoices = try reader["MaxSelectedChoices"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ProfileTemplateChoice {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileTemplateChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileTemplateChoice()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.choiceTitle = try reader["ChoiceTitle"].readIfPresent()
        value.choiceDescription = try reader["ChoiceDescription"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplate()
        value.description = try reader["Description"].readIfPresent()
        value.lenses = try reader["Lenses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notes = try reader["Notes"].readIfPresent()
        value.questionCounts = try reader["QuestionCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.owner = try reader["Owner"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplateAnswer {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplateAnswer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplateAnswer()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.questionDescription = try reader["QuestionDescription"].readIfPresent()
        value.improvementPlanUrl = try reader["ImprovementPlanUrl"].readIfPresent()
        value.helpfulResourceUrl = try reader["HelpfulResourceUrl"].readIfPresent()
        value.helpfulResourceDisplayText = try reader["HelpfulResourceDisplayText"].readIfPresent()
        value.choices = try reader["Choices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.Choice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedChoices = try reader["SelectedChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.choiceAnswers = try reader["ChoiceAnswers"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isApplicable = try reader["IsApplicable"].readIfPresent()
        value.answerStatus = try reader["AnswerStatus"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplateLensReview {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplateLensReview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplateLensReview()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        value.lensName = try reader["LensName"].readIfPresent()
        value.lensStatus = try reader["LensStatus"].readIfPresent()
        value.pillarReviewSummaries = try reader["PillarReviewSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notes = try reader["Notes"].readIfPresent()
        value.questionCounts = try reader["QuestionCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplatePillarReviewSummary()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.pillarName = try reader["PillarName"].readIfPresent()
        value.notes = try reader["Notes"].readIfPresent()
        value.questionCounts = try reader["QuestionCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.AnswerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.AnswerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.AnswerSummary()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.choices = try reader["Choices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.Choice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedChoices = try reader["SelectedChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.choiceAnswerSummaries = try reader["ChoiceAnswerSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceAnswerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isApplicable = try reader["IsApplicable"].readIfPresent()
        value.risk = try reader["Risk"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.questionType = try reader["QuestionType"].readIfPresent()
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.JiraConfiguration.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.ChoiceAnswerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ChoiceAnswerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ChoiceAnswerSummary()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.CheckDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.CheckDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.CheckDetail()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.provider = try reader["Provider"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.flaggedResources = try reader["FlaggedResources"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WellArchitectedClientTypes.CheckSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.CheckSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.CheckSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.provider = try reader["Provider"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.accountSummary = try reader["AccountSummary"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.LensSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensSummary()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensName = try reader["LensName"].readIfPresent()
        value.lensType = try reader["LensType"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.lensStatus = try reader["LensStatus"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ImprovementSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ImprovementSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ImprovementSummary()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.risk = try reader["Risk"].readIfPresent()
        value.improvementPlanUrl = try reader["ImprovementPlanUrl"].readIfPresent()
        value.improvementPlans = try reader["ImprovementPlans"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceImprovementPlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.jiraConfiguration = try reader["JiraConfiguration"].readIfPresent(with: WellArchitectedClientTypes.JiraConfiguration.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.ChoiceImprovementPlan {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ChoiceImprovementPlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ChoiceImprovementPlan()
        value.choiceId = try reader["ChoiceId"].readIfPresent()
        value.displayText = try reader["DisplayText"].readIfPresent()
        value.improvementPlanUrl = try reader["ImprovementPlanUrl"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.LensReviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensReviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensReviewSummary()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.lensVersion = try reader["LensVersion"].readIfPresent()
        value.lensName = try reader["LensName"].readIfPresent()
        value.lensStatus = try reader["LensStatus"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prioritizedRiskCounts = try reader["PrioritizedRiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.LensShareSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensShareSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensShareSummary()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.MilestoneSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.MilestoneSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.MilestoneSummary()
        value.milestoneNumber = try reader["MilestoneNumber"].readIfPresent()
        value.milestoneName = try reader["MilestoneName"].readIfPresent()
        value.recordedAt = try reader["RecordedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.workloadSummary = try reader["WorkloadSummary"].readIfPresent(with: WellArchitectedClientTypes.WorkloadSummary.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadSummary()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadArn = try reader["WorkloadArn"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lenses = try reader["Lenses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.riskCounts = try reader["RiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.improvementStatus = try reader["ImprovementStatus"].readIfPresent()
        value.profiles = try reader["Profiles"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.WorkloadProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prioritizedRiskCounts = try reader["PrioritizedRiskCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WellArchitectedClientTypes.NotificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.NotificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.NotificationSummary()
        value.type = try reader["Type"].readIfPresent()
        value.lensUpgradeSummary = try reader["LensUpgradeSummary"].readIfPresent(with: WellArchitectedClientTypes.LensUpgradeSummary.read(from:))
        return value
    }
}

extension WellArchitectedClientTypes.LensUpgradeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.LensUpgradeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.LensUpgradeSummary()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.currentLensVersion = try reader["CurrentLensVersion"].readIfPresent()
        value.latestLensVersion = try reader["LatestLensVersion"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ProfileNotificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileNotificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileNotificationSummary()
        value.currentProfileVersion = try reader["CurrentProfileVersion"].readIfPresent()
        value.latestProfileVersion = try reader["LatestProfileVersion"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileSummary()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.profileVersion = try reader["ProfileVersion"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.profileDescription = try reader["ProfileDescription"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WellArchitectedClientTypes.ProfileShareSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ProfileShareSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ProfileShareSummary()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplateAnswerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplateAnswerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplateAnswerSummary()
        value.questionId = try reader["QuestionId"].readIfPresent()
        value.pillarId = try reader["PillarId"].readIfPresent()
        value.questionTitle = try reader["QuestionTitle"].readIfPresent()
        value.choices = try reader["Choices"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.Choice.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedChoices = try reader["SelectedChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.choiceAnswerSummaries = try reader["ChoiceAnswerSummaries"].readListIfPresent(memberReadingClosure: WellArchitectedClientTypes.ChoiceAnswerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isApplicable = try reader["IsApplicable"].readIfPresent()
        value.answerStatus = try reader["AnswerStatus"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.questionType = try reader["QuestionType"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ReviewTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ReviewTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ReviewTemplateSummary()
        value.description = try reader["Description"].readIfPresent()
        value.lenses = try reader["Lenses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.owner = try reader["Owner"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ShareInvitationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ShareInvitationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ShareInvitationSummary()
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        value.sharedBy = try reader["SharedBy"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.permissionType = try reader["PermissionType"].readIfPresent()
        value.shareResourceType = try reader["ShareResourceType"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.lensName = try reader["LensName"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.profileName = try reader["ProfileName"].readIfPresent()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.templateName = try reader["TemplateName"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.TemplateShareSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.TemplateShareSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.TemplateShareSummary()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadShareSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadShareSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadShareSummary()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.permissionType = try reader["PermissionType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ShareInvitation {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ShareInvitation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ShareInvitation()
        value.shareInvitationId = try reader["ShareInvitationId"].readIfPresent()
        value.shareResourceType = try reader["ShareResourceType"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        value.lensAlias = try reader["LensAlias"].readIfPresent()
        value.lensArn = try reader["LensArn"].readIfPresent()
        value.profileArn = try reader["ProfileArn"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.WorkloadShare {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.WorkloadShare {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.WorkloadShare()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.sharedBy = try reader["SharedBy"].readIfPresent()
        value.sharedWith = try reader["SharedWith"].readIfPresent()
        value.permissionType = try reader["PermissionType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.workloadName = try reader["WorkloadName"].readIfPresent()
        value.workloadId = try reader["WorkloadId"].readIfPresent()
        return value
    }
}

extension WellArchitectedClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> WellArchitectedClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WellArchitectedClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension WellArchitectedClientTypes.ProfileQuestionUpdate {

    static func write(value: WellArchitectedClientTypes.ProfileQuestionUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QuestionId"].write(value.questionId)
        try writer["SelectedChoiceIds"].writeList(value.selectedChoiceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WellArchitectedClientTypes.WorkloadJiraConfigurationInput {

    static func write(value: WellArchitectedClientTypes.WorkloadJiraConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IssueManagementStatus"].write(value.issueManagementStatus)
        try writer["IssueManagementType"].write(value.issueManagementType)
        try writer["JiraProjectKey"].write(value.jiraProjectKey)
    }
}

extension WellArchitectedClientTypes.ChoiceUpdate {

    static func write(value: WellArchitectedClientTypes.ChoiceUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Notes"].write(value.notes)
        try writer["Reason"].write(value.reason)
        try writer["Status"].write(value.status)
    }
}

extension WellArchitectedClientTypes.AccountJiraConfigurationInput {

    static func write(value: WellArchitectedClientTypes.AccountJiraConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IntegrationStatus"].write(value.integrationStatus)
        try writer["IssueManagementStatus"].write(value.issueManagementStatus)
        try writer["IssueManagementType"].write(value.issueManagementType)
        try writer["JiraProjectKey"].write(value.jiraProjectKey)
    }
}

public enum WellArchitectedClientTypes {}
